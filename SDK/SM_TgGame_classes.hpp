#pragma once

// SMITE (8.2) SDK

#ifdef _MSC_VER
	#pragma pack(push, 0x8)
#endif

#include "SM_TgGame_structs.hpp"

namespace SDK
{
//---------------------------------------------------------------------------
//Classes
//---------------------------------------------------------------------------

// Class TgGame.AlienFXManager
// 0x0039 (0x0099 - 0x0060)
class UAlienFXManager : public UObject
{
public:
	unsigned long                                      m_bDirty : 1;                                             // 0x0060(0x0004)
	unsigned long                                      m_bLoaded : 1;                                            // 0x0060(0x0004)
	unsigned long                                      bBrighten : 1;                                            // 0x0060(0x0004)
	float                                              m_fHealthPct;                                             // 0x0064(0x0004)
	float                                              m_fHealthLow;                                             // 0x0068(0x0004)
	float                                              m_fDamagePulseTime;                                       // 0x006C(0x0004)
	float                                              m_fDamagePulseRemaining;                                  // 0x0070(0x0004)
	float                                              m_fEventPulseTime;                                        // 0x0074(0x0004)
	float                                              m_fEventPulseRemaining;                                   // 0x0078(0x0004)
	int                                                nTarget;                                                  // 0x007C(0x0004)
	float                                              fLowBounds;                                               // 0x0080(0x0004)
	float                                              fHighBounds;                                              // 0x0084(0x0004)
	float                                              fBoundsPct;                                               // 0x0088(0x0004)
	float                                              fSpeed;                                                   // 0x008C(0x0004)
	float                                              m_fUpdateFrequency;                                       // 0x0090(0x0004)
	float                                              m_fTimeUntilUpdate;                                       // 0x0094(0x0004)
	TEnumAsByte<EFXOverlay>                            eCurrOverlay;                                             // 0x0098(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.AlienFXManager");
		return ptr;
	}


	void UpdateHealth(float fValue);
	void Tick(float DeltaTime);
	void Start();
	void STATIC_ShowHealth();
	void STATIC_SetOverlay(unsigned char Type);
	void STATIC_OnDamage();
	void STATIC_OnEvent();
	void Close();
	void STATIC_Initialize();
};


// Class TgGame.TgActor_CH08_GooSpawner
// 0x0038 (0x0298 - 0x0260)
class ATgActor_CH08_GooSpawner : public AActor
{
public:
	unsigned long                                      m_bInDevMode : 1;                                         // 0x0260(0x0004)
	class UTexture2D*                                  m_TextureNormal;                                          // 0x0264(0x0008)
	class ATgRepInfo_CH08_GooSpawner*                  r_GSRI;                                                   // 0x026C(0x0008) (Net)
	float                                              m_fDefaultGooSpawnDelay;                                  // 0x0274(0x0004) (Const)
	TArray<struct FCH08_GOO_SPAWNER>                   s_StaticGooSpawners;                                      // 0x0278(0x0010) (Edit, NeedCtorLink)
	TArray<struct FCH08_GOO_SPAWNER>                   s_DynamicGooSpawners;                                     // 0x0288(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActor_CH08_GooSpawner");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void CleanUpDynamicGooSpawner(int nSpawnerIndex);
	void Destroyed();
	void InitReplicationInfo();
	void ToggleStaticGooSpawner(int nSpawnerIndex, bool bSetActive);
	void STATIC_SpawnGoo(int nSpawnerIndex, bool bUseDynamicSpawners);
	void AddDynamicGooZone(const struct FVector& vSpawnLocation, int nGooSpawnCount);
	void STATIC_DevModeSpawnTestStaticSpawner();
};


// Class TgGame.TgAIVolume
// 0x000C (0x02A8 - 0x029C)
class ATgAIVolume : public AVolume
{
public:
	int                                                LaneIndex;                                                // 0x029C(0x0004) (Edit)
	int                                                TaskforceIndex;                                           // 0x02A0(0x0004) (Edit)
	unsigned long                                      bEnabled : 1;                                             // 0x02A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIVolume");
		return ptr;
	}


	void PostBeginPlay();
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	struct FVector STATIC_GetRandomPointInAIVolume(float CollisionRadius);
};


// Class TgGame.TgAnimNodeBlendByVerticalAim
// 0x0043 (0x0154 - 0x0111)
class UTgAnimNodeBlendByVerticalAim : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	float                                              m_Aim;                                                    // 0x0114(0x0004) (Edit)
	struct FVector2D                                   m_Range;                                                  // 0x0118(0x0008) (Edit)
	float                                              m_AngleOffset;                                            // 0x0120(0x0004) (Edit)
	float                                              m_PreviousAim;                                            // 0x0124(0x0004) (Transient)
	unsigned long                                      bInitialized : 1;                                         // 0x0128(0x0004) (Transient)
	unsigned long                                      m_bLoopChildrenOnRelevant : 1;                            // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bPlayChildrenOnRelevant : 1;                            // 0x0128(0x0004) (Edit)
	struct FName                                       m_AnimName_Up;                                            // 0x012C(0x0008) (Edit)
	struct FName                                       m_AnimName_Center;                                        // 0x0134(0x0008) (Edit)
	struct FName                                       m_AnimName_Down;                                          // 0x013C(0x0008) (Edit)
	class UAnimNodeSequence*                           m_SeqNode1;                                               // 0x0144(0x0008) (Transient)
	class UAnimNodeSequence*                           m_SeqNode2;                                               // 0x014C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByVerticalAim");
		return ptr;
	}


	void OnBecomeRelevant();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimNodeFitToDurationInterface
// 0x0000 (0x0060 - 0x0060)
class UTgAnimNodeFitToDurationInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeFitToDurationInterface");
		return ptr;
	}


	void STATIC_SetPlayRate(float fPlayRate);
	bool STATIC_CanSetPlayRate();
};


// Class TgGame.TgAnimNodeSequence
// 0x0008 (0x01B4 - 0x01AC)
class UTgAnimNodeSequence : public UAnimNodeSequence
{
public:
	unsigned long                                      bAutoPlay : 1;                                            // 0x01AC(0x0004) (Edit)
	unsigned long                                      bResetOnActivate : 1;                                     // 0x01AC(0x0004)
	unsigned long                                      HasDynamicLength : 1;                                     // 0x01AC(0x0004) (Edit)
	unsigned long                                      EnableFootControlsOnCease : 1;                            // 0x01AC(0x0004) (Edit)
	unsigned long                                      SynchronizeGroupOnReplay : 1;                             // 0x01AC(0x0004) (Edit)
	unsigned long                                      bRandomStartPosition : 1;                                 // 0x01AC(0x0004) (Edit)
	float                                              ChainedSequenceDuration;                                  // 0x01B0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
};


// Class TgGame.TgAnimNodeSelfDestruct
// 0x0040 (0x01F4 - 0x01B4)
class UTgAnimNodeSelfDestruct : public UTgAnimNodeSequence
{
public:
	int                                                NumberOfLoopsBeforeDestruct;                              // 0x01B4(0x0004) (Edit)
	int                                                LoopsCompleted;                                           // 0x01B8(0x0004)
	TArray<struct FName>                               ScaleOutSkelControlNames;                                 // 0x01BC(0x0010) (Edit, NeedCtorLink)
	float                                              TimeRemaingForScaleOut;                                   // 0x01CC(0x0004) (Edit)
	TArray<class USkelControlBase*>                    ScaleOutSkelControls;                                     // 0x01D0(0x0010) (Transient, NeedCtorLink)
	TArray<float>                                      ScaleOutStartScales;                                      // 0x01E0(0x0010) (Transient, NeedCtorLink)
	float                                              ScaleOutStartTime;                                        // 0x01F0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSelfDestruct");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence_SpawnMesh
// 0x001C (0x01D0 - 0x01B4)
class UTgAnimNodeSequence_SpawnMesh : public UTgAnimNodeSequence
{
public:
	int                                                m_nMeshId;                                                // 0x01B4(0x0004) (Edit)
	float                                              m_fMeshWindowStart;                                       // 0x01B8(0x0004) (Edit)
	float                                              m_fMeshWindowEnd;                                         // 0x01BC(0x0004) (Edit)
	struct FName                                       m_nmSocketName;                                           // 0x01C0(0x0008) (Edit)
	float                                              m_fMeshLife;                                              // 0x01C8(0x0004) (Edit)
	unsigned long                                      c_bCanSpawn : 1;                                          // 0x01CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_SpawnMesh");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence_WithDisplayGroup
// 0x0008 (0x01BC - 0x01B4)
class UTgAnimNodeSequence_WithDisplayGroup : public UTgAnimNodeSequence
{
public:
	struct FName                                       m_DisplayGroup;                                           // 0x01B4(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_WithDisplayGroup");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence_WithMesh
// 0x0018 (0x01CC - 0x01B4)
class UTgAnimNodeSequence_WithMesh : public UTgAnimNodeSequence
{
public:
	int                                                m_nMeshId;                                                // 0x01B4(0x0004) (Edit)
	struct FName                                       m_nmSocketName;                                           // 0x01B8(0x0008) (Edit)
	struct FName                                       m_nmFullBodyName;                                         // 0x01C0(0x0008) (Edit)
	unsigned long                                      m_bUseSocketRelativeLoc : 1;                              // 0x01C8(0x0004) (Edit)
	unsigned long                                      m_bUseSocketRelativeRot : 1;                              // 0x01C8(0x0004) (Edit)
	unsigned long                                      m_bPlayAfterSpawn : 1;                                    // 0x01C8(0x0004) (Edit)
	unsigned long                                      m_bIgnoreOwnerHidden : 1;                                 // 0x01C8(0x0004) (Edit)
	unsigned long                                      m_bIgnoreOwnerRotation : 1;                               // 0x01C8(0x0004) (Edit)
	unsigned long                                      c_bActive : 1;                                            // 0x01C8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_WithMesh");
		return ptr;
	}


	void STATIC_OnDelete();
	void STATIC_StopAnim();
	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
	void STATIC_DeactivateMesh();
	void ActivateMesh();
};


// Class TgGame.TgAnimNodeSequence_WithMultiMesh
// 0x0010 (0x01DC - 0x01CC)
class UTgAnimNodeSequence_WithMultiMesh : public UTgAnimNodeSequence_WithMesh
{
public:
	TArray<struct FAnimMeshEntry>                      c_MultiMeshes;                                            // 0x01CC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_WithMultiMesh");
		return ptr;
	}


	void STATIC_DeactivateMesh();
	void ActivateMesh();
};


// Class TgGame.TgAnimNotify_CameraCut
// 0x0043 (0x00A8 - 0x0065)
class UTgAnimNotify_CameraCut : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	float                                              m_fTweenSpeed;                                            // 0x0068(0x0004) (Edit)
	struct FVector                                     m_vTweenDir;                                              // 0x006C(0x000C) (Edit)
	struct FVector                                     m_vLocationOffset;                                        // 0x0078(0x000C) (Edit)
	struct FRotator                                    m_rRotationOffset;                                        // 0x0084(0x000C) (Edit)
	struct FRotator                                    m_rRotationTarget;                                        // 0x0090(0x000C) (Edit)
	float                                              m_fRotationDuration;                                      // 0x009C(0x0004) (Edit)
	float                                              m_fRotationDelay;                                         // 0x00A0(0x0004) (Edit)
	unsigned long                                      m_bUseSocket : 1;                                         // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_CameraCut");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Disappear
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_Disappear : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Disappear");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_SpectatorSlomo
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_SpectatorSlomo : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_SpectatorSlomo");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_ToggleMeshAttachment
// 0x0013 (0x0078 - 0x0065)
class UTgAnimNotify_ToggleMeshAttachment : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	unsigned long                                      m_bDetachMesh : 1;                                        // 0x0068(0x0004) (Edit)
	TEnumAsByte<EeMeshAssemblyType>                    m_nChildType;                                             // 0x006C(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x006D(0x0003) MISSED OFFSET
	class USkeletalMesh*                               m_MeshOverride;                                           // 0x0070(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleMeshAttachment");
		return ptr;
	}

};


// Class TgGame.TgAttachPoint
// 0x0000 (0x0260 - 0x0260)
class ATgAttachPoint : public AActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAttachPoint");
		return ptr;
	}

};


// Class TgGame.TgPlayerController
// 0x0D98 (0x154C - 0x07B4)
class ATgPlayerController : public APComPlayerController
{
public:
	int                                                s_nPlayerId;                                              // 0x07B4(0x0004)
	struct FQWord                                      s_qwNetAccessFlags;                                       // 0x07B8(0x0008)
	int                                                r_nXp;                                                    // 0x07C0(0x0004) (Net)
	int                                                r_nCurrency;                                              // 0x07C4(0x0004) (Net)
	float                                              s_fCurrencyRemainder;                                     // 0x07C8(0x0004)
	float                                              s_fXpRemainder;                                           // 0x07CC(0x0004)
	unsigned long                                      r_bCanPurchaseItems : 1;                                  // 0x07D0(0x0004) (Net)
	unsigned long                                      r_bAutoPurchase : 1;                                      // 0x07D0(0x0004) (Net)
	unsigned long                                      r_bAutoSkillUp : 1;                                       // 0x07D0(0x0004) (Net)
	unsigned long                                      r_bEmoteFlooded : 1;                                      // 0x07D0(0x0004) (Net)
	unsigned long                                      s_bSentAutoKickAlert : 1;                                 // 0x07D0(0x0004)
	unsigned long                                      s_bAddDeadTimeStatsTracker : 1;                           // 0x07D0(0x0004) (Transient)
	unsigned long                                      c_bAllocateOnCast : 1;                                    // 0x07D0(0x0004)
	unsigned long                                      c_bEnableBasicAttackControllerFeedback : 1;               // 0x07D0(0x0004)
	unsigned long                                      c_bForceUnrestrictedPitch : 1;                            // 0x07D0(0x0004)
	unsigned long                                      m_bKeyboardBindingsDirty : 1;                             // 0x07D0(0x0004)
	unsigned long                                      m_bPlayerOverviewEnabled : 1;                             // 0x07D0(0x0004)
	unsigned long                                      r_bLockYawRotation : 1;                                   // 0x07D0(0x0004) (Net)
	unsigned long                                      m_bDeviceLockInput : 1;                                   // 0x07D0(0x0004)
	unsigned long                                      m_bDeviceLockCamera : 1;                                  // 0x07D0(0x0004)
	unsigned long                                      m_bDeviceLockCameraOnly : 1;                              // 0x07D0(0x0004)
	unsigned long                                      bPressingLeftMouseButton : 1;                             // 0x07D0(0x0004)
	unsigned long                                      r_bRove : 1;                                              // 0x07D0(0x0004) (Net)
	unsigned long                                      bFreeingMouse : 1;                                        // 0x07D0(0x0004)
	unsigned long                                      m_bReceivedIdleWarn : 1;                                  // 0x07D0(0x0004)
	unsigned long                                      s_bClearAchievementIgnoreListsOnNextTick : 1;             // 0x07D0(0x0004)
	unsigned long                                      s_bGiveAchievementAllowedException : 1;                   // 0x07D0(0x0004)
	unsigned long                                      c_bHasSpawnedProjectileThisFrame : 1;                     // 0x07D0(0x0004)
	unsigned long                                      c_bAssistModeSublevelLoaded : 1;                          // 0x07D0(0x0004)
	unsigned long                                      c_bRoleGuideSubLevelLoaded : 1;                           // 0x07D0(0x0004)
	unsigned long                                      c_bAllowSpecialMaterialEffects : 1;                       // 0x07D0(0x0004) (Config, GlobalConfig)
	unsigned long                                      m_bUseSilhouettes : 1;                                    // 0x07D0(0x0004) (Transient)
	unsigned long                                      m_bIgnoreOverlays : 1;                                    // 0x07D0(0x0004) (Transient)
	unsigned long                                      m_bForceOverlaysOnVisibleGods : 1;                        // 0x07D0(0x0004) (Transient)
	unsigned long                                      m_bDetailedViewEnabled : 1;                               // 0x07D0(0x0004) (Transient)
	unsigned long                                      m_bContextNotifiesEnabled : 1;                            // 0x07D0(0x0004) (Config)
	unsigned long                                      m_bShowPlayerCircles : 1;                                 // 0x07D0(0x0004)
	unsigned long                                      m_bCustomSkillsLoaded : 1;                                // 0x07D0(0x0004) (Transient)
	unsigned long                                      c_bShowFootstepInfoDebug : 1;                             // 0x07D4(0x0004)
	unsigned long                                      m_bDetailedDeviceLogging : 1;                             // 0x07D4(0x0004)
	unsigned long                                      m_bAllowAllSocialEmotes : 1;                              // 0x07D4(0x0004) (Transient)
	unsigned long                                      m_bUnlockVoicePacks : 1;                                  // 0x07D4(0x0004) (Transient)
	unsigned long                                      c_bHideNameplates : 1;                                    // 0x07D4(0x0004)
	unsigned long                                      s_bSkipClientAdjustment : 1;                              // 0x07D4(0x0004)
	float                                              c_fLastGoldNagTime;                                       // 0x07D8(0x0004)
	int                                                m_nReviveBuybackCost;                                     // 0x07DC(0x0004)
	int                                                r_nStatPoints;                                            // 0x07E0(0x0004) (Net)
	struct FFLOOD                                      s_VGSFlood;                                               // 0x07E4(0x0008)
	struct FFLOOD                                      s_PingFlood;                                              // 0x07EC(0x0008)
	struct FFLOOD                                      s_EmoteFlood;                                             // 0x07F4(0x0008)
	class UTgPlayerInput*                              m_CachedPlayerInput;                                      // 0x07FC(0x0008)
	class UTgSpectatorInput*                           m_CachedSpectatorInput;                                   // 0x0804(0x0008)
	class AActor*                                      m_aHoverActor;                                            // 0x080C(0x0008)
	struct FVector                                     m_vHoverLocation;                                         // 0x0814(0x000C)
	float                                              m_fHoverActorActiveTime;                                  // 0x0820(0x0004)
	struct FVector                                     m_vWorldMapLocation;                                      // 0x0824(0x000C)
	TArray<class AReplicationInfo*>                    m_WorldMapTargetRepInfos;                                 // 0x0830(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                m_nPawnPickerId;                                          // 0x0840(0x0004)
	struct FVector                                     m_vWorldMouseLocation;                                    // 0x0844(0x000C) (Transient)
	struct FVector                                     m_vWorldMouseDirection;                                   // 0x0850(0x000C) (Transient)
	float                                              c_fTimeTillAFK;                                           // 0x085C(0x0004)
	float                                              s_bAutoKickStartTime;                                     // 0x0860(0x0004)
	class APawn*                                       s_LastPossessedPawn;                                      // 0x0864(0x0008)
	float                                              c_fLastAbilityNagTime;                                    // 0x086C(0x0004)
	float                                              c_fLastHealthNagTime;                                     // 0x0870(0x0004)
	float                                              c_fLastManaNagTime;                                       // 0x0874(0x0004)
	float                                              c_fLastSkillPointNagTime;                                 // 0x0878(0x0004)
	float                                              c_fLastBasicAttackNagTime;                                // 0x087C(0x0004)
	float                                              c_fLastTargetedNagTime;                                   // 0x0880(0x0004)
	int                                                r_nNumBasicsToMiss;                                       // 0x0884(0x0004) (Net)
	float                                              r_BlindnessFactor;                                        // 0x0888(0x0004) (Net)
	float                                              m_fRecentLostHealth;                                      // 0x088C(0x0004)
	float                                              m_fLastLostHealthTime;                                    // 0x0890(0x0004)
	TArray<class AActor*>                              m_TargetedPlayers;                                        // 0x0894(0x0010) (NeedCtorLink)
	float                                              s_fWaitForSpawnSecs;                                      // 0x08A4(0x0004)
	float                                              c_fRespawnTime;                                           // 0x08A8(0x0004)
	float                                              m_fDeathTime;                                             // 0x08AC(0x0004)
	TEnumAsByte<ETG_EQUIP_POINT>                       c_eDelayedCastEquipPoint;                                 // 0x08B0(0x0001)
	TEnumAsByte<EWatchOtherPlayersMode>                r_WatchOtherPlayer;                                       // 0x08B1(0x0001) (Net)
	TEnumAsByte<EGAME_WIN_STATE>                       c_GameWinState;                                           // 0x08B2(0x0001)
	TEnumAsByte<EGAME_WIN_STATE>                       c_OvertimeWinState;                                       // 0x08B3(0x0001)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eDetailedDeviceEqp;                                     // 0x08B4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x08B5(0x0003) MISSED OFFSET
	float                                              c_fDelayedCastTime;                                       // 0x08B8(0x0004)
	float                                              c_fLastActionTimeStamp;                                   // 0x08BC(0x0004)
	class UTgControlModule*                            ControlModule;                                            // 0x08C0(0x0008) (Edit, EditInline)
	class UClass*                                      DefaultControlModuleClass;                                // 0x08C8(0x0008)
	int                                                c_nCameraYawOffset;                                       // 0x08D0(0x0004)
	class AActor*                                      m_EndGameFocus;                                           // 0x08D4(0x0008) (Transient)
	float                                              m_fLastVGS;                                               // 0x08DC(0x0004)
	float                                              m_fTimeToViewOthersCamAfterDeath;                         // 0x08E0(0x0004)
	struct FPlayerBuildRecs                            r_recommendedItems;                                       // 0x08E4(0x0128) (Net)
	TArray<class UTgAchievement*>                      s_Achievements;                                           // 0x0A0C(0x0010) (NeedCtorLink)
	struct FsSimProjectileFireInfo                     r_FlashProjectileEx[0x30];                                // 0x0A1C(0x0034) (Net)
	int                                                s_nFlashSimProjIdx;                                       // 0x13DC(0x0004)
	TArray<struct FsDeferredProjectileFireInfo>        c_DeferredProjectileEvents;                               // 0x13E0(0x0010) (NeedCtorLink)
	class ATgGameTipManager*                           c_GameTipManager;                                         // 0x13F0(0x0008) (Transient)
	struct FPointer                                    s_pCombatMessages;                                        // 0x13F8(0x0008) (Native)
	float                                              s_fLastCombatMessageProcess;                              // 0x1400(0x0004)
	int                                                c_nCurrentLevel;                                          // 0x1404(0x0004)
	class UTgTutorialAnnouncer*                        c_TutorialAnnouncer;                                      // 0x1408(0x0008)
	int                                                r_TutorialBlockedClientActions;                           // 0x1410(0x0004) (Net)
	class ATgRepInfo_Player*                           CachedPRI;                                                // 0x1414(0x0008) (Transient)
	class UMaterialInstanceConstant*                   m_OverlayPathMaterial;                                    // 0x141C(0x0008)
	int                                                m_nContextNotifyGroundTargeterId;                         // 0x1424(0x0004)
	TArray<class ATgPawn*>                             m_HiddenPawns;                                            // 0x1428(0x0010) (NeedCtorLink)
	struct FAbilityLevelInfo                           m_nLevelAbilities[0x14];                                  // 0x1438(0x0008)
	class UAudioComponent*                             c_AlertAudioComponent;                                    // 0x14D8(0x0008) (ExportObject, Component, EditInline)
	struct FString                                     Login2StartTime;                                          // 0x14E0(0x0010) (Config, GlobalConfig, NeedCtorLink)
	struct FString                                     Login3StartTime;                                          // 0x14F0(0x0010) (Config, GlobalConfig, NeedCtorLink)
	struct FString                                     Login2StartTimeLive;                                      // 0x1500(0x0010) (NeedCtorLink)
	struct FString                                     Login3StartTimeLive;                                      // 0x1510(0x0010) (NeedCtorLink)
	int                                                m_nChargeNumber;                                          // 0x1520(0x0004)
	TArray<class UTgObjectReferencer*>                 c_KismetLoadedDevices;                                    // 0x1524(0x0010) (NeedCtorLink)
	int                                                m_nRespawnPitch;                                          // 0x1534(0x0004) (Const)
	float                                              s_fLastVER;                                               // 0x1538(0x0004)
	int                                                r_nQueuedRole;                                            // 0x153C(0x0004) (Net)
	int                                                r_nPlayedRole;                                            // 0x1540(0x0004) (Net)
	class UTgGameplayCurves*                           c_DefaultCurves;                                          // 0x1544(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerController");
		return ptr;
	}


	void ClientSwapUnitPosition(int nInitPosition, bool bInitIsActiveSlot, int nFinalPosition, bool bFinalIsActiveSlot);
	void ClientSellUnit(int nPosition, bool bIsActiveSlot);
	void ClientPurchaseUnit(int nUnitIndex, int nPosition, bool bIsActiveSlot);
	void ClientSendGameEvent(TEnumAsByte<EClientGameEvent> eCGE, int nVal1, int nVal2, float fVal1);
	void STATIC_OnAddStacks(class UTgSeqAct_AddStacks* tgSeqAct);
	void STATIC_OnSwitchCamera(class UTgSeqAct_SwitchCamera* tgSeqAct);
	void STATIC_OnChangeGameMod(class UTgSeqAct_ChangeGameMod* tgSeqAct);
	void STATIC_OnModifyPropValue(class UTgSeqAct_ModifyPropValue* tgSeqAct);
	void STATIC_OnGetPropVal(class UTgSeqAct_GetPropVal* tgSeqAct);
	void ToggleGandhiMode();
	bool ShouldPartySessionsBePublic();
	void STATIC_DisplayRoundOverviewUI();
	void STATIC_CharacterDialogPlayUI(float fTextSpeedMultiplier, int nImageId);
	void STATIC_CharacterDialogToggleUI(bool bOpen);
	void UpdatePartyUI();
	void TryOpenPartyUI();
	void BlockPartySceneInput(bool bBlockInput);
	bool TryAutoLogin();
	bool IsInGame();
	void ShowCustomGameDisallowedPopup();
	void ShowPackageNotInstalledForPartyInviteWarning();
	void ShowPartyNoLongerAvailableWarning();
	void ShowPartyFullWarning(bool bPartySession);
	void ShowUnableToReadFriendsListWarning();
	void ShowNoFriendsForPartyInviteWarning();
	void ShowControllerDisconnectedWarning();
	void STATIC_ClearASCIntervals();
	bool SetPause(bool bPause, const struct FScriptDelegate& CanUnpauseDelegate);
	void STATIC_OnControllerChanged(int ControllerId, bool bIsConnected, bool bPauseGame);
	void STATIC_OnRemoteTalkerStatusChange(const struct FUniqueNetId& RemoteNetId, bool bIsTalking);
	void STATIC_OnCurrentUserChanged(unsigned char LocalUserNum, const struct FString& CurrentUser, const struct FString& LoggedInUser);
	void STATIC_OnConnectionStatusChange(TEnumAsByte<EOnlineServerConnectionStatus> ConnectionStatus);
	void STATIC_OnLoginStatusChange(TEnumAsByte<ELoginStatus> NewStatus, const struct FUniqueNetId& NewId);
	void STATIC_SetPlayerOverviewCamera(bool bOn);
	void STATIC_ClientPlayerOverviewCamera(bool bOn);
	void ClientUpdatePosition();
	void ClientPlayRoadkillNotify();
	void ReceivedContextNotify(int ContextId, const struct FVector& NotifyLocation, bool bEnemy);
	void EnableContextNotify(int ContextId);
	void ClientDrawDebugSphere(float X, float Y, float Z, float Radius, int Segments, unsigned char R, unsigned char G, unsigned char B);
	void ClientDrawDebugBox(float X, float Y, float Z, float extX, float extY, float extZ, unsigned char R, unsigned char G, unsigned char B);
	void ClientDrawDebugLine(float X, float Y, float Z, float X2, float Y2, float z2, unsigned char R, unsigned char G, unsigned char B);
	void PlayAthenaReinforcementSound(int SpecialFXId);
	void PlayMercuryIncomingEffects();
	void SetIgnoreMoveInput(bool bShow);
	void STATIC_FreeMouseCursor();
	void UnFreeMouseCursor();
	void ToggleDetailedView();
	bool IsPawnWithin(class APawn* aPawn, float Distance);
	void STATIC_SetCommandBindPC(bool bSpectator, int nAlternate, const struct FString& ExtendedBinding, const struct FString& Command);
	void STATIC_SetBindPC(bool bSpectator, const struct FString& ExtendedBinding, const struct FString& Command);
	void UnbindCommandAllPC(bool bSpectator, const struct FString& Command);
	void UnbindCommandPC(bool bSpectator, int nAlternate, const struct FString& Command);
	class UTgSpectatorInput* GetSpectatorInputClass();
	class UTgPlayerInput* GetPlayerInputClass();
	void STATIC_RemoveAdditionalPostProcess(class UPostProcessChain* PP, class ATgPawn* OtherDepthTarget);
	void STATIC_InsertAdditionalPostProcess(class UPostProcessChain* PP, bool bAlterMeshDepth, class ATgPawn* OtherDepthTarget);
	void ToggleIgnoreOverlays();
	void STATIC_IgnoreOverlays(bool bIgnore);
	void UseSilhoettes(bool bUse);
	void OnBecomeTowerTarget();
	void STATIC_OnScoreChange(int nTeam);
	void ArenaCrowdEvent(unsigned char EventType);
	void STATIC_ServerDropFlag();
	void DropFlag();
	void STATIC_StopTutorialAnnouncement(bool bFlushOthers);
	void STATIC_PlayTutorialAnnouncement(class USoundCue* OptionalCue, bool bPlayImmediately, bool bFlushOthers);
	void STATIC_SetAllowAnimationFrameRateLOD(bool Value, float lLODDistanceFactor, int lLODFrameRate);
	void STATIC_SetAllowParticleSystems(bool Value);
	void AllowRagdollUpdated();
	bool AllowRagdoll();
	bool AllowPausing();
	void STATIC_ServerRequestScoreBoard();
	void STATIC_ResetGameTips();
	void STATIC_SuppressHelpText();
	void STATIC_RequestScoreBoard();
	void UpdateLockedTarget(class AActor* LockedActor);
	void STATIC_ServerPlayEmote(TEnumAsByte<EEmote> Emote);
	bool STATIC_CanPlayEmote(TEnumAsByte<EEmote> Emote, TEnumAsByte<EEmoteFail>* failType);
	bool CheckCanPlayEmote(TEnumAsByte<EEmote> Emote, TEnumAsByte<EEmoteFail>* failType);
	void STATIC_ServerSurrender(bool bSurrender, bool bIsConsoleBuild);
	void ClientSurrender(bool bSurrender);
	void ClientTrackPlayerMute(const struct Fdword& nPlayerId, bool bConsole);
	void ClientPlayPing(float X, float Y, float Z, TEnumAsByte<EPING_TYPE> pingType);
	void ClientPlayVGS(int nId, int usedVPSetting);
	void ClientPlayLocalEmote(TEnumAsByte<EEmote> Emote);
	void ClientPlayEmote(TEnumAsByte<EEmote> Emote);
	void ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	bool OnInstantCastOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnInstantCastOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnQuickCastOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnQuickCastOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnDefaultCastOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool OnDefaultCastOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void ToggleAllocateOnCast(bool bEnable);
	bool TryLevelUp(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnOffhandSlotReleased(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool STATIC_OnOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqp, bool bDelayedCast);
	void DeviceOnStopFire(class ATgDevice* Device, bool WasInterrupted);
	void AbilityUsageHelpTimer();
	void DeviceOnStartFire(class ATgDevice* Device);
	void DeviceOnStopBuildup(class ATgDevice* Device, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Device);
	void AllocateAbilitySkillPoint(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_OnAddPercentVitals(class UTgSeqAct_AddPercentVitals* inAction);
	void AddPlayerPercentVitals(float pctHealth, float pctMana);
	void STATIC_OnGivePercentVitals(class UTgSeqAct_GivePercentVitals* inAction);
	void STATIC_GivePlayerPercentVitals(float pctHealth, float pctMana);
	void STATIC_OnGiveFullVitals(class UTgSeqAct_GiveFullVitals* inAction);
	void STATIC_GivePlayerFullVitals();
	void STATIC_ClientTutorialHighlighter(bool bShow, int highlightedElement);
	void STATIC_ClientTutorialImage(bool bShow, int HeaderMsgId, int ImageId, int msgId);
	void STATIC_ClientForceTutorialAction(int Action, int ActionElement);
	void STATIC_OnTutorialHighlighter(class UTgSeqAct_TutorialHighlighter* inAction);
	void STATIC_OnTutorialImage(class UTgSeqAct_TutorialImage* inAction);
	void STATIC_OnForceClientTutorialAction(class UTgSeqAct_ForceClientTutorialAction* inAction);
	void ClientNotifyTutorialUIEvent(int Evt, int evtData);
	void STATIC_ServerNotifyTutorialUIEvent(int Evt, int evtData);
	void STATIC_OnTutorialPlayerAction(class UTgSeqAct_LogTutorialAction* inAction);
	void StopTgCameraShake(class UTgCameraShake* CameraShake);
	void PlayTgCameraShake(class UTgCameraShake* CameraShake, const struct FVector& Epicenter, class AActor* ShakeInstigator);
	void STATIC_OnTgCameraShake(class UTgSeqAct_TgCameraShake* inAction);
	void Cloth(bool bEnabled);
	void STATIC_DoFade(bool bIn, float Time);
	void STATIC_OnClientLoadDevices(class UTgSeqAct_ClientLoadDevices* Action);
	void ClientSetCameraMode(const struct FName& NewCamMode);
	void STATIC_ServerCamera(const struct FName& NewMode);
	void Camera(const struct FName& NewMode);
	void STATIC_ClientCheatFly(bool bOn);
	void CheatFly(bool bOn);
	void ServerUpdateStats();
	bool CanCommunicate();
	void STATIC_SpeakTTS(const struct FString& S, class APlayerReplicationInfo* PRI);
	void STATIC_DumpClassInfo(const struct FString& sClassName);
	void STATIC_TestCrash();
	bool STATIC_CanPlayerMove(class APawn* P);
	class ATgRepInfo_TaskForce* STATIC_GetTFRI();
	void STATIC_ServerCycleTeammateView(bool bForward);
	void ViewPreviousTeammate();
	void ViewNextTeammate();
	void STATIC_GetServerValue(const struct FString& strObject, const struct FString& strVariable);
	void STATIC_GetClientValue(const struct FString& strObject, const struct FString& strVariable);
	void STATIC_SetServerValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void STATIC_SetClientValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void STATIC_ServerGetValue(const struct FString& strObject, const struct FString& strVariable);
	void STATIC_ClientGetValue(const struct FString& strObject, const struct FString& strVariable);
	void STATIC_ServerSetValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void STATIC_ClientSetValue(const struct FString& strObject, const struct FString& strVariable, const struct FString& StrValue);
	void STATIC_ServerKillPets();
	void KillPets();
	void STATIC_ServerGotoFly();
	void STATIC_GotoFly();
	void STATIC_StunTypeChanged();
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	void STATIC_ClientResetStunnedBehavior(bool bStunController, TEnumAsByte<EStunType> eType);
	bool STATIC_ShouldStunChangePhysics();
	void STATIC_OnRestartPlayers(class UTgSeqAct_RestartPlayers* inAction);
	bool STATIC_ClientPerformedUseAction();
	bool STATIC_ServerPerformedUseAction();
	void STATIC_ClientUse();
	void STATIC_ServerUse();
	bool STATIC_CanUseNow();
	void UpdateReviveTimeRemaining(float fTimeRemaining);
	void ViewObjectiveCamerasTimer();
	struct FName GetStateNameEx();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_OnCanPurchaseItemChange();
	void PawnDied(class APawn* P);
	void STATIC_ClientSetReadyState(bool bReadyToPlay);
	void STATIC_ServerSetReadyToPlay();
	void STATIC_SetReadyToPlay();
	void CheckJumpOrDuck();
	void NotifyJumpApex();
	void UpdateAssistModeSubLevel();
	void STATIC_EnableColorBlindEffect(bool bEnable, int Type, float Intensity);
	void OnSettingsChanged(class UTgClientSettings* Settings, int settingsType);
	void ReceivedPlayer();
	void STATIC_SwitchCamera(const struct FString& sCamera);
	void STATIC_SwitchControl(class UClass* ControlModuleClass);
	void PostBeginPlay();
	void STATIC_PostServerMoveUpdate();
	void STATIC_ServerToggleSceneCaptureState();
	int STATIC_GetCurrentDeviceBehaviorType();
	int STATIC_GetCurrentDeviceType();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetCurrentEqPoint();
	class ATgDevice* STATIC_GetEqPointDevice(TEnumAsByte<ETG_EQUIP_POINT> eEqPoint);
	class UTgDeviceFire* STATIC_GetEqPointDevFire();
	bool IsValidTarget(class AActor* HoverActor);
	bool IsTargetDied(class AActor* TargetActor);
	bool IsTargetInFrontOfPawn(const struct FVector& TargetLocation);
	struct FRotator STATIC_GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	void ClientSetOnlineStatus();
	void STATIC_DisplayHiddenActorsTimer();
	void STATIC_DisplayHiddenActors(float Time);
	bool STATIC_CanAFK(class ATgPawn* ThePawn);
	void STATIC_ServerToggleAFK(bool bEnabled);
	void STATIC_GoAFKTimer();
	void PlayerTick(float DeltaTime);
	void InitInputSystem();
	void STATIC_SetPlayerTeam(class ATeamInfo* NewTeam);
	void TeamTalk();
	void Talk();
	void BeginFadeOut();
	void ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner);
	void STATIC_GameHasEnded(class AActor* EndGameFocus, bool bIsWinner);
	void OnDestroyOnlineGameComplete(const struct FName& SessionName, bool bWasSuccessful);
	void STATIC_EndIntro();
	void STATIC_SetupIntro();
	void STATIC_ResetPlayer();
	void STATIC_ClientPlayIntro();
	void STATIC_PlayIntro();
	void STATIC_PrepareIntro();
	TEnumAsByte<EGAME_WIN_STATE> GetEOMWinState();
	void STATIC_ClientEndOTTransition();
	void SendClientEndOTTransition();
	void STATIC_ClientTriggerOTTransition(float fSceneDelay);
	void SendClientTriggerOTTransition(float fSceneDelay);
	void STATIC_ClientSetOvertimeWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void SendClientSetOvertimeWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void STATIC_ClientSetGameWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void SendClientSetGameWinState(TEnumAsByte<EGAME_WIN_STATE> gameWinState);
	void FindGoodView();
	void STATIC_GoSpectate();
	void AddNavFailedAlert(bool bAlreadyThere);
	void ShowPathTo(class AActor* destActor);
	void STATIC_ClientShowPathTo(class AActor* destActor);
	void TutorialMessage(int msgId, bool bTip);
	void STATIC_OnPingMinimap(class UTgSeqAct_PingMinimap* Action);
	void STATIC_OnNavIndicator(class UTgSeqAct_NavIndicator* Action);
	void STATIC_ShowPathToNearestPOI();
	void STATIC_ServerSetZoomFactor(float fZoom);
	void ZoomClamp();
	void ZoomOut();
	void ZoomIn();
	class UTgCameraModule* STATIC_GetCurrentCameraModule();
	void STATIC_ServerViewAPlayer(int Dir);
	void STATIC_HandleViewTargetOnAdjustPosition();
	void ViewPrevPlayer();
	void ViewNextPlayer();
	void STATIC_ServerViewPrevPlayer();
	void STATIC_ServerViewNextPlayer();
	float GetFOVAngle();
	int BlendRot(float DeltaTime, int BlendC, int NewC);
	void STATIC_ClientEnterStartState();
	void EnterStartState();
	bool AllowVoiceMessage(const struct FName& MessageType);
	void ClientSetHUD(class UClass* newHUDType);
	void GetAimingViewPoint(struct FVector* POVLocation, struct FRotator* POVRotation);
	bool UsingFirstPersonCamera();
	void STATIC_SetRadius(float NewRadius);
	void ClientReset();
	void Reset();
	void OnSkippableMatineeStarted(class USeqAct_Interp* Matinee);
	void ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD);
	void STATIC_SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsButtons);
	void STATIC_OnToggleCinematicMode(class USeqAct_ToggleCinematicMode* Action);
	void STATIC_OnToggleImmuneGodMode(class UTgSeqAct_ToggleImmuneGodMode* inAction);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void ViewPlayersTimer();
	void STATIC_ReviveTimer();
	void Revive();
	void LadderLetGo();
	void STATIC_ServerLadderLetGo();
	void RestartPlayerOnTransfer();
	void NotifyStructureTargeted();
	void STATIC_CancelInBombRange();
	void NotifyInBombRange();
	void STATIC_ClientNotifyBodyUnderAttack(unsigned char Damage);
	void NotifyBodyUnderAttack(unsigned char Damage);
	void STATIC_ClientPlayTakeHit(const struct FRotator& HitDir, int Damage, class UClass* DamageType);
	void STATIC_NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum);
	void STATIC_NotifyChangedWeapon(class AWeapon* PreviousWeapon, class AWeapon* NewWeapon);
	void UnPossess();
	void Possess(class APawn* aPawn, bool bVehicleTransition);
	void GivePawn(class APawn* NewPawn);
	void ServerAcknowledgePossession(class APawn* P);
	void AcknowledgePossession(class APawn* P);
	void PreRender(class UCanvas* Canvas);
	void CopyPropertiesTo(class AController* C);
	void CleanupPRI();
	void STATIC_InitPlayerReplicationInfo();
	void Destroyed();
	void ClientRevertInventoryTransaction();
	void ClientRollbackInventoryTransaction(int nNumSteps);
	void ClientSellItem(int nInventoryId);
	void ClientPurchaseItem(int nLootTableId, int nLootTableItemId, int nItemCount);
	void PressJump(bool bOn);
	void STATIC_ServerProfiling(const struct FString& Command);
	void STATIC_ServerProfileScript(const struct FString& Command);
	void STATIC_SelfAlert(int nPriority, float fDuration, int nMsgId);
	void STATIC_RemoveAlertScript(int nMsgId);
	void AddAlertScript(TEnumAsByte<EAlertPriority> Priority, TEnumAsByte<EAlertType> Type, float fDuration, int nMsgId, bool bBlockDuplicates);
	void ClientPingMap(const struct FVector& WorldLoc, TEnumAsByte<EPING_TYPE> pingType);
	void ClientSetRotationAndDesired(const struct FRotator& NewRotation, bool bResetCamera);
	void ClientSetRotation(const struct FRotator& NewRotation, bool bResetCamera);
	void STATIC_ServerRove(bool bOn);
	void ToggleRove();
	void STATIC_ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams);
	void STATIC_ServerWatchOtherPlayer(TEnumAsByte<EWatchOtherPlayersMode> Mode);
	void STATIC_StopWatchOthers();
	void STATIC_StartWatchOthers(TEnumAsByte<EWatchOtherPlayersMode> Mode);
	void STATIC_SetCorrectViewTarget();
	void STATIC_ServerSetViewTarget();
	void SelectPawn(int nPawnId);
	bool STATIC_PingMap(const struct FVector& WorldLocation, TEnumAsByte<EPING_TYPE> Type, TArray<class AReplicationInfo*>* worldActorRepInfos);
	void STATIC_OnRightMouseReleased();
	void STATIC_OnRightMousePressed();
	void STATIC_OnLeftMouseReleased();
	void STATIC_OnLeftMousePressed();
	bool ControlModuleInterceptRawKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> Event, float AmountDepressed);
	void STATIC_CCE(const struct FName& EventName);
	void CauseClientEvent(const struct FName& EventName);
	void WhereAmI();
	void AddAutoKickAlert();
	void AddAssistAlert(const struct FString& KilledName, const struct FString& KillerName);
	void AddKillAlert(const struct FString& KilledName, const struct FString& KillerName, bool KillerWasPlayer);
	void STATIC_SwapConsumableOrder();
	void STATIC_SwapAbilityOrder();
	void STATIC_ServerSetAutoSkillUp(bool bAutoSkill, bool bForMatch);
	void SetAutoSkillUp(bool bAutoSkill, bool bForMatch);
	void STATIC_ServerSetAutoPurchase(bool bAutoPurchase, bool bForMatch);
	void SetAutoPurchase(bool bAutoPurchase, bool bForMatch);
	void STATIC_SetCanPurchaseFlag(bool bCanPurchase);
	void STATIC_SetTaskforceLead(const struct FString& fsName);
	void STATIC_ShowRespawnTimerExpired();
	void RequestShowRespawnBuyback();
	void ClientShowRespawnBuyback(int nCost);
	void STATIC_ClientSendBattleRoundStateEvent(int nEventId);
	void STATIC_ClientSendMissionTimerEvent(int nEventId, int nWinningTaskForce);
	void ClientgfxProcessSound(const struct FName& aThemeName, const struct FName& aEventName);
	void ClientPlaySound(class USoundCue* ASound);
	void Logoff(bool bForced);
	void AllocateDevicePoint(int nDeviceId);
	void STATIC_FlashProjSync(int nProjInstance, float fSync1, float fSync2);
	void STATIC_FlashProjHitActor(int nProjInstance, class AActor* HitActor, const struct FVector& vHitLoc, const struct FVector& vHitNormal, float fGeneric1);
	void STATIC_FlashProjHitWall(int nProjInstance, class AActor* HitActor, const struct FVector& vHitLoc, const struct FVector& vHitNormal, float fGeneric1);
	void STATIC_SetPlayerGlobalEmote(int nGlobalEmoteSkinId);
	void STATIC_SetPlayerWard(int nWardSkinId);
	void STATIC_SetPlayerProfile(int nProfileId, int nSkinId);
	void STATIC_SetLevel(int nLevel);
	float STATIC_StartReviveTimer(bool bDoNotUpdateStatsTracker);
	void STATIC_SetNWCondition(int nPktLoss, int nPktLag);
	void STATIC_TestCrashReport();
	class UMaterialInstanceConstant* STATIC_GetMICResource(int nResourceId);
	void STATIC_SetPlayedRole(int nRole);
	int STATIC_GetPlayedRole();
	void STATIC_SetQueuedRole(int nRole);
	int STATIC_GetQueuedRole();
	bool UsesNewControllerCurves();
	void STATIC_ServerSendGameEvent(TEnumAsByte<EClientGameEvent> eCGE, int nVal1, int nVal2, float fVal1);
	void SetOnlineStatus(unsigned char LocalUserNum, const struct FString& StatusString);
	void STATIC_ServerMoveHandleClientError(float TimeStamp, const struct FVector& Accel, const struct FVector& ClientLoc);
	void STATIC_OnSpectateFail();
	int STATIC_QuickCastCloseGodTargeter();
	void STATIC_SetSpecialTimeToViewOthers(int BotID, int SkinId);
	void STATIC_HideTransitionalEOMScene();
	void STATIC_ShowTransitionalEOMScene();
	void LogAntiCheatPlayerState();
	void AchievementModifiedHealthProp(int nHealth, int nMaxHealth);
	void AchievementAchievedById(int nActivityId);
	void NativeUnPossess();
	void NativePossess(class APawn* aPawn);
	void STATIC_ServerRequestGraphData();
	void STATIC_ServerPlayContextNotify(int ContextId, const struct FVector& NotifyLocation);
	void STATIC_SendContextNotifyVGS(int ContextId, const struct FVector& NotifyLocation);
	void ClientAddCheats();
	void STATIC_CheckHealthFX(float fCurrent, float fMaximum);
	void STATIC_PlayEventFX();
	void STATIC_StartFX();
	void STATIC_FlushKeyboardBinds();
	void UpdateKeyboardBinds();
	void UpdateRuntimeInput(bool bSpectator);
	void ResetKeysToDefault(bool bSpectator, bool isForceSetKey, const struct FString& PresetName);
	void UpdateForceFeedback(float fDeltaTime, float fHealthPCT, float fHealthLostPCT, float fLastCastTime);
	bool IsGMPlayerController();
	bool STATIC_IsLocalPlayerController();
	void LiveSpectateStop();
	void STATIC_LiveSpectate(const struct FString& sPlayerNameInstanceId, const struct FString& sPassword);
	void STATIC_SpectateStop();
	void STATIC_Spectate(const struct FString& sPlayerName, const struct FString& sPassword);
	void STATIC_SpectateGM(const struct FString& sPlayerName);
	void KickWarning();
	void STATIC_SendCombatMessage(const struct FCombatMessageInfo& msgInfo);
	void STATIC_ShowRespawnBuyback(int nCost);
	void STATIC_gfxProcessSound(const struct FName& aThemeName, const struct FName& aEventName);
	void UpdateTransitionUI();
	void UpdateStoreCanPurchase();
	void UpdatePlayerVitalsUI();
	void ToggleMiniMapPing(bool bStart);
	void STATIC_ClearTargetingList();
	void UpdateTargetingList(TArray<struct FImpactInfo> ImpactList, bool bLightUp);
	void STATIC_ForwardEmoteAchievement(TEnumAsByte<EEmote> Emote);
	bool STATIC_CanEmoteBePlayed(TEnumAsByte<EEmote> Emote);
	void STATIC_HandlePlayEmoteFailure(TEnumAsByte<EEmote> Emote, TEnumAsByte<EEmoteFail> failType);
	bool STATIC_ShouldRequestTip(int nGameTipId);
	void UpdateRoleGuideSubLevel();
	void STATIC_OnSceneLoadChange(const struct FString& SceneName, bool bLoaded);
	bool IsTutorialBlockingAction(TEnumAsByte<EeTutorialForceableElements> Action);
	bool STATIC_HandleTutorialActionOnServer(class UTgSeqAct_ForceClientTutorialAction* inAction);
	void STATIC_HandleTutorialHighlighter(bool bShow, int highlightedElement);
	void STATIC_HandleTutorialImage(bool bShow, int HeaderMsgId, int ImageId, int msgId);
	void STATIC_HandleForcedClientTutorialAction(int nAction, int nActionElement);
	void TriggerTutorialEvent(int nTutEvent, int nInfoData);
	void LogTutorialAction(int nPlayerAction, int nEventData);
	void STATIC_ClientLogoff(bool bForced);
	void STATIC_ServerSwapUnitPosition(int nInitPosition, bool bInitIsActiveSlot, int nFinalPosition, bool bFinalIsActiveSlot);
	void STATIC_ServerSellUnit(int nPosition, bool bIsActiveSlot);
	void STATIC_ServerPurchaseUnit(int nUnitIndex, int nPosition, bool bIsActiveSlot);
	void STATIC_ServerTrackPlayerMute(const struct Fdword& nPlayerId, bool bConsole);
	void STATIC_ServerPlayPing(float X, float Y, float Z, TEnumAsByte<EPING_TYPE> pingType);
	void STATIC_ServerPlayVGS(int nVgsId, int usedVPSetting);
	void STATIC_ServerRevertInventoryTransaction();
	void STATIC_ServerRollbackInventoryTransaction(int nNumSteps);
	void STATIC_ServerSellItem(int nInventoryId);
	void STATIC_ServerUpgradeItem(int nLootTableId, int nLootTableItemId, int nUpgradeInvId);
	void STATIC_ServerPurchaseItem(int nLootTableId, int nLootTableItemId, int nItemCount);
	void STATIC_ServerSwapConsumableOrder();
	void STATIC_ServerSwapAbilityOrder();
	void STATIC_DisplayIdleWarning();
	int STATIC_GetTaskForceNumber();
	void STATIC_ClientUpdateTutorialBlockingActions();
	bool STATIC_ClientUpdateUIDeviceState();
	void STATIC_ServerAllocateDevicePoint(int nDeviceId);
	bool STATIC_HaveBasicAbilitiesBeenActivated();
	int STATIC_GetDevicePointsSpent();
	int STATIC_GetDevicePointsAvailable();
	bool STATIC_CanAllocateDevicePoint(int nDeviceId, class ATgDevice* aDevice, bool ignorePause);
	TEnumAsByte<EGiveGoldResult> STATIC_ServerTransferGoldBetweenFriendlyPlayers(int ReceivingPlayerID, int GoldCount);
	TEnumAsByte<EGiveGoldResult> STATIC_GiveGoldToFriendlyPlayer(int PlayerID, int GoldCount);
	void LoadRecommendedBuildForRole(TEnumAsByte<EConquestRole> eRole, int nGameMode);
	void STATIC_InitRecommendedRole();
	void STATIC_InitRecommendedBuilds();
	void STATIC_SetAutoSkillUpFlag(bool bOn, bool bForce);
	void STATIC_SetAutoPurchaseFlag(bool bOn, bool bForce);
	void AutoSkillUp();
	void AutoPurchase();
	void STATIC_GetDamageAngle(const struct FRotator& HitDir, float* PitchDegrees, float* YawDegrees);
	void STATIC_RefreshBuffIcons();
	void STATIC_SendUICurrencyChange();
	void STATIC_SendUIXpChange();
	void STATIC_HandleSimulatedProjectile();
	void STATIC_HandleDeferredProjectiles();
	void STATIC_DebugGetLangMsg(int nMsgId);
	void STATIC_SetSoundMode(const struct FName& NewSoundMode);
	void STATIC_DumpPerfTrackData();
	void TgPerfTrack(bool bStart);
	void STATIC_SetPawnTickState(int nState);
	void ToggleTick(const struct FString& ClassName, bool bDisable);
	void STATIC_DoClientSidePerfTracking(int nLength);
	void STATIC_OutputRelevantActors();
	void STATIC_FinishInputBlockCooldown();
	void STATIC_InputBlockCooldown();
	void STATIC_ResetInputBlockTimer();
	bool STATIC_CheckMaxEffectDistance(class APlayerController* P, const struct FVector& SpawnLocation, float CullDistance);
	void STATIC_ConvertTimeDisplay(int nMinutes, struct FString* sDisplay);
	class ATgPawn* STATIC_GetPlayerControlPawn();
	void STATIC_SendGameOverEvent(TEnumAsByte<EGAME_WIN_STATE> gameWinState, bool bPlayerIsAttacker);
	void STATIC_DumpClassInfoToFile(const struct FString& sClassName);
	void STATIC_ClientLoadDevices(class UTgSeqAct_ClientLoadDevices* Action);
	int STATIC_GetDeviceIdByName(const struct FString& sDeviceName);
	void STATIC_SetValue(const struct FString& fsObject, const struct FString& fsVariable, const struct FString& fsValue);
	void GetValue(const struct FString& fsObject, const struct FString& fsValue);
	bool bIsEditor();
	void STATIC_ForceRelevant(class AActor* pActor, float fDuration);
	void STATIC_FinalSave();
	void SpectateDefaultSkins(bool bShow);
	void SpectateAutoSlomo(bool bShow);
	void SpectateExpertMode(bool bShow);
	void SpectateOutlines(bool bShow);
	void SpectateXP(bool bShow);
	void SpectateGold(bool bShow);
	void SpectateCrits(bool bShow);
	void SpectateHeals(bool bShow);
	void SpectateDamage(bool bShow);
	void DisableProfanityFilter(bool bDisable);
	void ToggleInHandTargeting(bool bHide);
	void STATIC_StopLogTo();
	void LogTo(const struct FString& fsHost, int nPort);
	void _Crash();
	void Bug();
	class UTgClientSettings* STATIC_GetClientSettings();
	void MatchAccept(bool bAccepted);
	void MatchLeave(bool bAsTeam);
	void STATIC_ConfirmMatchLeave(bool bLeave);
	void STATIC_Friend(const struct FString& sCmd, const struct FString& sName);
	void STATIC_ServerSetTaskforceLead(const struct FString& fsName);
	bool STATIC_CanCameraSeeActorCenter(class AActor* Other, float ZOffset);
	bool STATIC_CanCameraSeePawnCenter(class ATgPawn* Other);
	class UClass* STATIC_GetHudClass(class UClass* pNewHudType);
	void STATIC_QueueReviveTimeChanged();
	bool IsReadyForStart();
	void STATIC_CanDoFullSellback();
};


// Class TgGame.TgBattleCheatManager
// 0x001C (0x00BC - 0x00A0)
class UTgBattleCheatManager : public UPComCheatManager
{
public:
	class ATgDemoRecSpectator_Debug*                   m_DebugCameraController;                                  // 0x00A0(0x0008)
	int                                                m_nYawRotation;                                           // 0x00A8(0x0004)
	int                                                m_nPitchRotation;                                         // 0x00AC(0x0004)
	int                                                m_nTiledShotAmount;                                       // 0x00B0(0x0004)
	class AActor*                                      m_OriginalViewTarget;                                     // 0x00B4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBattleCheatManager");
		return ptr;
	}


	void BotsOrbit(float fRadius);
	void STATIC_SetMeshScalarVal(const struct FString& ScalarParam, float fScalVal);
	void STATIC_SetMeshVectorVal(const struct FString& VecParam, float fVecX, float fVecY, float fVecZ, float fVecA);
	void STATIC_SpawnTwoBots(const struct FString& godName, bool shouldHookMeUp);
	void ldtest();
	void STATIC_pep();
	void STATIC_siege();
	void lobbymap();
	void assault();
	void arena();
	void STATIC_conquest();
	void STATIC_ranneytest(const struct FString& godName, const struct FString& SkinName);
	void joust();
	void tutorial();
	void JumpToLateGame();
	void STATIC_EnableDevFeatures(bool bEnable);
	void STATIC_DumpRacerData();
	void UpdateCamera();
	void STATIC_DoScreenshot();
	void ActivateGlobeCamera(int YawRotation, int PitchRotation, int TiledShotAmount, class ACameraActor* DesiredCamera);
	void UpdateArenaScore(int nTaskForce, int NewScore);
	void AdjustArenaScore(int nTaskForce, int NewScore);
	void ResetCooldown(TEnumAsByte<ETG_EQUIP_POINT> ItemSlot);
	void ItemCooldown(TEnumAsByte<ETG_EQUIP_POINT> ItemSlot);
	void STATIC_PlayerOverviewCamera(bool bOn);
	void UnlockVoicePack(bool bOn);
	void AllEmotes(bool bOn);
	void STATIC_TestToggleLightMode(unsigned char NewMode);
	void InvisMe(bool bInvis);
	void ToggleSpectatorCamera();
	void STATIC_ShowPlayerCircles(bool bEnabled);
	void ToggleRacerAutoDrive();
	void STATIC_SetCompletedLaps(int Laps);
	void STATIC_ForceAllRacersToFinish(float DeltaTime);
	void STATIC_RestartRacers();
	void STATIC_GiveRacerItem(int nItemId);
	void EnableDebugCamera(bool bEnableDebugText);
	void STATIC_CameraDebugSpeed(float fCamSpeed);
	void STATIC_FOVOverride(float fFOV);
	void BugItGo(float X, float Y, float Z, int Pitch, int Yaw, int Roll);
	void Warp(float fWarpLocX, float fWarpLocY, float fWarpLocZ);
	void STATIC_PlayersShoot(int eEquipSlot);
	void BotsShoot(int eEquipSlot);
	void STATIC_TestSilence(bool IsSilenced);
	void STATIC_TestStun(TEnumAsByte<EStunType> Type);
	void STATIC_TestStunEffect(float fDuration);
	void STATIC_TestTiDiEffect(float fDilation, float fDuration);
	void STATIC_TestShowInventory();
	void LevelAbilities(class ATgPawn* pawnGod);
	void STATIC_HitMeWith(int Value, int AttackDamageType);
	void STATIC_DamageTarget(int DamageAmount);
	void STATIC_DamageMe(int Value);
	void STATIC_SetEnergy(float Value);
	void QuickEndGame(bool bWin);
	void STATIC_Qeg(bool bWin);
	void STATIC_SetMeLevel(int nLevel);
	void STATIC_Obama(int nCurrency);
	void AddGold(int nCurrency);
	void STATIC_EquipDevice(int nDeviceId, int nEquipPointId);
	void STATIC_EquipDeviceByName(const struct FString& sDeviceName, int nEquipPointId);
	void STATIC_TEDBN(const struct FString& sDeviceName, int nEquipPointId);
	void STATIC_TargetEquipDeviceByName(const struct FString& sDeviceName, int nEquipPointId);
	void STATIC_TED(int nDeviceId, int nEquipPointId);
	void STATIC_TargetEquipDevice(int nDeviceId, int nEquipPointId);
	void STATIC_EquipDeviceOnPawn(class ATgPawn* TgP, int nDeviceId, int nEquipPointId);
	void STATIC_TargetMaxPower();
	void STATIC_ChangeTaskForce(unsigned char nTaskForce);
	void ShowFootstepInfo();
	void BeTheBoss();
	void TowerKiller();
	void ApplyProp(int nPropId, float nValue, int nCategory);
	void STATIC_SpectatorCamera(bool bOn);
	void botsstealth(bool bOn);
	void botscooldown(bool bOn);
	void botsenergy(bool bOn);
	void botslevel(int nLevel);
	void botsgod(bool bOn);
	void STATIC_RequestRelease();
	void STATIC_TestObstacleAvoidance(int TestType);
	void ToggleVisionRangeDebug();
	void ToggleAIVis(unsigned char TaskforceNum);
	void ToggleAIDebug(bool bAttachAIDebugger);
	void ToggleDebugDisplay(int btBitField);
	void ToggleAnimDebug();
	void ToggleCharDebug();
	void ToggleLightingDebug();
	void STATIC_EnableAnimDebug(bool bLockRotation, bool bShowAnims, const struct FName& nmSocket);
	void ToggleCustomPhysics();
	void ToggleDeviceLog(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void KillAllPawnsByClass(const struct FString& PawnClassName, int nTaskForce);
	void KillAllPawnsHelper(class UClass* PawnClass, int nTaskForce);
	void KillAllMinions();
	void _SpawnTemplatePlayer(int nProfileId, int nSkinId);
	void STATIC_SetInventoryDirty();
	void STATIC_ShowMoveErrors();
	void SetFogHUDFx(bool bOn);
	void SetWhiteoutHUDFx(bool bOn);
	void STATIC_SetPlayerTitleMsgId(int nId);
	void STATIC_SetRecallSkinId(int nId);
	void STATIC_SetGlobalEmoteSkinId(int nId);
	void STATIC_SetLevelUpSkinId(int nId);
	void STATIC_SetFountainSkinId(int nId);
	void STATIC_SetDeathStampId(int nId);
	void STATIC_SetJumpStampId(int nId);
	void STATIC_SetStealth(bool bOn);
	void STATIC_SetGroundspeed(float val);
	void BotsBuy(int nItemId);
	void STATIC_GiveRecommendedItems();
	void botsemote(TEnumAsByte<EEmote> EmoteId);
	void botsup();
	void ForwardConsoleCommand(const struct FString& strCommand, bool bWriteToLog);
	void STATIC_Showcase(int eEquipSlot, float fSlomoAmount);
	void NoMoreMinions();
	void STATIC_StreamMeUp();
	void STATIC_HookMeUp();
	void KnockbackDist(float newdist);
	void MaxPower();
	void Cooldown();
	void STATIC_Energy();
	void STATIC_PawnAnimTest(const struct FName& AnimName, float fRate, bool bLoop);
	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
	void STATIC_God();
	void STATIC_CheatLog(const struct FString& cheatText, bool bOn);
	void STATIC_SimNWCondition(int nPktLoss, int nPktLag);
	void MaxLevel();
	void STATIC_SetLobbySkin(int nSkinId);
	void STATIC_TestSkinGalleryLobby(int nGallery, int nPose);
	void STATIC_TestSkinGallery(int nGallery);
	void STATIC_SpawnBot121(const struct FString& sName, int nTaskForce, const struct FString& SkinName);
	void STATIC_SpawnBotGrid(const struct FString& sName, int nTaskForce, int nCountForward, int nCountLateral, const struct FString& SkinName);
	void STATIC_SpawnBotLine(const struct FString& sName, int nTaskForce, int nCount, const struct FString& SkinName);
	void SpawnBot(const struct FString& sName, int nTaskForce, int nCount, const struct FString& BehaviorTreeName, const struct FString& SkinName);
	void _SpawnBot(const struct FString& sName, int nTaskForce, int nCount, const struct FString& SkinName);
	void STATIC_ServerExec(const struct FString& FSCommand);
	void STATIC_Loc();
	void STATIC_echo(const struct FString& inputString);
	void ToggleAutoBuy(bool bEnable, bool bForce);
	struct FString STATIC_GetDefaultConfigName(class UClass* ConfigClass);
	struct FString STATIC_GetConfigName(class UClass* ConfigClass);
	void STATIC_ReloadConfigFile(class UClass* ConfigClass);
	void STATIC_RefreshRuntimeObjects(class UClass* ConfigClass);
	void UpdateConfig(const struct FString& sClassName, bool bRefreshRuntimeObjects);
	void ToggleAddWorldTimeLimitCheck();
	void STATIC_StopCurrentQueue();
	void LogBehaviorStats();
	void STATIC_DeferredEndShowcase();
	void STATIC_EndShowcase();
	void AddBotsToCustomMatch();
	void STATIC_SetAILevel(class ATgAIController_BehaviorGod* aic, int nLevel);
	void STATIC_StreamMusicTheme(int themeid);
	void STATIC_SetFallbackToDefaultSkins(bool bFallback, bool bForce);
	void STATIC_SetLobbySkinId(int nSkinId);
	void STATIC_SpawnBotAllSkinsLobby(int nBatch, unsigned char pose);
	void STATIC_SpawnBotAllSkins(int nBatch);
	void STATIC_SpawnBotInGrid(const struct FString& botName, int TaskForce, int nCountForward, int nCountLateral, const struct FString& SkinName);
	void STATIC_SpawnBotInLine(const struct FString& botName, int TaskForce, int nCount, const struct FString& SkinName);
	void STATIC_SpawnBotByName(const struct FString& botName, int TaskForce, int nCount, const struct FString& BehaviorTreeName, const struct FString& SkinName);
	void NativeMaxLevel();
	void STATIC_TestLanguage(const struct FString& newLangExt);
	void ListTickableActors(TEnumAsByte<ETickingGroup> checkgroup);
	void JoinMatchQueue(int nQueueId, int god1, int god2, int god3, int god4, int god5);
	void STATIC_SwitchGlobalEmote(const struct FString& globalEmoteSkinName);
	void STATIC_SwitchWard(const struct FString& wardSkinName);
	void STATIC_SwitchClass(const struct FString& godName, const struct FString& SkinName);
	void LogPerfLeakData();
};


// Class TgGame.TgCharacterBuilderLight
// 0x0000 (0x026C - 0x026C)
class ATgCharacterBuilderLight : public ASpotLightToggleable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCharacterBuilderLight");
		return ptr;
	}

};


// Class TgGame.TgClientSettings
// 0x01E8 (0x0248 - 0x0060)
class UTgClientSettings : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                             // 0x0060(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0068(0x0008) (Const, Native, NoExport)
	TEnumAsByte<ETgClientSettingVersion>               ClientSettingsVersion;                                    // 0x0070(0x0001) (Config, GlobalConfig)
	TEnumAsByte<ENamePlateName>                        OverlayGodName;                                           // 0x0071(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<EFriendStateNotifications>             ShowFriendStateNotifications;                             // 0x0072(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<EFriendStateNotifications>             ShowClanStateNotifications;                               // 0x0073(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ETargetingLineStyle>                   TargetingLineStyle;                                       // 0x0074(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ETargetingPreviewStyle>                TargetingPreviewStyle;                                    // 0x0075(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ETargetingReticleStyle>                TargetingReticleStyle;                                    // 0x0076(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ETargetingHighlightStyle>              TargetingHighlightStyle;                                  // 0x0077(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<ECastMode>                             CastMode;                                                 // 0x0078(0x0001) (Edit, Config, GlobalConfig)
	TEnumAsByte<EColorBlindOption>                     SelectedColorBlindOption;                                 // 0x0079(0x0001) (Edit, Config, GlobalConfig)
	unsigned char                                      UnknownData00[0x2];                                       // 0x007A(0x0002) MISSED OFFSET
	float                                              UIScaling;                                                // 0x007C(0x0004) (Edit, Config, GlobalConfig)
	float                                              HUDScaling;                                               // 0x0080(0x0004) (Edit, Config, GlobalConfig)
	float                                              CombatTextScaling;                                        // 0x0084(0x0004) (Edit, Config, GlobalConfig)
	float                                              ChatScaling;                                              // 0x0088(0x0004) (Edit, Config, GlobalConfig)
	float                                              ChatFadeout;                                              // 0x008C(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      OverlayShowLocalPlayer : 1;                               // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableHelpMessages : 1;                                  // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowInHandTargeting : 1;                                  // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableTargetingAid : 1;                                  // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      VerticalTargetingPreviews : 1;                            // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableProfanityFilter : 1;                               // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowTeamTags : 1;                                         // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateDamage : 1;                                       // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateHeals : 1;                                        // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateCrits : 1;                                        // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateGold : 1;                                         // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateXP : 1;                                           // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateOutlines : 1;                                     // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateExpertMode : 1;                                   // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateDefaultSkins : 1;                                 // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SpectateAutoSlomo : 1;                                    // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowRentNotification : 1;                                 // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowWardPings : 1;                                        // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SelfMuteChat : 1;                                         // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SelfMuteVGS : 1;                                          // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      HideOthersNamesInMatches : 1;                             // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      HideMyNameInMatches : 1;                                  // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      LoadAssistModeSubLevel : 1;                               // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      LandingPanelMinimized : 1;                                // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bJumpEnabled : 1;                                         // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bPublicParty : 1;                                         // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bOptInNewFeatures : 1;                                    // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bResetSensitivity : 1;                                    // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bTargetingAlwaysShowPreview : 1;                          // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bUseCastQueueing : 1;                                     // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bUseFixedPitchMode : 1;                                   // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      NewUserPromptTutorialMatch : 1;                           // 0x0090(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      NewUserFinished : 1;                                      // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      VendorStoreTopTier : 1;                                   // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableHelpPopups : 1;                                    // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bShowManaUsage : 1;                                       // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      GodPageDisplayCard : 1;                                   // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bUseHudv1 : 1;                                            // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableChatTrayPopup : 1;                                 // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bEnableFriendsTrayPopup : 1;                              // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bHideEventQuestNotice : 1;                                // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bIsVsAI : 1;                                              // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bIsPractice : 1;                                          // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ColorBlindMode : 1;                                       // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ColorBlindModeShader : 1;                                 // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      MasterMute : 1;                                           // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      SFXMute : 1;                                              // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      MusicMute : 1;                                            // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      VoiceMute : 1;                                            // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      MatchNotifierMute : 1;                                    // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      AllPlayerMute : 1;                                        // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ChatNotifierMute : 1;                                     // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      VivoxEnabled : 1;                                         // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      VivoxMute : 1;                                            // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      VivoxMicMute : 1;                                         // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      QueueWaitRegion : 1;                                      // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      QueueWaitSolo : 1;                                        // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      BotPracticeMode : 1;                                      // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableCrossplay : 1;                                     // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      PCInputIsGamepad : 1;                                     // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ConsoleInputIsGamepad : 1;                                // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      CrossplayMatchInput : 1;                                  // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      AutoPurchase : 1;                                         // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      AutoSkill : 1;                                            // 0x0094(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      AutoFilter : 1;                                           // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowGameTips : 1;                                         // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowRoleGuides : 1;                                       // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      ShowAllRecommendedBuilds : 1;                             // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableJoystickInput : 1;                                 // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      bAllowLogitechLedSdk : 1;                                 // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      EnableControllerFeedback : 1;                             // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      EnableBasicAttackControllerFeedback : 1;                  // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      DisableAimAssist : 1;                                     // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      InvertY : 1;                                              // 0x0098(0x0004) (Edit, Config, GlobalConfig)
	unsigned long                                      blockNonFriendChat : 1;                                   // 0x0098(0x0004)
	unsigned long                                      newUserFinishedTutorial : 1;                              // 0x0098(0x0004)
	unsigned long                                      hasSeenSmiteIntroCinematic : 1;                           // 0x0098(0x0004)
	unsigned long                                      newUserSkipTraining : 1;                                  // 0x0098(0x0004)
	unsigned long                                      newUserFinishedEmailSetup : 1;                            // 0x0098(0x0004)
	unsigned long                                      newPromotionalCode : 1;                                   // 0x0098(0x0004)
	unsigned long                                      bSkipSaveOnSettingsChanged : 1;                           // 0x0098(0x0004)
	unsigned long                                      bHasSeenNewLeague : 1;                                    // 0x0098(0x0004)
	unsigned long                                      bHasSeenMatchTeamBoosters : 1;                            // 0x0098(0x0004)
	unsigned long                                      bHasSeenProfileWorshipers : 1;                            // 0x0098(0x0004)
	unsigned long                                      bHasSeenCelestialVoyageEvent : 1;                         // 0x0098(0x0004)
	unsigned long                                      bHasSeenDreamHackEvent : 1;                               // 0x0098(0x0004)
	unsigned long                                      bHasSeen2017SummerOfSmite : 1;                            // 0x0098(0x0004)
	unsigned long                                      bHasSeenPointTipping : 1;                                 // 0x0098(0x0004)
	unsigned long                                      bHasSeenOdysseyVideo1 : 1;                                // 0x0098(0x0004)
	unsigned long                                      bHasSeenOdysseyVideo2 : 1;                                // 0x0098(0x0004)
	unsigned long                                      bHasSeenOdysseyVideo3 : 1;                                // 0x0098(0x0004)
	unsigned long                                      bHasSeenOdysseyVideo4 : 1;                                // 0x0098(0x0004)
	unsigned long                                      bHasSeenOdysseyVideo5 : 1;                                // 0x0098(0x0004)
	unsigned long                                      bHasSeenOdysseyVideo6 : 1;                                // 0x0098(0x0004)
	unsigned long                                      bHasSeenOdysseyVideo7 : 1;                                // 0x0098(0x0004)
	unsigned long                                      bHasSeenOdysseyVideo8 : 1;                                // 0x0098(0x0004)
	unsigned long                                      bHasSeenRagnarokEvent : 1;                                // 0x009C(0x0004)
	unsigned long                                      bHasSeenSTSpring2018 : 1;                                 // 0x009C(0x0004)
	unsigned long                                      bHasSeenBirthdayEvent : 1;                                // 0x009C(0x0004)
	unsigned long                                      bHasSeenBirthdayQuests : 1;                               // 0x009C(0x0004)
	unsigned long                                      bHasSeenSTSummer2018 : 1;                                 // 0x009C(0x0004)
	unsigned long                                      bHasSeenDivineUprisingRules : 1;                          // 0x009C(0x0004)
	unsigned long                                      bHasSeenDivineUprisingLore : 1;                           // 0x009C(0x0004)
	unsigned long                                      bHasSeenDivineUprisingLore2 : 1;                          // 0x009C(0x0004)
	unsigned long                                      bHasSeenDivineUprisingLore3 : 1;                          // 0x009C(0x0004)
	unsigned long                                      bHasSeenGrimOmensChapter2 : 1;                            // 0x009C(0x0004)
	unsigned long                                      bHasSeenGrimOmensChapter3 : 1;                            // 0x009C(0x0004)
	unsigned long                                      bHasSeenGrimOmensChapter4 : 1;                            // 0x009C(0x0004)
	unsigned long                                      bHasSeenGrimOmensChapter3Quests : 1;                      // 0x009C(0x0004)
	unsigned long                                      bHasSeenGrimOmensChapter4Quests : 1;                      // 0x009C(0x0004)
	unsigned long                                      bHasSeenCommendationSystem : 1;                           // 0x009C(0x0004)
	unsigned long                                      bHasSeenSTFall2018 : 1;                                   // 0x009C(0x0004)
	unsigned long                                      bHasSeenDivineUprisingFinal : 1;                          // 0x009C(0x0004)
	unsigned long                                      bHasSeenHerasOdyssey1 : 1;                                // 0x009C(0x0004)
	unsigned long                                      bHasSeenLegendOfCamelot1 : 1;                             // 0x009C(0x0004)
	unsigned long                                      bHasSeenSeasonalEvent : 1;                                // 0x009C(0x0004)
	unsigned long                                      bHasSeenSeasonalEvent2 : 1;                               // 0x009C(0x0004)
	unsigned long                                      bHasSeenSeasonalEventRedBull : 1;                         // 0x009C(0x0004)
	unsigned long                                      bHasSeenSeasonalEventRedBullFlawes : 1;                   // 0x009C(0x0004)
	unsigned long                                      bHasSeenSeasonalEventBirthday : 1;                        // 0x009C(0x0004)
	unsigned long                                      bHasSeenGiftingTutorial : 1;                              // 0x009C(0x0004)
	unsigned long                                      bHasSeenBattlePass : 1;                                   // 0x009C(0x0004)
	unsigned long                                      bHasSeenBattlePassQuests : 1;                             // 0x009C(0x0004)
	unsigned long                                      bHasSeenEsportAndStream : 1;                              // 0x009C(0x0004)
	unsigned long                                      bHasSeenNewMoonEvent : 1;                                 // 0x009C(0x0004)
	unsigned long                                      bHasSeenOdyssey2020 : 1;                                  // 0x009C(0x0004)
	unsigned long                                      bHasSeenGiftingEvent2020 : 1;                             // 0x009C(0x0004)
	unsigned long                                      bHasSeenRoleGuidesFeature : 1;                            // 0x009C(0x0004)
	unsigned long                                      m_bConfigDirty : 1;                                       // 0x00A0(0x0004)
	unsigned long                                      m_bServerDirty : 1;                                       // 0x00A0(0x0004)
	unsigned long                                      EnableUpcomingFeatures : 1;                               // 0x00A0(0x0004)
	int                                                TeamTagFormat;                                            // 0x00A4(0x0004) (Edit, Config, GlobalConfig)
	int                                                SpectateBottomBarSize;                                    // 0x00A8(0x0004) (Edit, Config, GlobalConfig)
	float                                              MinimapOpacity;                                           // 0x00AC(0x0004) (Edit, Config, GlobalConfig)
	int                                                PreferredControls;                                        // 0x00B0(0x0004) (Edit, Config, GlobalConfig)
	int                                                HealthBarOpacity;                                         // 0x00B4(0x0004) (Edit, Config, GlobalConfig)
	int                                                HealthBarScale;                                           // 0x00B8(0x0004) (Edit, Config, GlobalConfig)
	int                                                nSelectedPreset;                                          // 0x00BC(0x0004) (Edit, Config, GlobalConfig)
	float                                              CastQueueTime;                                            // 0x00C0(0x0004) (Edit, Config, GlobalConfig)
	float                                              FixedPitchLowerBoundDegrees;                              // 0x00C4(0x0004) (Edit, Config, GlobalConfig)
	float                                              FixedPitchUpperBoundDegrees;                              // 0x00C8(0x0004) (Edit, Config, GlobalConfig)
	int                                                PlayNowTabId;                                             // 0x00CC(0x0004) (Edit, Config, GlobalConfig)
	int                                                VendorStoreTabId;                                         // 0x00D0(0x0004) (Edit, Config, GlobalConfig)
	int                                                VendorStoreTypeId;                                        // 0x00D4(0x0004) (Edit, Config, GlobalConfig)
	int                                                VendorStoreTypeRecId;                                     // 0x00D8(0x0004) (Edit, Config, GlobalConfig)
	int                                                VPSelection;                                              // 0x00DC(0x0004) (Edit, Config, GlobalConfig)
	struct FString                                     TransformSettings;                                        // 0x00E0(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     TransformSettingsV2;                                      // 0x00F0(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	int                                                OdysseySeenFlags;                                         // 0x0100(0x0004) (Edit, Config, GlobalConfig)
	int                                                ChestTutorialSeen;                                        // 0x0104(0x0004) (Edit, Config, GlobalConfig)
	struct FString                                     FavoriteGameModes;                                        // 0x0108(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     DailyDealTracking;                                        // 0x0118(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     LastSeenLoginBlocker;                                     // 0x0128(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     LastSeenPatchOverview;                                    // 0x0138(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	struct FQWord                                      qwLastSeenGiftAcquisitionId;                              // 0x0148(0x0008) (Edit, Config, GlobalConfig)
	struct FString                                     PlayFeaturedQueue;                                        // 0x0150(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	struct FTgListLastSeen                             LastSeen;                                                 // 0x0160(0x0030) (Edit, Config, GlobalConfig, NeedCtorLink)
	int                                                queueA;                                                   // 0x0190(0x0004) (Edit, Config, GlobalConfig)
	int                                                queueB;                                                   // 0x0194(0x0004) (Edit, Config, GlobalConfig)
	int                                                ColorBlindModeShaderType;                                 // 0x0198(0x0004) (Edit, Config, GlobalConfig)
	float                                              ColorBlindModeIntensity;                                  // 0x019C(0x0004) (Edit, Config, GlobalConfig)
	float                                              MasterVolume;                                             // 0x01A0(0x0004) (Edit, Config, GlobalConfig)
	float                                              SFXVolume;                                                // 0x01A4(0x0004) (Edit, Config, GlobalConfig)
	float                                              MusicVolume;                                              // 0x01A8(0x0004) (Edit, Config, GlobalConfig)
	float                                              VoiceVolume;                                              // 0x01AC(0x0004) (Edit, Config, GlobalConfig)
	float                                              MatchNotifierVolume;                                      // 0x01B0(0x0004) (Edit, Config, GlobalConfig)
	float                                              VivoxVolume;                                              // 0x01B4(0x0004) (Edit, Config, GlobalConfig)
	float                                              VivoxMicVolume;                                           // 0x01B8(0x0004) (Edit, Config, GlobalConfig)
	int                                                VivoxInputType;                                           // 0x01BC(0x0004) (Edit, Config, GlobalConfig)
	struct FString                                     VivoxInputKey;                                            // 0x01C0(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)
	float                                              Gamma;                                                    // 0x01D0(0x0004) (Edit, Config, GlobalConfig)
	float                                              GammaHandheld;                                            // 0x01D4(0x0004) (Edit, Config, GlobalConfig)
	int                                                BotDifficulty;                                            // 0x01D8(0x0004) (Edit, Config, GlobalConfig)
	float                                              LookSensitivity;                                          // 0x01DC(0x0004) (Edit, Config, GlobalConfig)
	float                                              LookSensitivityY;                                         // 0x01E0(0x0004) (Edit, Config, GlobalConfig)
	float                                              LookAccelSpeed;                                           // 0x01E4(0x0004) (Edit, Config, GlobalConfig)
	float                                              LeftDeadZone;                                             // 0x01E8(0x0004) (Edit, Config, GlobalConfig)
	float                                              RightDeadZone;                                            // 0x01EC(0x0004) (Edit, Config, GlobalConfig)
	float                                              LookFriction;                                             // 0x01F0(0x0004) (Edit, Config, GlobalConfig)
	float                                              LookFrictionY;                                            // 0x01F4(0x0004) (Edit, Config, GlobalConfig)
	float                                              RangeRotationLimitSq;                                     // 0x01F8(0x0004) (Edit, Config, GlobalConfig)
	int                                                nCachedEventActiveQuests;                                 // 0x01FC(0x0004) (Edit, Config, GlobalConfig)
	int                                                nCachedEventActiveQuestChain;                             // 0x0200(0x0004) (Edit, Config, GlobalConfig)
	int                                                bHideGodStats;                                            // 0x0204(0x0004)
	TArray<int>                                        newUserWatchedVideos;                                     // 0x0208(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        newUserTutorialsPlayed;                                   // 0x0218(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                newUserTrainingProgression;                               // 0x0228(0x0004)
	int                                                hasSeenCurrentAdventure;                                  // 0x022C(0x0004)
	int                                                nBrowserMuteCount;                                        // 0x0230(0x0004)
	struct FString                                     m_sCurrentPreset;                                         // 0x0234(0x0010) (NeedCtorLink)
	float                                              m_nLastUpdate;                                            // 0x0244(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgClientSettings");
		return ptr;
	}


	bool UpdatePlayerMuteSetting(bool PlayerMuteSetting);
	bool STATIC_GetLastSeenIds(const struct FString& sValue, TArray<struct Fdword>* out_Value);
	bool UpdateLastSeenIds(struct FString* prop, TArray<struct Fdword>* Value);
	bool STATIC_GetLastSeenIdsByName(const struct FName& PropName, TArray<struct Fdword>* out_Value);
	bool UpdateLastSeenIdsByName(const struct FName& PropName, TArray<struct Fdword>* Value);
	TEnumAsByte<ETargetingHighlightStyle> STATIC_GetTargetingHighlightStyle();
	void STATIC_SetCastMode(TEnumAsByte<ECastMode> castModeVal, int godId, TEnumAsByte<ETG_EQUIP_POINT> equipPoint);
	TEnumAsByte<ECastMode> STATIC_GetCastMode(int godId, TEnumAsByte<ETG_EQUIP_POINT> equipPoint);
	void STATIC_OverrideVoiceInGameSettings(bool bOverride);
	bool WriteSaveGameDataViaInterface(unsigned char LocalUserNum, const struct FString& Title, const struct FString& SubTitle, const struct FString& Description, struct FString* SaveFileName, TArray<unsigned char>* SaveGameData);
	bool GetSaveGameDataViaInterface(unsigned char LocalUserNum, struct FString* SaveFileName, unsigned char* bIsValid, TArray<unsigned char>* SaveGameData);
	bool ConditionalReadSaveGameData(int PlayerID, const struct FString& SaveFileName);
	void STATIC_OnReadSaveGameData(bool bWasSuccessful, unsigned char LocalUserNum, const struct FString& SaveFileName);
	void STATIC_SetGammaValue(float InGamma);
	float STATIC_GetGammaValue();
	void STATIC_ForceSave(bool bConfig, bool bServer);
	void STATIC_SavePlayerSettings();
	void LoadPlayerSettingsFromIni();
	void LoadPlayerSettings();
	bool UpdateSettingsVersion();
	bool VerifySettingsAreValid();
	void ApplyVideoSettings();
	void ApplyInputSettings();
	void ApplyAudioSettings();
	void STATIC_OnCachedQueueUpdated();
	void STATIC_SetLastPatchOverviewSeen(const struct FString& sOverviewId);
	void STATIC_SetLastGiftAcquisitionSeen(const struct FQWord& nAcquisitionId);
	void STATIC_SetLastLoginBlockerSeen(const struct FString& sBlockerId);
	void STATIC_SetChestTutorialSeen();
	void STATIC_SaveLastSeenDailyDeal();
	void STATIC_OnOdysseyViewChanged();
	void STATIC_SetSkipSaveOnSettingsChanged(bool bSkipSave);
	void OnSettingsChanged(int settingtype, bool bSkipSave);
	void LoadSettingsOnStartup();
};


// Class TgGame.TgCollisionPlaneOptimizer
// 0x0004 (0x0264 - 0x0260)
class ATgCollisionPlaneOptimizer : public AActor
{
public:
	float                                              MinCollisionZ;                                            // 0x0260(0x0004) (Edit, Transient, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionPlaneOptimizer");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy
// 0x0054 (0x02B4 - 0x0260)
class ATgCollisionProxy : public AActor
{
public:
	TArray<class ATgPawn*>                             m_NearByPlayers;                                          // 0x0260(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIgnoreStealthPlayers : 1;                              // 0x0270(0x0004)
	unsigned long                                      m_bIgnoreNonPlayers : 1;                                  // 0x0270(0x0004)
	unsigned long                                      m_bIgnoreInvulnerablePlayers : 1;                         // 0x0270(0x0004)
	unsigned long                                      m_bForwardOwnerOnly : 1;                                  // 0x0270(0x0004)
	struct FScriptDelegate                             __ProxyTouch__Delegate;                                   // 0x0274(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0274(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyUnTouch__Delegate;                                 // 0x0284(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0284(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyTouchWithSource__Delegate;                         // 0x0294(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData02[0x4];                                       // 0x0294(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyUnTouchWithSource__Delegate;                       // 0x02A4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData03[0x4];                                       // 0x02A4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy");
		return ptr;
	}


	void BaseChange();
	void ForceProximityScan(float Radius);
	void STATIC_GetNearByPlayersTaskforce(bool bEndWhenMultipleFound, TArray<int>* NearByPlayerTaskforces);
	int STATIC_GetNearByPlayers(bool bOnlyValid);
	void STATIC_OnPlayerRemoved(class ATgPawn* aPawn);
	void STATIC_OnPlayerAdded(class ATgPawn* aPawn);
	void STATIC_CheckNearByPlayers(class ATgPawn* aPawn, bool bAdd);
	void Destroyed();
	void ForceClearNearByPlayersList();
	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TouchOther(class AActor* Other, class UPrimitiveComponent* OtherComp);
	void STATIC_DelegatesUpdated();
	void STATIC_ForwardUnTouch(class AActor* Other);
	void STATIC_ForwardTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProxyUnTouchWithSource(class ATgCollisionProxy* SourceProxy, class AActor* Other);
	void ProxyTouchWithSource(class ATgCollisionProxy* SourceProxy, class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgCollisionProxy_Blocking
// 0x0000 (0x02B4 - 0x02B4)
class ATgCollisionProxy_Blocking : public ATgCollisionProxy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Blocking");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Box
// 0x0008 (0x02BC - 0x02B4)
class ATgCollisionProxy_Box : public ATgCollisionProxy
{
public:
	class UStaticMeshComponent*                        m_CollisionBox;                                           // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Box");
		return ptr;
	}


	void STATIC_SetLocationAndSize(const struct FVector& Start, const struct FVector& End, float Width);
};


// Class TgGame.TgCollisionProxy_BumpNotifies
// 0x0020 (0x02D4 - 0x02B4)
class ATgCollisionProxy_BumpNotifies : public ATgCollisionProxy
{
public:
	struct FScriptDelegate                             __ProxyBump__Delegate;                                    // 0x02B4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x02B4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyBumpLevel__Delegate;                               // 0x02C4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x02C4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_BumpNotifies");
		return ptr;
	}


	void ProxyBumpLevel(struct FVector* HitLocation, struct FVector* HitNormal);
	void ProxyBump(class AActor* actorBumped, struct FVector* HitLocation, struct FVector* HitNormal);
};


// Class TgGame.TgCollisionProxy_Cylinder
// 0x0008 (0x02BC - 0x02B4)
class ATgCollisionProxy_Cylinder : public ATgCollisionProxy
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                                      // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Cylinder");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_CH08
// 0x0044 (0x0300 - 0x02BC)
class ATgCollisionProxy_CH08 : public ATgCollisionProxy_Cylinder
{
public:
	class ATgRepInfo_CH08_GooSpawner*                  m_GSRI;                                                   // 0x02BC(0x0008)
	unsigned long                                      m_bIsBeingDestroyed : 1;                                  // 0x02C4(0x0004)
	int                                                m_nSpawnerId;                                             // 0x02C8(0x0004)
	float                                              m_fCollisionHeight;                                       // 0x02CC(0x0004) (Const)
	float                                              m_fSpawnOffsetZ;                                          // 0x02D0(0x0004)
	float                                              m_fMaxSpread;                                             // 0x02D4(0x0004)
	float                                              m_fMinSpread;                                             // 0x02D8(0x0004)
	int                                                m_nMaxSpotCount;                                          // 0x02DC(0x0004)
	TArray<struct FCH08_GOO_SPOT>                      m_GooSpots;                                               // 0x02E0(0x0010) (NeedCtorLink)
	TArray<struct FCH08_PAWN_LOCATION_HISTORY>         m_PastLocations;                                          // 0x02F0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_CH08");
		return ptr;
	}


	void STATIC_OnPlayerRemoved(class ATgPawn* aPawn);
	void STATIC_OnPlayerAdded(class ATgPawn* aPawn);
	void Destroyed();
	void STATIC_DeleteGooSpot(int nSpotIndex);
	int STATIC_GetLocationHistoryIndex(class ATgPawn* TestPawn);
	float STATIC_GetGooSpotRadius(TEnumAsByte<ECH08_GOO_SPOT_TYPES> nGooType);
	bool IsTouchingGooSpot(const struct FVector& vTestLocation, float fTestRadius, int nSpotIndex);
	bool MovedThroughGooSpot(int nHistoryIndex, int nSpotIndex);
	void STATIC_SetMaxSpotCount(int nSpotCount);
};


// Class TgGame.TgCollisionProxy_SpectatorActionListener
// 0x0010 (0x02CC - 0x02BC)
class ATgCollisionProxy_SpectatorActionListener : public ATgCollisionProxy_Cylinder
{
public:
	struct FScriptDelegate                             __ProxyDeviceOnStartFire__Delegate;                       // 0x02BC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x02BC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_SpectatorActionListener");
		return ptr;
	}


	void PostDemoRewind();
	bool STATIC_HasMixedTaskforcePlayersNearby();
	void STATIC_ForwardDeviceOnStartFire(class ATgPawn* FiringPawn, int nEquipSlot);
	void ProxyDeviceOnStartFire(class ATgPawn* FiringPawn, int nEquipSlot);
};


// Class TgGame.TgCollisionProxy_FX
// 0x001C (0x02D0 - 0x02B4)
class ATgCollisionProxy_FX : public ATgCollisionProxy
{
public:
	int                                                c_nTargetFxID;                                            // 0x02B4(0x0004)
	struct FName                                       c_TargetSocketName;                                       // 0x02B8(0x0008)
	TArray<struct FProxyFxInfo>                        c_FxInfoList;                                             // 0x02C0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_FX");
		return ptr;
	}


	void STATIC_OnPlayerRemoved(class ATgPawn* aPawn);
	void STATIC_OnPlayerAdded(class ATgPawn* aPawn);
	bool STATIC_ShouldRemoveFx(class ATgPawn* Target);
	bool STATIC_ShouldApplyFx(class ATgPawn* Target);
	void Tick(float DeltaTime);
	void STATIC_RemoveTargetFx(class ATgPawn* Target);
	void ApplyTargetFx(class ATgPawn* Target);
};


// Class TgGame.TgCollisionProxy_GroundPlacementBlocker
// 0x0000 (0x02B4 - 0x02B4)
class ATgCollisionProxy_GroundPlacementBlocker : public ATgCollisionProxy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_GroundPlacementBlocker");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_PawnListener
// 0x0050 (0x0304 - 0x02B4)
class ATgCollisionProxy_PawnListener : public ATgCollisionProxy
{
public:
	struct FScriptDelegate                             __ProxyDeviceOnStartFire__Delegate;                       // 0x02B4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x02B4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyDeviceOnStopFire__Delegate;                        // 0x02C4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x02C4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyPawnOnDamaged__Delegate;                           // 0x02D4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData02[0x4];                                       // 0x02D4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyPawnOnDied__Delegate;                              // 0x02E4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData03[0x4];                                       // 0x02E4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __ProxyPawnOnDamageMitigation__Delegate;                  // 0x02F4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData04[0x4];                                       // 0x02F4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_PawnListener");
		return ptr;
	}


	void STATIC_OnPlayerRemoved(class ATgPawn* aPawn);
	void STATIC_OnPlayerAdded(class ATgPawn* aPawn);
	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void STATIC_DelegatesUpdated();
	void STATIC_ForwardPawnOnDamageMitigation(class ATgPawn* Other, class ATgPawn* attacker, class UTgEffectGroup* Effect, int nPropertyId, float* Damage);
	void STATIC_ForwardPawnOnDied(class ATgPawn* Other);
	void STATIC_ForwardPawnOnDamaged(class ATgPawn* Other, struct FOnDamagedParams* DamageParams);
	void STATIC_ForwardDeviceOnStopFire(class ATgPawn* Other, class ATgDevice* OtherDevice, bool bWasInterrupted);
	void STATIC_ForwardDeviceOnStartFire(class ATgPawn* Other, class ATgDevice* OtherDevice);
	void ProxyPawnOnDamageMitigation(class ATgPawn* Other, class ATgPawn* attacker, class UTgEffectGroup* Effect, int nPropertyId, float* Damage);
	void ProxyPawnOnDied(class ATgPawn* Other);
	void ProxyPawnOnDamaged(class ATgPawn* Other, struct FOnDamagedParams* DamageParams);
	void ProxyDeviceOnStopFire(class ATgPawn* Other, class ATgDevice* OtherDevice, bool bWasInterrupted);
	void ProxyDeviceOnStartFire(class ATgPawn* Other, class ATgDevice* OtherDevice);
};


// Class TgGame.TgCollisionProxy_RadialSweep
// 0x0068 (0x031C - 0x02B4)
class ATgCollisionProxy_RadialSweep : public ATgCollisionProxy
{
public:
	class UStaticMeshComponent*                        m_CollisionBox;                                           // 0x02B4(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fSweepPercent;                                          // 0x02BC(0x0004) (Transient)
	float                                              m_fSweepRadius;                                           // 0x02C0(0x0004) (Transient)
	float                                              m_fSweepWidth;                                            // 0x02C4(0x0004) (Transient)
	float                                              m_fSweepStartTime;                                        // 0x02C8(0x0004) (Transient)
	float                                              m_fSweepEndTime;                                          // 0x02CC(0x0004) (Transient)
	struct FRotator                                    m_SweepStart;                                             // 0x02D0(0x000C) (Transient)
	struct FRotator                                    m_SweepEnd;                                               // 0x02DC(0x000C) (Transient)
	struct FVector                                     m_SweepLastLocation;                                      // 0x02E8(0x000C) (Transient)
	struct FRotator                                    m_SweepLast;                                              // 0x02F4(0x000C) (Transient)
	float                                              m_fSpeed;                                                 // 0x0300(0x0004) (Transient)
	float                                              m_fDeltaSpeed;                                            // 0x0304(0x0004) (Transient)
	unsigned long                                      m_bSweepActive : 1;                                       // 0x0308(0x0004) (Transient)
	struct FScriptDelegate                             __ProxyEndSweep__Delegate;                                // 0x030C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x030C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_RadialSweep");
		return ptr;
	}


	void STATIC_ForceCompleteSweep(int nIterations);
	void UpdateSweep();
	void STATIC_EndSweep(bool bInterrupt);
	void STATIC_StartSweep(float fSweepTime, float fSweepAngle, bool bIndependentAngles, float fStartAngle);
	void STATIC_SetSweepSize(float fSweepWidth, float fSweepRadius);
	void ProxyEndSweep(bool bInterrupted);
};


// Class TgGame.TgCollisionProxy_RadialSweep_FollowBaseRotation
// 0x0000 (0x031C - 0x031C)
class ATgCollisionProxy_RadialSweep_FollowBaseRotation : public ATgCollisionProxy_RadialSweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_RadialSweep_FollowBaseRotation");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Vortex
// 0x002C (0x02E0 - 0x02B4)
class ATgCollisionProxy_Vortex : public ATgCollisionProxy
{
public:
	float                                              m_fGroundSpeedStrafePct;                                  // 0x02B4(0x0004) (Edit)
	float                                              m_fGroundSpeedToVortex;                                   // 0x02B8(0x0004) (Edit)
	float                                              m_fGroundSpeedPctRetained;                                // 0x02BC(0x0004) (Edit)
	float                                              m_fInnerRadius;                                           // 0x02C0(0x0004) (Edit)
	unsigned long                                      m_bEnabled : 1;                                           // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bOnlyAffectCurrentTarget : 1;                           // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bIgnoreFallingTargets : 1;                              // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bOverrideFirstTouch : 1;                                // 0x02C4(0x0004)
	TArray<class ATgPawn*>                             m_TouchedPawns;                                           // 0x02C8(0x0010) (NeedCtorLink)
	class APawn*                                       m_LastInstigator;                                         // 0x02D8(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Vortex");
		return ptr;
	}


	void Destroyed();
	void STATIC_OnPlayerRemoved(class ATgPawn* aPawn);
	void STATIC_OnPlayerAdded(class ATgPawn* aPawn);
	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void InstigatorChanged();
	void Tick(float DeltaTime);
};


// Class TgGame.TgCollisionProxy_ConeKnockback
// 0x0010 (0x02F0 - 0x02E0)
class ATgCollisionProxy_ConeKnockback : public ATgCollisionProxy_Vortex
{
public:
	struct FVector                                     s_vForwardNormal;                                         // 0x02E0(0x000C)
	float                                              s_fMinDot;                                                // 0x02EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_ConeKnockback");
		return ptr;
	}


	void DestroyIt();
};


// Class TgGame.TgCollisionProxy_StrongWinds
// 0x0014 (0x02F4 - 0x02E0)
class ATgCollisionProxy_StrongWinds : public ATgCollisionProxy_Vortex
{
public:
	struct FVector                                     m_vPushDirection;                                         // 0x02E0(0x000C) (Edit)
	float                                              m_fWindStrength;                                          // 0x02EC(0x0004) (Edit)
	unsigned long                                      m_bAffectsTaskForce1 : 1;                                 // 0x02F0(0x0004) (Edit)
	unsigned long                                      m_bAffectsTaskForce2 : 1;                                 // 0x02F0(0x0004) (Edit)
	unsigned long                                      m_bAffectsTaskForce3 : 1;                                 // 0x02F0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_StrongWinds");
		return ptr;
	}


	bool ShouldIgnoreActor(class ATgPawn* aPawn);
};


// Class TgGame.TgCollisionProxy_Vortex_Whirlpool
// 0x0000 (0x02E0 - 0x02E0)
class ATgCollisionProxy_Vortex_Whirlpool : public ATgCollisionProxy_Vortex
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Vortex_Whirlpool");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_WardTrigger
// 0x0008 (0x02BC - 0x02B4)
class ATgCollisionProxy_WardTrigger : public ATgCollisionProxy
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                                      // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_WardTrigger");
		return ptr;
	}

};


// Class TgGame.TgCombinedPostProcessEffect
// 0x003B (0x00C0 - 0x0085)
class UTgCombinedPostProcessEffect : public UPostProcessEffect
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	struct FColor                                      HitEffectColor;                                           // 0x0088(0x0004) (Edit)
	struct FVector                                     SceneShadows;                                             // 0x008C(0x000C)
	struct FVector                                     SceneHighLights;                                          // 0x0098(0x000C)
	struct FVector                                     SceneMidTones;                                            // 0x00A4(0x000C)
	float                                              SceneDesaturation;                                        // 0x00B0(0x0004)
	struct FVector                                     SceneColorize;                                            // 0x00B4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCombinedPostProcessEffect");
		return ptr;
	}

};


// Class TgGame.TgContextNotifyActor
// 0x0000 (0x0260 - 0x0260)
class ATgContextNotifyActor : public AActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgContextNotifyActor");
		return ptr;
	}


	void STATIC_SetContextNotifyType(int ContextId);
};


// Class TgGame.TgDamageType
// 0x0074 (0x0104 - 0x0090)
class UTgDamageType : public UDamageType
{
public:
	unsigned long                                      m_bImpulseMesh : 1;                                       // 0x0090(0x0004)
	unsigned long                                      m_bEnableMotors : 1;                                      // 0x0090(0x0004)
	unsigned long                                      m_bShouldRagdollAfterDeathAnim : 1;                       // 0x0090(0x0004)
	unsigned long                                      m_bCanPlayDeathSpecialFXOnDefaultDeath : 1;               // 0x0090(0x0004)
	unsigned long                                      m_bHarvestMaterialParameters : 1;                         // 0x0090(0x0004)
	unsigned long                                      m_bFreezeAnimsOnDeath : 1;                                // 0x0090(0x0004)
	unsigned long                                      m_bDeathAnimOnlyAffectsMinions : 1;                       // 0x0090(0x0004)
	float                                              m_bMinImpulse;                                            // 0x0094(0x0004)
	float                                              m_bMaxImpulse;                                            // 0x0098(0x0004)
	float                                              m_bMinUpKick;                                             // 0x009C(0x0004)
	float                                              m_bMaxUpKick;                                             // 0x00A0(0x0004)
	TArray<struct FName>                               m_nmDeathAnimNames;                                       // 0x00A4(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_nmDeathFlailAnimNames;                                  // 0x00B4(0x0010) (NeedCtorLink)
	float                                              m_fMinAngularVelocity;                                    // 0x00C4(0x0004)
	float                                              m_fMaxAngularVelocity;                                    // 0x00C8(0x0004)
	int                                                m_nDeathSpecialFXId;                                      // 0x00CC(0x0004)
	int                                                m_nDeathSpecial02FXId;                                    // 0x00D0(0x0004)
	struct FName                                       m_nmDeathSpecialFXSocket;                                 // 0x00D4(0x0008)
	struct FName                                       m_nmDeathSpecial02FXSocket;                               // 0x00DC(0x0008)
	class UMaterialInstanceConstant*                   m_OverrideMaterial;                                       // 0x00E4(0x0008)
	float                                              m_fLifeAfterDeathSeconds;                                 // 0x00EC(0x0004)
	int                                                m_nFadeOutSpecialFXId;                                    // 0x00F0(0x0004)
	TArray<struct FName>                               ActivateSkelControlListOnDeath;                           // 0x00F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType");
		return ptr;
	}


	float STATIC_GetRagdollImpulseMultiplier(class AActor* DamageInstigator);
	struct FName STATIC_GetRandomDeathAnimName();
	struct FName STATIC_GetRandomDeathFlailAnimName();
};


// Class TgGame.TgDamageType_AbilityCost
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_AbilityCost : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_AbilityCost");
		return ptr;
	}

};


// Class TgGame.TgDamageType_FallOutOfWorld
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_FallOutOfWorld : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_FallOutOfWorld");
		return ptr;
	}

};


// Class TgGame.TgDamageType_Major
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_Major : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_Major");
		return ptr;
	}

};


// Class TgGame.TgDamageType_Minor
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_Minor : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_Minor");
		return ptr;
	}

};


// Class TgGame.TgDataItem
// 0x0000 (0x0060 - 0x0060)
class UTgDataItem : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDataItem");
		return ptr;
	}

};


// Class TgGame.TgEventDataItem
// 0x0014 (0x0074 - 0x0060)
class UTgEventDataItem : public UTgDataItem
{
public:
	int                                                nEventType;                                               // 0x0060(0x0004)
	int                                                nSubEventType;                                            // 0x0064(0x0004)
	class UObject*                                     pTarget;                                                  // 0x0068(0x0008)
	unsigned long                                      m_bPreventDefault : 1;                                    // 0x0070(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEventDataItem");
		return ptr;
	}


	bool IsDefaultPrevented();
	void STATIC_PreventDefault();
};


// Class TgGame.TgDataEvent
// 0x0008 (0x007C - 0x0074)
class UTgDataEvent : public UTgEventDataItem
{
public:
	class UTgDataItem*                                 m_pData;                                                  // 0x0074(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDataEvent");
		return ptr;
	}

};


// Class TgGame.TgGameEffectFormEvent
// 0x0014 (0x0088 - 0x0074)
class UTgGameEffectFormEvent : public UTgEventDataItem
{
public:
	int                                                nInstigatorPawnId;                                        // 0x0074(0x0004)
	int                                                nTargetPawnId;                                            // 0x0078(0x0004)
	int                                                nCategoryId;                                              // 0x007C(0x0004)
	int                                                nStackCount;                                              // 0x0080(0x0004)
	int                                                nCustom1;                                                 // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameEffectFormEvent");
		return ptr;
	}

};


// Class TgGame.TgGameQuestEvent
// 0x0010 (0x0084 - 0x0074)
class UTgGameQuestEvent : public UTgEventDataItem
{
public:
	int                                                nId;                                                      // 0x0074(0x0004)
	int                                                nCount;                                                   // 0x0078(0x0004)
	int                                                nGoal;                                                    // 0x007C(0x0004)
	int                                                nMsgId;                                                   // 0x0080(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameQuestEvent");
		return ptr;
	}

};


// Class TgGame.TgGameTRIEvent
// 0x000C (0x0080 - 0x0074)
class UTgGameTRIEvent : public UTgEventDataItem
{
public:
	class ATgRepInfo_TaskForce*                        pTRI;                                                     // 0x0074(0x0008) (Native)
	int                                                nValue;                                                   // 0x007C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameTRIEvent");
		return ptr;
	}

};


// Class TgGame.TgNameEvent
// 0x0008 (0x007C - 0x0074)
class UTgNameEvent : public UTgEventDataItem
{
public:
	struct FName                                       Value;                                                    // 0x0074(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNameEvent");
		return ptr;
	}

};


// Class TgGame.TgStringEvent
// 0x0010 (0x0084 - 0x0074)
class UTgStringEvent : public UTgEventDataItem
{
public:
	struct FString                                     sValue;                                                   // 0x0074(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStringEvent");
		return ptr;
	}

};


// Class TgGame.TgValueEvent
// 0x000C (0x0080 - 0x0074)
class UTgValueEvent : public UTgEventDataItem
{
public:
	struct FTgDataItemValue                            Value;                                                    // 0x0074(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgValueEvent");
		return ptr;
	}

};


// Class TgGame.TgValueDataItem
// 0x000C (0x006C - 0x0060)
class UTgValueDataItem : public UTgDataItem
{
public:
	struct FTgDataItemValue                            Value;                                                    // 0x0060(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgValueDataItem");
		return ptr;
	}

};


// Class TgGame.TgDestructible
// 0x015C (0x0424 - 0x02C8)
class ATgDestructible : public ASkeletalMeshActor
{
public:
	class ATgEffectManager*                            r_EffectManager;                                          // 0x02C8(0x0008) (Net)
	int                                                r_nMaxHealth;                                             // 0x02D0(0x0004) (Edit, Net)
	unsigned long                                      m_bDisplayHealth : 1;                                     // 0x02D4(0x0004) (Edit)
	unsigned long                                      m_bDestroyed : 1;                                         // 0x02D4(0x0004)
	unsigned long                                      m_bFogOfWarBlocker : 1;                                   // 0x02D4(0x0004) (Edit)
	unsigned long                                      m_bOneDirectional : 1;                                    // 0x02D4(0x0004) (Edit)
	int                                                m_nPhysicalType;                                          // 0x02D8(0x0004) (Edit)
	int                                                r_nHealth;                                                // 0x02DC(0x0004) (Net)
	int                                                r_nActorInstanceId;                                       // 0x02E0(0x0004) (Net)
	struct FTG_HUD_INFO                                c_HudInfo;                                                // 0x02E4(0x0140) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDestructible");
		return ptr;
	}


	bool CanApplyEffects();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void ForceNetRelevant();
};


// Class TgGame.TgDistributionFloatSoundAttenuation
// 0x0040 (0x00BC - 0x007C)
class UTgDistributionFloatSoundAttenuation : public UDistributionFloat
{
public:
	TEnumAsByte<ESoundAttenuationType>                 AttenuationType;                                          // 0x007C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x007D(0x0003) MISSED OFFSET
	float                                              Attenuation_Sm_foley;                                     // 0x0080(0x0004) (Config)
	float                                              Attenuation_Lg_foley;                                     // 0x0084(0x0004) (Config)
	float                                              Attenuation_Melee_hit;                                    // 0x0088(0x0004) (Config)
	float                                              Attenuation_Sm_gun;                                       // 0x008C(0x0004) (Config)
	float                                              Attenuation_Med_gun;                                      // 0x0090(0x0004) (Config)
	float                                              Attenuation_Lg_gun;                                       // 0x0094(0x0004) (Config)
	float                                              Attenuation_Sm_exp;                                       // 0x0098(0x0004) (Config)
	float                                              Attenuation_Med_exp;                                      // 0x009C(0x0004) (Config)
	float                                              Attenuation_Lg_exp;                                       // 0x00A0(0x0004) (Config)
	struct FName                                       GroupName;                                                // 0x00A4(0x0008) (Edit)
	TArray<struct FAttenuationGroup>                   AttenuationGroups;                                        // 0x00AC(0x0010) (Config, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDistributionFloatSoundAttenuation");
		return ptr;
	}

};


// Class TgGame.TgEffectParameterTransition
// 0x001C (0x007C - 0x0060)
class UTgEffectParameterTransition : public UObject
{
public:
	struct FEffectParameterTransition                  m_effectTransition;                                       // 0x0060(0x0014)
	float                                              m_fTimeElapsed;                                           // 0x0074(0x0004)
	float                                              m_fLerp;                                                  // 0x0078(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectParameterTransition");
		return ptr;
	}

};


// Class TgGame.TgEffectParameterTransition_Scalar
// 0x0008 (0x0084 - 0x007C)
class UTgEffectParameterTransition_Scalar : public UTgEffectParameterTransition
{
public:
	float                                              m_fStartValue;                                            // 0x007C(0x0004) (Const)
	float                                              m_fTargetValue;                                           // 0x0080(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectParameterTransition_Scalar");
		return ptr;
	}

};


// Class TgGame.TgMaterialParameterTransition_Scalar
// 0x0008 (0x008C - 0x0084)
class UTgMaterialParameterTransition_Scalar : public UTgEffectParameterTransition_Scalar
{
public:
	class UMaterialInstanceConstant*                   m_mic;                                                    // 0x0084(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMaterialParameterTransition_Scalar");
		return ptr;
	}

};


// Class TgGame.TgPscParameterTransition_Scalar
// 0x0008 (0x008C - 0x0084)
class UTgPscParameterTransition_Scalar : public UTgEffectParameterTransition_Scalar
{
public:
	class UParticleSystemComponent*                    m_psc;                                                    // 0x0084(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPscParameterTransition_Scalar");
		return ptr;
	}

};


// Class TgGame.TgEffectParameterTransition_Vector
// 0x0020 (0x009C - 0x007C)
class UTgEffectParameterTransition_Vector : public UTgEffectParameterTransition
{
public:
	struct FLinearColor                                m_colorStartValue;                                        // 0x007C(0x0010) (Const)
	struct FLinearColor                                m_colorTargetValue;                                       // 0x008C(0x0010) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectParameterTransition_Vector");
		return ptr;
	}

};


// Class TgGame.TgMaterialParameterTransition_Vector
// 0x0008 (0x00A4 - 0x009C)
class UTgMaterialParameterTransition_Vector : public UTgEffectParameterTransition_Vector
{
public:
	class UMaterialInstanceConstant*                   m_mic;                                                    // 0x009C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMaterialParameterTransition_Vector");
		return ptr;
	}

};


// Class TgGame.TgPscParameterTransition_Vector
// 0x0008 (0x00A4 - 0x009C)
class UTgPscParameterTransition_Vector : public UTgEffectParameterTransition_Vector
{
public:
	class UParticleSystemComponent*                    m_psc;                                                    // 0x009C(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPscParameterTransition_Vector");
		return ptr;
	}

};


// Class TgGame.TgEffectTransitions
// 0x0048 (0x00A8 - 0x0060)
class UTgEffectTransitions : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<class UTgMaterialParameterTransition_Scalar*> c_materialScalarTransitions;                              // 0x0068(0x0010) (NeedCtorLink)
	TArray<class UTgMaterialParameterTransition_Vector*> c_materialVectorTransitions;                              // 0x0078(0x0010) (NeedCtorLink)
	TArray<class UTgPscParameterTransition_Scalar*>    c_pscScalarTransitions;                                   // 0x0088(0x0010) (NeedCtorLink)
	TArray<class UTgPscParameterTransition_Vector*>    c_pscVectorTransitions;                                   // 0x0098(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectTransitions");
		return ptr;
	}


	void AddPscVectorTarget(class UParticleSystemComponent* PSC, struct FEffectParameterTransition* effectParamTransition, struct FLinearColor* colorTarget);
	void AddPscVectorRange(class UParticleSystemComponent* PSC, struct FEffectParameterTransition* effectParamTransition, struct FLinearColor* colorStart, struct FLinearColor* colorTarget);
	void AddPscScalarTarget(class UParticleSystemComponent* PSC, float fTarget, struct FEffectParameterTransition* effectParamTransition);
	void AddPscScalarRange(class UParticleSystemComponent* PSC, float fStart, float fTarget, struct FEffectParameterTransition* effectParamTransition);
	int STATIC_GetPscVectorIndex(class UParticleSystemComponent* PSC, struct FName* nmParam);
	int STATIC_GetPscScalarIndex(class UParticleSystemComponent* PSC, struct FName* nmParam);
	bool IsPscInterpolating(class UParticleSystemComponent* PSC, struct FName* nmParam);
	void AddMaterialVectorTarget(class UMaterialInstanceConstant* MIC, struct FEffectParameterTransition* effectParamTransition, struct FLinearColor* colorTarget);
	void AddMaterialVectorRange(class UMaterialInstanceConstant* MIC, struct FEffectParameterTransition* effectParamTransition, struct FLinearColor* colorStart, struct FLinearColor* colorTarget);
	void AddMaterialScalarTarget(class UMaterialInstanceConstant* MIC, float fTarget, struct FEffectParameterTransition* effectParamTransition);
	void AddMaterialScalarRange(class UMaterialInstanceConstant* MIC, float fStart, float fTarget, struct FEffectParameterTransition* effectParamTransition);
	int STATIC_GetMaterialVectorIndex(class UMaterialInstanceConstant* MIC, struct FName* nmParam);
	int STATIC_GetMaterialScalarIndex(class UMaterialInstanceConstant* MIC, struct FName* nmParam);
	bool IsMaterialInterpolating(class UMaterialInstanceConstant* MIC, struct FName* nmParam);
};


// Class TgGame.TgEmitterSpawnable
// 0x0000 (0x0274 - 0x0274)
class ATgEmitterSpawnable : public AEmitter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitterSpawnable");
		return ptr;
	}

};


// Class TgGame.TgEmoteConfigResource
// 0x0020 (0x0080 - 0x0060)
class UTgEmoteConfigResource : public UObject
{
public:
	TArray<struct FEmoteConfigEntry>                   m_EnabledEmotes;                                          // 0x0060(0x0010) (NeedCtorLink)
	TArray<struct FEmoteSuccessiveStates>              m_EmoteTrackedStates;                                     // 0x0070(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmoteConfigResource");
		return ptr;
	}


	bool STATIC_EmoteUsesPostProcess(TEnumAsByte<EEmote> Emote);
	bool STATIC_EmoteLocksMusic(TEnumAsByte<EEmote> Emote);
	bool STATIC_EmoteAnimRestarts(TEnumAsByte<EEmote> Emote);
	int STATIC_GetEmoteTrackCap(TEnumAsByte<EEmote> Emote);
	bool STATIC_EmoteUnlocked(TEnumAsByte<EEmote> Emote, int nPlayerLevel);
};


// Class TgGame.TgEmoteConfigResource_VXGLooping
// 0x0000 (0x0080 - 0x0080)
class UTgEmoteConfigResource_VXGLooping : public UTgEmoteConfigResource
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmoteConfigResource_VXGLooping");
		return ptr;
	}

};


// Class TgGame.TgEmoteConfigResource_VXGPostProcess
// 0x0000 (0x0080 - 0x0080)
class UTgEmoteConfigResource_VXGPostProcess : public UTgEmoteConfigResource
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmoteConfigResource_VXGPostProcess");
		return ptr;
	}

};


// Class TgGame.TgEmoteConfigResource_VXGSuppressed
// 0x0000 (0x0080 - 0x0080)
class UTgEmoteConfigResource_VXGSuppressed : public UTgEmoteConfigResource
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmoteConfigResource_VXGSuppressed");
		return ptr;
	}

};


// Class TgGame.TgEmoteConfigResource_VXGSuppressedLooping
// 0x0000 (0x0080 - 0x0080)
class UTgEmoteConfigResource_VXGSuppressedLooping : public UTgEmoteConfigResource
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmoteConfigResource_VXGSuppressedLooping");
		return ptr;
	}

};


// Class TgGame.TgEventDispatcher
// 0x0058 (0x00B8 - 0x0060)
class UTgEventDispatcher : public UObject
{
public:
	unsigned char                                      UnknownData00[0x48];                                      // 0x0060(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgEventDispatcher.m_mapEvents
	struct FScriptDelegate                             __OnTgEvent__Delegate;                                    // 0x00A8(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x00A8(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEventDispatcher");
		return ptr;
	}


	void DoEventDelegate(const struct FScriptDelegate& delCallback, class UTgEventDataItem* pEvent);
	bool STATIC_DispatchEvent(class UTgEventDataItem* pEvent, class UObject* pOwner);
	void STATIC_RemoveAllListeners(int nEventId, class UObject* pScope);
	int STATIC_RemoveEventListener(int nEventId, const struct FScriptDelegate& delCallback);
	int AddEventListener(int nEventId, const struct FScriptDelegate& delCallback);
	void OnTgEvent(class UTgEventDataItem* pEvent);
};


// Class TgGame.TgEventDispatcherInterface
// 0x0000 (0x0060 - 0x0060)
class UTgEventDispatcherInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEventDispatcherInterface");
		return ptr;
	}


	class UTgEventDispatcher* STATIC_GetDispatcher();
};


// Class TgGame.TgFlagContentData
// 0x0010 (0x0070 - 0x0060)
class UTgFlagContentData : public UObject
{
public:
	TArray<struct FFlagMeshData>                       m_MeshData;                                               // 0x0060(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFlagContentData");
		return ptr;
	}


	void STATIC_PreloadTextures(float ForceDuration);
	void GetMeshData(TEnumAsByte<EFlagContentDataType> ContentDataType, struct FFlagMeshData* Data);
	void Init();
};


// Class TgGame.TgFogOfWarBarrier
// 0x0008 (0x027C - 0x0274)
class ATgFogOfWarBarrier : public AStaticMeshActor
{
public:
	unsigned long                                      m_bOneDirectional : 1;                                    // 0x0274(0x0004) (Edit)
	float                                              m_fBlockMinimumDistance;                                  // 0x0278(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFogOfWarBarrier");
		return ptr;
	}

};


// Class TgGame.TgGameEngine
// 0x0000 (0x0AB0 - 0x0AB0)
class UTgGameEngine : public UPComGameEngine
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameEngine");
		return ptr;
	}

};


// Class TgGame.TgHUD
// 0x0008 (0x0588 - 0x0580)
class ATgHUD : public AHUD
{
public:
	class ATgPlayerController*                         m_TgPlayerController;                                     // 0x0580(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHUD");
		return ptr;
	}


	void ToggleStatPanel();
	void STATIC_SetIntendedPanel();
	void STATIC_ShowPreviousInfoPanel();
	void STATIC_ShowNextInfoPanel();
	void STATIC_ShowPreviousStatPanel();
	void STATIC_ShowNextStatPanel();
	bool IsLoggedIn();
	void STATIC_ShowGodTargeter(bool bShow);
	void STATIC_ShowTargetingMap(bool bShow);
	void CommitClassSelectionChange();
	void STATIC_OnCameraReady(class ATgLobbyCamera* PCam);
	void STATIC_PlayDeviceFailResponse(TEnumAsByte<EDeviceFailType> failType);
	void ToggleViewSkipCinematic(bool bShow);
	void STATIC_ShowCursor(bool bShow, bool bUpdateCapture);
	void TutorialMessage(int msgId, bool bTips);
	void STATIC_HideGameTip(bool bNoSound);
	void STATIC_ShowGameTip(int nTipId, bool bNoSound, bool bPopup);
	void STATIC_SetWaypointPing(bool bSetWaypointActive, const struct FVector& vWaypointLoc, int* nWaypointId);
	void STATIC_PingWorldLocation(const struct FVector& PingLocation, TEnumAsByte<EPING_TYPE> Type);
	void STATIC_OnPingInfoUpdate(class ATgRepInfo_Player* updatedPri);
	void STATIC_EndMission(bool bPlayerAttacker, TEnumAsByte<EGAME_WIN_STATE> finalWinState);
	bool UpdateItemStoreItems(class ATgRepInfo_Player* PRI);
	void UpdateScoreboard();
	void UpdateSpectatorSettingsMenu();
	void UpdateKeyBindSettingsMenu(int settingtype);
	void UpdateReleaseTimeRemaining(float fTimeRemaining);
	void PlayTakeHit(const struct FRotator& HitDir, int nDamage, class UClass* DamageType);
	bool UpdatePlayerStatUI(class ATgPawn* changedPawn);
	bool UpdatePlayerVitalsUI(class ATgPlayerController* PC);
	bool UpdatePlayerInfoUI(class ATgRepInfo_Player* PRI);
	bool UpdateGameCapturePointsUI();
	bool UpdateGameScoreUI();
	bool UpdateGameClockUI();
	void STATIC_DeviceChangeEvent(class ATgDevice* Dev, TEnumAsByte<EDeviceChangeEvent> Event);
};


// Class TgGame.TgKActorSpawnable
// 0x0000 (0x038C - 0x038C)
class ATgKActorSpawnable : public AKActorSpawnable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKActorSpawnable");
		return ptr;
	}

};


// Class TgGame.TgKAsset_ClientSideSim
// 0x0068 (0x02E4 - 0x027C)
class ATgKAsset_ClientSideSim : public AKAsset
{
public:
	float                                              m_fDamageImpulse;                                         // 0x027C(0x0004) (Edit)
	class UArrowComponent*                             m_Arrow;                                                  // 0x0280(0x0008) (ExportObject, Component, EditInline)
	class USpriteComponent*                            m_ForceSprite;                                            // 0x0288(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      m_bEnableWind : 1;                                        // 0x0290(0x0004) (Edit)
	unsigned long                                      m_bEnableGusts : 1;                                       // 0x0290(0x0004) (Edit)
	unsigned long                                      bAnimates : 1;                                            // 0x0290(0x0004) (Edit)
	float                                              m_fWindForceMin;                                          // 0x0294(0x0004) (Edit)
	float                                              m_fWindForceMax;                                          // 0x0298(0x0004) (Edit)
	float                                              m_fWindForceStrength;                                     // 0x029C(0x0004)
	float                                              m_fWindForceTargetStrength;                               // 0x02A0(0x0004)
	float                                              m_fWindFrequency;                                         // 0x02A4(0x0004) (Edit)
	float                                              m_fWindForceRemainingTime;                                // 0x02A8(0x0004)
	struct FVector                                     m_vWindDirection;                                         // 0x02AC(0x000C) (Edit)
	float                                              m_fForceDistance;                                         // 0x02B8(0x0004) (Edit)
	float                                              m_fForceZOffsetMultiplier;                                // 0x02BC(0x0004) (Edit)
	float                                              m_fGustActiveTime;                                        // 0x02C0(0x0004) (Edit)
	struct FVector2D                                   m_vTimeBetweenGusts;                                      // 0x02C4(0x0008) (Edit)
	float                                              m_fGustActiveRemainingTime;                               // 0x02CC(0x0004)
	float                                              m_fTimeTillNextGust;                                      // 0x02D0(0x0004)
	struct FVector2D                                   m_WindFrequencyMultiplier;                                // 0x02D4(0x0008) (Edit)
	struct FVector2D                                   m_WindForceMultiplier;                                    // 0x02DC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKAsset_ClientSideSim");
		return ptr;
	}


	void OnHit(const struct FVector& HitLocation, const struct FVector& HitNormal, class AActor* SourceActor, const struct FTraceHitInfo& HitInfo);
};


// Class TgGame.TgKAssetSpawnable
// 0x0000 (0x027C - 0x027C)
class ATgKAssetSpawnable : public AKAssetSpawnable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKAssetSpawnable");
		return ptr;
	}

};


// Class TgGame.TgLevelStreamingLogin
// 0x0004 (0x0104 - 0x0100)
class UTgLevelStreamingLogin : public ULevelStreaming
{
public:
	unsigned long                                      UsedByLoginPage1 : 1;                                     // 0x0100(0x0004) (Edit)
	unsigned long                                      UsedByLoginPage2 : 1;                                     // 0x0100(0x0004) (Edit)
	unsigned long                                      UsedByLoginPage3 : 1;                                     // 0x0100(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLevelStreamingLogin");
		return ptr;
	}

};


// Class TgGame.TgLevelStreamingWorldDetail
// 0x0010 (0x0110 - 0x0100)
class UTgLevelStreamingWorldDetail : public ULevelStreaming
{
public:
	int                                                MinimumWorldDetailLevel;                                  // 0x0100(0x0004) (Edit)
	int                                                MaximumWorldDetailLevel;                                  // 0x0104(0x0004) (Edit)
	unsigned char                                      CachedDetailCheck;                                        // 0x0108(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0109(0x0003) MISSED OFFSET
	int                                                LastUpdateTime;                                           // 0x010C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLevelStreamingWorldDetail");
		return ptr;
	}

};


// Class TgGame.TgLevelStreamingSpectator
// 0x0001 (0x0111 - 0x0110)
class UTgLevelStreamingSpectator : public UTgLevelStreamingWorldDetail
{
public:
	TEnumAsByte<ESpectatorStreamingMethod>             m_LoadingMethod;                                          // 0x0110(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLevelStreamingSpectator");
		return ptr;
	}

};


// Class TgGame.TgLocalPlayer
// 0x002C (0x0498 - 0x046C)
class UTgLocalPlayer : public ULocalPlayer
{
public:
	float                                              m_fViewScale;                                             // 0x046C(0x0004)
	struct FVector                                     m_vViewPan;                                               // 0x0470(0x000C)
	unsigned long                                      m_bEnableOutlineEffect : 1;                               // 0x047C(0x0004)
	unsigned long                                      m_bEnableColorBlindEffect : 1;                            // 0x047C(0x0004)
	float                                              m_fHitOnlyAlpha;                                          // 0x0480(0x0004)
	float                                              m_fHealthOnlyAlpha;                                       // 0x0484(0x0004)
	float                                              m_fHealthPPAlpha;                                         // 0x0488(0x0004)
	float                                              m_fDeathDesatPPAlpha;                                     // 0x048C(0x0004)
	int                                                m_eColorBlindEffectType;                                  // 0x0490(0x0004)
	float                                              m_fColorBlindIntensity;                                   // 0x0494(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLocalPlayer");
		return ptr;
	}


	class UPostProcessEffect* GetPostProcessEffect(const struct FName& EffectName);
	void UpdateLowHealthEffect(float DeltaSeconds, float fHealthPCT, float fHealthLostPCT, bool bDeathVision);
	void STATIC_EnableColorBlindEffect(bool bEnable, int Type, float Intensity);
	void STATIC_EnableOutlineEffect(bool bEnable);
	void STATIC_InitMaterialEffects();
};


// Class TgGame.TgLootTable
// 0x0028 (0x0088 - 0x0060)
class UTgLootTable : public UObject
{
public:
	TArray<class UTgLootTable*>                        m_SubTables;                                              // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FLootData>                           m_LootList;                                               // 0x0070(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              m_fWeight;                                                // 0x0080(0x0004)
	int                                                m_nTableId;                                               // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLootTable");
		return ptr;
	}


	class UTgLootTable* STATIC_RollSubTable();
	struct FLootData STATIC_RollLoot(int nPlayerId);
	bool STATIC_CanGiveLootFrom(int nPlayerId);
};


// Class TgGame.TgManifestGroup
// 0x0048 (0x00A8 - 0x0060)
class UTgManifestGroup : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                             // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<struct FPointer>                            m_ManifestList;                                           // 0x0068(0x0010) (Native, AlwaysInit)
	TArray<class UTgObjectReferencer*>                 m_pObjectReferencers;                                     // 0x0078(0x0010) (AlwaysInit, NeedCtorLink)
	class UObject*                                     m_OwningObject;                                           // 0x0088(0x0008)
	unsigned long                                      m_bIsInCallback : 1;                                      // 0x0090(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x0090(0x0004)
	unsigned long                                      m_bResetOnMapLoad : 1;                                    // 0x0090(0x0004)
	unsigned long                                      m_bSetWorldLifetimeFlag : 1;                              // 0x0090(0x0004)
	TEnumAsByte<EAsyncLoadPriority>                    m_AsyncLoadPriority;                                      // 0x0094(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	struct FScriptDelegate                             __OnAllManifestsLoaded__Delegate;                         // 0x0098(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0095(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgManifestGroup");
		return ptr;
	}


	void OnAllManifestsLoaded();
};


// Class TgGame.TgMarkComponent
// 0x0037 (0x00BC - 0x0085)
class UTgMarkComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	TArray<struct FTargetMark>                         s_MarkList;                                               // 0x0088(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_MarkEffectGroup;                                        // 0x0098(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                m_nHostItemId;                                            // 0x00A8(0x0004) (Const)
	unsigned long                                      m_bStackEffects : 1;                                      // 0x00AC(0x0004) (Const)
	unsigned long                                      m_bRemoveMarksOnDeath : 1;                                // 0x00AC(0x0004) (Const)
	unsigned long                                      m_bSetEffectGroupLifetime : 1;                            // 0x00AC(0x0004) (Const)
	float                                              m_fMarkDuration;                                          // 0x00B0(0x0004) (Const)
	int                                                m_nMaxMarks;                                              // 0x00B4(0x0004) (Const)
	int                                                m_nPhysicalType;                                          // 0x00B8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent");
		return ptr;
	}


	int STATIC_GetNumMarksFor(class AActor* Target);
	void STATIC_RemoveAllMarks();
	void STATIC_RemoveMarkByIndex(int nIndex);
	void STATIC_RemoveAllMarksByIndex(int nIndex);
	void STATIC_RemoveMarkByActor(class AActor* Target);
	void STATIC_RemoveAllMarksByActor(class AActor* Target);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgMarkComponent_WithEnergy
// 0x0004 (0x00C0 - 0x00BC)
class UTgMarkComponent_WithEnergy : public UTgMarkComponent
{
public:
	float                                              m_fEnergyPerMark;                                         // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_WithEnergy");
		return ptr;
	}


	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgMenuContentData
// 0x0010 (0x0070 - 0x0060)
class UTgMenuContentData : public UObject
{
public:
	TArray<struct FMeshData>                           m_MeshData;                                               // 0x0060(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuContentData");
		return ptr;
	}


	void STATIC_PreloadTextures(float ForceDuration);
	void GetMeshData(TEnumAsByte<EMenuContentDataType> ContentDataType, struct FMeshData* Data);
	void Init();
};


// Class TgGame.TgMenuMeshInfo
// 0x0090 (0x00F0 - 0x0060)
class UTgMenuMeshInfo : public UObject
{
public:
	struct FLobbyMeshInfo                              MeshInfo;                                                 // 0x0060(0x0068) (Edit, NeedCtorLink)
	TArray<class UTgMenuMeshInfo*>                     Children;                                                 // 0x00C8(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FName                                       ParentSocketName;                                         // 0x00D8(0x0008)
	TArray<struct FParticleSystemInfo>                 AttachedParticleSystems;                                  // 0x00E0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuMeshInfo");
		return ptr;
	}


	void STATIC_PreloadTextures(float ForceDuration);
	bool IsFullyConfigured();
	void AddFxAttachments(class UTgSkeletalMeshComponent* SkelComp);
	void STATIC_SetupMeshFromMeshInfo(class UTgSkeletalMeshComponent* SkelComp);
	void STATIC_ConfigureMesh(class ATgSkeletalMeshActor_Loader* lobbyOwner);
};


// Class TgGame.TgMeshAssembly
// 0x0018 (0x0278 - 0x0260)
class ATgMeshAssembly : public AActor
{
public:
	int                                                m_nMeshAsmId;                                             // 0x0260(0x0004) (Edit)
	int                                                m_nTeam;                                                  // 0x0264(0x0004) (Edit)
	class UMeshComponent*                              m_Mesh;                                                   // 0x0268(0x0008) (ExportObject, Transient, Component, EditInline)
	class ULightEnvironmentComponent*                  m_LightEnvironment;                                       // 0x0270(0x0008) (Const, ExportObject, EditConst, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMeshAssembly");
		return ptr;
	}


	void STATIC_NotifyLocalPlayerTeamReceived();
	void PostBeginPlay();
	void STATIC_RecalculateTeamColor();
	void LoadMesh();
};


// Class TgGame.TgNewUserSettings
// 0x0010 (0x0070 - 0x0060)
class UTgNewUserSettings : public UObject
{
public:
	TArray<int>                                        WatchedVideoIds;                                          // 0x0060(0x0010) (Edit, Config, GlobalConfig, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNewUserSettings");
		return ptr;
	}

};


// Class TgGame.TgObject
// 0x0000 (0x0060 - 0x0060)
class UTgObject : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObject");
		return ptr;
	}


	void StartFire();
	void SetTaskForceNumber();
	void InitializeDefaultProps();
	void SortDamageDisplay();
	void IsFriendlyWithLocalPawn();
};


// Class TgGame.TgObjectReferencer
// 0x0008 (0x007C - 0x0074)
class UTgObjectReferencer : public UObjectReferencer
{
public:
	struct FPointer                                    m_Manifest;                                               // 0x0074(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjectReferencer");
		return ptr;
	}

};


// Class TgGame.TgPedestalProcessor
// 0x0008 (0x0068 - 0x0060)
class UTgPedestalProcessor : public UObject
{
public:
	class ATgSkeletalMeshActor_Pedestal*               m_PedestalActor;                                          // 0x0060(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPedestalProcessor");
		return ptr;
	}

};


// Class TgGame.TgProjGroundTargetInterface
// 0x0000 (0x0060 - 0x0060)
class UTgProjGroundTargetInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProjGroundTargetInterface");
		return ptr;
	}


	void SetGroundTarget(const struct FVector& GTLocation);
};


// Class TgGame.TgProperty
// 0x0000 (0x0060 - 0x0060)
class UTgProperty : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProperty");
		return ptr;
	}


	int STATIC_GetPropIndex(int propId);
	float STATIC_GetCurrentValue(struct FTgPropertyInstance* prop);
};


// Class TgGame.TgSeqEvent_BotDied
// 0x000C (0x0134 - 0x0128)
class UTgSeqEvent_BotDied : public USequenceEvent
{
public:
	unsigned long                                      bUseCountingOutput : 1;                                   // 0x0128(0x0004) (Edit)
	int                                                nCountingMultiple;                                        // 0x012C(0x0004) (Edit)
	int                                                nLastDiedCount;                                           // 0x0130(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BotDied");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_BotSpawned
// 0x000C (0x0134 - 0x0128)
class UTgSeqEvent_BotSpawned : public USequenceEvent
{
public:
	unsigned long                                      bUseCountingOutput : 1;                                   // 0x0128(0x0004) (Edit)
	int                                                nCountingMultiple;                                        // 0x012C(0x0004) (Edit)
	int                                                nLastSpawnCount;                                          // 0x0130(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BotSpawned");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ClassSelected
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ClassSelected : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ClassSelected");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_DoorStatusChanged
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_DoorStatusChanged : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DoorStatusChanged");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FactoryEmpty
// 0x000C (0x0134 - 0x0128)
class UTgSeqEvent_FactoryEmpty : public USequenceEvent
{
public:
	unsigned long                                      bUseCountingOutput : 1;                                   // 0x0128(0x0004) (Edit)
	int                                                nCountingMultiple;                                        // 0x012C(0x0004) (Edit)
	int                                                nLastEmptyCount;                                          // 0x0130(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FactoryEmpty");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerDied
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerDied : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerDied");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerOnPurchaseFlagSet
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerOnPurchaseFlagSet : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerOnPurchaseFlagSet");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerRecalled
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerRecalled : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerRecalled");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerScoredKill
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerScoredKill : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerScoredKill");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayersTeamScoredPhoenixKill
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayersTeamScoredPhoenixKill : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayersTeamScoredPhoenixKill");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayersTeamScoredTowerKill
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayersTeamScoredTowerKill : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayersTeamScoredTowerKill");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_MICParameterEvent
// 0x0014 (0x013C - 0x0128)
class UTgSeqEvent_MICParameterEvent : public USequenceEvent
{
public:
	TEnumAsByte<EeMICEventType>                        MICEventType;                                             // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	TArray<class UMaterialInstanceConstant*>           AttachedMICs;                                             // 0x012C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MICParameterEvent");
		return ptr;
	}


	void STATIC_SetVectorParameterValue(const struct FName& ParamName, const struct FLinearColor& Value);
	void STATIC_SetScalarParameterValue(const struct FName& ParamName, float fValue);
};


// Class TgGame.TgSeqEvent_PlaceableDestroyed
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PlaceableDestroyed : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlaceableDestroyed");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlayerCountHit
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PlayerCountHit : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayerCountHit");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PlayerInitialized
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_PlayerInitialized : public USequenceEvent
{
public:
	unsigned long                                      bLocalPlayerOnly : 1;                                     // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PlayerInitialized");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TutorialEvent
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_TutorialEvent : public USequenceEvent
{
public:
	TEnumAsByte<ETUTORIAL_EVENT>                       TutEvent;                                                 // 0x0128(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0129(0x0003) MISSED OFFSET
	int                                                EventData;                                                // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TutorialEvent");
		return ptr;
	}


	int GetObjClassVersion();
};


// Class TgGame.TgSoundNodeAttenuation
// 0x0000 (0x00F0 - 0x00F0)
class UTgSoundNodeAttenuation : public USoundNodeAttenuation
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundNodeAttenuation");
		return ptr;
	}

};


// Class TgGame.TgSpectatorDirector
// 0x0094 (0x02F4 - 0x0260)
class ATgSpectatorDirector : public AInfo
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x0260(0x0004) (Transient)
	unsigned long                                      m_bIsPending : 1;                                         // 0x0260(0x0004) (Transient)
	unsigned long                                      m_bAutoSwitchCameraViews : 1;                             // 0x0260(0x0004) (Transient)
	unsigned long                                      m_bForceThirdPersonView : 1;                              // 0x0260(0x0004) (Transient)
	float                                              m_fRemainingAutoUpdateCheckTime;                          // 0x0264(0x0004)
	float                                              m_fTimeSinceViewSwitchedTeams;                            // 0x0268(0x0004)
	float                                              m_fTimeSinceViewSwitchedMode;                             // 0x026C(0x0004)
	float                                              m_fRemainingAutoReturnCheckTime;                          // 0x0270(0x0004)
	TEnumAsByte<ESpectatorCameraMode>                  m_CurrentCameraMode;                                      // 0x0274(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0275(0x0003) MISSED OFFSET
	struct FViewTargetInfo                             m_CurrentRatedViewTarget;                                 // 0x0278(0x0038)
	struct FViewTargetInfo                             m_DemoRewindViewTarget;                                   // 0x02B0(0x0038) (Transient)
	struct FVector2D                                   m_v2dForcedDirectorLocation;                              // 0x02E8(0x0008) (Transient)
	float                                              m_fForcedDirectorLocationTimestamp;                       // 0x02F0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorDirector");
		return ptr;
	}


	void STATIC_SetForcedDirectorLocation(const struct FVector2D& NewLocation);
	void ClearAssistModeTarget();
	void PostDemoRewind();
	void PreDemoRewind();
	bool IsPending();
	bool IsActive();
	bool IsCurrentlyViewing();
	void ResetCamera(class ATgSpectatorController* PC);
	void SetActive(bool bIsActive);
	void SetCameraMode(TEnumAsByte<ESpectatorCameraMode> NewCameraMode);
	void SetViewTarget(const struct FViewTargetInfo& NewViewTarget);
	void UpdateOverviewCamUI(bool bEnable);
	void STATIC_OnPlayerMoved();
};


// Class TgGame.TgSplineLoftActorSpawnable
// 0x0000 (0x0320 - 0x0320)
class ATgSplineLoftActorSpawnable : public ASplineLoftActorMovable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineLoftActorSpawnable");
		return ptr;
	}

};


// Class TgGame.TgSplineLoftActorSpawnableLinear
// 0x0000 (0x0320 - 0x0320)
class ATgSplineLoftActorSpawnableLinear : public ATgSplineLoftActorSpawnable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineLoftActorSpawnableLinear");
		return ptr;
	}


	void UpdateSplineParams();
};


// Class TgGame.TgTauntSettingsInterface
// 0x0000 (0x0060 - 0x0060)
class UTgTauntSettingsInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTauntSettingsInterface");
		return ptr;
	}


	float STATIC_GetMinTauntRadius();
};


// Class TgGame.TgTimerManager
// 0x005C (0x00BC - 0x0060)
class UTgTimerManager : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0068(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgTimerManager.m_TimerMap
	unsigned long                                      m_bActive : 1;                                            // 0x00B0(0x0004)
	unsigned long                                      m_bGameWasPaused : 1;                                     // 0x00B0(0x0004)
	class AActor*                                      m_Owner;                                                  // 0x00B4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTimerManager");
		return ptr;
	}


	void STATIC_ResetTimerTimeDilation(int byTimerIndex);
	void STATIC_ModifyTimerTimeDilation(int byTimerIndex, float InTimerTimeDilation);
	void STATIC_ResetTimeDilation();
	void ModifyTimeDilation(float InTimerTimeDilation);
	void STATIC_CloseAllTimers(bool bFireEvent);
	bool IsActiveTimers();
	bool UnRegisterForEvents(int byTimerIndex, class UObject* HostObject);
	bool STATIC_RegisterForEvents(int byTimerIndex, class UObject* HostObject, const struct FName& nmFunc);
	float STATIC_GetTimeInitial(int byTimerIndex);
	float STATIC_GetPercentRemaining(int byTimerIndex);
	float STATIC_GetTimeRemaining(int byTimerIndex);
	float STATIC_GetTimeElapsed(int byTimerIndex);
	bool STATIC_IsPaused(int byTimerIndex);
	bool IsSet(int byTimerIndex);
	bool Close(int byTimerIndex, bool bFireEvent);
	bool STATIC_Pause(int byTimerIndex, float fTime);
	bool Update(int byTimerIndex, float fTime, float fTimeInitial);
	bool Start(int byTimerIndex, float fTime, bool bRepeat, bool bPausedByGame);
};


// Class TgGame.TgVolume_Adventure
// 0x0010 (0x02AC - 0x029C)
class ATgVolume_Adventure : public AVolume
{
public:
	int                                                m_nActivityId;                                            // 0x029C(0x0004) (Edit)
	int                                                m_nGoalId;                                                // 0x02A0(0x0004) (Edit)
	int                                                m_nActivityTaskForce;                                     // 0x02A4(0x0004) (Edit)
	unsigned long                                      bTriggeredQuest : 1;                                      // 0x02A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolume_Adventure");
		return ptr;
	}


	void STATIC_CheckForContainsAllEvents();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgVolumePathNode
// 0x001C (0x037C - 0x0360)
class ATgVolumePathNode : public AVolumePathNode
{
public:
	unsigned long                                      m_bIsAboveGround : 1;                                     // 0x0360(0x0004) (Edit, EditConst)
	struct FVector                                     m_vGroundHitLocation;                                     // 0x0364(0x000C) (Edit, EditConst)
	float                                              m_fGroundTraceDistance;                                   // 0x0370(0x0004) (Edit)
	class USpriteComponent*                            m_GroundSprite;                                           // 0x0374(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolumePathNode");
		return ptr;
	}

};


// Class TgGame.TgTitanForgeTools
// 0x0000 (0x0060 - 0x0060)
class UTgTitanForgeTools : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTitanForgeTools");
		return ptr;
	}

};


// Class TgGame.TgTiDiInterface
// 0x0000 (0x0060 - 0x0060)
class UTgTiDiInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTiDiInterface");
		return ptr;
	}


	void STATIC_ShutdownTiDi();
	void TransmitTiDiClient();
	void TransmitTiDiServer();
	void ApplyTiDi();
	bool STATIC_ShouldUpdateTiDi();
	class UTgTiDiState* STATIC_GetCurrentTiDi();
	void STATIC_InitializeTiDi();
};


// Class TgGame.TgTiDiInterfaceLite
// 0x0000 (0x0060 - 0x0060)
class UTgTiDiInterfaceLite : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTiDiInterfaceLite");
		return ptr;
	}


	void ApplyTiDi(float fTotalTiDi);
};


// Class TgGame.TgTiDiState
// 0x0068 (0x00C8 - 0x0060)
class UTgTiDiState : public UObject
{
public:
	float                                              m_fTiDiMin;                                               // 0x0060(0x0004) (Const)
	float                                              m_fTiDiMax;                                               // 0x0064(0x0004) (Const)
	float                                              m_fTiDiLocalMin;                                          // 0x0068(0x0004) (Const)
	float                                              m_fTiDiLocalMax;                                          // 0x006C(0x0004) (Const)
	float                                              m_fTiDiTotalMin;                                          // 0x0070(0x0004) (Const)
	float                                              m_fTiDiTotalMax;                                          // 0x0074(0x0004) (Const)
	unsigned long                                      m_bTiDiEnabled : 1;                                       // 0x0078(0x0004) (Const)
	unsigned long                                      m_bInheritTiDi : 1;                                       // 0x0078(0x0004)
	unsigned long                                      m_bInheritLocalTiDi : 1;                                  // 0x0078(0x0004)
	unsigned long                                      m_bEnabled : 1;                                           // 0x0078(0x0004)
	unsigned long                                      m_bIsDirty : 1;                                           // 0x0078(0x0004)
	struct FPointer                                    m_critSectionTiDiStateSyncObject;                         // 0x007C(0x0008)
	TScriptInterface<class UTgTiDiInterface>           m_tOwner;                                                 // 0x0084(0x0010)
	struct FPointer                                    m_ParentState;                                            // 0x0094(0x0008) (Native)
	TArray<struct FTidiStackItem>                      m_TidiStack;                                              // 0x009C(0x0010) (NeedCtorLink)
	TArray<struct FTidiStackItem>                      m_LocalTidiStack;                                         // 0x00AC(0x0010) (NeedCtorLink)
	float                                              m_fTiDi;                                                  // 0x00BC(0x0004)
	float                                              m_fLocalTiDi;                                             // 0x00C0(0x0004)
	float                                              m_fTotalTiDiOverride;                                     // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTiDiState");
		return ptr;
	}


	void STATIC_InheritAndUpdate(class UTgTiDiState* tidiStateParent);
	void Update();
	void ShutDown();
	void STATIC_Initialize(const TScriptInterface<class UTgTiDiInterface>& tOwner);
	void UpdateGrabTidiValue();
	void STATIC_RemoveAllLocalTiDiStacks();
	void STATIC_RemoveAllTiDiStacks();
	void STATIC_RemoveLocalTiDiStack(class UTgEffectGroup* eg, class APawn* pawnInstigator, int nStacks);
	void STATIC_RemoveTiDiStack(class UTgEffectGroup* eg, class APawn* pawnInstigator, int nStacks);
	void AddLocalTiDiStack(class UTgEffectGroup* eg, class APawn* pawnInstigator, int nStacks);
	void AddTiDiStack(class UTgEffectGroup* eg, class APawn* pawnInstigator, int nStacks);
	void STATIC_SetTotalTiDiOverride(float fTotalTiDiOverride);
	void STATIC_SetLocalTiDi(float fTiDi);
	void STATIC_SetTiDi(float fTiDi);
	void STATIC_SetInheritLocalTiDi(bool bInherit);
	void STATIC_SetInheritTiDi(bool bInherit);
	void SetEnabled(bool bEnabled);
	float STATIC_GetTotalTiDi();
	float STATIC_GetLocalTiDi();
	float STATIC_GetTiDi();
};


// Class TgGame.TgTiDiVolumeInterface
// 0x0000 (0x0060 - 0x0060)
class UTgTiDiVolumeInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTiDiVolumeInterface");
		return ptr;
	}


	float STATIC_GetEnemyTiDi();
	float STATIC_GetFriendlyTiDi();
	bool IsCollidingWithTimeField(float fRadius, struct FVector* vLoc);
	int STATIC_GetCachedRegisteredIndex();
	void STATIC_CacheRegisteredIndex(int nIndex);
	void UpdatePawnTidi(class ATgPawn* Pawn);
	void UpdateProjectileTidi(class ATgProjectile* Projectile);
	void UpdateDeployableTidi(class ATgDeployable* deployable);
};


// Class TgGame.TgAnimBlendByPosture_Player
// 0x0000 (0x01AC - 0x01AC)
class UTgAnimBlendByPosture_Player : public UAnimNodeSequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPosture_Player");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPropertyIfNotRelevant
// 0x0000 (0x0184 - 0x0184)
class UTgAnimBlendByPropertyIfNotRelevant : public UAnimNodeBlendByProperty
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPropertyIfNotRelevant");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
	void SetActiveAnimationIndex();
	void STATIC_SetActiveChild(int ChildIndex, float ChildBlendTime);
};


// Class TgGame.TgAnimBlendBySpeed
// 0x00A4 (0x020C - 0x0168)
class UTgAnimBlendBySpeed : public UAnimNodeBlendBySpeed
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	TEnumAsByte<ESpeedType>                            m_SpeedType;                                              // 0x0170(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	TArray<struct FResetSynchGroup>                    ResetSynchGroups;                                         // 0x0174(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bIgnoreRootMotion : 1;                                  // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bIgnoreZVelocity : 1;                                   // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bNotifyOwnerOnChildChange : 1;                          // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bEnableClassOverrides : 1;                              // 0x0184(0x0004) (Edit)
	TArray<int>                                        m_WalkChildren;                                           // 0x0188(0x0010) (Edit, NeedCtorLink)
	TArray<int>                                        m_SprintChildren;                                         // 0x0198(0x0010) (Edit, NeedCtorLink)
	TArray<float>                                      m_BaseSpeed;                                              // 0x01A8(0x0010) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<EPhysics>>                      m_IgnoredPhysics;                                         // 0x01B8(0x0010) (Edit, NeedCtorLink)
	int                                                m_nIndexToOverride;                                       // 0x01C8(0x0004) (Edit)
	float                                              m_fBaseSpeedRecon;                                        // 0x01CC(0x0004) (Edit)
	float                                              m_fBaseSpeedRobotics;                                     // 0x01D0(0x0004) (Edit)
	float                                              m_fBaseSpeedAssault;                                      // 0x01D4(0x0004) (Edit)
	float                                              m_fBaseSpeedMedic;                                        // 0x01D8(0x0004) (Edit)
	float                                              m_fBaseSpeedReconFemale;                                  // 0x01DC(0x0004) (Edit)
	float                                              m_fBaseSpeedRoboticsFemale;                               // 0x01E0(0x0004) (Edit)
	float                                              m_fBaseSpeedAssaultFemale;                                // 0x01E4(0x0004) (Edit)
	float                                              m_fBaseSpeedMedicFemale;                                  // 0x01E8(0x0004) (Edit)
	float                                              m_fBaseSpeedReconCity;                                    // 0x01EC(0x0004) (Edit)
	float                                              m_fBaseSpeedRoboticsCity;                                 // 0x01F0(0x0004) (Edit)
	float                                              m_fBaseSpeedAssaultCity;                                  // 0x01F4(0x0004) (Edit)
	float                                              m_fBaseSpeedMedicCity;                                    // 0x01F8(0x0004) (Edit)
	float                                              m_fBaseSpeedReconFemaleCity;                              // 0x01FC(0x0004) (Edit)
	float                                              m_fBaseSpeedRoboticsFemaleCity;                           // 0x0200(0x0004) (Edit)
	float                                              m_fBaseSpeedAssaultFemaleCity;                            // 0x0204(0x0004) (Edit)
	float                                              m_fBaseSpeedMedicFemaleCity;                              // 0x0208(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySpeed");
		return ptr;
	}


	void OnInit();
	class UAnimNodeSynch* STATIC_FindSynchAnimNode(const struct FName& nmNodeName);
};


// Class TgGame.TgAnimBlendBySpeedWithExhaustion
// 0x0038 (0x0244 - 0x020C)
class UTgAnimBlendBySpeedWithExhaustion : public UTgAnimBlendBySpeed
{
public:
	unsigned long                                      m_bEnableExhaustion : 1;                                  // 0x020C(0x0004) (Edit)
	float                                              m_fExhaustionLevel;                                       // 0x0210(0x0004) (Edit)
	TArray<int>                                        m_ExhaustedChildren;                                      // 0x0214(0x0010) (Edit, NeedCtorLink)
	TArray<int>                                        m_GainExhaustionChildren;                                 // 0x0224(0x0010) (Edit, NeedCtorLink)
	float                                              m_fExhaustionGainSpeed;                                   // 0x0234(0x0004) (Edit)
	float                                              m_fExhaustionLossSpeed;                                   // 0x0238(0x0004) (Edit)
	float                                              m_fExhaustionLevelMax;                                    // 0x023C(0x0004) (Edit)
	float                                              m_fExhaustionLevelMin;                                    // 0x0240(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySpeedWithExhaustion");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendPerBone
// 0x0044 (0x019C - 0x0158)
class UTgAnimBlendPerBone : public UAnimNodeBlendPerBone
{
public:
	unsigned long                                      m_bLoopSourceChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bLoopTargetChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bPlaySourceChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bPlayTargetChild : 1;                                   // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bSetStrengthFromAnimNode : 1;                           // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bInvertStrengthFromAnimNode : 1;                        // 0x0158(0x0004) (Edit)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0158(0x0004) (Transient)
	TArray<struct FName>                               m_StrengthAnimNodeNameList;                               // 0x015C(0x0010) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<EEmote>>                        m_StrengthEmoteList;                                      // 0x016C(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x017C(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            m_CachedEmoteSequences;                                   // 0x018C(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendPerBone");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimBlendPerBone_DynamicLooping
// 0x0000 (0x019C - 0x019C)
class UTgAnimBlendPerBone_DynamicLooping : public UTgAnimBlendPerBone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendPerBone_DynamicLooping");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimNodeBlendPerBone_CustomBlend
// 0x0004 (0x01A0 - 0x019C)
class UTgAnimNodeBlendPerBone_CustomBlend : public UTgAnimBlendPerBone
{
public:
	float                                              fBlendWeightControl;                                      // 0x019C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendPerBone_CustomBlend");
		return ptr;
	}


	float STATIC_GetCustomBlend();
};


// Class TgGame.TgAnimMetaData_InvisibleWallFailSafe
// 0x0008 (0x0068 - 0x0060)
class UTgAnimMetaData_InvisibleWallFailSafe : public UAnimMetaData
{
public:
	struct FName                                       WallEnableBaseName;                                       // 0x0060(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_InvisibleWallFailSafe");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_LobbyCameraModifier
// 0x0020 (0x0080 - 0x0060)
class UTgAnimMetaData_LobbyCameraModifier : public UAnimMetaData
{
public:
	struct FVector                                     CameraPositionOffset;                                     // 0x0060(0x000C) (Edit)
	struct FRotator                                    CameraRotationOffset;                                     // 0x006C(0x000C) (Edit)
	float                                              OffsetStartTime;                                          // 0x0078(0x0004) (Edit)
	float                                              OffsetEndTime;                                            // 0x007C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_LobbyCameraModifier");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MICScalarParameter
// 0x0030 (0x0090 - 0x0060)
class UTgAnimMetaData_MICScalarParameter : public UAnimMetaData
{
public:
	TArray<struct FMICScalarParameterSkinIdOverride>   SkinIdOverrides;                                          // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FName                                       MICParameterName;                                         // 0x0070(0x0008) (Edit)
	int                                                MaterialIndex;                                            // 0x0078(0x0004) (Edit)
	TArray<struct FMICScalarParameterKeyFrame>         KeyFrames;                                                // 0x007C(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;                  // 0x008C(0x0004) (Edit)
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;                    // 0x008C(0x0004) (Edit)
	unsigned long                                      bApplyToParentAnimComponentChildren : 1;                  // 0x008C(0x0004) (Edit)
	unsigned long                                      m_bApplyToPacs : 1;                                       // 0x008C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MICScalarParameter");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MICVectorParameter
// 0x0030 (0x0090 - 0x0060)
class UTgAnimMetaData_MICVectorParameter : public UAnimMetaData
{
public:
	TArray<struct FMICVectorParameterSkinIdOverride>   SkinIdOverrides;                                          // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FName                                       MICParameterName;                                         // 0x0070(0x0008) (Edit)
	int                                                MaterialIndex;                                            // 0x0078(0x0004) (Edit)
	TArray<struct FMICVectorParameterKeyFrame>         KeyFrames;                                                // 0x007C(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;                  // 0x008C(0x0004) (Edit)
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;                    // 0x008C(0x0004) (Edit)
	unsigned long                                      bApplyToParentAnimComponentChildren : 1;                  // 0x008C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MICVectorParameter");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_MICVectorPlusSocket
// 0x0044 (0x00A4 - 0x0060)
class UTgAnimMetaData_MICVectorPlusSocket : public UAnimMetaData
{
public:
	TArray<struct FMICVectorSocketSkinIdOverride>      SkinIdOverrides;                                          // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FName                                       TranslationMICParameterName;                              // 0x0070(0x0008) (Edit)
	struct FName                                       RotationMICParameterName;                                 // 0x0078(0x0008) (Edit)
	int                                                TranslationMaterialIndex;                                 // 0x0080(0x0004) (Edit)
	int                                                RotationMaterialIndex;                                    // 0x0084(0x0004) (Edit)
	struct FName                                       SocketName;                                               // 0x0088(0x0008) (Edit)
	TArray<struct FMICVectorSocketKeyFrame>            KeyFrames;                                                // 0x0090(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;                  // 0x00A0(0x0004) (Edit)
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;                    // 0x00A0(0x0004) (Edit)
	unsigned long                                      bApplyToParentAnimComponentChildren : 1;                  // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_MICVectorPlusSocket");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_ScyllaTentacleMesh
// 0x0004 (0x0064 - 0x0060)
class UTgAnimMetaData_ScyllaTentacleMesh : public UAnimMetaData
{
public:
	unsigned long                                      bTentaclesActive : 1;                                     // 0x0060(0x0004) (Edit)
	unsigned long                                      bTentacleOverlaysActive : 1;                              // 0x0060(0x0004) (Edit)
	unsigned long                                      bTentacleFlamesActive : 1;                                // 0x0060(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_ScyllaTentacleMesh");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControl_BoneRotKeyFrame
// 0x0001 (0x0091 - 0x0090)
class UTgAnimMetaData_SkelControl_BoneRotKeyFrame : public UAnimMetaData_SkelControlKeyFrame
{
public:
	TEnumAsByte<EAxis>                                 m_eAxis;                                                  // 0x0090(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControl_BoneRotKeyFrame");
		return ptr;
	}


	void STATIC_SetCurrentAxisRotation(class USkelControlBase* SkelControl, float fRotation);
	float STATIC_GetCurrentAxisRotation(class USkelControlBase* SkelControl);
};


// Class TgGame.TgAnimMetaData_SkelCon_BoneRotMod
// 0x000B (0x009C - 0x0091)
class UTgAnimMetaData_SkelCon_BoneRotMod : public UTgAnimMetaData_SkelControl_BoneRotKeyFrame
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0091(0x0003) MISSED OFFSET
	float                                              m_fRotationMod;                                           // 0x0094(0x0004) (Edit)
	float                                              m_fRotationMax;                                           // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelCon_BoneRotMod");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControl_BoneScale
// 0x0020 (0x0080 - 0x0060)
class UTgAnimMetaData_SkelControl_BoneScale : public UAnimMetaData
{
public:
	TArray<struct FName>                               SkelControlNameList;                                      // 0x0060(0x0010) (Edit, NeedCtorLink)
	float                                              BoneScale;                                                // 0x0070(0x0004) (Edit)
	unsigned long                                      bFullControlOverController : 1;                           // 0x0074(0x0004) (Edit)
	struct FName                                       SkelControlName;                                          // 0x0078(0x0008) (Deprecated)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControl_BoneScale");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControl_BoneScale_KeyFrame
// 0x0048 (0x00A8 - 0x0060)
class UTgAnimMetaData_SkelControl_BoneScale_KeyFrame : public UAnimMetaData
{
public:
	TArray<struct FBoneScaleKeyFrameSkinIdOverride>    SkinIdOverrides;                                          // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	TArray<struct FName>                               SkelControlNameList;                                      // 0x0070(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTimeModifier>                       KeyFrames;                                                // 0x0080(0x0010) (Edit, NeedCtorLink, EditInline)
	unsigned long                                      bAllowScaleUp : 1;                                        // 0x0090(0x0004) (Edit)
	unsigned long                                      bAllowScaleDown : 1;                                      // 0x0090(0x0004) (Edit)
	unsigned long                                      bAdjustControllerStrength : 1;                            // 0x0090(0x0004) (Const)
	unsigned long                                      bFullControlOverController : 1;                           // 0x0090(0x0004) (Edit)
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;                  // 0x0090(0x0004) (Deprecated)
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;                    // 0x0090(0x0004) (Deprecated)
	struct FName                                       SkelControlName;                                          // 0x0094(0x0008) (Deprecated)
	TEnumAsByte<EOnRelevanceChange>                    OnBecomeRelevantBehavior;                                 // 0x009C(0x0001) (Edit)
	TEnumAsByte<EOnRelevanceChange>                    OnCeaseRelevantBehavior;                                  // 0x009D(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x009E(0x0002) MISSED OFFSET
	float                                              OnBecomeRelevantStrength;                                 // 0x00A0(0x0004) (Edit)
	float                                              OnCeaseRelevantStrength;                                  // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControl_BoneScale_KeyFrame");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkelControlModWeight
// 0x0008 (0x0098 - 0x0090)
class UTgAnimMetaData_SkelControlModWeight : public UAnimMetaData_SkelControlKeyFrame
{
public:
	float                                              m_fWeightMod;                                             // 0x0090(0x0004) (Edit)
	float                                              m_fWeightMax;                                             // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControlModWeight");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_SkinLevel
// 0x002C (0x008C - 0x0060)
class UTgAnimMetaData_SkinLevel : public UAnimMetaData
{
public:
	TArray<struct FSkinLevelParameterKeyFrame>         KeyFrames;                                                // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	TEnumAsByte<EStartingSkinLevel>                    m_eStartingSkinLevelState;                                // 0x0070(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0071(0x0003) MISSED OFFSET
	TArray<int>                                        m_nCustomSkinLevelStarts;                                 // 0x0074(0x0010) (Edit, NeedCtorLink, EditInline)
	int                                                m_nMaxSkinLevel;                                          // 0x0084(0x0004) (Edit)
	unsigned long                                      m_bVXGStarted : 1;                                        // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkinLevel");
		return ptr;
	}


	void UpdateServerLevel(class ATgPawn* owningPawn, int nSkinLevel);
};


// Class TgGame.TgAnimMetaData_WithMesh
// 0x0048 (0x00A8 - 0x0060)
class UTgAnimMetaData_WithMesh : public UAnimMetaData
{
public:
	TArray<struct FWithMeshMetaData>                   SkinIdOverrides;                                          // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FWithMeshMetaData                           BaseMetaData;                                             // 0x0070(0x0034) (Edit, NeedCtorLink)
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;                  // 0x00A4(0x0004) (Edit)
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;                    // 0x00A4(0x0004) (Edit)
	unsigned long                                      bApplyToParentAnimComponentChildren : 1;                  // 0x00A4(0x0004) (Edit)
	unsigned long                                      c_bCurrentlyActive : 1;                                   // 0x00A4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_WithMesh");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAdditiveBlending
// 0x0044 (0x016C - 0x0128)
class UTgAnimNodeAdditiveBlending : public UAnimNodeAdditiveBlending
{
public:
	unsigned long                                      m_bSetStrengthFromAnimNode : 1;                           // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bInvertStrengthFromAnimNode : 1;                        // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0128(0x0004) (Transient)
	TArray<struct FName>                               m_StrengthAnimNodeNameList;                               // 0x012C(0x0010) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<EEmote>>                        m_StrengthEmoteList;                                      // 0x013C(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x014C(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            m_CachedEmoteSequences;                                   // 0x015C(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAdditiveBlending");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAimOffset
// 0x0065 (0x01D1 - 0x016C)
class UTgAnimNodeAimOffset : public UAnimNodeAimOffset
{
public:
	class ATgPawn*                                     Owner;                                                    // 0x016C(0x0008) (Const, Transient)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x0174(0x0010) (NeedCtorLink)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0184(0x0004) (Transient)
	unsigned long                                      m_bDisableVerticalAiming : 1;                             // 0x0184(0x0004) (Edit)
	unsigned long                                      bInterpolating : 1;                                       // 0x0184(0x0004) (Const, Transient)
	unsigned long                                      m_bBakeAllProfileOffsetsFromAnimations : 1;               // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bPopulateAnimNamesWithPrefixes : 1;                     // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bRandomAimPointsEnabled : 1;                            // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bOverrideAim : 1;                                       // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bAimAtTarget : 1;                                       // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bUseDeviceOffset : 1;                                   // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bUseOwnerIfNoTarget : 1;                                // 0x0184(0x0004) (Edit)
	unsigned long                                      m_bFacingBackwards : 1;                                   // 0x0184(0x0004) (Edit)
	float                                              TurnInPlaceOffset;                                        // 0x0188(0x0004) (Edit, Const, Transient)
	float                                              LastAimX;                                                 // 0x018C(0x0004) (Const, Transient)
	float                                              InterpSpeed;                                              // 0x0190(0x0004) (Edit)
	struct FVector2D                                   m_AimOffsetPct;                                           // 0x0194(0x0008) (Const, Transient)
	struct FVector2D                                   m_RandomAimPointsRangeX;                                  // 0x019C(0x0008) (Edit)
	struct FVector2D                                   m_RandomAimPointsRangeY;                                  // 0x01A4(0x0008) (Edit)
	float                                              m_fRandomAimPointsInterpRate;                             // 0x01AC(0x0004) (Edit)
	float                                              m_fRandomAimPointsIntervalMin;                            // 0x01B0(0x0004) (Edit)
	float                                              m_fRandomAimPointsIntervalMax;                            // 0x01B4(0x0004) (Edit)
	float                                              m_fCurrentRandomAimPointsInterval;                        // 0x01B8(0x0004)
	struct FVector2D                                   m_TargetRandomAimLocation;                                // 0x01BC(0x0008)
	float                                              m_fDeltaTime;                                             // 0x01C4(0x0004)
	struct FVector2D                                   m_OverriddenAim;                                          // 0x01C8(0x0008) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eDeviceEquipPoint;                                      // 0x01D0(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAimOffset");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAimOffset_Charge
// 0x001F (0x01F0 - 0x01D1)
class UTgAnimNodeAimOffset_Charge : public UTgAnimNodeAimOffset
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x01D1(0x0003) MISSED OFFSET
	unsigned long                                      m_bInterpToCurrentTurnRate : 1;                           // 0x01D4(0x0004) (Edit)
	float                                              m_fInterpSpeed;                                           // 0x01D8(0x0004) (Edit)
	float                                              m_fMaxYawRate;                                            // 0x01DC(0x0004) (Edit)
	float                                              m_fAimYawOffset;                                          // 0x01E0(0x0004) (Transient)
	struct FRotator                                    m_rCachedOwnerRotator;                                    // 0x01E4(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAimOffset_Charge");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeAimOffset_Skinned
// 0x0013 (0x01E4 - 0x01D1)
class UTgAnimNodeAimOffset_Skinned : public UTgAnimNodeAimOffset
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x01D1(0x0003) MISSED OFFSET
	TArray<struct FAimSkinProfile>                     m_SkinnedAimProfiles;                                     // 0x01D4(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeAimOffset_Skinned");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendAnimsByDirection
// 0x003C (0x01F8 - 0x01BC)
class UTgAnimNodeBlendAnimsByDirection : public UAnimNodeSequenceBlendBase
{
public:
	struct FPointer                                    VfTable_ITgAnimNodeFitToDurationInterface;                // 0x01BC(0x0008) (Const, Native, NoExport)
	float                                              m_BlendSpeed;                                             // 0x01C4(0x0004) (Edit)
	unsigned long                                      m_bUsePlayRateByDirection : 1;                            // 0x01C8(0x0004) (Edit)
	unsigned long                                      m_bIncludeStandingAnim : 1;                               // 0x01C8(0x0004) (Edit)
	unsigned long                                      m_bEnableFitToDuration : 1;                               // 0x01C8(0x0004) (Edit)
	unsigned long                                      m_bForceStanding : 1;                                     // 0x01C8(0x0004) (Transient)
	unsigned long                                      m_bInterpolateWeights : 1;                                // 0x01C8(0x0004) (Const, Transient)
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;                  // 0x01C8(0x0004) (Edit)
	unsigned long                                      m_bForwardLeftCorrection : 1;                             // 0x01C8(0x0004) (Edit)
	float                                              m_PlayRateByDirection[0x8];                               // 0x01CC(0x0004) (Edit)
	float                                              m_PlayRateStanding;                                       // 0x01EC(0x0004) (Edit)
	float                                              m_DirAngle;                                               // 0x01F0(0x0004)
	float                                              m_LastRelevantTime;                                       // 0x01F4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendAnimsByDirection");
		return ptr;
	}


	void STATIC_SetPlayRate(float fPlayRate);
	bool STATIC_CanSetPlayRate();
};


// Class TgGame.TgAnimNodeBlend_ParentDirection
// 0x000C (0x0204 - 0x01F8)
class UTgAnimNodeBlend_ParentDirection : public UTgAnimNodeBlendAnimsByDirection
{
public:
	class UTgAnimNodeBlendAnimsByDirection*            c_ParentBlend;                                            // 0x01F8(0x0008) (Edit)
	unsigned long                                      m_bSyncParentTime : 1;                                    // 0x0200(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlend_ParentDirection");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByBlink
// 0x0044 (0x019C - 0x0158)
class UTgAnimNodeBlendByBlink : public UAnimNodeBlendPerBone
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0158(0x0008) (Transient)
	class USkeletalMeshComponent*                      m_SkelMesh;                                               // 0x0160(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              m_fBlinkAnimRate;                                         // 0x0168(0x0004) (Edit)
	struct FVector2D                                   m_vTimeBetweenBlinks;                                     // 0x016C(0x0008) (Edit)
	float                                              m_fTimeTillNextBlink;                                     // 0x0174(0x0004)
	TArray<struct FName>                               m_DisableBlinkingAnimNodeNameList;                        // 0x0178(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNode*>                           m_CachedNodeList;                                         // 0x0188(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      m_bInitializedCachedNodeList : 1;                         // 0x0198(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByBlink");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByPhysics
// 0x0038 (0x016C - 0x0134)
class UTgAnimNodeBlendByPhysics : public UAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0134(0x0008)
	TEnumAsByte<EPhysics>                              m_LastPhysics;                                            // 0x013C(0x0001)
	TEnumAsByte<EPhysics>                              m_CurrentPhysics;                                         // 0x013D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x013E(0x0002) MISSED OFFSET
	int                                                m_CurrentPhysicsChildIndex;                               // 0x0140(0x0004)
	TArray<TEnumAsByte<EPhysics>>                      m_PhysicsChildren;                                        // 0x0144(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bDirectUnspecifiedPhysicsThroughChild0 : 1;             // 0x0154(0x0004) (Edit)
	float                                              DefaultBlendTime;                                         // 0x0158(0x0004) (Edit)
	TArray<struct FChildrenBlendInfo>                  m_ChildrenBlendInfo;                                      // 0x015C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByPhysics");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByStrafe
// 0x000C (0x0130 - 0x0124)
class UTgAnimNodeBlendByStrafe : public UAnimNodeBlend
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0124(0x0008)
	float                                              m_fBlendTime;                                             // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByStrafe");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList
// 0x0034 (0x0168 - 0x0134)
class UTgAnimNodeBlendList : public UAnimNodeBlendList
{
public:
	float                                              DefaultBlendTime;                                         // 0x0134(0x0004) (Edit)
	TArray<float>                                      ChildBlendTimes;                                          // 0x0138(0x0010) (Edit, NeedCtorLink)
	int                                                DesiredChildIndex;                                        // 0x0148(0x0004)
	unsigned long                                      DesiredChildWaitsForCurrentChildCompletion : 1;           // 0x014C(0x0004) (Edit)
	TArray<struct FChildBlendParam>                    SpecificChildBlendTimes;                                  // 0x0150(0x0010) (Edit, NeedCtorLink)
	class AActor*                                      ActorOwner;                                               // 0x0160(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList");
		return ptr;
	}


	float STATIC_GetBlendTime(int ChildIndex);
};


// Class TgGame.TgAnim_MeshPassthrough
// 0x0024 (0x018C - 0x0168)
class UTgAnim_MeshPassthrough : public UTgAnimNodeBlendList
{
public:
	TArray<struct FTgAnimPassthroughMeshMap>           m_MeshMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTgAnimPassthroughPACMap>            m_PACMap;                                                 // 0x0178(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bVisualsActive : 1;                                     // 0x0188(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnim_MeshPassthrough");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByBuffMonsterIntro
// 0x0014 (0x017C - 0x0168)
class UTgAnimBlendByBuffMonsterIntro : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bEndIntroStateEarly : 1;                                // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bIntroHasBeenSetup : 1;                                 // 0x0168(0x0004)
	float                                              m_fIntroTimeHittableAt;                                   // 0x016C(0x0004) (Edit)
	float                                              m_fTimeToStartIntroAnim;                                  // 0x0170(0x0004)
	class ATgPawn*                                     m_CachedPawn;                                             // 0x0174(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByBuffMonsterIntro");
		return ptr;
	}


	void STATIC_SetupIntro(float fTotalIntroTime, float fIntroOffset);
};


// Class TgGame.TgAnimBlendByCharge
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendByCharge : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       ChargeEquipSlot;                                          // 0x0168(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0169(0x0003) MISSED OFFSET
	unsigned long                                      m_bActivelyCharging : 1;                                  // 0x016C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByCharge");
		return ptr;
	}


	void InterruptCharge();
	bool EndCharge(bool bHitTarget);
	void BeginCharge();
};


// Class TgGame.TgAnimBlendByDirection
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByDirection : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	TEnumAsByte<EBlendByDirectionSpeedType>            m_SpeedType;                                              // 0x0170(0x0001) (Edit)
	TEnumAsByte<EBlendDirTypes>                        LastDirection;                                            // 0x0171(0x0001) (Const)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0172(0x0002) MISSED OFFSET
	unsigned long                                      bAdjustRateByVelocity : 1;                                // 0x0174(0x0004) (Edit)
	unsigned long                                      bNoDirectionIsEnabled : 1;                                // 0x0174(0x0004) (Edit)
	unsigned long                                      bResetLooping : 1;                                        // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                           // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                               // 0x0174(0x0004)
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;                  // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bStopChildrenOnCeaseRelevant : 1;                       // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bUseParentsDirections : 1;                              // 0x0174(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByDirection");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByDirection_CorrectedDirectionTracker
// 0x0000 (0x0178 - 0x0178)
class UTgAnimBlendByDirection_CorrectedDirectionTracker : public UTgAnimBlendByDirection
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByDirection_CorrectedDirectionTracker");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByDirection_WithTransitions
// 0x0028 (0x01A0 - 0x0178)
class UTgAnimBlendByDirection_WithTransitions : public UTgAnimBlendByDirection_CorrectedDirectionTracker
{
public:
	class UAnimNodeSequence*                           m_animTransitionNodeSeq;                                  // 0x0178(0x0008) (Transient)
	int                                                m_nTransitionIndex;                                       // 0x0180(0x0004) (Const)
	TArray<struct FDirectionalProfile>                 m_directionTransitionProfiles;                            // 0x0184(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bWaitForCompletePreviousTransition : 1;                 // 0x0194(0x0004) (Edit)
	class UAnimNodeSequence*                           m_TransitionAnimNodeSeq;                                  // 0x0198(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByDirection_WithTransitions");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByEmote
// 0x005C (0x01C4 - 0x0168)
class UTgAnimBlendByEmote : public UTgAnimNodeBlendList
{
public:
	struct FName                                       nmEmotePrefix;                                            // 0x0168(0x0008)
	struct FName                                       mnEmoteMovingSuffix;                                      // 0x0170(0x0008)
	struct FName                                       nmEmoteFullMovingSuffix;                                  // 0x0178(0x0008)
	unsigned long                                      bForceTreatAsMovingEmoteNode : 1;                         // 0x0180(0x0004) (Edit)
	TArray<class UTgAnimNodeEmoteSequence*>            EmoteSequenceChildren;                                    // 0x0184(0x0010) (NeedCtorLink)
	TArray<class UAnimNodeBlendPerBone*>               PerBoneChildren;                                          // 0x0194(0x0010) (NeedCtorLink)
	TArray<class UAnimNodeBlendList*>                  FullMovingBlendLists;                                     // 0x01A4(0x0010) (NeedCtorLink)
	TArray<struct FEmoteBlendMap>                      m_EmoteOverrideMap;                                       // 0x01B4(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByEmote");
		return ptr;
	}


	bool STATIC_DoesEmoteOverride(TEnumAsByte<EEmote> Emote, int* nNewChildIndex);
	bool IsFullBody();
	void STATIC_CancelEmote(bool bNoBlend);
	float PlayEmote(TEnumAsByte<EEmote> Emote);
};


// Class TgGame.TgAnimBlendByFall
// 0x003C (0x01A4 - 0x0168)
class UTgAnimBlendByFall : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<EBlendFallTypes>                       FallState;                                                // 0x0168(0x0001) (Const)
	TEnumAsByte<EPhysics>                              m_PreviousTickPhysics;                                    // 0x0169(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x016A(0x0002) MISSED OFFSET
	float                                              LastFallingVelocity;                                      // 0x016C(0x0004) (Const)
	class ATgPawn*                                     pOwner;                                                   // 0x0170(0x0008)
	float                                              m_fPrelandDistance;                                       // 0x0178(0x0004) (Edit)
	unsigned long                                      m_bDebugMeasureJumpUp : 1;                                // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bDebugMeasureJumpDownToLand : 1;                        // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bMeasuring : 1;                                         // 0x017C(0x0004)
	unsigned long                                      m_bForceToIdleOnAttack : 1;                               // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bBypassJumping : 1;                                     // 0x017C(0x0004) (Edit)
	struct FVector                                     m_StartMeasureJump;                                       // 0x0180(0x000C)
	float                                              m_fMeasureTime;                                           // 0x018C(0x0004)
	float                                              m_fLandingMovementPlayRate;                               // 0x0190(0x0004) (Edit)
	struct FName                                       m_nmNameLandingSynchGroup;                                // 0x0194(0x0008) (Edit)
	float                                              m_fMovingLandCutOffTime;                                  // 0x019C(0x0004) (Edit)
	float                                              m_fMovingLandCountDown;                                   // 0x01A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFall");
		return ptr;
	}


	void STATIC_OnBasicOrOffhandAttack();
};


// Class TgGame.TgAnimBlendByFire
// 0x0084 (0x01EC - 0x0168)
class UTgAnimBlendByFire : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bSetToIdleOnCeaseRelevant : 1;                          // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bShouldReplayIfAlreadyActive : 1;                       // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bFirstInit : 1;                                         // 0x0168(0x0004) (Transient)
	struct FDeviceParameters                           m_InHandDeviceParameters;                                 // 0x016C(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand1DeviceParameters;                               // 0x0180(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand2DeviceParameters;                               // 0x0194(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand3DeviceParameters;                               // 0x01A8(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_OffHand4DeviceParameters;                               // 0x01BC(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_RecallDeviceParameters;                                 // 0x01D0(0x0014) (Edit, NeedCtorLink)
	class ATgPawn*                                     m_OwningPawn;                                             // 0x01E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFire");
		return ptr;
	}


	int NativeGetChildIndexByEquipPoint(unsigned char eqp);
	void STATIC_OnDeviceFormInterruptFire(class UTgDeviceForm* DeviceForm);
	void STATIC_OnDeviceFormStopFire(class UTgDeviceForm* DeviceForm);
	void STATIC_OnDeviceFormStartFire(class UTgDeviceForm* DeviceForm, float FireDuration);
	void STATIC_OnDeviceFormBuildup(class UTgDeviceForm* DeviceForm, float BuildupTime);
};


// Class TgGame.TgAnimBlendByFire_Complete
// 0x01E0 (0x03CC - 0x01EC)
class UTgAnimBlendByFire_Complete : public UTgAnimBlendByFire
{
public:
	struct FDeviceParameters                           m_PassiveDeviceParameters;                                // 0x01EC(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Active1DeviceParameters;                                // 0x0200(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Active2DeviceParameters;                                // 0x0214(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Active3DeviceParameters;                                // 0x0228(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Consumable1DeviceParameters;                            // 0x023C(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Consumable2DeviceParameters;                            // 0x0250(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Unused1DeviceParameters;                                // 0x0264(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Unused2DeviceParameters;                                // 0x0278(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Unused3DeviceParameters;                                // 0x028C(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Unused4DeviceParameters;                                // 0x02A0(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Unused5DeviceParameters;                                // 0x02B4(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_SpecialDeviceParameters;                                // 0x02C8(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_ItemStore1DeviceParameters;                             // 0x02DC(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_ItemStore2DeviceParameters;                             // 0x02F0(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_ItemStore3DeviceParameters;                             // 0x0304(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_ItemStore4DeviceParameters;                             // 0x0318(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_ItemStore5DeviceParameters;                             // 0x032C(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_ItemStore6DeviceParameters;                             // 0x0340(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_AltInDeviceParameters;                                  // 0x0354(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_AltOffhand1DeviceParameters;                            // 0x0368(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_AltOffhand2DeviceParameters;                            // 0x037C(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_AltOffhand3DeviceParameters;                            // 0x0390(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_AltOffhand4DeviceParameters;                            // 0x03A4(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_AltPassiveDeviceParameters;                             // 0x03B8(0x0014) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFire_Complete");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFire_CTF
// 0x0028 (0x0214 - 0x01EC)
class UTgAnimBlendByFire_CTF : public UTgAnimBlendByFire
{
public:
	struct FDeviceParameters                           m_Active1DeviceParameters;                                // 0x01EC(0x0014) (Edit, NeedCtorLink)
	struct FDeviceParameters                           m_Active2DeviceParameters;                                // 0x0200(0x0014) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFire_CTF");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFireGiantChest
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByFireGiantChest : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFireGiantChest");
		return ptr;
	}


	void STATIC_SetOpened(bool bForced);
	void STATIC_OpenChest(float StartOffset);
	void STATIC_ForceClosed();
};


// Class TgGame.TgAnimBlendByFlying
// 0x0038 (0x01A0 - 0x0168)
class UTgAnimBlendByFlying : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      bAdjustRateByVelocity : 1;                                // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bAdjustRateByAcceleration : 1;                          // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bPreviewJetpackPerBoneBlend : 1;                        // 0x0168(0x0004) (Edit, Transient)
	unsigned long                                      m_bIsUsingHandsFreeJetpack : 1;                           // 0x0168(0x0004)
	float                                              m_fUpLoopStartTime;                                       // 0x016C(0x0004) (Edit)
	TEnumAsByte<EFlyDirTypes>                          LastDirection;                                            // 0x0170(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	struct FName                                       m_nmHandsFreeJetpackPerBoneBlendNodeName;                 // 0x0174(0x0008) (Edit)
	class UAnimNodeBlendPerBone*                       m_HandsFreeJetpackPerBoneBlendNode;                       // 0x017C(0x0008)
	float                                              m_fHandsFreeJetpackBlendBias;                             // 0x0184(0x0004) (Edit)
	struct FName                                       m_nmHandsFreeJetpackBiasBlendNodeName;                    // 0x0188(0x0008) (Edit)
	class UAnimNodeBlend*                              m_HandsFreeJetpackBiasBlendNode;                          // 0x0190(0x0008)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0198(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFlying");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPhase
// 0x0024 (0x018C - 0x0168)
class UTgAnimBlendByPhase : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	int                                                m_LastPhase;                                              // 0x0170(0x0004)
	int                                                m_CurrentPhase;                                           // 0x0174(0x0004)
	unsigned long                                      m_bEnableTransitionAnims : 1;                             // 0x0178(0x0004) (Edit)
	TArray<struct Fm_PhaseProfile>                     m_PhaseProfiles;                                          // 0x017C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPhase");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPhysics
// 0x003C (0x01A4 - 0x0168)
class UTgAnimBlendByPhysics : public UTgAnimNodeBlendList
{
public:
	int                                                PhysicsMap[0xE];                                          // 0x0168(0x0004) (Edit)
	int                                                LastPhysics;                                              // 0x01A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPhysics");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByPosture
// 0x0044 (0x01AC - 0x0168)
class UTgAnimBlendByPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	class ATgSkeletalMeshActor_Posture*                m_TgPostureMesh;                                          // 0x0170(0x0008)
	TEnumAsByte<ETG_POSTURE>                           m_LastPosture;                                            // 0x0178(0x0001)
	TEnumAsByte<ETG_POSTURE>                           m_CurrentPosture;                                         // 0x0179(0x0001)
	TEnumAsByte<ETG_POSTURE>                           m_TransitionFromPosture;                                  // 0x017A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x017B(0x0001) MISSED OFFSET
	unsigned long                                      m_bEnableTransitionAnims : 1;                             // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bSkipTransitionAnimOnCeaseRelevant : 1;                 // 0x017C(0x0004) (Edit)
	unsigned long                                      m_bCheckLowerPriorityPostures : 1;                        // 0x017C(0x0004) (Edit)
	int                                                m_CurrentPostureChildIndex;                               // 0x0180(0x0004)
	TArray<struct FPostureTransitionOverride>          m_QueuedTransitionOverrides;                              // 0x0184(0x0010) (NeedCtorLink)
	TArray<struct Fm_PostureProfile>                   m_PostureProfiles;                                        // 0x0194(0x0010) (Edit, NeedCtorLink)
	class UAnimNodeSequence*                           m_TransitionAnimNodeSeq;                                  // 0x01A4(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByPosture");
		return ptr;
	}


	int STATIC_GetPostureChildIndex(int nPostureId);
	bool STATIC_ForcePostureChange(bool bAllowTransitionAnims);
	void STATIC_OverrideTransition(const struct FName& AnimName, float BlendTime, TEnumAsByte<ETG_POSTURE> StartPosture, TEnumAsByte<ETG_POSTURE> EndPosture);
};


// Class TgGame.TgAnimBlendByRacerAction
// 0x001C (0x0184 - 0x0168)
class UTgAnimBlendByRacerAction : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Racer*                               m_Racer;                                                  // 0x0168(0x0008)
	unsigned long                                      m_IsInit : 1;                                             // 0x0170(0x0004) (Transient)
	TArray<struct FRacerActionAnimSlotData>            m_ActionSlots;                                            // 0x0174(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByRacerAction");
		return ptr;
	}


	void STATIC_ReevaluateRacerAction();
	void TriggerRacerAction(TEnumAsByte<ERacerActionAnimNames> ActionName);
};


// Class TgGame.TgAnimBlendBySkin
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendBySkin : public UTgAnimNodeBlendList
{
public:
	TArray<struct FSkinChildInfo>                      m_SkinMap;                                                // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySkin");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByStartingPosture
// 0x0010 (0x0178 - 0x0168)
class UTgAnimBlendByStartingPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0168(0x0008)
	TEnumAsByte<ETG_POSTURE>                           m_StartingPosture;                                        // 0x0170(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0171(0x0003) MISSED OFFSET
	unsigned long                                      m_bExpired : 1;                                           // 0x0174(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByStartingPosture");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByState
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendByState : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_pawnOwner;                                              // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByState");
		return ptr;
	}


	void STATIC_OnPawnEndState(const struct FName& nmState, const struct FName& nmNextState);
	void STATIC_OnPawnBeginState(const struct FName& nmState, const struct FName& nmPreviousState);
};


// Class TgGame.TgAnimBlendByWard
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendByWard : public UTgAnimNodeBlendList
{
public:
	class ATgDeployable_Ward*                          m_OwnerWard;                                              // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByWard");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendOnlyWhenRelevant
// 0x0001 (0x0169 - 0x0168)
class UTgAnimBlendOnlyWhenRelevant : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ETG_POSTURE>                           m_eCurrentPosture;                                        // 0x0168(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendOnlyWhenRelevant");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimNodeBlendByAFK
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByAFK : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     PawnOwner;                                                // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByAFK");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByCH06Fox
// 0x0010 (0x0178 - 0x0168)
class UTgAnimNodeBlendByCH06Fox : public UTgAnimNodeBlendList
{
public:
	TArray<int>                                        m_TransitionQueue;                                        // 0x0168(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByCH06Fox");
		return ptr;
	}


	void STATIC_GoToVulnerable();
	void STATIC_GoToImmune();
	void STATIC_GoToMoving();
};


// Class TgGame.TgAnimNodeBlendByCombatWariness
// 0x000C (0x0174 - 0x0168)
class UTgAnimNodeBlendByCombatWariness : public UTgAnimNodeBlendList
{
public:
	float                                              CombatWarinessDuration;                                   // 0x0168(0x0004) (Edit)
	unsigned long                                      AllowIdleAnimToComplete : 1;                              // 0x016C(0x0004) (Edit)
	unsigned long                                      AllowWaryAnimToComplete : 1;                              // 0x016C(0x0004) (Edit)
	unsigned long                                      IsWary : 1;                                               // 0x016C(0x0004) (Transient)
	float                                              WaryTime;                                                 // 0x0170(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByCombatWariness");
		return ptr;
	}


	void BecomeWary();
	bool STATIC_ShouldBeWary();
};


// Class TgGame.TgAnimNodeBlendByGameState
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByGameState : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     PawnOwner;                                                // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByGameState");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByHealth
// 0x0018 (0x0180 - 0x0168)
class UTgAnimNodeBlendByHealth : public UTgAnimNodeBlendList
{
public:
	TArray<float>                                      m_HealthChildren;                                         // 0x0168(0x0010) (Edit, NeedCtorLink)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0178(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByHealth");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByHitReaction
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByHitReaction : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByHitReaction");
		return ptr;
	}


	void STATIC_OnMajorHit(const struct FVector& DirectionFromHit);
	void STATIC_OnMinorHit(const struct FVector& DirectionFromHit);
};


// Class TgGame.TgAnimNodeBlendByIntroduction
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendByIntroduction : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bIsRelevant : 1;                                        // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByIntroduction");
		return ptr;
	}


	void STATIC_PlayIntroduction();
	void STATIC_PrepareIntroduction();
};


// Class TgGame.TgAnimNodeBlendByKnockdown
// 0x0034 (0x019C - 0x0168)
class UTgAnimNodeBlendByKnockdown : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bAdjustPlayRateByVelocity : 1;                          // 0x0168(0x0004) (Edit)
	float                                              m_fVelocityMultiplier;                                    // 0x016C(0x0004) (Edit)
	float                                              m_PreviewVelocity;                                        // 0x0170(0x0004) (Edit)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0174(0x0008)
	struct FName                                       m_FaceDownAnimName;                                       // 0x017C(0x0008) (Edit)
	struct FName                                       m_FaceUpAnimName;                                         // 0x0184(0x0008) (Edit)
	struct FName                                       m_FaceDownRecoverAnimName;                                // 0x018C(0x0008) (Edit)
	struct FName                                       m_FaceUpRecoverAnimName;                                  // 0x0194(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByKnockdown");
		return ptr;
	}


	void STATIC_SetDownStateAnim(bool bFaceDown);
};


// Class TgGame.TgAnimNodeBlendByTowerSideHealth
// 0x001C (0x0184 - 0x0168)
class UTgAnimNodeBlendByTowerSideHealth : public UTgAnimNodeBlendList
{
public:
	int                                                m_nTowerSideIndex;                                        // 0x0168(0x0004) (Edit)
	TArray<float>                                      m_HealthChildren;                                         // 0x016C(0x0010) (Edit, NeedCtorLink)
	class ATgPawn_Tower*                               m_TgPawn;                                                 // 0x017C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByTowerSideHealth");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_EquipScreen
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendList_EquipScreen : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_EquipScreen");
		return ptr;
	}


	void STATIC_PlayIdleAnim();
	void STATIC_PlayBackpackReaction();
	void STATIC_PlaySuitReaction();
	void STATIC_PlayHelmetReaction();
	void STATIC_PlayWeaponReaction();
};


// Class TgGame.TgAnimNodeBlendList_Skadi_Dev2
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendList_Skadi_Dev2 : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Skadi*                               OwningSkadiPawn;                                          // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Skadi_Dev2");
		return ptr;
	}


	void STATIC_ReplayAnim();
};


// Class TgGame.TgAnimNodeBlendList_Staging_Multi
// 0x0001 (0x0169 - 0x0168)
class UTgAnimNodeBlendList_Staging_Multi : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       EquipSlot;                                                // 0x0168(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Staging_Multi");
		return ptr;
	}


	void SetActiveAnimationIndex(int ChildIndex);
};


// Class TgGame.TgAnimNodeBlentList_IntroLoopOutro
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlentList_IntroLoopOutro : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlentList_IntroLoopOutro");
		return ptr;
	}


	void STATIC_PlayOutro();
	void STATIC_PlayIntro();
};


// Class TgGame.TgAnimNodeChannelFire
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeChannelFire : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       m_EquipPoint;                                             // 0x0168(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0169(0x0003) MISSED OFFSET
	unsigned long                                      m_bResetOnRelevant : 1;                                   // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bDoneChanneling : 1;                                    // 0x016C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeChannelFire");
		return ptr;
	}


	void STATIC_SetLockedBase(bool bLocked);
	void STATIC_ReplayAnim();
	void STATIC_EndChannel();
};


// Class TgGame.TgAnimNodeEmoteSwitch
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeEmoteSwitch : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteSwitch");
		return ptr;
	}


	void PlayEmote(TEnumAsByte<EEmote> Emote);
};


// Class TgGame.TgAnimNodeRandom
// 0x0048 (0x01B0 - 0x0168)
class UTgAnimNodeRandom : public UTgAnimNodeBlendList
{
public:
	int                                                m_iDefaultChildIndex;                                     // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bConsiderRelevancy : 1;                                 // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bMasterOtherNodes : 1;                                  // 0x016C(0x0004) (Edit)
	unsigned long                                      m_bIsASlave : 1;                                          // 0x016C(0x0004) (Transient)
	unsigned long                                      m_bEnableTimer : 1;                                       // 0x016C(0x0004) (Edit)
	unsigned long                                      m_TimeAllChildren : 1;                                    // 0x016C(0x0004) (Edit)
	TArray<struct FName>                               m_SlaveNames;                                             // 0x0170(0x0010) (Edit, NeedCtorLink)
	TArray<class UTgAnimNodeRandom*>                   m_Slaves;                                                 // 0x0180(0x0010) (Transient, NeedCtorLink)
	int                                                m_nPrimaryChild;                                          // 0x0190(0x0004) (Edit)
	struct FVector2D                                   m_TimeRange;                                              // 0x0194(0x0008) (Edit)
	float                                              m_fRemainingTime;                                         // 0x019C(0x0004)
	TArray<struct FTgRandomAnimInfo>                   RandomInfo;                                               // 0x01A0(0x0010) (Edit, EditFixedSize, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeRandom");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeShuffle
// 0x0024 (0x01D4 - 0x01B0)
class UTgAnimNodeShuffle : public UTgAnimNodeRandom
{
public:
	struct FString                                     m_strPersistentShuffleListIdentifier;                     // 0x01B0(0x0010) (Edit, Const, NeedCtorLink)
	unsigned long                                      m_bUsePersistentShuffleList : 1;                          // 0x01C0(0x0004) (Edit, Const)
	unsigned long                                      m_bPreventRepeatsBetweenReshuffles : 1;                   // 0x01C0(0x0004) (Edit, Const)
	TArray<int>                                        m_nShuffledChildIndexes;                                  // 0x01C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeShuffle");
		return ptr;
	}

};


// Class TgGame.TgAnimSequenceChain
// 0x0004 (0x016C - 0x0168)
class UTgAnimSequenceChain : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bLoopChain : 1;                                         // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bResetOnRelevant : 1;                                   // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                           // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bAdvanceOnReplay : 1;                                   // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bAdvanceOnAnimEnd : 1;                                  // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                               // 0x0168(0x0004)
	unsigned long                                      m_ReplayedThisFrame : 1;                                  // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimSequenceChain");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeEmoteCustomAnim
// 0x0004 (0x0130 - 0x012C)
class UTgAnimNodeEmoteCustomAnim : public UAnimNodePlayCustomAnim
{
public:
	unsigned long                                      c_bIsInHandDeviceMeshInvisible : 1;                       // 0x012C(0x0004)
	unsigned long                                      c_bHasReachedFullWeight : 1;                              // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteCustomAnim");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeEmoteSequence
// 0x000C (0x01C8 - 0x01BC)
class UTgAnimNodeEmoteSequence : public UAnimNodeSequenceBlendBase
{
public:
	TEnumAsByte<EEmote>                                ActiveEmote;                                              // 0x01BC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01BD(0x0003) MISSED OFFSET
	float                                              BlendSpeed;                                               // 0x01C0(0x0004) (Edit)
	unsigned long                                      ForceCeaseRelevant : 1;                                   // 0x01C4(0x0004) (Edit)
	unsigned long                                      InterpWeights : 1;                                        // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteSequence");
		return ptr;
	}


	bool STATIC_SetActiveEmote(const struct FName& FullBody, const struct FName& Moving, TEnumAsByte<EEmote> Emote, bool bResetSynchGroup);
};


// Class TgGame.TgAnimNodeEmoteSequence_WithMesh
// 0x0015 (0x01DD - 0x01C8)
class UTgAnimNodeEmoteSequence_WithMesh : public UTgAnimNodeEmoteSequence
{
public:
	unsigned long                                      m_bPlayEmoteAfterSpawn : 1;                               // 0x01C8(0x0004) (Edit)
	TArray<struct FEMOTE_MESH_INFO>                    m_Emote_Mesh_Map;                                         // 0x01CC(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<EEmote>                                c_eActiveEmote;                                           // 0x01DC(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteSequence_WithMesh");
		return ptr;
	}


	void STATIC_OnDelete();
	bool STATIC_CheckEmoteOrder(TEnumAsByte<EEmote> EmoteType);
	void STATIC_DeactivateEmoteMesh(TEnumAsByte<EEmote> EmoteType);
	void ActivateEmoteMesh(TEnumAsByte<EEmote> EmoteType);
	bool STATIC_SetActiveEmote(const struct FName& FullBody, const struct FName& Moving, TEnumAsByte<EEmote> Emote, bool bResetSynchGroup);
};


// Class TgGame.TgAnimNodeEmoteSequence_WithPAC
// 0x0010 (0x01D8 - 0x01C8)
class UTgAnimNodeEmoteSequence_WithPAC : public UTgAnimNodeEmoteSequence
{
public:
	TArray<struct FEMOTE_PAC_INFO>                     m_Emote_PAC_Map;                                          // 0x01C8(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeEmoteSequence_WithPAC");
		return ptr;
	}


	void STATIC_DeactivateEmotePAC(int PACIndex);
	void ActivateEmotePAC(int PACIndex);
	bool STATIC_SetActiveEmote(const struct FName& FullBody, const struct FName& Moving, TEnumAsByte<EEmote> Emote, bool bResetSynchGroup);
};


// Class TgGame.TgAnimNodeFidget
// 0x0024 (0x0158 - 0x0134)
class UTgAnimNodeFidget : public UAnimNodeBlendList
{
public:
	float                                              m_SelectedIdleTimeBeforeFidgeting;                        // 0x0134(0x0004) (Transient)
	float                                              m_CurrentIdleTime;                                        // 0x0138(0x0004) (Transient)
	float                                              BlendToFidgetDuration;                                    // 0x013C(0x0004) (Edit)
	float                                              BlendFromFidgetDuration;                                  // 0x0140(0x0004) (Edit)
	TEnumAsByte<EFidgetType>                           FidgetType;                                               // 0x0144(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0145(0x0003) MISSED OFFSET
	float                                              MinimumIdleTimeBeforeFidgeting;                           // 0x0148(0x0004) (Edit)
	float                                              MaximumIdleTimeBeforeFidgeting;                           // 0x014C(0x0004) (Edit)
	unsigned long                                      AllowIdleAnimToComplete : 1;                              // 0x0150(0x0004) (Edit)
	float                                              ChanceToFidgetWhenIdleCompletes;                          // 0x0154(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeFidget");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeFitToDuration
// 0x001B (0x012C - 0x0111)
class UTgAnimNodeFitToDuration : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	float                                              Duration;                                                 // 0x0114(0x0004) (Edit)
	float                                              OverrideDuration;                                         // 0x0118(0x0004)
	unsigned long                                      bAllowIncreasedPlayRate : 1;                              // 0x011C(0x0004) (Edit)
	unsigned long                                      bAllowDecreasedPlayRate : 1;                              // 0x011C(0x0004) (Edit)
	unsigned long                                      bClampDuration : 1;                                       // 0x011C(0x0004) (Edit)
	unsigned long                                      m_bOverrideAnimLength : 1;                                // 0x011C(0x0004) (Edit)
	float                                              ClampedMinDuration;                                       // 0x0120(0x0004) (Edit)
	float                                              ClampedMaxDuration;                                       // 0x0124(0x0004) (Edit)
	float                                              m_fAnimLengthOverride;                                    // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeFitToDuration");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeJumpLeanOffset
// 0x0030 (0x019C - 0x016C)
class UTgAnimNodeJumpLeanOffset : public UAnimNodeAimOffset
{
public:
	float                                              JumpLeanStrength;                                         // 0x016C(0x0004) (Edit)
	float                                              MaxLeanChangeSpeed;                                       // 0x0170(0x0004) (Edit)
	unsigned long                                      bMultiplyByZVelocity : 1;                                 // 0x0174(0x0004) (Edit)
	class UAnimNodeAimOffset*                          CachedAimNode;                                            // 0x0178(0x0008)
	struct FName                                       OldAimProfileName;                                        // 0x0180(0x0008)
	struct FVector2D                                   PreBlendAim;                                              // 0x0188(0x0008)
	float                                              LeanWeight;                                               // 0x0190(0x0004)
	float                                              LeanWeightTarget;                                         // 0x0194(0x0004)
	float                                              BlendTimeToGo;                                            // 0x0198(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeJumpLeanOffset");
		return ptr;
	}


	void STATIC_SetLeanWeight(float WeightTarget, float BlendTime);
};


// Class TgGame.TgAnimNodeSequence_WithPAC
// 0x0018 (0x01CC - 0x01B4)
class UTgAnimNodeSequence_WithPAC : public UTgAnimNodeSequence
{
public:
	struct FANIM_PAC_INFO                              m_AnimPAC;                                                // 0x01B4(0x0018) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_WithPAC");
		return ptr;
	}


	void STATIC_DeactivatePac();
	void ActivatePac();
};


// Class TgGame.TgAnimNodeSequence_WithMultiPAC
// 0x0010 (0x01DC - 0x01CC)
class UTgAnimNodeSequence_WithMultiPAC : public UTgAnimNodeSequence_WithPAC
{
public:
	TArray<struct FANIM_PAC_INFO>                      c_MultiPACs;                                              // 0x01CC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_WithMultiPAC");
		return ptr;
	}


	void STATIC_DeactivatePac();
	void ActivatePac();
};


// Class TgGame.TgAnimNodeSimpleTransitioner
// 0x0020 (0x0154 - 0x0134)
class UTgAnimNodeSimpleTransitioner : public UAnimNodeBlendList
{
public:
	int                                                m_nDeviceId;                                              // 0x0134(0x0004) (Edit)
	unsigned long                                      m_bConfigureBasedOnDevice : 1;                            // 0x0138(0x0004) (Edit)
	unsigned long                                      m_bIgnoreFireMode : 1;                                    // 0x0138(0x0004) (Edit)
	int                                                m_nNumberOfStances;                                       // 0x013C(0x0004) (Edit)
	struct FName                                       m_StanceBaseName;                                         // 0x0140(0x0008) (Edit)
	struct FName                                       m_TransitionBaseName;                                     // 0x0148(0x0008) (Edit)
	float                                              m_BlendTransitionDuration;                                // 0x0150(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSimpleTransitioner");
		return ptr;
	}


	bool Fire(int nMode);
	bool STATIC_SetStance(int nStance, bool bNoBlend);
	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
};


// Class TgGame.TgAnimNodeSlot
// 0x005C (0x0194 - 0x0138)
class UTgAnimNodeSlot : public UAnimNodeSlot
{
public:
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0138(0x0008) (Transient)
	unsigned long                                      m_bBlendOutIfVelocityIsGreaterThanZero : 1;               // 0x0140(0x0004) (Transient)
	unsigned long                                      m_bIsTransitionAnim : 1;                                  // 0x0140(0x0004) (Transient)
	unsigned long                                      m_bNotifyActorOnChildAnimEnd : 1;                         // 0x0140(0x0004) (Edit)
	unsigned long                                      m_bCustomBlending : 1;                                    // 0x0140(0x0004) (Edit)
	unsigned long                                      m_bLastNodeInTree : 1;                                    // 0x0140(0x0004) (Edit)
	struct FName                                       m_nmHackingTransitionAnimName;                            // 0x0144(0x0008) (Edit)
	struct FName                                       m_nmHackingLoopingAnimName;                               // 0x014C(0x0008) (Edit)
	struct FName                                       m_nmAFKTransitionAnimName;                                // 0x0154(0x0008) (Edit)
	struct FName                                       m_nmAFKLoopingAnimName;                                   // 0x015C(0x0008) (Edit)
	struct FName                                       m_nmQueuedAnim;                                           // 0x0164(0x0008) (Transient)
	float                                              m_fBlendInTime;                                           // 0x016C(0x0004) (Edit)
	float                                              m_fBlendOutTime;                                          // 0x0170(0x0004) (Edit)
	TArray<struct FTgAnimSlotMeshMap>                  m_MeshMap;                                                // 0x0174(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTgAnimSlotPACMap>                   m_PACMap;                                                 // 0x0184(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSlot");
		return ptr;
	}


	void STATIC_DeactivateAll();
	void STATIC_DeactivatePac(int nPACIndex);
	void ActivatePac(int nPACIndex);
	void STATIC_DeactivateMesh(int nMeshIndex, int nAnimIndex);
	void ActivateMesh(int nMeshIndex, int nAnimIndex);
	void STATIC_StopCustomAnim(float BlendOutTime);
	void STATIC_StopHacking();
	void STATIC_PlayHacking();
	void STATIC_StopAFK();
	void STATIC_PlayAFK();
	float STATIC_PlayLoopingCustomAnimWithTransition(const struct FName& TransitionAnimName, const struct FName& LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime);
	float STATIC_PlayCustomAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, float StartTime, float EndTime);
};


// Class TgGame.TgAnimNodeStance
// 0x0004 (0x0138 - 0x0134)
class UTgAnimNodeStance : public UAnimNodeBlendList
{
public:
	int                                                m_Stance;                                                 // 0x0134(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStance");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeStanceTransition
// 0x0008 (0x013C - 0x0134)
class UTgAnimNodeStanceTransition : public UAnimNodeBlendList
{
public:
	int                                                m_SourceStance;                                           // 0x0134(0x0004) (Edit)
	int                                                m_DestinationStance;                                      // 0x0138(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceTransition");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeStanceTransitioner
// 0x0030 (0x0164 - 0x0134)
class UTgAnimNodeStanceTransitioner : public UAnimNodeBlendList
{
public:
	int                                                m_DefaultStance;                                          // 0x0134(0x0004) (Edit)
	int                                                m_CurrentStance;                                          // 0x0138(0x0004) (Edit)
	unsigned long                                      m_bIsPlayingTransition : 1;                               // 0x013C(0x0004)
	float                                              m_BlendTransitionDuration;                                // 0x0140(0x0004) (Edit)
	TArray<struct FCachedTgAnimNodeStanceInfo>         m_StanceNodeInfos;                                        // 0x0144(0x0010) (NeedCtorLink)
	TArray<struct FCachedTgAnimNodeStanceTransitionInfo> m_TransitionNodeInfos;                                    // 0x0154(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeStanceTransitioner");
		return ptr;
	}


	bool BlendToStance(int DestinationStance);
	bool TransitionToStance(int DestinationStance);
	void STATIC_GetTransitionableStances(int SourceStance, TArray<int>* DestinationStances);
	bool STATIC_SetStance(int Stance);
	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float InRate, float StartTime);
	void GetStances(TArray<int>* Stances);
	int GetCurrentStance();
};


// Class TgGame.TgAnimNodeTiltTowardsVelocity
// 0x0023 (0x0134 - 0x0111)
class UTgAnimNodeTiltTowardsVelocity : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	struct FVector2D                                   m_MaximumVelocity;                                        // 0x0114(0x0008) (Edit)
	int                                                m_PitchOffset;                                            // 0x011C(0x0004) (Transient)
	int                                                m_MaximumPitchOffset;                                     // 0x0120(0x0004) (Edit)
	int                                                m_RollOffset;                                             // 0x0124(0x0004) (Transient)
	int                                                m_MaximumRollOffset;                                      // 0x0128(0x0004) (Edit)
	class ATgPawn*                                     m_Pawn;                                                   // 0x012C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeTiltTowardsVelocity");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_ApplyRigidBodyPhysics
// 0x0023 (0x0088 - 0x0065)
class UTgAnimNotify_ApplyRigidBodyPhysics : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	unsigned long                                      ShouldAttachToBone : 1;                                   // 0x0068(0x0004) (Edit)
	struct FName                                       BoneName;                                                 // 0x006C(0x0008) (Edit)
	struct FVector                                     ImpulseLocation;                                          // 0x0074(0x000C) (Edit)
	float                                              ImpulseRadius;                                            // 0x0080(0x0004) (Edit)
	float                                              ImpulseStrength;                                          // 0x0084(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ApplyRigidBodyPhysics");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_AudioGroup
// 0x0014 (0x0079 - 0x0065)
class UTgAnimNotify_AudioGroup : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	class USoundCue*                                   c_PreviewSound;                                           // 0x0068(0x0008) (Edit)
	struct FName                                       c_SoundCueName;                                           // 0x0070(0x0008) (Edit)
	TEnumAsByte<ETG_MESH_SOURCE>                       c_eMeshSource;                                            // 0x0078(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_AudioGroup");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Disappear_ExtraMeshes
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_Disappear_ExtraMeshes : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Disappear_ExtraMeshes");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_InterpolateMorphTargetWeight
// 0x001B (0x0080 - 0x0065)
class UTgAnimNotify_InterpolateMorphTargetWeight : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       MorphNodePoseName;                                        // 0x0068(0x0008) (Edit)
	float                                              MorphTargetWeight;                                        // 0x0070(0x0004) (Edit)
	TEnumAsByte<EInterruptMorphTargetBehavior>         OnInterruptBehavior;                                      // 0x0074(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0075(0x0003) MISSED OFFSET
	float                                              InterruptMorphTargetWeight;                               // 0x0078(0x0004) (Edit)
	float                                              InitialMorphTargetWeight;                                 // 0x007C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_InterpolateMorphTargetWeight");
		return ptr;
	}


	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_PlayParticleEffect_Skinned
// 0x001C (0x00B4 - 0x0098)
class UTgAnimNotify_PlayParticleEffect_Skinned : public UAnimNotify_PlayParticleEffect
{
public:
	TArray<struct FPPE_Skin>                           m_SkinOverrideList;                                       // 0x0098(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bApplyTeamColor : 1;                                    // 0x00A8(0x0004) (Edit)
	unsigned long                                      m_bTurnOffParticleSystemOnCeaseRelevence : 1;             // 0x00A8(0x0004) (Edit)
	class UParticleSystem*                             PSTemplateLobby;                                          // 0x00AC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_PlayParticleEffect_Skinned");
		return ptr;
	}


	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
	struct FParticleChannelContainer STATIC_GetParticleChannels(class USkeletalMeshComponent* skel);
	class UParticleSystem* STATIC_GetParticleSystemToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_PlayParticleEffect_Limited
// 0x0004 (0x00B8 - 0x00B4)
class UTgAnimNotify_PlayParticleEffect_Limited : public UTgAnimNotify_PlayParticleEffect_Skinned
{
public:
	int                                                m_nParticleEffectLimit;                                   // 0x00B4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_PlayParticleEffect_Limited");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_PlayPetAnim
// 0x000B (0x0070 - 0x0065)
class UTgAnimNotify_PlayPetAnim : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       m_ChildSeqName;                                           // 0x0068(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_PlayPetAnim");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Sound
// 0x0020 (0x00A8 - 0x0088)
class UTgAnimNotify_Sound : public UAnimNotify_Sound
{
public:
	TArray<struct FPSE_Skin>                           m_SkinOverrideList;                                       // 0x0088(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bPreventRepeat : 1;                                     // 0x0098(0x0004) (Edit)
	unsigned long                                      m_bPreventGroupRepeat : 1;                                // 0x0098(0x0004) (Edit)
	float                                              m_fCueDuration;                                           // 0x009C(0x0004) (Edit)
	int                                                m_nCueGroup;                                              // 0x00A0(0x0004) (Edit)
	float                                              m_fInLobbyMultiplier;                                     // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Sound");
		return ptr;
	}


	class USoundCue* STATIC_GetSoundCueToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgAnimNotify_Sound_OncePerLoop
// 0x0008 (0x00B0 - 0x00A8)
class UTgAnimNotify_Sound_OncePerLoop : public UTgAnimNotify_Sound
{
public:
	int                                                m_nAnimPlayCount;                                         // 0x00A8(0x0004) (Transient)
	int                                                m_nNotifyPlayCount;                                       // 0x00AC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Sound_OncePerLoop");
		return ptr;
	}


	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_SpawnMesh
// 0x0027 (0x008C - 0x0065)
class UTgAnimNotify_SpawnMesh : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	int                                                m_nSkinId;                                                // 0x0068(0x0004) (Edit)
	int                                                m_nSkinLevel;                                             // 0x006C(0x0004) (Edit)
	int                                                m_nMeshId;                                                // 0x0070(0x0004) (Edit)
	struct FName                                       m_nmSocket;                                               // 0x0074(0x0008) (Edit)
	unsigned long                                      m_bNeedsRelevancy : 1;                                    // 0x007C(0x0004) (Edit)
	unsigned long                                      m_bHideIfOwnerHidden : 1;                                 // 0x007C(0x0004) (Edit)
	float                                              m_fMeshLifespan;                                          // 0x0080(0x0004) (Edit)
	struct FName                                       m_nmFullbodyAnim;                                         // 0x0084(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_SpawnMesh");
		return ptr;
	}


	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_ToggleInvisibleWall
// 0x003B (0x00A0 - 0x0065)
class UTgAnimNotify_ToggleInvisibleWall : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	unsigned long                                      TurnWallOn : 1;                                           // 0x0068(0x0004) (Edit)
	unsigned long                                      TurnOffOnCeaseRelevant : 1;                               // 0x0068(0x0004) (Edit)
	int                                                WallIndex;                                                // 0x006C(0x0004) (Edit)
	struct FVector                                     WallPosition;                                             // 0x0070(0x000C) (Edit)
	struct FVector                                     WallNormal;                                               // 0x007C(0x000C) (Edit)
	struct FName                                       WallEnableBaseName;                                       // 0x0088(0x0008) (Const)
	struct FName                                       WallPositionBaseName;                                     // 0x0090(0x0008) (Const)
	struct FName                                       WallNormalBaseName;                                       // 0x0098(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleInvisibleWall");
		return ptr;
	}


	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_ToggleRigidBodies
// 0x0014 (0x0079 - 0x0065)
class UTgAnimNotify_ToggleRigidBodies : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	TArray<struct FName>                               BoneNames;                                                // 0x0068(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ERigidBodyFixationChange>              Effect;                                                   // 0x0078(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleRigidBodies");
		return ptr;
	}


	void OnAnimNodeSequenceBecomeRelevant(class UAnimNodeSequence* OwningNode);
	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgAnimNotify_ToggleSocketSpecialFX
// 0x0013 (0x0078 - 0x0065)
class UTgAnimNotify_ToggleSocketSpecialFX : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FName                                       m_DisplayGroupName;                                       // 0x0068(0x0008) (Edit)
	int                                                m_EquipSlot;                                              // 0x0070(0x0004) (Edit)
	unsigned long                                      m_bActivateFxGroup : 1;                                   // 0x0074(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ToggleSocketSpecialFX");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_ViewShake
// 0x000C (0x00C8 - 0x00BC)
class UTgAnimNotify_ViewShake : public UAnimNotify_ViewShake
{
public:
	float                                              m_fShakeRadius;                                           // 0x00BC(0x0004) (EditConst)
	float                                              m_fDuration;                                              // 0x00C0(0x0004) (EditConst)
	float                                              m_fAmplitude;                                             // 0x00C4(0x0004) (EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_ViewShake");
		return ptr;
	}

};


// Class TgGame.TgAnimNotifySkinData
// 0x003C (0x009C - 0x0060)
class UTgAnimNotifySkinData : public UObject
{
public:
	struct FString                                     OwningNotify;                                             // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	class USoundCue*                                   SoundCueTemplate;                                         // 0x0070(0x0008)
	class UParticleSystem*                             ParticleSystemTemplate;                                   // 0x0078(0x0008)
	int                                                nSkinId;                                                  // 0x0080(0x0004)
	int                                                nSkinLevel;                                               // 0x0084(0x0004)
	unsigned long                                      bPreventRepeat : 1;                                       // 0x0088(0x0004)
	float                                              fCueDuration;                                             // 0x008C(0x0004)
	int                                                nCueGroup;                                                // 0x0090(0x0004)
	class UParticleSystem*                             LobbyParticleSystemTemplate;                              // 0x0094(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotifySkinData");
		return ptr;
	}

};


// Class TgGame.TgAnimTurnInPlace
// 0x0088 (0x01AC - 0x0124)
class UTgAnimTurnInPlace : public UAnimNodeBlend
{
public:
	unsigned long                                      bInitialized : 1;                                         // 0x0124(0x0004) (Const, Transient)
	unsigned long                                      bRootRotInitialized : 1;                                  // 0x0124(0x0004) (Const, Transient)
	unsigned long                                      m_bDisableRotation : 1;                                   // 0x0124(0x0004) (Edit)
	unsigned long                                      bDelayBlendOutToPlayAnim : 1;                             // 0x0124(0x0004) (Edit)
	unsigned long                                      bPlayingTurnTransition : 1;                               // 0x0124(0x0004) (Const)
	unsigned long                                      m_bCanChooseNewTransition : 1;                            // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bOverrideInterpolationTime : 1;                         // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bMirrorOffsetWhenPawnMirrored : 1;                      // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bAlwaysUpdateYawOffset : 1;                             // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bIgnoreTransitionAnimations : 1;                        // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bOnlyUpdateRotationWhenMoving : 1;                      // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bTurnTowardsVelocity : 1;                               // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bUsePawnRotationAtZeroVelocity : 1;                     // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bUse180ShortestRoute : 1;                               // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bConstrictIdleYawOffset : 1;                            // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bDisableAllTurning : 1;                                 // 0x0124(0x0004) (Edit)
	unsigned long                                      m_bJustBecameRelevant : 1;                                // 0x0124(0x0004)
	int                                                LastPawnYaw;                                              // 0x0128(0x0004) (Const, Transient)
	int                                                LastPawnPitch;                                            // 0x012C(0x0004) (Const, Transient)
	float                                              PawnRotationRate;                                         // 0x0130(0x0004) (Const, Transient)
	int                                                LastRootBoneYaw;                                          // 0x0134(0x0004) (Const, Transient)
	int                                                YawOffset;                                                // 0x0138(0x0004) (Edit, Const, Transient)
	int                                                PitchOffset;                                              // 0x013C(0x0004) (Edit, Const, Transient)
	float                                              RelativeOffset;                                           // 0x0140(0x0004) (Const, Transient)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0144(0x0008) (Const, Transient)
	TArray<class UTgAnimNodeAimOffset*>                OffsetNodes2;                                             // 0x014C(0x0010) (NeedCtorLink)
	TArray<struct FRotTransitionInfo>                  RotTransitions;                                           // 0x015C(0x0010) (Edit, NeedCtorLink)
	float                                              TransitionBlendTime;                                      // 0x016C(0x0004) (Edit)
	int                                                CurrentTransitionIndex;                                   // 0x0170(0x0004) (Const)
	float                                              TransitionThresholdAngle;                                 // 0x0174(0x0004) (Edit)
	TEnumAsByte<EForcedTransitionAngle>                m_ForcedTransitionAngle;                                  // 0x0178(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0179(0x0003) MISSED OFFSET
	float                                              m_fChooseNewTransitionPercent;                            // 0x017C(0x0004) (Edit)
	float                                              m_fInterpolationTime;                                     // 0x0180(0x0004) (Edit)
	float                                              m_RemainingInterpolationTime;                             // 0x0184(0x0004)
	TArray<class UTgAnimTurnInPlace_Player*>           PlayerNodes;                                              // 0x0188(0x0010) (NeedCtorLink)
	float                                              m_fIgnoredTransitionTime;                                 // 0x0198(0x0004) (Edit)
	float                                              m_fTurnInterpTime;                                        // 0x019C(0x0004) (Edit)
	struct FRotator                                    m_InterpRotation;                                         // 0x01A0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimTurnInPlace");
		return ptr;
	}


	void STATIC_OverrideYawOffset(float Value);
};


// Class TgGame.TgAnimTurnInPlace_Player
// 0x0010 (0x01BC - 0x01AC)
class UTgAnimTurnInPlace_Player : public UAnimNodeSequence
{
public:
	TArray<struct FTIP_Transition>                     TIP_Transitions;                                          // 0x01AC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimTurnInPlace_Player");
		return ptr;
	}

};


// Class TgGame.TgAnimTurnInPlace_Rotator
// 0x001B (0x012C - 0x0111)
class UTgAnimTurnInPlace_Rotator : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	TArray<class UTgAnimTurnInPlace*>                  c_TurnInPlaceNodes;                                       // 0x0114(0x0010) (Const, NeedCtorLink)
	class ATgPawn*                                     m_TgPawn;                                                 // 0x0124(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimTurnInPlace_Rotator");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_CCD_IK_FootPlacement
// 0x0064 (0x0134 - 0x00D0)
class UTgSkelCon_CCD_IK_FootPlacement : public USkelControlBase
{
public:
	int                                                NumBones;                                                 // 0x00D0(0x0004) (Edit)
	int                                                MaxPerBoneIterations;                                     // 0x00D4(0x0004) (Edit)
	int                                                IterationsCount;                                          // 0x00D8(0x0004) (Const)
	float                                              Precision;                                                // 0x00DC(0x0004) (Edit)
	unsigned long                                      bStartFromTail : 1;                                       // 0x00E0(0x0004) (Edit)
	unsigned long                                      bNoTurnOptimization : 1;                                  // 0x00E0(0x0004) (Edit)
	unsigned long                                      bAllowStretching : 1;                                     // 0x00E0(0x0004) (Edit)
	unsigned long                                      bInvertFootUpAxis : 1;                                    // 0x00E0(0x0004) (Edit)
	unsigned long                                      bOrientFootToGround : 1;                                  // 0x00E0(0x0004) (Edit)
	unsigned long                                      bOnlyEnableForUpAdjustment : 1;                           // 0x00E0(0x0004) (Edit)
	unsigned long                                      m_bUseCachedFootOffset : 1;                               // 0x00E0(0x0004)
	TArray<struct FJointConstraintInformation>         JointConstraints;                                         // 0x00E4(0x0010) (Edit, Const, NeedCtorLink)
	float                                              MaxAngleSteps;                                            // 0x00F4(0x0004) (Edit)
	float                                              MaxStretchSteps;                                          // 0x00F8(0x0004) (Edit)
	float                                              FootOffset;                                               // 0x00FC(0x0004) (Edit)
	TEnumAsByte<EAxis>                                 FootUpAxis;                                               // 0x0100(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0101(0x0003) MISSED OFFSET
	struct FRotator                                    FootRotOffset;                                            // 0x0104(0x000C) (Edit)
	float                                              MaxUpAdjustment;                                          // 0x0110(0x0004) (Edit)
	float                                              MaxDownAdjustment;                                        // 0x0114(0x0004) (Edit)
	float                                              MaxFootOrientAdjust;                                      // 0x0118(0x0004) (Edit)
	struct FVector                                     EffectorLocation;                                         // 0x011C(0x000C)
	struct FVector                                     m_vCachedFootOffset;                                      // 0x0128(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_CCD_IK_FootPlacement");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_CCD_IK_TargetLocation
// 0x0018 (0x0134 - 0x011C)
class UTgSkelCon_CCD_IK_TargetLocation : public USkelControl_CCD_IK
{
public:
	unsigned long                                      bAimAtFeet : 1;                                           // 0x011C(0x0004) (Edit)
	unsigned long                                      m_bHadTargetLastTick : 1;                                 // 0x011C(0x0004) (Transient)
	float                                              fInterpSpeed;                                             // 0x0120(0x0004) (Edit)
	float                                              fEnableInterpSpeed;                                       // 0x0124(0x0004) (Edit)
	class ATgPawn*                                     m_Owner;                                                  // 0x0128(0x0008) (Transient)
	float                                              fEnabledAlpha;                                            // 0x0130(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_CCD_IK_TargetLocation");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_ClockworkSpinner
// 0x0044 (0x0144 - 0x0100)
class UTgSkelCon_ClockworkSpinner : public USkelControlSingleBone
{
public:
	float                                              m_fInterpTime;                                            // 0x0100(0x0004) (Edit)
	float                                              m_fRemainingInterpTime;                                   // 0x0104(0x0004)
	float                                              m_fPauseTime;                                             // 0x0108(0x0004) (Edit)
	float                                              m_fRemainingPauseTime;                                    // 0x010C(0x0004)
	TEnumAsByte<EAxis>                                 RotationAxis;                                             // 0x0110(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0111(0x0003) MISSED OFFSET
	int                                                DeltaRotation;                                            // 0x0114(0x0004)
	float                                              m_fInterpRotation;                                        // 0x0118(0x0004) (Edit)
	unsigned long                                      bLimitedRotation : 1;                                     // 0x011C(0x0004) (Edit)
	unsigned long                                      bForward : 1;                                             // 0x011C(0x0004)
	float                                              m_fRotationMin;                                           // 0x0120(0x0004) (Edit)
	float                                              m_fRotationMax;                                           // 0x0124(0x0004) (Edit)
	float                                              m_fResetInterpTime;                                       // 0x0128(0x0004) (Edit)
	float                                              m_fResetPauseTime;                                        // 0x012C(0x0004) (Edit)
	float                                              m_fResetRotation;                                         // 0x0130(0x0004) (Edit)
	float                                              m_fRotatorMin;                                            // 0x0134(0x0004)
	float                                              m_fRotatorMax;                                            // 0x0138(0x0004)
	float                                              RotationsPerSecond;                                       // 0x013C(0x0004)
	float                                              ResetRotationsPerSecond;                                  // 0x0140(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_ClockworkSpinner");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_FootPlacement
// 0x0004 (0x015C - 0x0158)
class UTgSkelCon_FootPlacement : public USkelControlFootPlacement
{
public:
	unsigned long                                      bShouldUseWorldDown : 1;                                  // 0x0158(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_FootPlacement");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Gate
// 0x0010 (0x00E0 - 0x00D0)
class UTgSkelCon_Gate : public USkelControlBase
{
public:
	TArray<struct FSkelControlGateChild>               ChildControls;                                            // 0x00D0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Gate");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_HitReaction
// 0x03A8 (0x0510 - 0x0168)
class UTgSkelCon_HitReaction : public UGameSkelCtrl_Recoil
{
public:
	TEnumAsByte<ERecoilHitDir>                         m_CurrentRecoilDir;                                       // 0x0168(0x0001) (Edit)
	TEnumAsByte<EHitReactionMoveType>                  m_MoveType;                                               // 0x0169(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x016A(0x0002) MISSED OFFSET
	struct FRecoilInfo                                 m_RecoilFromFront;                                        // 0x016C(0x00E0) (Edit)
	struct FRecoilInfo                                 m_RecoilFromBack;                                         // 0x024C(0x00E0) (Edit)
	struct FRecoilInfo                                 m_RecoilFromLeft;                                         // 0x032C(0x00E0) (Edit)
	struct FRecoilInfo                                 m_RecoilFromRight;                                        // 0x040C(0x00E0) (Edit)
	TArray<struct FName>                               m_SlaveSkelControlNames;                                  // 0x04EC(0x0010) (Edit, NeedCtorLink)
	TArray<class USkelControlBase*>                    m_SlaveSkelControls;                                      // 0x04FC(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      m_bInitialized : 1;                                       // 0x050C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_HitReaction");
		return ptr;
	}


	struct FRecoilDef STATIC_GenRecoil(const struct FRecoilInfo& RecoilParam);
	struct FVector VRandRange(const struct FVector& v1, const struct FVector& v2);
	void SetRecoilParam();
	void STATIC_SetRecoilDir(TEnumAsByte<ERecoilHitDir> NewDir);
};


// Class TgGame.TgSkelCon_LookAt
// 0x000C (0x0178 - 0x016C)
class UTgSkelCon_LookAt : public USkelControlLookAt
{
public:
	class ATgPawn*                                     m_Owner;                                                  // 0x016C(0x0008)
	unsigned long                                      m_bAimAtEnemyTarget : 1;                                  // 0x0174(0x0004) (Edit)
	unsigned long                                      m_AlwaysInterpolateTarget : 1;                            // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bAimAtOwner : 1;                                        // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bHadTargetLastTick : 1;                                 // 0x0174(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_LookAt");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_OscillateBoneScale
// 0x0010 (0x0110 - 0x0100)
class UTgSkelCon_OscillateBoneScale : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                                     // 0x0100(0x0004) (Edit)
	float                                              OscillationFrequency;                                     // 0x0104(0x0004) (Edit)
	float                                              OscillationBaseScale;                                     // 0x0108(0x0004) (Edit)
	float                                              Theta;                                                    // 0x010C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_OscillateBoneScale");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_OscillateRotation
// 0x0024 (0x0124 - 0x0100)
class UTgSkelCon_OscillateRotation : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                                     // 0x0100(0x0004) (Edit)
	float                                              OscillationFrequency;                                     // 0x0104(0x0004) (Edit)
	struct FVector                                     OscillationAxis;                                          // 0x0108(0x000C) (Edit)
	TEnumAsByte<EBoneControlSpace>                     OscillationAxisSpace;                                     // 0x0114(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0115(0x0003) MISSED OFFSET
	struct FName                                       OscillationAxisSpaceBoneName;                             // 0x0118(0x0008) (Edit)
	float                                              Theta;                                                    // 0x0120(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_OscillateRotation");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_OscillateTranslation
// 0x0024 (0x0124 - 0x0100)
class UTgSkelCon_OscillateTranslation : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                                     // 0x0100(0x0004) (Edit)
	float                                              OscillationFrequency;                                     // 0x0104(0x0004) (Edit)
	struct FVector                                     OscillationAxis;                                          // 0x0108(0x000C) (Edit)
	TEnumAsByte<EBoneControlSpace>                     OscillationAxisSpace;                                     // 0x0114(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0115(0x0003) MISSED OFFSET
	struct FName                                       OscillationAxisSpaceBoneName;                             // 0x0118(0x0008) (Edit)
	float                                              Theta;                                                    // 0x0120(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_OscillateTranslation");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_PropertyGate
// 0x006C (0x013C - 0x00D0)
class UTgSkelCon_PropertyGate : public USkelControlBase
{
public:
	struct FSkelControlPropertyGateConfig              m_PropertyGateConfig;                                     // 0x00D0(0x002C)
	struct FSkelControlPropertyGateChild               DefaultChild;                                             // 0x00FC(0x001C)
	TArray<struct FSkelControlPropertyGateChild>       ChildControls;                                            // 0x0118(0x0010) (Edit, NeedCtorLink)
	struct FName                                       PropertyName;                                             // 0x0128(0x0008) (Edit)
	unsigned long                                      bNormalizeFloats : 1;                                     // 0x0130(0x0004) (Edit)
	float                                              fFloatPropMin;                                            // 0x0134(0x0004) (Edit)
	float                                              fFloatPropMax;                                            // 0x0138(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_PropertyGate");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_SkinGate
// 0x0024 (0x00F4 - 0x00D0)
class UTgSkelCon_SkinGate : public USkelControlBase
{
public:
	struct FSkelControlSkinGateChild                   DefaultChild;                                             // 0x00D0(0x0014)
	TArray<struct FSkelControlSkinGateChild>           ChildControls;                                            // 0x00E4(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_SkinGate");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Spinner
// 0x000C (0x010C - 0x0100)
class UTgSkelCon_Spinner : public USkelControlSingleBone
{
public:
	TEnumAsByte<EAxis>                                 RotationAxis;                                             // 0x0100(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0101(0x0003) MISSED OFFSET
	float                                              RotationsPerSecond;                                       // 0x0104(0x0004) (Edit)
	int                                                DeltaRotation;                                            // 0x0108(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Spinner");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Spinner_Skinned
// 0x0018 (0x0124 - 0x010C)
class UTgSkelCon_Spinner_Skinned : public UTgSkelCon_Spinner
{
public:
	TArray<struct FSkinnedSpinData>                    m_SkinOverrides;                                          // 0x010C(0x0010) (Edit, NeedCtorLink)
	float                                              fEditorRotationsPerSecond;                                // 0x011C(0x0004) (Edit)
	unsigned long                                      m_bInitializedSpin : 1;                                   // 0x0120(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Spinner_Skinned");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_Spring
// 0x0030 (0x019C - 0x016C)
class UTgSkelCon_Spring : public USkelControlLookAt
{
public:
	struct FVector                                     m_vWorldSpaceGoal;                                        // 0x016C(0x000C)
	struct FVector                                     m_vInitialWorldSpaceGoalOffset;                           // 0x0178(0x000C) (Edit)
	struct FVector                                     m_vVelocity;                                              // 0x0184(0x000C)
	float                                              m_fSpringStiffness;                                       // 0x0190(0x0004) (Edit)
	float                                              m_fSpringDamping;                                         // 0x0194(0x0004) (Edit)
	unsigned long                                      m_bApplySpring : 1;                                       // 0x0198(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Spring");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone
// 0x0068 (0x0168 - 0x0100)
class UTgSkelControlSingleBone : public USkelControlSingleBone
{
public:
	TArray<TEnumAsByte<EEmote>>                        StrengthEmoteList;                                        // 0x0100(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               FullBodyAnimNameList;                                     // 0x0110(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTgSkelControlSingleBoneSkinControls> OverrideSkinSkelControls;                                 // 0x0120(0x0010) (Edit, NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            CachedEmoteSequences;                                     // 0x0130(0x0010) (Transient, NeedCtorLink)
	TArray<class UAnimNode*>                           CachedNodes;                                              // 0x0140(0x0010) (Transient, NeedCtorLink)
	TArray<TEnumAsByte<EEmote>>                        TestingStrengthEmoteList;                                 // 0x0150(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      m_bUseIndependentBlendTime : 1;                           // 0x0160(0x0004) (Edit)
	unsigned long                                      m_bIsBlendingIn : 1;                                      // 0x0160(0x0004) (Const, Transient)
	float                                              m_fPreviousAnimNodeStrength;                              // 0x0164(0x0004) (Const, Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_ScaleByTranslation
// 0x0010 (0x0178 - 0x0168)
class UTgSkelCon_ScaleByTranslation : public UTgSkelControlSingleBone
{
public:
	TEnumAsByte<ESkelControlAxis>                      m_ControlAxis;                                            // 0x0168(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0169(0x0003) MISSED OFFSET
	struct FName                                       m_TranslationBoneName;                                    // 0x016C(0x0008) (Edit)
	float                                              m_fNormalizationValue;                                    // 0x0174(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_ScaleByTranslation");
		return ptr;
	}


	float GetSpecialControlStrength(class USkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgSkelCon_ScalarParamByTranslation
// 0x002C (0x01A4 - 0x0178)
class UTgSkelCon_ScalarParamByTranslation : public UTgSkelCon_ScaleByTranslation
{
public:
	float                                              ParameterStart;                                           // 0x0178(0x0004) (Edit)
	float                                              ParameterMax;                                             // 0x017C(0x0004) (Edit)
	int                                                m_nInterpLockout;                                         // 0x0180(0x0004) (Edit)
	int                                                m_nTicksSinceChange;                                      // 0x0184(0x0004)
	struct FName                                       m_RootBoneName;                                           // 0x0188(0x0008) (Edit)
	TEnumAsByte<ETranslationRoundingType>              m_RoundingType;                                           // 0x0190(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0191(0x0003) MISSED OFFSET
	TArray<struct FTranslationScalarMICParamInfo>      ScalarMICParamInfos;                                      // 0x0194(0x0010) (Edit, ExportObject, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_ScalarParamByTranslation");
		return ptr;
	}


	float GetSpecialControlStrength(class USkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgSkelCon_SingleBone_LobbyMeshState
// 0x0008 (0x0170 - 0x0168)
class UTgSkelCon_SingleBone_LobbyMeshState : public UTgSkelControlSingleBone
{
public:
	int                                                c_nActiveMeshState;                                       // 0x0168(0x0004) (Edit)
	unsigned long                                      c_bIsActive : 1;                                          // 0x016C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_SingleBone_LobbyMeshState");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_WithMesh
// 0x0010 (0x0178 - 0x0168)
class UTgSkelCon_WithMesh : public UTgSkelControlSingleBone
{
public:
	TArray<struct FWithMeshInfo>                       MeshInfos;                                                // 0x0168(0x0010) (Edit, ExportObject, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_WithMesh");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone_DisplayGroup
// 0x0010 (0x0178 - 0x0168)
class UTgSkelControlSingleBone_DisplayGroup : public UTgSkelControlSingleBone
{
public:
	TArray<struct FDisplayGroupInfo>                   DisplayGroupInfos;                                        // 0x0168(0x0010) (Edit, ExportObject, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_DisplayGroup");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone_ScalarMICParam
// 0x0010 (0x0178 - 0x0168)
class UTgSkelControlSingleBone_ScalarMICParam : public UTgSkelControlSingleBone
{
public:
	TArray<struct FScalarMICParamInfo>                 ScalarMICParamInfos;                                      // 0x0168(0x0010) (Edit, ExportObject, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_ScalarMICParam");
		return ptr;
	}

};


// Class TgGame.TgSkelControlSingleBone_Skinned
// 0x001C (0x0184 - 0x0168)
class UTgSkelControlSingleBone_Skinned : public UTgSkelControlSingleBone
{
public:
	float                                              DefaultStrength;                                          // 0x0168(0x0004) (Edit)
	TArray<struct FSkinStrengthOverride>               SkinOverrides;                                            // 0x016C(0x0010) (Edit, ExportObject, NeedCtorLink, EditInline)
	unsigned long                                      bInitializedStrength : 1;                                 // 0x017C(0x0004)
	float                                              fSkinStrength;                                            // 0x0180(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelControlSingleBone_Skinned");
		return ptr;
	}

};


// Class TgGame.TgCharmComponent
// 0x0053 (0x00D8 - 0x0085)
class UTgCharmComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	class UTgDeviceFire*                               m_DeviceModeMelee;                                        // 0x0088(0x0008)
	class UTgDeviceFire*                               m_DeviceModeProjectile;                                   // 0x0090(0x0008)
	class ATgPawn*                                     m_Instigator;                                             // 0x0098(0x0008)
	class ATgPawn*                                     m_pawnOwner;                                              // 0x00A0(0x0008)
	class ATgDevice*                                   m_SimulatedDevice;                                        // 0x00A8(0x0008)
	float                                              m_fAttackSpeed;                                           // 0x00B0(0x0004)
	TArray<struct FFireChainInfo>                      m_CachedFireChainInfos;                                   // 0x00B4(0x0010) (NeedCtorLink)
	TEnumAsByte<EFiringState>                          m_eCurrentFiringState;                                    // 0x00C4(0x0001)
	unsigned char                                      UnknownData01[0x3];                                       // 0x00C5(0x0003) MISSED OFFSET
	int                                                m_nCurrentFiringChain;                                    // 0x00C8(0x0004)
	float                                              m_fFiringTimer;                                           // 0x00CC(0x0004)
	float                                              m_fMinimumPreFire;                                        // 0x00D0(0x0004) (Const)
	float                                              m_fMinimumPostFire;                                       // 0x00D4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCharmComponent");
		return ptr;
	}

};


// Class TgGame.TgDevice
// 0x0214 (0x04F0 - 0x02DC)
class ATgDevice : public AWeapon
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterface;                                 // 0x02DC(0x0008) (Const, Native, NoExport)
	int                                                r_nDeviceId;                                              // 0x02E4(0x0004) (Net)
	int                                                r_nDeviceInstanceId;                                      // 0x02E8(0x0004) (Net)
	int                                                r_nInstanceCount;                                         // 0x02EC(0x0004) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eEquippedAt;                                            // 0x02F0(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eDisplayedAt;                                           // 0x02F1(0x0001) (Net)
	unsigned char                                      CurrentFireMode;                                          // 0x02F2(0x0001) (Net)
	unsigned char                                      m_PendingFireMode;                                        // 0x02F3(0x0001)
	TEnumAsByte<ETargetingModeStatus>                  c_eTargetingModeStatus;                                   // 0x02F4(0x0001)
	TEnumAsByte<EDeviceFailType>                       m_eCachedDeviceFailType;                                  // 0x02F5(0x0001)
	unsigned char                                      s_nCurrentFiringInstance;                                 // 0x02F6(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x02F7(0x0001) MISSED OFFSET
	unsigned long                                      c_bUsingServerEquippedAt : 1;                             // 0x02F8(0x0004)
	unsigned long                                      c_bDeviceInstanceIdReplicated : 1;                        // 0x02F8(0x0004)
	unsigned long                                      c_bEquippedAtReplicated : 1;                              // 0x02F8(0x0004)
	unsigned long                                      m_bIsTrained : 1;                                         // 0x02F8(0x0004)
	unsigned long                                      m_bSocketMaxCalculated : 1;                               // 0x02F8(0x0004)
	unsigned long                                      m_bReplicateParentDevice : 1;                             // 0x02F8(0x0004) (Const)
	unsigned long                                      r_bParentDeviceOwnedByOffhand : 1;                        // 0x02F8(0x0004) (Net)
	unsigned long                                      m_bIgnoreParentDeviceId : 1;                              // 0x02F8(0x0004)
	unsigned long                                      bPendingFire : 1;                                         // 0x02F8(0x0004)
	unsigned long                                      m_IsPendingSetFireMode : 1;                               // 0x02F8(0x0004)
	unsigned long                                      m_bEquipEffectsApplied : 1;                               // 0x02F8(0x0004)
	unsigned long                                      r_OverrideUsesTargetingModeAsFalse : 1;                   // 0x02F8(0x0004) (Net)
	unsigned long                                      m_bUsesCustomUpdateTargetingModeLocation : 1;             // 0x02F8(0x0004)
	unsigned long                                      m_bOverrideIsToggledAsTrue : 1;                           // 0x02F8(0x0004)
	unsigned long                                      s_bIgnoreReceivedAim : 1;                                 // 0x02F8(0x0004)
	unsigned long                                      m_bAlignEndTraceWithCamera : 1;                           // 0x02F8(0x0004) (Const)
	unsigned long                                      m_bHandDevice : 1;                                        // 0x02F8(0x0004)
	unsigned long                                      m_bLockInputDuringFire : 1;                               // 0x02F8(0x0004)
	unsigned long                                      m_bLockCameraDuringFire : 1;                              // 0x02F8(0x0004)
	unsigned long                                      m_bShouldCacheAim : 1;                                    // 0x02F8(0x0004)
	unsigned long                                      m_bEffectsOnlyInHand : 1;                                 // 0x02F8(0x0004)
	unsigned long                                      r_bConsumedOnUse : 1;                                     // 0x02F8(0x0004) (Net)
	unsigned long                                      r_bConsumedOnDeath : 1;                                   // 0x02F8(0x0004) (Net)
	unsigned long                                      m_bConsumableContainer : 1;                               // 0x02F8(0x0004)
	unsigned long                                      c_bCustomLeftClickBehavior : 1;                           // 0x02F8(0x0004)
	unsigned long                                      c_bCustomLeftClickBehaviorLoaded : 1;                     // 0x02F8(0x0004)
	unsigned long                                      m_bSimulateStartFire : 1;                                 // 0x02F8(0x0004)
	unsigned long                                      m_bDeviceProcsItem : 1;                                   // 0x02F8(0x0004)
	unsigned long                                      m_bDeviceProcsMinionReactions : 1;                        // 0x02F8(0x0004)
	unsigned long                                      m_bUsesParentFiringInstance : 1;                          // 0x02F8(0x0004)
	unsigned long                                      m_bUsesIncrementalFiringInstance : 1;                     // 0x02F8(0x0004)
	unsigned long                                      m_bEnablesCrit : 1;                                       // 0x02F8(0x0004)
	unsigned long                                      m_bInterruptOnMove : 1;                                   // 0x02FC(0x0004)
	unsigned long                                      m_bCachedDeviceCanFire : 1;                               // 0x02FC(0x0004)
	unsigned long                                      m_bConsumePowerPoolOnStartFire : 1;                       // 0x02FC(0x0004)
	unsigned long                                      m_bAlwaysStartCooldown : 1;                               // 0x02FC(0x0004)
	unsigned long                                      s_bIsInTimerSync : 1;                                     // 0x02FC(0x0004)
	unsigned long                                      m_bInTargetingMode : 1;                                   // 0x02FC(0x0004)
	unsigned long                                      m_IsBeingInterrupted : 1;                                 // 0x02FC(0x0004)
	unsigned long                                      HasAlreadyFiredOnce : 1;                                  // 0x02FC(0x0004)
	unsigned long                                      m_bApplyPostHitDelayCorrection : 1;                       // 0x02FC(0x0004)
	unsigned long                                      m_bTiDiAffectsCooldownTimers : 1;                         // 0x02FC(0x0004)
	unsigned long                                      r_bDeviceUnavailable : 1;                                 // 0x02FC(0x0004) (Net)
	unsigned long                                      m_bFireInstanceLocksProcs : 1;                            // 0x02FC(0x0004)
	unsigned long                                      m_bForceEnableDebugLog : 1;                               // 0x02FC(0x0004)
	unsigned long                                      m_bForceEnableDebugDraw : 1;                              // 0x02FC(0x0004)
	unsigned long                                      m_bDamages : 1;                                           // 0x02FC(0x0004)
	unsigned long                                      m_bStuns : 1;                                             // 0x02FC(0x0004)
	unsigned long                                      m_bSlows : 1;                                             // 0x02FC(0x0004)
	int                                                r_nPointsAllocated;                                       // 0x0300(0x0004) (Net)
	int                                                m_nSocketIndex;                                           // 0x0304(0x0004)
	int                                                m_nSocketMax;                                             // 0x0308(0x0004)
	class ATgDevice*                                   r_ParentDevice;                                           // 0x030C(0x0008) (Net)
	class ATgDevice*                                   r_deviceSubs[0x8];                                        // 0x0314(0x0008) (Net)
	TArray<class UTgDeviceFire*>                       m_FireMode;                                               // 0x0354(0x0010) (NeedCtorLink)
	int                                                r_nMeleeComboSeed;                                        // 0x0364(0x0004) (Net)
	class UTgDeviceForm*                               c_DeviceForm;                                             // 0x0368(0x0008)
	class UTgTimerManager*                             m_CooldownTimers;                                         // 0x0370(0x0008)
	TArray<struct FImpactInfo>                         PendingImpactList;                                        // 0x0378(0x0010) (Component, NeedCtorLink)
	struct FAimData                                    c_TargetingAim;                                           // 0x0388(0x0030)
	struct FAimData                                    m_CachedAim;                                              // 0x03B8(0x0030)
	float                                              m_fCachedFirePostHitDelay;                                // 0x03E8(0x0004)
	struct FAimData                                    s_ReceivedAim;                                            // 0x03EC(0x0030)
	int                                                m_nCalcGroundTargetPlaceFlags;                            // 0x041C(0x0004) (Const)
	float                                              s_fRangeTolerance;                                        // 0x0420(0x0004) (Const)
	struct FPointer                                    m_pwzDeviceName;                                          // 0x0424(0x0008) (Native)
	int                                                m_nDeviceType;                                            // 0x042C(0x0004)
	float                                              EquipTime;                                                // 0x0430(0x0004)
	float                                              PutDownTime;                                              // 0x0434(0x0004)
	float                                              WeaponRange;                                              // 0x0438(0x0004)
	class UTgInventoryObject_Device*                   s_InventoryObject;                                        // 0x043C(0x0008)
	int                                                m_nSkillId;                                               // 0x0444(0x0004)
	int                                                m_nContainerRefill;                                       // 0x0448(0x0004)
	int                                                m_nRightClickBehaviorType;                                // 0x044C(0x0004)
	int                                                r_nInventoryId;                                           // 0x0450(0x0004) (Net)
	int                                                m_nRequiredLevel;                                         // 0x0454(0x0004)
	int                                                m_nItemStoreType;                                         // 0x0458(0x0004)
	float                                              m_fLastDeviceCanFireTimeStamp;                            // 0x045C(0x0004)
	struct FVector                                     m_vCachedWeaponStartTraceLocation;                        // 0x0460(0x000C)
	float                                              m_fLastWeaponTraceLocTimeStamp;                           // 0x046C(0x0004)
	float                                              m_fClientBuildUpTime;                                     // 0x0470(0x0004)
	float                                              m_EndOfLastFireTimeStamp;                                 // 0x0474(0x0004)
	float                                              m_fFiringTimer;                                           // 0x0478(0x0004)
	float                                              m_IndividualOffhandCooldownTime;                          // 0x047C(0x0004)
	float                                              m_IndividualInhandCooldownTime;                           // 0x0480(0x0004)
	float                                              c_fCachedPowerPoolAtStartFire;                            // 0x0484(0x0004)
	float                                              c_fCachedHealthPoolAtStartFire;                           // 0x0488(0x0004)
	float                                              c_fCachedManaPoolAtStartFire;                             // 0x048C(0x0004)
	float                                              c_fCachedEnergyPoolAtStartFire;                           // 0x0490(0x0004)
	class UTgDeviceFire*                               s_WhileFiringDeviceMode;                                  // 0x0494(0x0008)
	class UTgTiDiState*                                s_CurrentTiDi;                                            // 0x049C(0x0008)
	float                                              r_fTotalTiDi;                                             // 0x04A4(0x0004) (Net)
	struct FVector                                     m_vDeviceSpecificOffset;                                  // 0x04A8(0x000C)
	int                                                r_nDisplayIconOverride;                                   // 0x04B4(0x0004) (Net)
	TArray<struct FRollingLineAttack>                  m_RollingLineAttacks;                                     // 0x04B8(0x0010) (NeedCtorLink)
	struct FName                                       m_nmDeviceBuildupName;                                    // 0x04C8(0x0008) (Const)
	struct FName                                       m_nmDeviceFiringName;                                     // 0x04D0(0x0008) (Const)
	struct FName                                       m_nmFirePreHitDelay;                                      // 0x04D8(0x0008) (Const)
	struct FName                                       m_nmFirePostHitDelay;                                     // 0x04E0(0x0008) (Const)
	struct FName                                       m_nmActive;                                               // 0x04E8(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice");
		return ptr;
	}


	bool STATIC_CanAIRefire();
	bool UsesControllerRotation();
	bool GetGroundTargetOffset(float* FMin, float* FMax);
	bool ShouldClampGroundTarget();
	void STATIC_StopFiringLogic();
	void ClientReconnected();
	struct FVector STATIC_GetSpecificOffset();
	bool STATIC_HasSpecificOffset();
	bool HasRemoteOwner();
	bool IsToggleDevice();
	bool ApplyGlobalOffhandCooldown();
	struct FVector STATIC_GetStartTraceLocation();
	void STATIC_CacheStartTraceLocation(const struct FVector& vLoc);
	void Destroyed();
	void UpdateIndex();
	void STATIC_StartFiringLogic();
	bool IsEnteringFiringState(const struct FName& NextStateName);
	void STATIC_DeviceBuildupTimer();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void STATIC_HandleDeviceFormBuildup(int nDeviceModeNum, float fBuildupTime);
	bool STATIC_ShouldRefire(class UTgDeviceFire* FireMode, struct FAimData* Aim);
	void STATIC_EndFireLoop();
	void STATIC_RestartFireLoop(bool bRefire);
	void FirePostHitDelay();
	void FirePreHitDelay();
	void STATIC_RefireCheckTimer();
	void STATIC_PauseFiringInHandWeapon();
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	void STATIC_OnTeleportToBaseNotify(class AActor* TeleportingActor);
	void NotifySwitchMode();
	void NotifyPutAway();
	void ClientEndCooldown();
	void ClientResetCooldown(int nMode, float fCooldownTime);
	void ClientStartCooldown(int nMode, float fCooldownTime);
	void EndCooldown();
	void ResetCooldown(int nMode, float fCooldownTimeOverride);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void STATIC_ClientCooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void STATIC_CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	float GetCooldownRemaining();
	void STATIC_FireAmmunition();
	void TrackDeviceModeFired(class ATgPawn* PawnFiring);
	class AActor* STATIC_GetTrackingTarget(int nFireIndex);
	bool UsesTrackingTarget();
	struct FVector STATIC_GetPhysicalFireStartLoc(const struct FVector& AimDir);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void OnTeleportFireFailed();
	void STATIC_CustomFire();
	void AOEArcingFlash(TArray<struct FImpactInfo> ImpactList, const struct FVector& StartLocation);
	void ArcingFire();
	void RollingInstantFire(int Index);
	void InitiateRollingInstantFire();
	void InstantFire();
	void MeleeFire();
	class ATgPawn* AcquireMeleeTarget(int* bExactTarget);
	float LinePointDist(const struct FVector& A, const struct FVector& B, const struct FVector& Pt);
	bool ShouldApplyHitSpecial();
	void DeliverQueuedPendingHits();
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_ServerForceStopFire();
	void ForceStopFire();
	void STATIC_ServerStopFire();
	void ServerStopFireAsEvent();
	void StopFireAsEvent();
	void StopFire();
	void STATIC_ServerStartFire(const struct FAimData& ClientAim, float EndTraceX, float EndTraceY, int nCompressedRot);
	void ServerStartFireAsEvent();
	void STATIC_FireLockComplete();
	void STATIC_GlobalOffhandCooldownCompleteClient();
	void STATIC_GlobalOffhandCooldownCompleteServer();
	void STATIC_SetFireLock();
	bool StartFire();
	bool STATIC_ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
	bool AllowFireFromStunTaunt(class ATgPawn* P);
	bool SimulateStartFire();
	bool Use();
	bool STATIC_CheckCustomStartFire();
	bool NeedCustomLeftClickBehavior();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_CacheDeviceCanFire(bool bDeviceCanFire, TEnumAsByte<EDeviceFailType> failType);
	bool CanFireWhileDead();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool IsInterruptRecallException();
	void InterruptRecall();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool IsGreaterAegisAmulet();
	bool IsPurificationBeads();
	bool IsAegisAmulet();
	float STATIC_GetLockoutExtensionTime();
	float AmountCurrentlyOffOfTargetAccuracy(unsigned char FireModeNum);
	bool STATIC_CanFireWhileTargetingWhenOffhandPressed();
	bool STATIC_CanFireWhileFalling();
	bool STATIC_CanFireWhileHanging();
	bool STATIC_CanFireWhileDoingRoutineTasks(int FireModeNum);
	void TriggerRefill();
	void OnPurchased();
	void ConsumeDevice();
	bool UsesEnergy();
	bool UsesMana();
	bool UsesHealth();
	float GetEnergyCost(unsigned char FireModeNum);
	float GetManaCost(unsigned char FireModeNum);
	float GetHealthCost(unsigned char FireModeNum);
	float GetDeviceSpecificPowerPoolToConsume(int nPacingType);
	float GetDevicePowerPoolToConsume();
	void DeviceConsumeSpecificPowerPool(unsigned char FireModeNum, int nPacingType);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void STATIC_PlayClientOffhandFx(const struct FAimData& Aim, int nSocketIndex);
	void STATIC_PlayClientFireFx(const struct FVector& HitLocation, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	bool ShouldCancelStealth();
	void STATIC_HandleFiringRejection();
	void STATIC_ClientInterrupt();
	void InterruptFiring();
	void STATIC_DeviceRestart();
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_ServerDoRemoteDetonation(int nFireMode);
	void SetActiveState();
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	struct FRotator AddSpread(const struct FRotator& BaseAim, float fAccuracy);
	bool STATIC_CanFireIfLeftMouseDown();
	bool ShouldInterruptInhand();
	bool CanBeInterrupted();
	bool CancelledByJumping();
	bool CanJumpWhileFiring();
	bool CanBeFiredWhileTweening();
	bool CanBeCanceledByRightMouse();
	bool CanBeCanceled();
	float STATIC_GetEffectiveRange();
	float STATIC_GetRange();
	bool IsActiveWhilefiring();
	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
	bool ShouldTriggerCastReactionItems();
	void WeaponEquipped();
	bool IsEquipping();
	bool STATIC_NativeIsFiring();
	void ForceCooldownIfFiring();
	int STATIC_GetRestrictType();
	void STATIC_DisplayMessage(const struct FString& sMessage);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void WeaponLog(const struct FString& msg, const struct FString& FuncStr);
	void ReplicatedEvent(const struct FName& VarName);
	int STATIC_GetCurrentDeviceType();
	bool ApplySpecialTargetingModeStatus();
	void ApplyTiDiToTimers();
	void STATIC_ShutdownTiDi();
	void TransmitTiDiClient();
	void TransmitTiDiServer();
	void ApplyTiDi();
	bool STATIC_ShouldUpdateTiDi();
	class UTgTiDiState* STATIC_GetCurrentTiDi();
	void STATIC_InitializeTiDi();
	bool STATIC_ShouldUpdateTimer();
	void UpdateDisplayData();
	bool TweenKnockbackTargetToLocation(TEnumAsByte<ETweenState> ETweenState, float fSpeed, struct FImpactInfo* Impact, struct FVector* vLoc);
	bool TweenKnockbackTarget(TEnumAsByte<ETweenState> ETweenState, float fRange, float fSpeed, struct FImpactInfo* Impact);
	void STATIC_GameOnPrematchStop();
	void STATIC_GameOnPrematchStart();
	float AssistInputs(float* fTurn, float* fLookUp);
	struct FVector STATIC_GetTargetPredictedLocation(class ATgPawn* Target);
	float STATIC_GetAssistRange();
	float STATIC_GetAssistRadius(bool bTargetSelection);
	float STATIC_GetVariablePreHitTime(class ATgPawn* Target);
	float STATIC_GetFixedPreHitTime();
	bool AssistsLookUp();
	class ATgPawn* STATIC_GetBestAimAssistTarget(float fTurn, float fLookUp);
	void STATIC_OnUnequipAsEffectListener();
	void STATIC_OnEquipAsEffectListener();
	unsigned char STATIC_GetCurrentFiringInstance();
	unsigned char STATIC_IncrementFiringInstance();
	void STATIC_ConfigureFireMode(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_ShouldRevealFromStealth();
	void STATIC_SetInstanceCount(int nInstanceCount);
	void STATIC_SetPointsAllocated(int nPoints);
	void STATIC_ClientPtsAllocatedUpdated();
	bool STATIC_HasBeenTrained();
	bool AllocateDevicePoint();
	int STATIC_GetAllocatedDevicePoints(bool bForceBasePoints);
	int STATIC_GetTotalDevicePoints();
	void ExitTargetingMode();
	void EnterTargetingMode();
	bool IsInTargetingMode();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	struct FVector AdjustAIGroundTargetLead(class ATgPawn* TargetPawn);
	void UpdateAimWhileFiring(struct FAimData* Aim);
	bool STATIC_CanLockOnToTarget(class AActor* Target);
	struct FVector STATIC_GetRadialLocationLocal(const struct FVector& CenterLocation, const struct FVector& AimDirection, float fRadius, float fAngle, bool bIsRadians);
	void STATIC_GetPawnSelectTargetAim(struct FAimData* Aim);
	void STATIC_GetWorldMapLockOnTargetAim(struct FAimData* Aim);
	void STATIC_GetWorldMapTargetAim(struct FAimData* Aim);
	void STATIC_GetSpawnPointTargetAim(struct FAimData* Aim);
	void STATIC_GetLockOnTargetAim(struct FAimData* Aim);
	void STATIC_GetDeployAim(struct FAimData* Aim);
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
	void STATIC_GetSelfTargetAim(struct FAimData* Aim);
	void STATIC_GetAOETargetAim(struct FAimData* Aim);
	void STATIC_GetConeTargetAim(struct FAimData* Aim);
	void STATIC_GetMeleeTargetAim(struct FAimData* Aim);
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	TEnumAsByte<ETargetingModeStatus> STATIC_GetCannotFireTargetingStatus();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	struct FAimData STATIC_CacheAim();
	void STATIC_GetCachedAim(struct FAimData* Aim);
	bool UsesCachedAim();
	bool STATIC_ForceDefaultCastMode();
	bool UsesTargetingMode();
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	float STATIC_GetTotalTimeRemaining();
	float STATIC_GetCachedFiringPostHitDelay();
	float STATIC_CacheFiringPostHitDelay();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetRefireTime(int nMode);
	float GetBuildupTime(int nMode);
	void STATIC_GetCombatLogEventLocation(int* LocationX, int* LocationY);
	void STATIC_SendCombatLogEvent(TEnumAsByte<EITEM_EVENT_TYPE> Type);
	void STATIC_SendDeviceChangeEvent(TEnumAsByte<EDeviceChangeEvent> Event);
	bool IsToggledOn();
	bool IsLockedDown();
	bool IsSilenced();
	bool STATIC_ShowUICanFire();
	void STATIC_CheckAndUpdateCooldown();
	class UTgTimerManager* STATIC_GetCooldownTimerManager();
	bool IsDeviceRefiring();
	bool IsInCooldownGracePeriod();
	bool IsDeviceCoolingDown();
	bool STATIC_HasEnoughSpecificPowerPool(unsigned char FireModeNum, int nPacingType);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool STATIC_CanCrit();
	bool IsDeviceLimited();
	bool IsTutorialFiringDisabled();
	float STATIC_GetConePullbackDistance();
	bool AllowFireFromGrab(class ATgPawn* P);
	bool STATIC_CanBeGrabbed();
	bool STATIC_CanBeCrippled();
	bool STATIC_CanBeDisarmed();
	bool STATIC_CanBeSilenced();
	bool STATIC_CanBeStunned();
	bool IsPurchasedAbility();
	int STATIC_GetTopMostDeviceId();
	class ATgDevice* STATIC_GetTopMostDevice();
	bool IsUltimateDevice();
	bool IsOwnedByDevice(int nDeviceId);
	bool IsOwnedByOffhand();
	bool IsInhand();
	bool IsOffhand();
	bool IsMeleeAttack();
	bool IsRangedAttack();
	int STATIC_GetModeRange(int nMode);
	bool STATIC_CheckModeRange(int nMode, const struct FVector& vDelta);
	void RemoveEquipEffects();
	void ApplyEquipEffects();
	bool STATIC_ShouldApplyModeEquipEffects();
	class UTgDeviceFire* STATIC_GetDeviceFire(int nMode);
	class UTgDeviceFire* STATIC_GetCurrentFire();
	void UpdateManaUseVitals(class ATgPlayerController* PC);
	void STATIC_CustomUpdateTargetingModeLocation();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_ClearInstigatorEquippedDevices();
	void STATIC_PopulateInstigatorEquippedDevices();
	bool NeedServerDetonate(int nFireMode);
	bool ServerDetonate(int nFireMode);
	bool STATIC_DrawDebugInfo();
	bool LogDebugInfo();
	void STATIC_RemoveConsumableFromOwnerInventory();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetDisplaySlot();
	struct FString STATIC_GetDeviceName();
	void STATIC_CalcFireSocketIndexMax();
	struct FName STATIC_GetFireSocketName();
	struct FName STATIC_QueryDeployableClass(int nMode);
	struct FName STATIC_QueryProjectileClass(int nMode);
	bool ApplyDeviceSetup();
};


// Class TgGame.TgDevice_Adv_Chest
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Adv_Chest : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Adv_Chest");
		return ptr;
	}

};


// Class TgGame.TgDevice_AegisAmulet
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_AegisAmulet : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AegisAmulet");
		return ptr;
	}


	bool IsAegisAmulet();
};


// Class TgGame.TgDevice_Apep_Strike
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Apep_Strike : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Apep_Strike");
		return ptr;
	}

};


// Class TgGame.TgDevice_ArcingBeam
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_ArcingBeam : public ATgDevice
{
public:
	TArray<struct FArcTargetSequence>                  s_ArcSequences;                                           // 0x04F0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ArcingBeam");
		return ptr;
	}


	void BeginArcing(class AActor* initialTarget, class UTgDeviceFire_ArcingBeam* FireMode);
	void STATIC_EndArcing(int nIndex);
	void TriggerArc(int nIndex);
	class AActor* STATIC_DetermineNextTarget(int nIndex);
};


// Class TgGame.TgDevice_ArthurianBase
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_ArthurianBase : public ATgDevice
{
public:
	class ATgPawn*                                     r_InstigatorPawn;                                         // 0x04F0(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ArthurianBase");
		return ptr;
	}


	void DeliverQueuedPendingHits();
	bool ApplyGlobalOffhandCooldown();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_Arondight
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Arondight : public ATgDevice_ArthurianBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Arondight");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	class ATgRepInfo_TaskForce* STATIC_GetEnemyTaskForce(int* nIndex);
};


// Class TgGame.TgDevice_Aura
// 0x0034 (0x0524 - 0x04F0)
class ATgDevice_Aura : public ATgDevice
{
public:
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x04F0(0x0008) (Transient)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x04F8(0x0010) (Transient, NeedCtorLink)
	TArray<class AActor*>                              s_DelayedAppliedList;                                     // 0x0508(0x0010) (Transient, NeedCtorLink)
	class AActor*                                      s_AppliedToBaseActor;                                     // 0x0518(0x0008) (Transient)
	unsigned long                                      s_bApplyToOwner : 1;                                      // 0x0520(0x0004) (Transient)
	unsigned long                                      m_bAuraBehavior : 1;                                      // 0x0520(0x0004) (Transient)
	unsigned long                                      m_bHardAttached : 1;                                      // 0x0520(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aura");
		return ptr;
	}


	void AuraRemoved(class AActor* Other);
	void AuraApplied(class AActor* Other);
	bool CanJumpWhileFiring();
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void Destroyed();
	void EndAura();
	void BeginAura();
	void RemoveFromAllHitAura();
	void ApplyToAllHitAura();
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ProxyUnTouch(class AActor* Other);
	void AttemptDelayedHitAura();
	void ApplyHitAura(class AActor* Other);
	bool STATIC_ShouldApplyAura();
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaTime);
	void UpdateCollisionProxyDelegates();
	bool IsAuraActive();
	void STATIC_ConfigureFireMode(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_ActiveAura
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_ActiveAura : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ActiveAura");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool IsAuraActive();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_ActiveAura_VisualToggle
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_ActiveAura_VisualToggle : public ATgDevice_ActiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ActiveAura_VisualToggle");
		return ptr;
	}

};


// Class TgGame.TgDevice_CH05_Surtr_FireSpin
// 0x0010 (0x0534 - 0x0524)
class ATgDevice_CH05_Surtr_FireSpin : public ATgDevice_ActiveAura
{
public:
	TArray<class AActor*>                              s_NewlyHitList;                                           // 0x0524(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_Surtr_FireSpin");
		return ptr;
	}


	void EndAura();
	void ApplyHitAura(class AActor* Other);
};


// Class TgGame.TgDevice_CH05_Surtr_FireSpinAndTrail
// 0x0030 (0x0564 - 0x0534)
class ATgDevice_CH05_Surtr_FireSpinAndTrail : public ATgDevice_CH05_Surtr_FireSpin
{
public:
	float                                              m_fDeployDelayTime;                                       // 0x0534(0x0004)
	TArray<class ATgDeployable*>                       s_Deployables;                                            // 0x0538(0x0010) (NeedCtorLink)
	TArray<struct FSurtrDeployTouchStatus>             m_DeployRegistration;                                     // 0x0548(0x0010) (NeedCtorLink)
	struct FVector                                     m_vLastDeployLocation;                                    // 0x0558(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_Surtr_FireSpinAndTrail");
		return ptr;
	}


	void Destroyed();
	void UnregisterDeployTouch(class AActor* Other);
	void RegisterDeployTouch(class AActor* Other);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_RepeatFire();
	void STATIC_FireAmmunition();
	bool STATIC_CanSpawnDeployable();
};


// Class TgGame.TgDevice_AuraToggle
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_AuraToggle : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AuraToggle");
		return ptr;
	}


	bool STATIC_ShouldInterruptReload();
	bool IsToggleDevice();
	bool StartFire();
	bool STATIC_CanDeviceFireInTargetingMode();
	bool IsAuraActive();
	bool IsToggledOn();
	void UpdateUIToggleState();
};


// Class TgGame.TgDevice_CooldownAura
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_CooldownAura : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CooldownAura");
		return ptr;
	}


	void STATIC_DeviceRestart();
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void STATIC_CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	bool IsAuraActive();
};


// Class TgGame.TgDevice_Kaldr_Dev4
// 0x0020 (0x0544 - 0x0524)
class ATgDevice_Kaldr_Dev4 : public ATgDevice_Aura
{
public:
	class ATgPawn_Kaldr*                               m_Kaldr;                                                  // 0x0524(0x0008) (Const)
	struct FVector                                     m_vUltAimEndTrace;                                        // 0x052C(0x000C)
	float                                              m_fLeapTime;                                              // 0x0538(0x0004) (Const)
	float                                              m_fForcedTPDistance;                                      // 0x053C(0x0004) (Const)
	float                                              m_fNoPrefireDistance;                                     // 0x0540(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kaldr_Dev4");
		return ptr;
	}


	void EndAura();
	void BeginAura();
	bool IsAuraActive();
	bool CanBeCanceled();
	bool CanBeInterrupted();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool CanBeFiredWhileTweening();
	bool ApplyGlobalOffhandCooldown();
	void STATIC_FireAmmunition();
	float STATIC_GetFiringPreHitDelay(int nMode);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_FindKaldrTarget();
	void STATIC_HandleLeapDecision();
};


// Class TgGame.TgDevice_PassiveAura
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_PassiveAura : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PassiveAura");
		return ptr;
	}


	void EndAura();
	void BeginAura();
	void STATIC_DeviceRestart();
	bool IsAuraActive();
	void RemoveEquipEffects();
	void ApplyEquipEffects();
};


// Class TgGame.TgDevice_AchieveOnNearbyDeath
// 0x0004 (0x0528 - 0x0524)
class ATgDevice_AchieveOnNearbyDeath : public ATgDevice_PassiveAura
{
public:
	unsigned long                                      s_bChecking : 1;                                          // 0x0524(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AchieveOnNearbyDeath");
		return ptr;
	}


	int STATIC_GetStacksFor(class ATgPawn* Other);
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_CheckAchieved();
};


// Class TgGame.TgDevice_Aura_PawnsInProximity
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_Aura_PawnsInProximity : public ATgDevice_PassiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aura_PawnsInProximity");
		return ptr;
	}


	void RemoveFromAllHitAura();
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
};


// Class TgGame.TgDevice_Aura_TopPawnInProximity_ScaleMagicalProtections
// 0x0018 (0x053C - 0x0524)
class ATgDevice_Aura_TopPawnInProximity_ScaleMagicalProtections : public ATgDevice_Aura_PawnsInProximity
{
public:
	float                                              m_fPctMagicalProtections;                                 // 0x0524(0x0004) (Const)
	float                                              m_fCurrentTopMagicalProtections;                          // 0x0528(0x0004)
	TArray<class AActor*>                              s_ProximityList;                                          // 0x052C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aura_TopPawnInProximity_ScaleMagicalProtections");
		return ptr;
	}


	void STATIC_ScaleAndApplyEffectGroup();
	float STATIC_GetTopMagicalProtections();
	void UpdateProtections();
	void RemoveFromAllHitAura();
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
	void Tick(float DeltaTime);
};


// Class TgGame.TgDevice_AuraOnNearPawn
// 0x0004 (0x0528 - 0x0524)
class ATgDevice_AuraOnNearPawn : public ATgDevice_PassiveAura
{
public:
	unsigned long                                      m_bAppliesToOwner : 1;                                    // 0x0524(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AuraOnNearPawn");
		return ptr;
	}


	void RemoveFromAllHitAura();
	void AuraRemoved(class AActor* Other);
	void AuraApplied(class AActor* Other);
};


// Class TgGame.TgDevice_CH05_KillOnTouch
// 0x0004 (0x0528 - 0x0524)
class ATgDevice_CH05_KillOnTouch : public ATgDevice_PassiveAura
{
public:
	unsigned long                                      s_bAlreadyHit : 1;                                        // 0x0524(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_KillOnTouch");
		return ptr;
	}


	void AuraApplied(class AActor* Other);
};


// Class TgGame.TgDevice_CH05_SeaweedBot_Nightmare
// 0x0008 (0x0530 - 0x0528)
class ATgDevice_CH05_SeaweedBot_Nightmare : public ATgDevice_CH05_KillOnTouch
{
public:
	class ATgPawn_CH05_Draugr_Nightmare*               m_Draugr;                                                 // 0x0528(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_SeaweedBot_Nightmare");
		return ptr;
	}


	void AuraApplied(class AActor* Other);
};


// Class TgGame.TgDevice_PassiveAura_EffectListener
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_PassiveAura_EffectListener : public ATgDevice_PassiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PassiveAura_EffectListener");
		return ptr;
	}


	bool STATIC_ShouldApplyAura();
	void STATIC_OnUnequipAsEffectListener();
	void STATIC_OnEquipAsEffectListener();
};


// Class TgGame.TgDevice_PassiveAura_WithConditionalEffect
// 0x0008 (0x052C - 0x0524)
class ATgDevice_PassiveAura_WithConditionalEffect : public ATgDevice_PassiveAura
{
public:
	unsigned long                                      s_ApplyBonusEffect : 1;                                   // 0x0524(0x0004)
	int                                                s_BonusEffectSituationalType;                             // 0x0528(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PassiveAura_WithConditionalEffect");
		return ptr;
	}


	void ToggleApplyBonusEffect(bool ApplyBonusEffect, int BonusEffectSituationalType);
	void AuraRemoved(class AActor* Other);
	void AuraApplied(class AActor* Other);
};


// Class TgGame.TgDevice_ProcOnNearbyDeath
// 0x0019 (0x053D - 0x0524)
class ATgDevice_ProcOnNearbyDeath : public ATgDevice_PassiveAura
{
public:
	class ATgCollisionProxy_PawnListener*              s_CollisionProxyListener;                                 // 0x0524(0x0008)
	TArray<int>                                        m_nBotRanks;                                              // 0x052C(0x0010) (Const, NeedCtorLink)
	TEnumAsByte<EProcOnNearbyDeathFaction>             m_eBotFaction;                                            // 0x053C(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ProcOnNearbyDeath");
		return ptr;
	}


	void Destroyed();
	void STATIC_CollisionProxyOnPawnDied(class ATgPawn* Other);
	void UpdateCollisionProxyDelegates();
	void ApplyHitAura(class AActor* Other);
	bool STATIC_DoesPawnDeathProc(class ATgPawn* OtherPawn);
};


// Class TgGame.TgDevice_SentinelsEmbrace
// 0x000C (0x0530 - 0x0524)
class ATgDevice_SentinelsEmbrace : public ATgDevice_PassiveAura
{
public:
	int                                                m_nProtAmount;                                            // 0x0524(0x0004)
	int                                                m_nSelfProtAmount;                                        // 0x0528(0x0004) (Const)
	int                                                m_nTotalProtAmount;                                       // 0x052C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SentinelsEmbrace");
		return ptr;
	}


	void EndAura();
	void BeginAura();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ApplyToNearbyAllies();
	void STATIC_RemoveOverlappingActorsEffect(TArray<struct FImpactInfo> impacts);
	void NotifyOtherAuraChanged();
	void STATIC_CalculateProtAmount();
	void STATIC_RemoveOldHit(class AActor* actorAlly);
	void STATIC_RemoveOldHits();
	void ApplyHits(TArray<struct FImpactInfo> impacts);
	void STATIC_FillOutApplyProcList(TArray<struct FImpactInfo>* impacts);
	bool STATIC_ShouldApplyEffectToActor(class AActor* actorOther);
	bool IsAllyGod(class AActor* actorOther);
	class UTgEffectGroup* STATIC_GetAppliedEffectGroup(class AActor* actorOther, bool bAnyOwner);
};


// Class TgGame.TgDevice_SentinelsGift
// 0x0018 (0x053C - 0x0524)
class ATgDevice_SentinelsGift : public ATgDevice_PassiveAura
{
public:
	float                                              r_fBonusDisableTime;                                      // 0x0524(0x0004) (Const, Net)
	TArray<class AActor*>                              m_actorNearbyAllies;                                      // 0x0528(0x0010) (NeedCtorLink)
	float                                              m_fTimeAwayFromAllyGods;                                  // 0x0538(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SentinelsGift");
		return ptr;
	}


	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool IsAllyGod(class AActor* actorOther);
};


// Class TgGame.TgDevice_Pyromancer_S8
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_Pyromancer_S8 : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pyromancer_S8");
		return ptr;
	}


	void STATIC_CustomFire();
	bool STATIC_CanBeSilenced();
};


// Class TgGame.TgDevice_Blink
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Blink : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Blink");
		return ptr;
	}


	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	void TimerDeviceAvailable();
	bool IsLockedDown();
	bool STATIC_ShowUICanFire();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_CH05_ToggleBot
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_CH05_ToggleBot : public ATgDevice
{
public:
	unsigned long                                      s_bToggledOn : 1;                                         // 0x04F0(0x0004)
	unsigned long                                      s_bShouldTurnOn : 1;                                      // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_ToggleBot");
		return ptr;
	}


	void STATIC_PerformToggle();
	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_CH05_Loki_Invisible_Nightmare
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_CH05_Loki_Invisible_Nightmare : public ATgDevice_CH05_ToggleBot
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_Loki_Invisible_Nightmare");
		return ptr;
	}


	void STATIC_PerformToggle();
};


// Class TgGame.TgDevice_CH05_WaterGun
// 0x0020 (0x0510 - 0x04F0)
class ATgDevice_CH05_WaterGun : public ATgDevice
{
public:
	class AActor*                                      m_InitialTarget;                                          // 0x04F0(0x0008)
	float                                              m_fCachedPostHitDelayWithError;                           // 0x04F8(0x0004)
	struct FVector                                     m_fCachedJetStartDirection;                               // 0x04FC(0x000C)
	float                                              m_fRotationAngle;                                         // 0x0508(0x0004)
	int                                                m_nRotationDirection;                                     // 0x050C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_WaterGun");
		return ptr;
	}


	void STATIC_FindRotationDirection();
	void STATIC_EndWaterJet();
	void STATIC_SpecialFireLoop();
	void UpdateJetRotation();
	float STATIC_GetFiringPostHitDelay(int nMode);
};


// Class TgGame.TgDevice_ChainedMelee
// 0x0048 (0x0538 - 0x04F0)
class ATgDevice_ChainedMelee : public ATgDevice
{
public:
	int                                                m_nAttackCounter;                                         // 0x04F0(0x0004)
	TArray<struct FAttackModeInfo>                     c_AttackHistory;                                          // 0x04F4(0x0010) (NeedCtorLink)
	TArray<struct FAttackModeInfo>                     c_AttackFuture;                                           // 0x0504(0x0010) (NeedCtorLink)
	int                                                m_nMaxNumFireModes;                                       // 0x0514(0x0004)
	int                                                m_nNextChainedFireMode;                                   // 0x0518(0x0004)
	int                                                m_nSelectedFireMode;                                      // 0x051C(0x0004)
	float                                              m_fAttackPercentRemaining;                                // 0x0520(0x0004)
	float                                              m_fAttackTimeRemaining;                                   // 0x0524(0x0004)
	float                                              m_fPreHitTimeRemaining;                                   // 0x0528(0x0004)
	float                                              m_fAttackTimeElapsed;                                     // 0x052C(0x0004)
	float                                              m_fCachedRefireTime;                                      // 0x0530(0x0004)
	float                                              m_fCachedFirePreHitDelay;                                 // 0x0534(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ChainedMelee");
		return ptr;
	}


	void UpdateAttackTimeElapsed(int DesiredFireMode, bool bFire, float fDesiredRefireTime, float fAttackTimeDifferential);
	void STATIC_ReleasePostFireInternalCooldown();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_FixAttack(int DesiredFireMode, float fDesiredRefireTime, float fAttackTimeDifferential);
	void STATIC_ClientGoToNextChainAttack(int AttackNumber, unsigned char DesiredFireMode, float fRefireTime);
	void STATIC_GoToNextChainAttack(int nMode);
	void InterruptFiring();
	void STATIC_ClientResetChainedAttack();
	void ResetChainedAttack();
	int CalculateNextMode(int CurrentMode);
	int GetBaseMode();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetRefireTime(int nMode);
};


// Class TgGame.TgDevice_ActiveMode
// 0x0014 (0x054C - 0x0538)
class ATgDevice_ActiveMode : public ATgDevice_ChainedMelee
{
public:
	int                                                m_nActiveMode;                                            // 0x0538(0x0004)
	TArray<struct FActiveModeInfo>                     c_NextActiveModes;                                        // 0x053C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ActiveMode");
		return ptr;
	}


	void STATIC_ClientResetChainedAttack();
	int CalculateNextMode(int CurrentMode);
	int GetBaseMode();
	void STATIC_ClientChangeActiveMode(unsigned char NewMode, int FirstAttackNumber);
	void ChangeActiveMode(unsigned char NewMode);
};


// Class TgGame.TgDevice_Kaldr_Basic
// 0x0000 (0x054C - 0x054C)
class ATgDevice_Kaldr_Basic : public ATgDevice_ActiveMode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kaldr_Basic");
		return ptr;
	}

};


// Class TgGame.TgDevice_Charge
// 0x004C (0x053C - 0x04F0)
class ATgDevice_Charge : public ATgDevice
{
public:
	TEnumAsByte<EChargeState>                          m_eChargeState;                                           // 0x04F0(0x0001)
	TEnumAsByte<EChargeStopOnHitType>                  m_eStopOnHitType;                                         // 0x04F1(0x0001)
	TEnumAsByte<EChargeFiringType>                     m_ChargeTimingType;                                       // 0x04F2(0x0001)
	TEnumAsByte<EChargeEndState>                       m_CurrentChargeEndState;                                  // 0x04F3(0x0001) (Transient)
	class ATgCollisionProxy_Cylinder*                  m_HitProxy;                                               // 0x04F4(0x0008)
	struct FVector                                     m_vHitProxyOffset;                                        // 0x04FC(0x000C)
	unsigned long                                      m_bIgnoreHumanoids : 1;                                   // 0x0508(0x0004)
	unsigned long                                      m_bHitOnce : 1;                                           // 0x0508(0x0004)
	unsigned long                                      m_bApplyHitOnTouch : 1;                                   // 0x0508(0x0004)
	unsigned long                                      m_bApplyHitSpecialOnTouch : 1;                            // 0x0508(0x0004)
	unsigned long                                      m_bIgnoreRange : 1;                                       // 0x0508(0x0004)
	unsigned long                                      m_bCharging : 1;                                          // 0x0508(0x0004)
	unsigned long                                      m_bInterruptDeviceIfChargeEnds : 1;                       // 0x0508(0x0004)
	unsigned long                                      m_bUseDirectHitSpecial : 1;                               // 0x0508(0x0004)
	unsigned long                                      m_bDoNotCompensateForTimerError : 1;                      // 0x0508(0x0004)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x050C(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_HitActors;                                              // 0x051C(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_TouchingActors;                                         // 0x052C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Charge");
		return ptr;
	}


	void STATIC_HandleHitSpecialOnTouch(class AActor* Other, const struct FImpactInfo& Impact, class UTgDeviceFire* FireMode);
	void STATIC_EndChargePhysics(bool bInterrupted);
	void STATIC_StartChargePhysics();
	void STATIC_OnChargeEnd();
	void STATIC_OnChargeStart();
	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	bool PredictChargeHit(const struct FVector& ChargeDir, const struct FVector& ChargeStart, float fChargeRange, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	void STATIC_OnStoppedChargeOnHit(class AActor* Other);
	void STATIC_OnValidTargetTouched(class AActor* Other);
	void ApplyDamageReduction(struct FImpactInfo* Impact);
	bool STATIC_ShouldApplyHitSpecialOnTouch(class AActor* Target);
	bool IsSpecialChargeTarget(class AActor* Other);
	bool STATIC_ShouldStopOnThisHit(class AActor* Other);
	float GetChargeSpeed();
	float GetChargeTime();
	float GetChargeRange();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_ProcessChargeNumber(int nChargeNumber);
	void STATIC_ClientStoppingOnHit();
	unsigned char STATIC_GetMaxChargeValue();
	unsigned char STATIC_GetCurrentChargeValue();
	void EndCharge(bool bRestart);
	void StartCharge();
	void ChargeUnTouch(class AActor* Other);
	void ChargeTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void AttemptApplyMissedUntouch();
	void AttemptApplyMissedTouch();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_BoarAdv_Charge
// 0x0000 (0x053C - 0x053C)
class ATgDevice_BoarAdv_Charge : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BoarAdv_Charge");
		return ptr;
	}


	void STATIC_EndChargePhysics(bool bInterrupted);
	void STATIC_StartChargePhysics();
	void STATIC_GetCachedAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_CH06_Sweeper_Dev2
// 0x0018 (0x0554 - 0x053C)
class ATgDevice_CH06_Sweeper_Dev2 : public ATgDevice_Charge
{
public:
	class ATgPawn*                                     m_CachedOwner;                                            // 0x053C(0x0008)
	TArray<struct FChargeHitInfo>                      m_ChargeHitInfos;                                         // 0x0544(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH06_Sweeper_Dev2");
		return ptr;
	}


	void STATIC_OnChargeEnd();
	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	void STATIC_PerformPunchKnockback(class ATgPawn* HitActor);
	bool STATIC_HasCachedPawnOwner();
};


// Class TgGame.TgDevice_CH06_TurtleSpin
// 0x0030 (0x056C - 0x053C)
class ATgDevice_CH06_TurtleSpin : public ATgDevice_Charge
{
public:
	float                                              m_fDeployDelayTime;                                       // 0x053C(0x0004)
	TArray<class ATgDeployable*>                       s_Deployables;                                            // 0x0540(0x0010) (NeedCtorLink)
	TArray<struct FTurtleSpinDeployTouchStatus>        m_DeployRegistration;                                     // 0x0550(0x0010) (NeedCtorLink)
	struct FVector                                     m_vLastDeployLocation;                                    // 0x0560(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH06_TurtleSpin");
		return ptr;
	}


	void Destroyed();
	void UnregisterDeployTouch(class AActor* Other);
	void RegisterDeployTouch(class AActor* Other);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_RepeatFire();
	void STATIC_FireAmmunition();
	bool STATIC_CanSpawnDeployable();
};


// Class TgGame.TgDevice_Charge_ChainSubDevice
// 0x0028 (0x0564 - 0x053C)
class ATgDevice_Charge_ChainSubDevice : public ATgDevice_Charge
{
public:
	class ATgDevice*                                   r_SubDevices[0x4];                                        // 0x053C(0x0008) (Const, Net)
	unsigned long                                      m_bReplicateToClient : 1;                                 // 0x055C(0x0004) (Const)
	unsigned long                                      m_bAutoUpgradeSubDevices : 1;                             // 0x055C(0x0004) (Const)
	int                                                r_CurrentSubDeviceIndex;                                  // 0x0560(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Charge_ChainSubDevice");
		return ptr;
	}


	void OnSubDeviceStopFire(class ATgDevice* devSub);
	int STATIC_GetSubDeviceIndex();
	class ATgDevice* STATIC_GetCurrentSubDevice();
	bool STATIC_CanChainSubDevice(class ATgDevice* SubDevice);
	void STATIC_ClientChainSubDevice(class ATgDevice* SubDevice);
	void STATIC_ChainSubDevice(class ATgDevice* SubDevice);
	bool ApplyGlobalOffhandCooldown();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
};


// Class TgGame.TgDevice_Charge_MovementAim
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Charge_MovementAim : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Charge_MovementAim");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_CTF_CarrierCharge
// 0x0000 (0x053C - 0x053C)
class ATgDevice_CTF_CarrierCharge : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CTF_CarrierCharge");
		return ptr;
	}

};


// Class TgGame.TgDevice_DoubleCharge
// 0x000C (0x0548 - 0x053C)
class ATgDevice_DoubleCharge : public ATgDevice_Charge
{
public:
	unsigned char                                      m_nTotalNumShots;                                         // 0x053C(0x0001)
	unsigned char                                      m_nShotsFired;                                            // 0x053D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x053E(0x0002) MISSED OFFSET
	float                                              m_fAimingTime;                                            // 0x0540(0x0004)
	unsigned long                                      m_bForceRefire : 1;                                       // 0x0544(0x0004)
	unsigned long                                      m_bShowTargetingDuringFire : 1;                           // 0x0544(0x0004)
	unsigned long                                      m_bAlreadyEnded : 1;                                      // 0x0544(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DoubleCharge");
		return ptr;
	}


	void STATIC_ClientStopFirstCharge(unsigned char nChargeNumber);
	float GetAimTime();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool STATIC_ServerRefireTimer(unsigned char nRefireIndex, const struct FAimData& ClientAim, float EndTraceX, float EndTraceY);
	bool STATIC_RefireTimer(unsigned char nRefireIndex);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool Use();
	bool CanBeCanceled();
	bool STATIC_CanFireAgain();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Kaldr_Dev2
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Kaldr_Dev2 : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kaldr_Dev2");
		return ptr;
	}


	bool STATIC_ShouldStopOnThisHit(class AActor* Other);
	bool CanBeFiredWhileTweening();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool ApplyGlobalOffhandCooldown();
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_Container
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Container : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Container");
		return ptr;
	}

};


// Class TgGame.TgDevice_Deployable
// 0x000C (0x04FC - 0x04F0)
class ATgDevice_Deployable : public ATgDevice
{
public:
	class ATgDeployable*                               r_Deployable;                                             // 0x04F0(0x0008) (Net)
	unsigned long                                      m_bUseMovingEffectVolumeAim : 1;                          // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Deployable");
		return ptr;
	}


	void OnDeployableDeployComplete(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Apep_AcidSpray
// 0x0024 (0x0520 - 0x04FC)
class ATgDevice_Apep_AcidSpray : public ATgDevice_Deployable
{
public:
	int                                                m_nRemainingDeployables;                                  // 0x04FC(0x0004)
	float                                              m_fDeployDelayTime;                                       // 0x0500(0x0004)
	TArray<struct FDeployTouchStatus>                  m_DeployRegistration;                                     // 0x0504(0x0010) (NeedCtorLink)
	struct FVector                                     m_vLastDeployLocation;                                    // 0x0514(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Apep_AcidSpray");
		return ptr;
	}


	void UnregisterDeployTouch(class AActor* Other);
	void RegisterDeployTouch(class AActor* Other);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_RepeatFire();
	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_AutoPortal
// 0x009C (0x0598 - 0x04FC)
class ATgDevice_AutoPortal : public ATgDevice_Deployable
{
public:
	struct FAimData                                    m_SecondaryAim;                                           // 0x04FC(0x0030)
	struct FAimData                                    m_CachedSecondaryAim;                                     // 0x052C(0x0030)
	struct FAimData                                    s_ReceivedSecondaryAim;                                   // 0x055C(0x0030)
	unsigned long                                      m_bOutOfRange : 1;                                        // 0x058C(0x0004)
	unsigned long                                      m_bCachedOutOfRange : 1;                                  // 0x058C(0x0004)
	float                                              m_fMaxPortalRange;                                        // 0x0590(0x0004)
	float                                              m_fEdgeOfWorldOffsetScaler;                               // 0x0594(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AutoPortal");
		return ptr;
	}


	void STATIC_ServerPortalStartFire(float P1X, float P1Y, float P2X, float P2Y, int nCompressedRot, bool bUseSecondaryAim);
	bool StartFire();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
	struct FAimData STATIC_CacheAim();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool UsesCachedAim();
};


// Class TgGame.TgDevice_CH05_SunderEarth
// 0x0010 (0x050C - 0x04FC)
class ATgDevice_CH05_SunderEarth : public ATgDevice_Deployable
{
public:
	TArray<struct FSunderEarthDeployTouchStatus>       m_DeployRegistration;                                     // 0x04FC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_SunderEarth");
		return ptr;
	}


	void Destroyed();
	void UnregisterDeployTouch(class AActor* Other);
	void RegisterDeployTouch(class AActor* Other);
};


// Class TgGame.TgDevice_CTF_FlagManager
// 0x000C (0x0508 - 0x04FC)
class ATgDevice_CTF_FlagManager : public ATgDevice_Deployable
{
public:
	class ATgDeployable_CTF_Flag*                      m_OwnedFlag;                                              // 0x04FC(0x0008)
	int                                                m_nFlagDeployableId;                                      // 0x0504(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CTF_FlagManager");
		return ptr;
	}


	class ATgDeployable_CTF_Flag* STATIC_SpawnDeployable();
};


// Class TgGame.TgDevice_Deployable_ConeShaped
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Deployable_ConeShaped : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Deployable_ConeShaped");
		return ptr;
	}

};


// Class TgGame.TgDevice_FireGiant_FlamesOfRagnarok
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_FireGiant_FlamesOfRagnarok : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FireGiant_FlamesOfRagnarok");
		return ptr;
	}


	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Hydra_Arc
// 0x0014 (0x0510 - 0x04FC)
class ATgDevice_Hydra_Arc : public ATgDevice_Deployable
{
public:
	float                                              s_fSetupOffset;                                           // 0x04FC(0x0004)
	TArray<struct FDEP_TOUCH_INFO>                     s_TouchList;                                              // 0x0500(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hydra_Arc");
		return ptr;
	}


	void UnregisterDeployTouch(class AActor* Other, class ATgDeployable* Deploy);
	void RegisterDeployTouch(class AActor* Other, class ATgDeployable* Deploy);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_CustomFire();
};


// Class TgGame.TgDevice_Surtr_LavaPools
// 0x0048 (0x0544 - 0x04FC)
class ATgDevice_Surtr_LavaPools : public ATgDevice_Deployable
{
public:
	TArray<class ATgDeployable*>                       s_Deployables;                                            // 0x04FC(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             s_TargetPawns;                                            // 0x050C(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             s_ValidEnemyPawns;                                        // 0x051C(0x0010) (NeedCtorLink)
	int                                                s_nTargetIndex;                                           // 0x052C(0x0004)
	int                                                m_nPlayerPoolLimit;                                       // 0x0530(0x0004)
	TArray<struct FSurtrPoolDeployTouchStatus>         m_DeployRegistration;                                     // 0x0534(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Surtr_LavaPools");
		return ptr;
	}


	void Destroyed();
	void CleanUpDevice();
	void UnregisterDeployTouch(class AActor* Other);
	void RegisterDeployTouch(class AActor* Other);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_CustomFire();
	void STATIC_SpawnEnemyPools();
	void STATIC_CalcTargetPawns();
};


// Class TgGame.TgDevice_TogglableDeployable
// 0x0018 (0x0514 - 0x04FC)
class ATgDevice_TogglableDeployable : public ATgDevice_Deployable
{
public:
	TEnumAsByte<ETogglableDeployableState>             m_eToggleState;                                           // 0x04FC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04FD(0x0003) MISSED OFFSET
	unsigned long                                      m_bWaitForDeploy : 1;                                     // 0x0500(0x0004)
	unsigned long                                      m_bCanToggleOffWhenDead : 1;                              // 0x0500(0x0004)
	unsigned long                                      m_bDoCanDeviceFireCheckOnToggleOff : 1;                   // 0x0500(0x0004)
	TArray<class ATgProjectile*>                       s_DeployingProjectiles;                                   // 0x0504(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TogglableDeployable");
		return ptr;
	}


	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void InterruptFiring();
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void ToggleOffConsumePowerPool(class ATgDeployable* deployable);
	bool STATIC_ServerToggleOff();
	void STATIC_ServerToggleOn(const struct FAimData& ClientAim, float EndTraceX, float EndTraceY, int nCompressedRot);
	bool ToggleOff();
	bool ToggleOn();
	bool Use();
	bool STATIC_CanBeRetoggled();
	bool CanBeCanceled();
	bool ShouldInterruptInhand();
	bool STATIC_ShouldInterruptReload();
	bool IsToggleDevice();
	bool STATIC_CanDeviceFireInTargetingMode();
	void STATIC_ClientSetState(TEnumAsByte<ETogglableDeployableState> NewState);
	void SetState(TEnumAsByte<ETogglableDeployableState> NewState, bool bStartCooldown);
	bool IsToggledOn();
	bool ShouldCooldownAfterFire();
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool STATIC_ProjectileWillSpawnDeployable(class ATgProjectile* Proj);
};


// Class TgGame.TgDevice_PersistentCostTogglableDeployable
// 0x0004 (0x0518 - 0x0514)
class ATgDevice_PersistentCostTogglableDeployable : public ATgDevice_TogglableDeployable
{
public:
	float                                              m_TimeSinceLastManaCostApplied;                           // 0x0514(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PersistentCostTogglableDeployable");
		return ptr;
	}


	void Tick(float DeltaTime);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_Ward
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Ward : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ward");
		return ptr;
	}


	void STATIC_GetCombatLogEventLocation(int* LocationX, int* LocationY);
	void STATIC_PlayEmoteWardPlaced();
};


// Class TgGame.TgDevice_EyeOfProvidenceS3
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_EyeOfProvidenceS3 : public ATgDevice_Ward
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EyeOfProvidenceS3");
		return ptr;
	}

};


// Class TgGame.TgDevice_WardContainer
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_WardContainer : public ATgDevice_Ward
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WardContainer");
		return ptr;
	}

};


// Class TgGame.TgDevice_Dialogue
// 0x00A8 (0x0598 - 0x04F0)
class ATgDevice_Dialogue : public ATgDevice
{
public:
	class ATgRepInfo_Game*                             m_GRI;                                                    // 0x04F0(0x0008) (Const)
	class ATgGame_Mission*                             m_Game;                                                   // 0x04F8(0x0008) (Const)
	class ATgPawn*                                     m_PawnSpeaker;                                            // 0x0500(0x0008) (Const)
	TScriptInterface<class UTgPawn_DialogueInterface>  m_Speaker;                                                // 0x0508(0x0010) (Const)
	TArray<int>                                        m_SituationalDialogueProgression;                         // 0x0518(0x0010) (Const, NeedCtorLink)
	struct FName                                       m_nmCooldownEnd;                                          // 0x0528(0x0008) (Const)
	struct FName                                       m_nmActiveFiringEnd;                                      // 0x0530(0x0008) (Const)
	struct FName                                       m_nmCueNextDialogueLine;                                  // 0x0538(0x0008) (Const)
	float                                              m_fDefaultCooldownTime;                                   // 0x0540(0x0004) (Const)
	float                                              m_fTriggerDistance;                                       // 0x0544(0x0004) (Const)
	float                                              m_fRelevancyDistance;                                     // 0x0548(0x0004) (Const)
	unsigned long                                      m_bConverseWithEnemies : 1;                               // 0x054C(0x0004) (Const)
	unsigned long                                      m_bConverseWithFriendlies : 1;                            // 0x054C(0x0004) (Const)
	unsigned long                                      s_bRemoveAllOnCueNext : 1;                                // 0x054C(0x0004)
	unsigned long                                      s_bEnabled : 1;                                           // 0x054C(0x0004)
	TArray<struct FDialogueInfo>                       s_Dialogues;                                              // 0x0550(0x0010) (Const, NeedCtorLink)
	TArray<TScriptInterface<class UTgPawn_DialogueInterface>> s_SpeakersInRange;                                        // 0x0560(0x0010) (NeedCtorLink)
	TArray<TScriptInterface<class UTgPawn_DialogueInterface>> s_ActiveSpeakers;                                         // 0x0570(0x0010) (NeedCtorLink)
	TArray<int>                                        s_AvailableDialogues;                                     // 0x0580(0x0010) (NeedCtorLink)
	int                                                s_nActiveDialogueMode;                                    // 0x0590(0x0004)
	int                                                s_nActiveSituationalType;                                 // 0x0594(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Dialogue");
		return ptr;
	}


	void STATIC_CueNextDialogueLine(bool bSkipIncrement);
	void ActiveFiringEnd();
	void STATIC_CooldownEnd();
	void STATIC_ResetState();
	void STATIC_ClearInactiveDialogues();
	bool IsOnCooldown();
	bool STATIC_NativeIsFiring();
	TScriptInterface<class UTgPawn_DialogueInterface> STATIC_GetPawnAsInterface(class APawn* Pawn);
};


// Class TgGame.TgDevice_Dialogue_Arthurian
// 0x0010 (0x05A8 - 0x0598)
class ATgDevice_Dialogue_Arthurian : public ATgDevice_Dialogue
{
public:
	TArray<struct FMerlinDialogueRestriction>          m_MerlinRestrictions;                                     // 0x0598(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Dialogue_Arthurian");
		return ptr;
	}

};


// Class TgGame.TgDevice_EyeOfRetaliation
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_EyeOfRetaliation : public ATgDevice
{
public:
	float                                              m_fFlipPoint;                                             // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_EyeOfRetaliation");
		return ptr;
	}


	void Tick(float DeltaTime);
	void STATIC_DeviceRestart();
	void TestFlipPoint();
};


// Class TgGame.TgDevice_Grenade
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Grenade : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Grenade");
		return ptr;
	}

};


// Class TgGame.TgDevice_GroundTarget_LockOn
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_GroundTarget_LockOn : public ATgDevice
{
public:
	unsigned long                                      m_bCanFireWithoutTarget : 1;                              // 0x04F0(0x0004)
	unsigned long                                      m_bSelfTargetIfNone : 1;                                  // 0x04F0(0x0004)
	unsigned long                                      m_bOnlyTargetValidGrabSources : 1;                        // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GroundTarget_LockOn");
		return ptr;
	}


	bool STATIC_CanLockOnToTarget(class AActor* Target);
	void UpdateAimWhileFiring(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_CH05_LokiExsanguinate
// 0x0010 (0x0504 - 0x04F4)
class ATgDevice_CH05_LokiExsanguinate : public ATgDevice_GroundTarget_LockOn
{
public:
	TArray<struct FExsanguinateData>                   m_Data;                                                   // 0x04F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_LokiExsanguinate");
		return ptr;
	}


	void Destroyed();
	void AddData(class AActor* HitActor);
	void DeliverQueuedPendingHits();
};


// Class TgGame.TgDevice_Kaldr_Dev3
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Kaldr_Dev3 : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kaldr_Dev3");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool CanBeFiredWhileTweening();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool ApplyGlobalOffhandCooldown();
	bool STATIC_HasBeenTrained();
};


// Class TgGame.TgDevice_GuardiansBlessing
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_GuardiansBlessing : public ATgDevice
{
public:
	float                                              m_fAllyZoneRadius;                                        // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GuardiansBlessing");
		return ptr;
	}


	void ApplyAllyMarker();
	bool IsWithinAlly();
};


// Class TgGame.TgDevice_HitPulse
// 0x000C (0x04FC - 0x04F0)
class ATgDevice_HitPulse : public ATgDevice
{
public:
	unsigned long                                      s_ShouldPayCostPerPulse : 1;                              // 0x04F0(0x0004)
	unsigned long                                      s_bCostPaid : 1;                                          // 0x04F0(0x0004)
	unsigned long                                      m_bShouldDelayPostFire : 1;                               // 0x04F0(0x0004)
	unsigned long                                      m_bForceDelayedPostFire : 1;                              // 0x04F0(0x0004)
	unsigned long                                      m_bHasPostFireDelayed : 1;                                // 0x04F0(0x0004) (Transient)
	int                                                m_CurrentPulseIndex;                                      // 0x04F4(0x0004)
	int                                                m_MaxPulseIndex;                                          // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HitPulse");
		return ptr;
	}


	void STATIC_ClientStartPostHitDelay();
	float STATIC_GetLockoutExtensionTime();
	void STATIC_FireDelayedPostHitDelay();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	void STATIC_ClientInterrupt();
	void InterruptFiring();
	float GetPersistPulseHitTime(int nMode);
	float GetPersistTime(int nMode);
	void STATIC_PulseHit();
	float GetRefireTime(int nMode);
	void STATIC_PersistTimer();
	bool ApplyGlobalOffhandCooldown();
};


// Class TgGame.TgDevice_CH05_KnockbackPulse
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_CH05_KnockbackPulse : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_KnockbackPulse");
		return ptr;
	}


	void DeliverQueuedPendingHits();
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void KnockbackWrapper(const struct FImpactInfo& Impact);
};


// Class TgGame.TgDevice_Ch05_RadialHitPulse
// 0x0010 (0x050C - 0x04FC)
class ATgDevice_Ch05_RadialHitPulse : public ATgDevice_HitPulse
{
public:
	struct FVector                                     s_vAdjustedAimVec;                                        // 0x04FC(0x000C)
	float                                              s_fRotPerShot;                                            // 0x0508(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ch05_RadialHitPulse");
		return ptr;
	}


	void STATIC_FireAmmunition();
	bool StartFire();
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	float GetPersistPulseHitTime(int nMode);
	void STATIC_RotateToNextAim();
};


// Class TgGame.TgDevice_CH05_Spiral_Swirl
// 0x003C (0x0538 - 0x04FC)
class ATgDevice_CH05_Spiral_Swirl : public ATgDevice_HitPulse
{
public:
	struct FAimData                                    m_OriginalAim;                                            // 0x04FC(0x0030)
	float                                              m_fCurrentRadiusOffset;                                   // 0x052C(0x0004)
	float                                              m_fStartingRadiusOffset;                                  // 0x0530(0x0004)
	int                                                m_nNumShots;                                              // 0x0534(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_Spiral_Swirl");
		return ptr;
	}


	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
	bool UsesCachedAim();
};


// Class TgGame.TgDevice_CH06_BlindingBall
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_CH06_BlindingBall : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH06_BlindingBall");
		return ptr;
	}


	void DeliverQueuedPendingHits();
};


// Class TgGame.TgDevice_FireGiant_RagnarokFury
// 0x0048 (0x0544 - 0x04FC)
class ATgDevice_FireGiant_RagnarokFury : public ATgDevice_HitPulse
{
public:
	TArray<struct FRFPotentialTargetData>              m_TargetOrder;                                            // 0x04FC(0x0010) (NeedCtorLink)
	TArray<struct FVector>                             m_ShotOffsets;                                            // 0x050C(0x0010) (NeedCtorLink)
	int                                                m_nMaxShots;                                              // 0x051C(0x0004)
	int                                                m_nCurrentShot;                                           // 0x0520(0x0004)
	int                                                m_nPreviousFXSpawned;                                     // 0x0524(0x0004)
	float                                              m_fSpawnDelay;                                            // 0x0528(0x0004)
	class ATgPawn_FireGiant_S5*                        m_FGOwner;                                                // 0x052C(0x0008)
	struct FScriptDelegate                             __SortTargetDelegate__Delegate;                           // 0x0534(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0534(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_FireGiant_RagnarokFury");
		return ptr;
	}


	bool StartFire();
	void CleanUpDevice();
	class AActor* STATIC_GetTrackingTarget(int nFireIndex);
	int SortTargetDelegate(const struct FRFPotentialTargetData& A, const struct FRFPotentialTargetData& B);
	void SortTargets();
	void FillTargetList();
	struct FVector STATIC_GetSpecificOffset();
	bool STATIC_HasSpecificOffset();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_StoreTargetsInRange(class ATgRepInfo_TaskForce* targetTRI);
	void STATIC_SpawnSetupFX();
	void STATIC_CalculateTargets();
	void STATIC_CalculateOffsets();
};


// Class TgGame.TgDevice_LionAdv_Roar
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_LionAdv_Roar : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LionAdv_Roar");
		return ptr;
	}


	void STATIC_PersistTimer();
};


// Class TgGame.TgDevice_Surtr_SwordSwing
// 0x0020 (0x051C - 0x04FC)
class ATgDevice_Surtr_SwordSwing : public ATgDevice_HitPulse
{
public:
	TArray<struct FSurtrFanInformation>                s_FanInfos;                                               // 0x04FC(0x0010) (NeedCtorLink)
	TArray<class ATgProjectile*>                       s_ActiveProjectiles;                                      // 0x050C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Surtr_SwordSwing");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	class AProjectile* STATIC_ProjectileFire(int nProjectileIndex);
	float GetPersistPulseHitTime(int nMode);
	bool STATIC_ShouldApplyHit(class ATgProjectile* Proj, class AActor* HitActor, int* nHitCount);
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_TogglableHitPulse
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_TogglableHitPulse : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TogglableHitPulse");
		return ptr;
	}


	bool STATIC_ShouldInterruptReload();
	bool IsToggleDevice();
	bool StartFire();
	bool STATIC_CanDeviceFireInTargetingMode();
	bool IsToggledOn();
	void UpdateUIToggleState();
};


// Class TgGame.TgDevice_Hydra_Mark
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Hydra_Mark : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hydra_Mark");
		return ptr;
	}


	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_HydraAdv_Lob
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_HydraAdv_Lob : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HydraAdv_Lob");
		return ptr;
	}


	struct FVector AdjustAIGroundTargetLead(class ATgPawn* TargetPawn);
};


// Class TgGame.TgDevice_Item_TalismanOfEnergy
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Item_TalismanOfEnergy : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Item_TalismanOfEnergy");
		return ptr;
	}


	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_Kaldr_Passive
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Kaldr_Passive : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kaldr_Passive");
		return ptr;
	}


	bool CanBeFiredWhileTweening();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_FireAmmunition();
	bool ApplyGlobalOffhandCooldown();
};


// Class TgGame.TgDevice_KnockbackTween_OnHit
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_KnockbackTween_OnHit : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_KnockbackTween_OnHit");
		return ptr;
	}


	void DeliverQueuedPendingHits();
};


// Class TgGame.TgDevice_LimitedDuration
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_LimitedDuration : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LimitedDuration");
		return ptr;
	}

};


// Class TgGame.TgDevice_LimitedGroundTarget
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_LimitedGroundTarget : public ATgDevice
{
public:
	struct FVector                                     r_vLimitedGroundTargetOrigin;                             // 0x04F0(0x000C) (Net)
	class ATgDeployable_LimitedGroundTarget*           m_TargetingBoundsDeployable;                              // 0x04FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LimitedGroundTarget");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void SetLimitedAimLocation(const struct FVector& Loc);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetLimitedTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_LineCone
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_LineCone : public ATgDevice
{
public:
	unsigned long                                      m_bImpactWorld : 1;                                       // 0x04F0(0x0004)
	unsigned long                                      m_bImpactActors : 1;                                      // 0x04F0(0x0004)
	unsigned long                                      m_bImpactPawns : 1;                                       // 0x04F0(0x0004)
	unsigned long                                      m_bImpactFamiliars : 1;                                   // 0x04F0(0x0004)
	unsigned long                                      m_bImpactMinions : 1;                                     // 0x04F0(0x0004)
	unsigned long                                      m_bImpactTowers : 1;                                      // 0x04F0(0x0004)
	unsigned long                                      m_bImpactGuardians : 1;                                   // 0x04F0(0x0004)
	unsigned long                                      m_bImpactPhoenixes : 1;                                   // 0x04F0(0x0004)
	unsigned long                                      m_bImpactGods : 1;                                        // 0x04F0(0x0004)
	unsigned long                                      m_bImpactMonsters : 1;                                    // 0x04F0(0x0004)
	unsigned long                                      m_bImpactLargeMonsters : 1;                               // 0x04F0(0x0004)
	unsigned long                                      m_bImpactBuffMonsters : 1;                                // 0x04F0(0x0004)
	unsigned long                                      m_bImpactNeutralBosses : 1;                               // 0x04F0(0x0004)
	unsigned long                                      m_bImpactDecoys : 1;                                      // 0x04F0(0x0004)
	unsigned long                                      m_bImpactDeployables : 1;                                 // 0x04F0(0x0004)
	unsigned long                                      m_bImpactEliteMinions : 1;                                // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LineCone");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_LineTarget_LockOn
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_LineTarget_LockOn : public ATgDevice
{
public:
	unsigned long                                      m_bCanFireWithoutTarget : 1;                              // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LineTarget_LockOn");
		return ptr;
	}


	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Listener_AOEOnRemove
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Listener_AOEOnRemove : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Listener_AOEOnRemove");
		return ptr;
	}


	void STATIC_OnUnequipAsEffectListener();
};


// Class TgGame.TgDevice_CH05_Bomb
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_CH05_Bomb : public ATgDevice_Listener_AOEOnRemove
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_Bomb");
		return ptr;
	}


	void STATIC_OnUnequipAsEffectListener();
	void STATIC_OnEquipAsEffectListener();
};


// Class TgGame.TgDevice_LobToTarget
// 0x0060 (0x0550 - 0x04F0)
class ATgDevice_LobToTarget : public ATgDevice
{
public:
	float                                              m_MaxLobHeight;                                           // 0x04F0(0x0004)
	int                                                m_LobCount;                                               // 0x04F4(0x0004)
	float                                              m_fTimeToHitGround;                                       // 0x04F8(0x0004)
	struct FVector                                     m_LobVelocity;                                            // 0x04FC(0x000C)
	float                                              m_fCurrentTimeLeft;                                       // 0x0508(0x0004)
	unsigned long                                      m_bKnockingUpThisFrame : 1;                               // 0x050C(0x0004)
	struct FAimData                                    m_aimCachedLob;                                           // 0x0510(0x0030)
	TArray<class ATgPawn*>                             s_ToApplyKnockupActors;                                   // 0x0540(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LobToTarget");
		return ptr;
	}


	void Tick(float fDeltaSeconds);
	void DeliverQueuedPendingHits();
	bool STATIC_CanBeKnockedUp(class ATgPawn* Target);
	void LobPawnToTargetPawn(class ATgPawn* Pawn, class ATgPawn* Target);
	float STATIC_CalculateLobMath(float MaxLobHeight);
};


// Class TgGame.TgDevice_LockOnShooter
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_LockOnShooter : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LockOnShooter");
		return ptr;
	}


	void STATIC_GetLockOnTargetAim(struct FAimData* Aim);
	bool STATIC_CanLockOnToTarget(class AActor* Target);
};


// Class TgGame.TgDevice_MapTargetLockOn
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_MapTargetLockOn : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MapTargetLockOn");
		return ptr;
	}


	void STATIC_GetWorldMapLockOnTargetAim(struct FAimData* Aim);
	bool STATIC_CanLockOnToTarget(class AActor* Target);
	bool STATIC_ShowUICanFire();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_HasValidTargets();
	bool STATIC_ForceDefaultCastMode();
};


// Class TgGame.TgDevice_MapTargetTeleport
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_MapTargetTeleport : public ATgDevice_MapTargetLockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MapTargetTeleport");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDevice_MapTargetTeleportGod
// 0x0030 (0x0520 - 0x04F0)
class ATgDevice_MapTargetTeleportGod : public ATgDevice_MapTargetLockOn
{
public:
	struct FAimData                                    s_LastGoodAim;                                            // 0x04F0(0x0030)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MapTargetTeleportGod");
		return ptr;
	}


	void StopFire();
	void OnTeleportFireFailed();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_RallyingRitual
// 0x0000 (0x0520 - 0x0520)
class ATgDevice_RallyingRitual : public ATgDevice_MapTargetTeleportGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RallyingRitual");
		return ptr;
	}


	void ConsumeDevice();
	void STATIC_FireAmmunition();
	bool StartFire();
	void InterruptFiring();
	bool CanBeInterrupted();
	void STATIC_GetWorldMapLockOnTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_TeleportSiegeVariant
// 0x0030 (0x0520 - 0x04F0)
class ATgDevice_TeleportSiegeVariant : public ATgDevice_MapTargetLockOn
{
public:
	struct FAimData                                    s_LastGoodAim;                                            // 0x04F0(0x0030)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TeleportSiegeVariant");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool STATIC_HasValidTargets();
	bool STATIC_CanBeCrippled();
};


// Class TgGame.TgDevice_Melee
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Melee : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Melee");
		return ptr;
	}


	struct FImpactInfo MeleeMouseOver(class AActor* TraceActor, const struct FVector& StartTrace, const struct FVector& EndTrace);
	class ATgPawn* AcquireMeleeTarget(int* bExactTarget);
	bool StartFire();
	bool STATIC_NativeIsFiring();
};


// Class TgGame.TgDevice_CTF_CarrierBash
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_CTF_CarrierBash : public ATgDevice_Melee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CTF_CarrierBash");
		return ptr;
	}


	float GetRefireTime(int nMode);
};


// Class TgGame.TgDevice_MOB_MinionSpawn
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_MOB_MinionSpawn : public ATgDevice
{
public:
	class UTgDeviceFire_MOB_MinionSpawn*               m_CachedMode;                                             // 0x04F0(0x0008)
	struct FVector                                     c_vCurrentTargeting2Location;                             // 0x04F8(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MOB_MinionSpawn");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void STATIC_SpawnNext();
	void STATIC_CalcSpecialTarget(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Racer_Blink
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Racer_Blink : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Racer_Blink");
		return ptr;
	}


	void EnterTargetingMode();
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_RadialSweep
// 0x002C (0x051C - 0x04F0)
class ATgDevice_RadialSweep : public ATgDevice
{
public:
	class ATgCollisionProxy_RadialSweep*               m_CollisionProxy;                                         // 0x04F0(0x0008)
	class UClass*                                      m_DefaultRadialProxyClass;                                // 0x04F8(0x0008)
	TArray<class AActor*>                              m_HitActors;                                              // 0x0500(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               m_SweepFiremode;                                          // 0x0510(0x0008)
	unsigned long                                      m_bForceEndSweepOnStopFire : 1;                           // 0x0518(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RadialSweep");
		return ptr;
	}


	void Destroyed();
	void STATIC_EndSweep();
	void STATIC_StartOffsetSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime, float fAngleOffset);
	void STATIC_StartSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime);
	bool STATIC_CanRadialSweep();
	bool IsSweepActive();
	float GetPersistTime(int nMode);
	void STATIC_OnApplyHitFromTouch(class UTgDeviceFire* FireMode, struct FImpactInfo* Impact);
	void ProxyEndSweep(bool bInterrupt);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UpdateCollisionProxyDelegates();
};


// Class TgGame.TgDevice_CH05_Seaweed
// 0x0011 (0x052D - 0x051C)
class ATgDevice_CH05_Seaweed : public ATgDevice_RadialSweep
{
public:
	class ATgCollisionProxy_RadialSweep*               m_FirstSweep;                                             // 0x051C(0x0008)
	class ATgCollisionProxy_RadialSweep*               m_SecondSweep;                                            // 0x0524(0x0008)
	TEnumAsByte<ECURRENTSEAWEEDSTATE>                  m_CurrentActiveArm;                                       // 0x052C(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_Seaweed");
		return ptr;
	}


	void Destroyed();
	void STATIC_EndSweep();
	void STATIC_StartSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime);
	void STATIC_OnApplyHitFromTouch(class UTgDeviceFire* FireMode, struct FImpactInfo* Impact);
	void UpdateCollisionProxyDelegates();
	void STATIC_DelayedSlam();
	TEnumAsByte<ECURRENTSEAWEEDSTATE> STATIC_GetCurrentArm();
	void STATIC_SetActiveArm(TEnumAsByte<ECURRENTSEAWEEDSTATE> eActiveState);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_ConeSweep
// 0x0000 (0x051C - 0x051C)
class ATgDevice_ConeSweep : public ATgDevice_RadialSweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ConeSweep");
		return ptr;
	}


	bool IsValidHitLocation(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_StartOffsetSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime, float fAngleOffset);
	void STATIC_StartSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime);
};


// Class TgGame.TgDevice_DoubleSweep
// 0x001C (0x0538 - 0x051C)
class ATgDevice_DoubleSweep : public ATgDevice_RadialSweep
{
public:
	class ATgCollisionProxy_RadialSweep*               m_CollisionProxyB;                                        // 0x051C(0x0008)
	TArray<class AActor*>                              m_HitActorsB;                                             // 0x0524(0x0010) (NeedCtorLink)
	unsigned long                                      m_bMirroredProxy : 1;                                     // 0x0534(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DoubleSweep");
		return ptr;
	}


	void Destroyed();
	void STATIC_EndSweep();
	void STATIC_StartOffsetSweepB(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime, float fAngleOffset);
	void STATIC_StartSweepB(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime);
	bool IsSweepBActive();
	float GetRadiusB(int nMode);
	float GetAttackAngleOffsetB(int nMode, float fPrevOffset);
	float GetAttackAngleB(int nMode);
	float GetPersistTimeB(int nMode);
	void ProxyBEndSweep(bool bInterrupt);
	void ProxyBUnTouch(class AActor* Other);
	void ProxyBTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UpdateCollisionProxyDelegates();
};


// Class TgGame.TgDevice_RadialSweep_MultiHit
// 0x002C (0x0548 - 0x051C)
class ATgDevice_RadialSweep_MultiHit : public ATgDevice_RadialSweep
{
public:
	TArray<float>                                      m_fClearTimes;                                            // 0x051C(0x0010) (NeedCtorLink)
	float                                              m_fHitClearTime;                                          // 0x052C(0x0004)
	unsigned long                                      m_bLocksOtherDevices : 1;                                 // 0x0530(0x0004)
	TArray<struct FMultiHitTrackingInfo>               m_HitTrackingList;                                        // 0x0534(0x0010) (NeedCtorLink)
	int                                                m_nMaxHits;                                               // 0x0544(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RadialSweep_MultiHit");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void Tick(float DeltaSeconds);
	void STATIC_OnApplyHitFromTouch(class UTgDeviceFire* FireMode, struct FImpactInfo* Impact);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_RadialSweep_IndependentSpeed
// 0x0000 (0x0548 - 0x0548)
class ATgDevice_RadialSweep_IndependentSpeed : public ATgDevice_RadialSweep_MultiHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RadialSweep_IndependentSpeed");
		return ptr;
	}


	void STATIC_StartSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime);
};


// Class TgGame.TgDevice_RadialSweep_MultiHit_WithReturnSweep
// 0x0004 (0x054C - 0x0548)
class ATgDevice_RadialSweep_MultiHit_WithReturnSweep : public ATgDevice_RadialSweep_MultiHit
{
public:
	int                                                m_SweepIndex;                                             // 0x0548(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RadialSweep_MultiHit_WithReturnSweep");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
	void InterruptFiring();
	void STATIC_StartSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime);
	void ProxyEndSweep(bool bInterrupt);
};


// Class TgGame.TgDevice_RadialSweep_WithReturnSweep
// 0x0004 (0x0520 - 0x051C)
class ATgDevice_RadialSweep_WithReturnSweep : public ATgDevice_RadialSweep
{
public:
	int                                                m_SweepIndex;                                             // 0x051C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_RadialSweep_WithReturnSweep");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
	void InterruptFiring();
	void STATIC_StartSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime);
	void ProxyEndSweep(bool bInterrupt);
};


// Class TgGame.TgDevice_Range
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Range : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Range");
		return ptr;
	}

};


// Class TgGame.TgDevice_Apep_BasicAttack
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Apep_BasicAttack : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Apep_BasicAttack");
		return ptr;
	}


	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void STATIC_StartShockwaveAt(class UTgDeviceFire* DeviceFire, const struct FVector& SpawnLoc);
};


// Class TgGame.TgDevice_BoarAdv_Proj
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_BoarAdv_Proj : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BoarAdv_Proj");
		return ptr;
	}


	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_CTF_CarrierThrow
// 0x0048 (0x0538 - 0x04F0)
class ATgDevice_CTF_CarrierThrow : public ATgDevice_Range
{
public:
	class ATgDeployable_CTF_Flag*                      s_OriginalFlag;                                           // 0x04F0(0x0008)
	struct FVector                                     m_vYmirOffset;                                            // 0x04F8(0x000C)
	struct FVector                                     m_vHerculesOffset;                                        // 0x0504(0x000C)
	struct FVector                                     m_vArtemisOffset;                                         // 0x0510(0x000C)
	struct FVector                                     m_vAnubisOffset;                                          // 0x051C(0x000C)
	struct FVector                                     m_vLokiOffset;                                            // 0x0528(0x000C)
	unsigned long                                      s_bWasValidThrow : 1;                                     // 0x0534(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CTF_CarrierThrow");
		return ptr;
	}


	bool STATIC_HasSpecificOffset();
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void STATIC_FireAmmunition();
	struct FVector STATIC_GetSpecificOffset();
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	struct FVector STATIC_CheckValidFlagLocation(class ATgProjectile* Proj);
};


// Class TgGame.TgDevice_Kaldr_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Kaldr_Dev1 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kaldr_Dev1");
		return ptr;
	}


	bool CanBeFiredWhileTweening();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool ApplyGlobalOffhandCooldown();
	bool AllocateDevicePoint();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void UpdateAimWhileFiring(struct FAimData* Aim);
	struct FAimData STATIC_CacheAim();
};


// Class TgGame.TgDevice_ManticoreScorpion
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_ManticoreScorpion : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ManticoreScorpion");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Obelisk_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Obelisk_Dev1 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Obelisk_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDevice_ProjectileTeleport
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_ProjectileTeleport : public ATgDevice_Range
{
public:
	unsigned long                                      m_bShutdownProjOnTeleport : 1;                            // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ProjectileTeleport");
		return ptr;
	}


	class ATgProjectile* GetProjectile();
	bool STATIC_DoTeleport(const struct FVector& vLocation, const struct FVector& vClientLocation);
	bool STATIC_ServerTeleportToProjectile(const struct FVector& vClientLocation);
	bool STATIC_TeleportToProjectile();
	bool Use();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_Range_UsesSelfFiringInstance
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Range_UsesSelfFiringInstance : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Range_UsesSelfFiringInstance");
		return ptr;
	}

};


// Class TgGame.TgDevice_TeamDevice
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_TeamDevice : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TeamDevice");
		return ptr;
	}


	void STATIC_TeamFlashCooldown(unsigned char nMode);
	void STATIC_TeamGotoState(const struct FName& NewState);
	void STATIC_TeamCooldownEnd();
	void STATIC_TeamCooldownReset(int nMode, float fCooldownTime);
	void STATIC_TeamCooldownStart(int nMode, float fCooldownTime);
	void STATIC_TeamCooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void EndCooldown();
	void ResetCooldown(int nMode, float fCooldownTimeOverride);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void ToggleCooldownEffects(bool bOnCooldown);
	void STATIC_FlashCooldown(unsigned char nMode);
	void STATIC_CheckAndUpdateCooldown();
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce();
	class UTgTimerManager* STATIC_GetCooldownTimerManager();
};


// Class TgGame.TgDevice_ReverseCone
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_ReverseCone : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ReverseCone");
		return ptr;
	}


	void STATIC_GetConeTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Satyr_Ability_S8
// 0x0058 (0x0548 - 0x04F0)
class ATgDevice_Satyr_Ability_S8 : public ATgDevice
{
public:
	float                                              m_fAngleOffset;                                           // 0x04F0(0x0004) (Const)
	float                                              m_fFrontRowOffset;                                        // 0x04F4(0x0004) (Const)
	float                                              m_fBackRowOffset;                                         // 0x04F8(0x0004) (Const)
	class ATgPawn*                                     s_satyr;                                                  // 0x04FC(0x0008)
	TArray<class ATgPawn*>                             s_miniSatyrList;                                          // 0x0504(0x0010) (NeedCtorLink)
	unsigned long                                      m_bSpawnFrontRow : 1;                                     // 0x0514(0x0004)
	struct FVector                                     m_vFrontLeft;                                             // 0x0518(0x000C)
	struct FVector                                     m_vFrontRight;                                            // 0x0524(0x000C)
	struct FVector                                     m_vBackLeft;                                              // 0x0530(0x000C)
	struct FVector                                     m_vBackRight;                                             // 0x053C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Satyr_Ability_S8");
		return ptr;
	}


	void STATIC_CustomFire();
	void KillAllSatyrs();
	void STATIC_SpawnMiniSatyr(const struct FVector& vSpawnLoc);
	void STATIC_CalcSatyrSpawnPosition(const struct FVector& vTargetLoc);
};


// Class TgGame.TgDevice_Sequenced
// 0x0024 (0x0514 - 0x04F0)
class ATgDevice_Sequenced : public ATgDevice
{
public:
	int                                                r_NextDeviceId;                                           // 0x04F0(0x0004) (Net)
	TArray<class ATgDevice_Sequenced*>                 m_Sequence;                                               // 0x04F4(0x0010) (NeedCtorLink)
	class ATgDevice_Sequenced*                         m_RootDevice;                                             // 0x0504(0x0008)
	float                                              r_RetriggerTimeLimit;                                     // 0x050C(0x0004) (Net)
	unsigned long                                      m_ForceNoFire : 1;                                        // 0x0510(0x0004)
	unsigned long                                      r_IsAnActiveSequence : 1;                                 // 0x0510(0x0004) (Net)
	unsigned long                                      r_TriggerComboAtEnd : 1;                                  // 0x0510(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sequenced");
		return ptr;
	}


	class ATgDevice_Sequenced* STATIC_GetNextChildInSequence();
	void STATIC_PushNextDevice();
	void STATIC_PopToRootDevice();
	void STATIC_RetriggerTimeExpired();
	void STATIC_DeinitializeInSequence();
	void STATIC_InitializeInSequence(class ATgDevice_Sequenced* rootDevice);
	bool AllowNextDeviceInSequence();
	bool ShouldCooldownAfterFire();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void HandleComboTrigger();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetFireMode(int FireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int Points);
	bool IsDeviceCoolingDown();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void UpdateManaUseVitals(class ATgPlayerController* PC);
	bool IsRootDevice();
};


// Class TgGame.TgDevice_Sequenced_RadialSweep
// 0x0024 (0x0538 - 0x0514)
class ATgDevice_Sequenced_RadialSweep : public ATgDevice_Sequenced
{
public:
	class ATgCollisionProxy_RadialSweep*               m_CollisionProxy;                                         // 0x0514(0x0008)
	TArray<class AActor*>                              m_HitActors;                                              // 0x051C(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               m_SweepFiremode;                                          // 0x052C(0x0008)
	unsigned long                                      m_bForceEndSweepOnStopFire : 1;                           // 0x0534(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sequenced_RadialSweep");
		return ptr;
	}


	void Destroyed();
	bool STATIC_CanRadialSweep();
	bool IsSweepActive();
	float GetPersistTime(int nMode);
	void STATIC_OnApplyHitFromTouch(class UTgDeviceFire* FireMode, struct FImpactInfo* Impact);
	void ProxyEndSweep(bool bInterrupt);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UpdateCollisionProxyDelegates();
};


// Class TgGame.TgDevice_ShieldedRecall
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_ShieldedRecall : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ShieldedRecall");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanBeInterrupted();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_SixRank
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_SixRank : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SixRank");
		return ptr;
	}


	int STATIC_GetTotalDevicePoints();
	bool STATIC_HasBeenTrained();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_SpecialItem
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_SpecialItem : public ATgDevice
{
public:
	int                                                m_nMaxSpecialItems;                                       // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SpecialItem");
		return ptr;
	}


	void ApplySpecialItems(TArray<int> EnabledItemIds, TArray<int> DisabledItemIds, unsigned char eTargeterType);
	void STATIC_GrabSpecialItemsIds(class UTgDeviceFire* devFire, TArray<int>* SpecialItemIds);
	void STATIC_SpecialItemSetup(class UTgDeviceFire* currentFire, class UTgDeviceFire* PreviousFire);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Spline
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Spline : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgSplineDeviceInterface;                         // 0x04F0(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Spline");
		return ptr;
	}


	void GetAdjustedAimSpline(int nShotIndex, struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
	bool STATIC_CalculateFlightPath(int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Staging
// 0x0038 (0x0528 - 0x04F0)
class ATgDevice_Staging : public ATgDevice
{
public:
	TArray<int>                                        m_LockOutExceptionList;                                   // 0x04F0(0x0010) (NeedCtorLink)
	TEnumAsByte<EBlockAegisType>                       m_eBlockAegis;                                            // 0x0500(0x0001) (Const)
	TEnumAsByte<EBlockAegisType>                       m_eBlockNonTargetingPurchaseables;                        // 0x0501(0x0001) (Const)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0502(0x0002) MISSED OFFSET
	unsigned long                                      m_bCanBeGrabSource : 1;                                   // 0x0504(0x0004) (Const)
	unsigned long                                      s_bShouldFireStageShooterOnEndStage : 1;                  // 0x0504(0x0004) (Const)
	unsigned long                                      s_bReplicateFireOnEndStageToClient : 1;                   // 0x0504(0x0004) (Const)
	unsigned long                                      m_bStageShooterFired : 1;                                 // 0x0504(0x0004)
	unsigned long                                      m_bAllowStageShooterToFire : 1;                           // 0x0504(0x0004) (Transient)
	unsigned long                                      m_bSwapInHandOnShooterStopFire : 1;                       // 0x0504(0x0004)
	unsigned long                                      c_bLockStageShooterFiring : 1;                            // 0x0504(0x0004)
	unsigned long                                      m_bStartStagingDuringFireAmmunition : 1;                  // 0x0504(0x0004)
	class ATgDevice*                                   r_StageShooter;                                           // 0x0508(0x0008) (Net, Transient)
	int                                                m_nStageShooterId;                                        // 0x0510(0x0004) (Const)
	class ATgDevice*                                   s_StoredInHand;                                           // 0x0514(0x0008)
	struct FVector                                     m_vInHandFiringOffset;                                    // 0x051C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Staging");
		return ptr;
	}


	void STATIC_EndPreStaging(bool bInterrupted);
	void STATIC_StartPreStaging();
	bool STATIC_InStage();
	bool STATIC_InPreStage();
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_ChangeInHandFiringOffset(bool bUsingStageShooter);
	void STATIC_ClientSwapOutShooter();
	void SwapOutShooter();
	void STATIC_ClientSwapInShooter();
	void STATIC_SwapInShooter();
	bool STATIC_EndStage(bool bInterrupted);
	bool STATIC_StartStage();
	void STATIC_FireAmmunition();
	void OnStageShooterStopFire(bool bInterrupted);
	bool STATIC_ShouldSwapInHandOnShooterStopFire();
	void OnStageShooterFire();
	void OnStageShooterStartFire();
	void OnStageShooterStopBuildup(bool bInterrupted);
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	bool STATIC_ShouldSetStageShooterFired();
	bool STATIC_ClientFireOnEndStage();
	bool STATIC_FireEndStageDevice();
	void STATIC_ClientLockStageShooterFiring(bool bLock);
	bool LockStageShooterFiring();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanBeCanceled();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
};


// Class TgGame.TgDevice_StagingRefresh
// 0x0004 (0x052C - 0x0528)
class ATgDevice_StagingRefresh : public ATgDevice_Staging
{
public:
	float                                              s_fCachedPostHitTime;                                     // 0x0528(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_StagingRefresh");
		return ptr;
	}


	void OnStageShooterStopFire(bool bInterrupted);
	float STATIC_GetRefreshTime();
	bool STATIC_CanRefreshPostHitDelay();
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	void STATIC_ClientLockStageShooterFiring(bool bLock);
	bool LockStageShooterFiring();
	void STATIC_ClientInterrupt();
	void STATIC_ClientResumePostHitDelay(float fTimeRemaining);
	void STATIC_ClientPausePostHitDelay();
	bool STATIC_ResumePostHitDelay(float fTimeRemaining);
	bool STATIC_PausePostHitDelay(float* fTimeRemaining);
};


// Class TgGame.TgDevice_Staging_MultiBase
// 0x005C (0x054C - 0x04F0)
class ATgDevice_Staging_MultiBase : public ATgDevice
{
public:
	TArray<int>                                        m_LockOutExceptionList;                                   // 0x04F0(0x0010) (NeedCtorLink)
	TEnumAsByte<EBlockAegisType>                       m_eBlockAegis;                                            // 0x0500(0x0001) (Const)
	TEnumAsByte<EBlockAegisType>                       m_eBlockNonTargetingPurchaseables;                        // 0x0501(0x0001) (Const)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0502(0x0002) MISSED OFFSET
	unsigned long                                      m_bCanBeGrabSource : 1;                                   // 0x0504(0x0004) (Const)
	unsigned long                                      r_bAnyShooterHasFired : 1;                                // 0x0504(0x0004) (Net)
	unsigned long                                      m_bAllowShooterToFire : 1;                                // 0x0504(0x0004) (Transient)
	unsigned long                                      c_bLockShooterFiring : 1;                                 // 0x0504(0x0004)
	unsigned long                                      m_bBlockPreStagingAnim : 1;                               // 0x0504(0x0004)
	unsigned long                                      m_bBlockPostStagingAnim : 1;                              // 0x0504(0x0004)
	unsigned long                                      m_bDeferAimToShooters : 1;                                // 0x0504(0x0004)
	unsigned long                                      m_bForceFirstShooterWhenReady : 1;                        // 0x0504(0x0004)
	class ATgDevice*                                   r_FirstShooter;                                           // 0x0508(0x0008) (Net)
	class ATgDevice*                                   r_CurrentShooter;                                         // 0x0510(0x0008) (Net, Transient)
	int                                                r_nCurrentShooterIndex;                                   // 0x0518(0x0004) (Net)
	TArray<class ATgDevice*>                           r_Shooters;                                               // 0x051C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        m_nShooterIds;                                            // 0x052C(0x0010) (Const, NeedCtorLink)
	TArray<unsigned long>                              m_bShooterFired;                                          // 0x053C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Staging_MultiBase");
		return ptr;
	}


	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
	void STATIC_ClientSwapOutCurrentShooter();
	void SwapOutCurrentShooter();
	void STATIC_ClientSwapInNextShooter();
	void STATIC_SwapInNextShooter();
	void STATIC_EndPostStage(bool bInterrupted);
	bool InPostStage();
	void STATIC_StartPostStage();
	bool STATIC_EndStage(bool bInterrupted);
	bool STATIC_StartStage();
	void STATIC_EndPreStage(bool bInterrupted);
	bool STATIC_InStage();
	bool STATIC_InPreStage();
	void STATIC_StartPreStage();
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void InterruptAllShooters();
	void InterruptFiring();
	void StopFire();
	void StopAllAnim();
	void StartPostStagingAnim();
	void StartShooterPostFireAnim(class ATgDevice* Dev);
	void StartShooterFireAnim(class ATgDevice* Dev);
	void StartShooterPreFireAnim(class ATgDevice* Dev);
	void StartPreStagingAnim();
	void SetActiveAnimChild(int nChild);
	void OnShooterStopFire(bool bInterrupted);
	void OnShooterFire();
	void OnShooterStartFire();
	void OnShooterStopBuildup(bool bInterrupted);
	void OnShooterStartBuildup();
	void STATIC_SetAllShootersFired(bool bFired);
	void STATIC_SetShooterFired(class ATgDevice* Dev, bool bFired);
	bool STATIC_ShouldSetShooterFired(class ATgDevice* Dev);
	bool AnyShooterHasFired();
	bool STATIC_ShooterHasFired(class ATgDevice* Dev);
	class ATgDevice* STATIC_GetNextShooter(class ATgDevice* Dev);
	class ATgDevice* GetFirstShooter();
	int STATIC_GetShooterIndex(class ATgDevice* Dev);
	void STATIC_ClientLockShooterFiring(bool bLock);
	bool LockShooterFiring();
	float STATIC_GetLockoutExtensionTime();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanStagingBeInterrupted();
	bool CanBeInterrupted();
	bool CanStagingBeCanceled();
	bool CanBeCanceled();
	bool ForceFirstShooter();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
};


// Class TgGame.TgDevice_TauntTowardsPawn
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_TauntTowardsPawn : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TauntTowardsPawn");
		return ptr;
	}


	void STATIC_ServerStartTaunt(class AActor* Other);
};


// Class TgGame.TgDevice_TimerFromParent
// 0x0006 (0x04F6 - 0x04F0)
class ATgDevice_TimerFromParent : public ATgDevice
{
public:
	unsigned long                                      m_bUsesDistanceScaleTimer : 1;                            // 0x04F0(0x0004)
	TEnumAsByte<ETargetingTimerCheckpointType>         m_eStartTimerCheckpoint;                                  // 0x04F4(0x0001)
	TEnumAsByte<ETargetingTimerCheckpointType>         m_eStopTimerCheckpoint;                                   // 0x04F5(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TimerFromParent");
		return ptr;
	}

};


// Class TgGame.TgDevice_AnvilSlamBase
// 0x0012 (0x0508 - 0x04F6)
class ATgDevice_AnvilSlamBase : public ATgDevice_TimerFromParent
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x04F6(0x0002) MISSED OFFSET
	unsigned long                                      m_bDoTimeOutJump : 1;                                     // 0x04F8(0x0004)
	unsigned long                                      m_bUseBackupLocation : 1;                                 // 0x04F8(0x0004)
	struct FVector                                     m_vBackupLocation;                                        // 0x04FC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AnvilSlamBase");
		return ptr;
	}


	bool CanBeCanceled();
	bool ApplyGlobalOffhandCooldown();
	bool ShouldInterruptInhand();
	bool TriggerTimeOutJump();
	void UpdateBackupLocation(const struct FVector& vLoc);
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Toggle
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Toggle : public ATgDevice
{
public:
	unsigned long                                      m_bIsToggle : 1;                                          // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Toggle");
		return ptr;
	}


	bool STATIC_ShouldInterruptReload();
	bool STATIC_CanBeRetoggled();
	bool CanBeInterrupted();
	bool IsToggleDevice();
	void InterruptFiring();
	bool StartFire();
	bool STATIC_CanDeviceFireInTargetingMode();
	bool IsToggledOn();
	void UpdateUIToggleState();
};


// Class TgGame.TgDevice_TriggerItemsOnFire
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_TriggerItemsOnFire : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TriggerItemsOnFire");
		return ptr;
	}


	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
};


// Class TgGame.TgDevice_TweenBase
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_TweenBase : public ATgDevice
{
public:
	TEnumAsByte<ETweenState>                           m_eTweenState;                                            // 0x04F0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F1(0x0003) MISSED OFFSET
	unsigned long                                      m_bFixedTweenTime : 1;                                    // 0x04F4(0x0004)
	unsigned long                                      m_bIsInPreHit : 1;                                        // 0x04F4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TweenBase");
		return ptr;
	}


	void STATIC_OnTweenEnd(bool bInterrupted);
	void STATIC_OnTweenStart();
	struct FVector GetTweenLocation(struct FAimData* Aim);
	float STATIC_GetTweenTime();
	float GetTweenTimeNative();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_LionAdv_Pounce
// 0x0004 (0x04FC - 0x04F8)
class ATgDevice_LionAdv_Pounce : public ATgDevice_TweenBase
{
public:
	unsigned long                                      s_bUsingCachedAim : 1;                                    // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LionAdv_Pounce");
		return ptr;
	}


	void DeliverQueuedPendingHits();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	bool UsesCachedAim();
};


// Class TgGame.TgDevice_MOB_GenericLeap
// 0x0004 (0x04FC - 0x04F8)
class ATgDevice_MOB_GenericLeap : public ATgDevice_TweenBase
{
public:
	unsigned long                                      s_bUsingCachedAim : 1;                                    // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_MOB_GenericLeap");
		return ptr;
	}


	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	bool UsesCachedAim();
};


// Class TgGame.TgDevice_CH05_BDK_Elite_Leap
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_CH05_BDK_Elite_Leap : public ATgDevice_MOB_GenericLeap
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_BDK_Elite_Leap");
		return ptr;
	}


	struct FVector GetTweenLocation(struct FAimData* Aim);
};


// Class TgGame.TgDevice_TwoPhase
// 0x0018 (0x0508 - 0x04F0)
class ATgDevice_TwoPhase : public ATgDevice
{
public:
	TEnumAsByte<ETwoPhaseState>                        m_eLocalState;                                            // 0x04F0(0x0001)
	TEnumAsByte<ETwoPhaseCustomValueType>              m_eCustomValueType;                                       // 0x04F1(0x0001) (Const)
	unsigned char                                      UnknownData00[0x2];                                       // 0x04F2(0x0002) MISSED OFFSET
	unsigned long                                      m_bDeductCooldownTime : 1;                                // 0x04F4(0x0004) (Const)
	unsigned long                                      m_bCacheCooldownInfoOnStopFire : 1;                       // 0x04F4(0x0004)
	float                                              m_fStopFireTimeStamp;                                     // 0x04F8(0x0004)
	float                                              m_fCachedCooldownTime;                                    // 0x04FC(0x0004)
	class UTgDeviceFire*                               m_CachedFireMode;                                         // 0x0500(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_TwoPhase");
		return ptr;
	}


	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_FireAmmunition();
	void STATIC_SetAltFireReady();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void STATIC_HandleFiringRejection();
	void InterruptFiring();
	void STATIC_ClientSetState(TEnumAsByte<ETwoPhaseState> NewState);
	void SetState(TEnumAsByte<ETwoPhaseState> NewState, bool bStartCooldown);
	void STATIC_OnStateSet(TEnumAsByte<ETwoPhaseState> PrevState, TEnumAsByte<ETwoPhaseState> CurrentState);
	void STATIC_SelectStopFiringState();
	void ExpireTarget();
	bool ShouldCooldownAfterFire();
	bool CanUseToggle();
	unsigned char STATIC_IncrementFiringInstance();
	float STATIC_GetToggleMaxTime(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetBuildupTime(int nMode);
};


// Class TgGame.TgDevice_Gateway
// 0x001C (0x0524 - 0x0508)
class ATgDevice_Gateway : public ATgDevice_TwoPhase
{
public:
	class ATgDeployable_GatewayEntrance*               m_gatewayEntrance;                                        // 0x0508(0x0008)
	class ATgDeployable_GatewayExit*                   m_gatewayExit;                                            // 0x0510(0x0008)
	struct FVector                                     r_vEntranceLocation;                                      // 0x0518(0x000C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Gateway");
		return ptr;
	}


	int GetDeployableId();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	float STATIC_GetToggleMaxTime(int nMode);
};


// Class TgGame.TgDevice_WarningDeployable
// 0x002C (0x051C - 0x04F0)
class ATgDevice_WarningDeployable : public ATgDevice
{
public:
	int                                                m_nWarningDeployableId;                                   // 0x04F0(0x0004) (Const)
	struct FPointer                                    m_pWarningDeployableSetup;                                // 0x04F4(0x0008) (Native)
	class ATgDeployable*                               m_LastWarningDeployable;                                  // 0x04FC(0x0008)
	TArray<struct FWarningDeployableInfo>              m_WarningDeployableInfos;                                 // 0x0504(0x0010) (NeedCtorLink)
	TEnumAsByte<EWarningDeployableTimingType>          m_eDeployTiming;                                          // 0x0514(0x0001)
	TEnumAsByte<EWarningDeployableTimingType>          m_eDestroyTiming;                                         // 0x0515(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0516(0x0002) MISSED OFFSET
	unsigned long                                      m_bCachedValidSetup : 1;                                  // 0x0518(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WarningDeployable");
		return ptr;
	}


	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	class AProjectile* STATIC_ProjectileFire(int nProjectileIndex);
	void STATIC_FireAmmunition();
	void STATIC_GetWarningAim(struct FAimData* Aim);
	void STATIC_DestroyWarningDeployable(class ATgProjectile* Proj);
	void STATIC_SpawnWarningDeployable();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_WithAmmo
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_WithAmmo : public ATgDevice
{
public:
	int                                                r_nAmmoCount;                                             // 0x04F0(0x0004) (Net)
	int                                                m_nMaxAmmoCount;                                          // 0x04F4(0x0004)
	unsigned long                                      m_bReplenishAmmoOnEndCooldown : 1;                        // 0x04F8(0x0004)
	unsigned long                                      m_bLoadAmmoOnInit : 1;                                    // 0x04F8(0x0004)
	float                                              m_fForceCooldownTime;                                     // 0x04FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WithAmmo");
		return ptr;
	}


	void SetAmmoCount(int nAmmoCount, bool bDoNotFowardToClient);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void ResetCooldown(int nMode, float fCooldownTimeOverride);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
	bool ApplyGlobalOffhandCooldown();
	void STATIC_ForceIntoCooldown();
	void ConsumeAllAmmo();
	void ReplenishAllAmmo();
	float GetAmmoCount();
};


// Class TgGame.TgDevice_Painting
// 0x0014 (0x0514 - 0x0500)
class ATgDevice_Painting : public ATgDevice_WithAmmo
{
public:
	struct FVector                                     m_vLastDeployLocation;                                    // 0x0500(0x000C)
	float                                              m_fDistanceBetweenDeployables;                            // 0x050C(0x0004)
	unsigned long                                      m_bDeployHoneyFromTargetingChange : 1;                    // 0x0510(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Painting");
		return ptr;
	}


	void STATIC_CustomFire();
	void DeployNextHoney();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool ShouldCooldownAfterFire();
	bool ApplyGlobalOffhandCooldown();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_WithAmmo_Additive
// 0x0008 (0x0508 - 0x0500)
class ATgDevice_WithAmmo_Additive : public ATgDevice_WithAmmo
{
public:
	unsigned long                                      m_bAllowRespawnRestore : 1;                               // 0x0500(0x0004)
	unsigned long                                      m_bOwnerWasDead : 1;                                      // 0x0500(0x0004)
	float                                              r_fAmmoReplenishTime;                                     // 0x0504(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WithAmmo_Additive");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void ResetCooldown(int nMode, float fCooldownTimeOverride);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void GrantAmmoCount(int nAmmoCount);
	void GrantAmmo();
	float GetRegainTime();
	float GetAmmoReplenishTime();
};


// Class TgGame.TgDeviceFire
// 0x0160 (0x01C0 - 0x0060)
class UTgDeviceFire : public UObject
{
public:
	class AActor*                                      m_Owner;                                                  // 0x0060(0x0008)
	TEnumAsByte<EWeaponFireType>                       m_nFireType;                                              // 0x0068(0x0001)
	TEnumAsByte<EDeviceTargetMode>                     m_eTargetingMode;                                         // 0x0069(0x0001)
	TEnumAsByte<EDeviceTargeterType>                   m_eTargeterType;                                          // 0x006A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x006B(0x0001) MISSED OFFSET
	unsigned long                                      m_bIsAOE : 1;                                             // 0x006C(0x0004)
	unsigned long                                      m_bIsCone : 1;                                            // 0x006C(0x0004)
	unsigned long                                      m_bIsLinear : 1;                                          // 0x006C(0x0004)
	unsigned long                                      m_bIsRollingLinear : 1;                                   // 0x006C(0x0004)
	unsigned long                                      m_bApplyInitialHit : 1;                                   // 0x006C(0x0004)
	unsigned long                                      m_bContinuousFire : 1;                                    // 0x006C(0x0004)
	unsigned long                                      m_bRequireLOS : 1;                                        // 0x006C(0x0004)
	unsigned long                                      m_bDoNotPauseAIDuringBuildup : 1;                         // 0x006C(0x0004)
	unsigned long                                      m_bVerifyTargetPlacement : 1;                             // 0x006C(0x0004)
	unsigned long                                      m_bAllowPetDomination : 1;                                // 0x006C(0x0004)
	unsigned long                                      m_bUseTargetingEncroachmentActor : 1;                     // 0x006C(0x0004) (Const)
	TArray<class UTgEffectGroup*>                      s_EffectGroupList;                                        // 0x0070(0x0010) (NeedCtorLink)
	TArray<struct FTgPropertyInstance>                 m_Properties;                                             // 0x0080(0x0010) (NeedCtorLink)
	TArray<struct FTGDFM_ANIM_SEQUENCE>                s_AnimSeqArrayRightSide;                                  // 0x0090(0x0010) (NeedCtorLink)
	TArray<struct FTGDFM_ANIM_SEQUENCE>                s_AnimSeqArrayLeftSide;                                   // 0x00A0(0x0010) (NeedCtorLink)
	struct FPointer                                    m_pAmSetup;                                               // 0x00B0(0x0008) (Native)
	struct FPointer                                    m_pFireModeSetup;                                         // 0x00B8(0x0008) (Native)
	int                                                m_nId;                                                    // 0x00C0(0x0004)
	struct FPointer                                    m_pwzDeviceFireName;                                      // 0x00C4(0x0008) (Native)
	int                                                m_nAttackType;                                            // 0x00CC(0x0004)
	int                                                m_nMovementType;                                          // 0x00D0(0x0004)
	struct FName                                       m_nmOffhandAnimationType;                                 // 0x00D4(0x0008)
	int                                                m_nTargetAffectsType;                                     // 0x00DC(0x0004)
	struct FName                                       c_nmZoomScopeMaterial;                                    // 0x00E0(0x0008)
	int                                                m_nAllowUseWhileFlags;                                    // 0x00E8(0x0004)
	int                                                m_nDamageType;                                            // 0x00EC(0x0004)
	int                                                m_nArcingJumps;                                           // 0x00F0(0x0004)
	int                                                m_nVisionRangeIndex;                                      // 0x00F4(0x0004)
	int                                                m_nProximityDistanceIndex;                                // 0x00F8(0x0004)
	int                                                m_nRangeIndex;                                            // 0x00FC(0x0004)
	int                                                m_nMinRangeIndex;                                         // 0x0100(0x0004)
	int                                                m_nConeAttackAngleIndex;                                  // 0x0104(0x0004)
	int                                                m_nDamageRadiusIndex;                                     // 0x0108(0x0004)
	int                                                m_nAccuracyIndex;                                         // 0x010C(0x0004)
	int                                                m_nAccuracyCrouchIndex;                                   // 0x0110(0x0004)
	int                                                m_nAccuracySprintIndex;                                   // 0x0114(0x0004)
	int                                                m_nAccuracyWalkIndex;                                     // 0x0118(0x0004)
	int                                                m_nAccuracyLossMaxIndex;                                  // 0x011C(0x0004)
	int                                                m_nEffectiveRangeIndex;                                   // 0x0120(0x0004)
	int                                                m_nInterruptChanceIndex;                                  // 0x0124(0x0004)
	int                                                s_nMaxDeployableIndex;                                    // 0x0128(0x0004)
	int                                                m_nCoolDownTimeIndex;                                     // 0x012C(0x0004)
	int                                                m_nActivationTimeIndex;                                   // 0x0130(0x0004)
	int                                                m_nEffectiveRadiusIndex;                                  // 0x0134(0x0004)
	int                                                m_nMinimumRadiusIndex;                                    // 0x0138(0x0004)
	int                                                s_nPetLifeSpanIndex;                                      // 0x013C(0x0004)
	int                                                s_nProjectileSpeedIndex;                                  // 0x0140(0x0004)
	int                                                m_nCustomValue1Index;                                     // 0x0144(0x0004)
	int                                                m_nCustomValue2Index;                                     // 0x0148(0x0004)
	int                                                m_nCustomValue3Index;                                     // 0x014C(0x0004)
	int                                                m_nCustomValue4Index;                                     // 0x0150(0x0004)
	int                                                m_nCustomValue5Index;                                     // 0x0154(0x0004)
	int                                                m_nAIDeviceRangeIndex;                                    // 0x0158(0x0004)
	int                                                m_nAIDeviceRadiusIndex;                                   // 0x015C(0x0004)
	int                                                m_nAIDamageBaseIndex;                                     // 0x0160(0x0004)
	int                                                m_nAIDamageScalingIndex;                                  // 0x0164(0x0004)
	float                                              m_fHealthCost;                                            // 0x0168(0x0004)
	float                                              m_fManaCost;                                              // 0x016C(0x0004)
	float                                              m_fEnergyCost;                                            // 0x0170(0x0004)
	float                                              m_fFireTime;                                              // 0x0174(0x0004)
	float                                              m_fEquipTime;                                             // 0x0178(0x0004)
	float                                              m_fBuildupTime;                                           // 0x017C(0x0004)
	float                                              m_fFirePreHitDelay;                                       // 0x0180(0x0004)
	float                                              m_fFirePostHitDelay;                                      // 0x0184(0x0004)
	float                                              m_fChainAnimSwingTime;                                    // 0x0188(0x0004)
	float                                              s_fMaxControlRange;                                       // 0x018C(0x0004)
	int                                                m_nShotsPerFire;                                          // 0x0190(0x0004)
	float                                              m_fTeamPassthroughDistance;                               // 0x0194(0x0004)
	float                                              m_fMeleeHitTime;                                          // 0x0198(0x0004)
	struct FName                                       m_nmDamageTypeClass;                                      // 0x019C(0x0008)
	float                                              m_fMaxTargetCount;                                        // 0x01A4(0x0004)
	float                                              m_fFullBodyAnimTime;                                      // 0x01A8(0x0004)
	float                                              m_fFireLockTime;                                          // 0x01AC(0x0004)
	float                                              m_fVisionRange;                                           // 0x01B0(0x0004)
	int                                                m_nTargetingEncroachmentActorOverride;                    // 0x01B4(0x0004) (Const)
	class AActor*                                      m_TargetingEncroachmentActor;                             // 0x01B8(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire");
		return ptr;
	}


	bool STATIC_SpawnPetFire();
	float GetConeAttackAngleOffset();
	float GetSignedConeAttackAngle();
	float GetConeAttackAngle();
	float GetContagiousRadius();
	void STATIC_PayAccuracyForWeaponSwitch();
	float GetCooldownTime();
	float GetFireLockTime();
	float GetChainAnimSwingTime();
	float GetPostHitDelay();
	float GetPreHitDelay();
	float GetBuildupTime();
	float GetRefireTime();
	float STATIC_GetEquipModeTime();
	bool ValidateApplyHit(const struct FImpactInfo& Impact);
	void STATIC_SubmitHitEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact, int nType);
	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	void TrackDeviceModeHit(class ATgPawn* Hitter, float fDistance, bool bHitPlayer);
	bool IsValidAOETarget(class ATgPawn* P, const struct FVector& vHitLocation, float fRadius);
	void RemoveHitSpecial(class AActor* Target, bool bForceRemove, int nHitSpecialSituationalType, int StackCount);
	void ApplyHitSpecial(class AActor* Target, const struct FImpactInfo& Impact, int nHitSpecialSituationalType, int StackCount);
	void RemoveEffectType(class AActor* Target, bool bForceRemove, int nEffectGroupType, int StackCount);
	void ApplyEffectType(class AActor* Target, int nEffectGroupType, const struct FImpactInfo& Impact, int StackCount);
	struct FString STATIC_GetTargetName(class AActor* TargetActor);
	bool IsValidTraceTarget(class AActor* P);
	void STATIC_DisplayMessage(const struct FString& sMessage);
	class ATgDevice* STATIC_CheckSimutainousFiring();
	float GetInterruptChance();
	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	void RemoveEquipEffects();
	void ApplyEquipEffects();
	void STATIC_DrawDebugQuad(float fExtentRadius, float fHeightOffset, struct FVector* vEnd, struct FVector* vStart, struct FLinearColor* ColorValue);
	void STATIC_DrawDebugTriangle(float fOuterRadius, struct FAimData* Aim);
	void STATIC_CalcTriangleFire(class AActor* actorDamageInstigator, bool bPredicting, float fOuterRadius, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_CalcTrapezoidQuadFire(class AActor* aDamageInstigator, const struct FAimData& Aim, float fFrontRadius, float fBackRadius, bool bPredicting, bool bDrawDebug, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcActorEncroachmentTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcChargeTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float fRange, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcDeployableTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, int nDeployableId, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcRollingLinearFire(const struct FRollingLineAttack& lineAttack, class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseProximityDistance, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcLinearFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseProximityDistance, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcArcingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcInstantFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcMeleeAttack(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, bool bPriorityFirst, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_CheckValidTarget(class AActor* Target, bool bPredicting);
	bool IsInSlice(class AActor* SourceActor, class AActor* TargetActor, const struct FVector& StartCone, const struct FVector& ConeDir, float ConeAngle, float ConeRadius);
	bool STATIC_ShouldAddToImpactList(class AActor* HitActor, TArray<struct FImpactInfo>* ImpactList);
	struct FVector STATIC_GetHitLocationToCenter(struct FVector* StartTrace, struct FVector* TargetLocation, struct FVector* TargetExtent);
	struct FVector STATIC_GetHitLocationFlat(struct FVector* StartTrace, struct FVector* TargetLocation, struct FVector* TargetExtent);
	bool IsBlockedByBlocker(class AActor* DamageInstigator, class AActor* Target, const struct FVector& originLocation);
	float LinePointDist(const struct FVector& A, const struct FVector& B, const struct FVector& Pt);
	int STATIC_GetDeviceIdFromMode();
	int STATIC_GetTopMostDeviceId();
	class ATgDevice* STATIC_GetTopMostDevice();
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
	float STATIC_GetShotPowerCost(int nPacingType, bool bBaseOnly);
	bool UsesActorEncroachmentForCalcTargetingFire();
	bool IsArcingAttack();
	bool IsRangedAttack();
	bool IsMeleeAttack();
	struct FImpactInfo STATIC_GetTraceImpact(const struct FVector& StartTrace, const struct FVector& EndTrace, const struct FVector& Extent, bool bIgnoreWorld, bool bCheckLockOn, bool MapVisionAssist);
	bool STATIC_IsEnemy(class AActor* TargetActor);
	bool IsSelfOrOwner(class AActor* Target);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
	bool STATIC_CheckTeamPassThrough(class AActor* HitActor);
	float STATIC_GetCustomValue5();
	float STATIC_GetCustomValue4();
	float STATIC_GetCustomValue3();
	float STATIC_GetCustomValue2();
	float STATIC_GetCustomValue1();
	int STATIC_GetShotsPerFire();
	int STATIC_GetMaxBotCount();
	int STATIC_GetMaxDeployableCount();
	int STATIC_GetMaxProjectileCount();
	bool IsWithinEffectiveRange(float fDistance);
	bool IsWithinRange(float fDistance);
	float STATIC_GetMinimumRadius();
	float STATIC_GetEffectiveRange();
	float STATIC_GetMinRange();
	float STATIC_GetRange();
	float STATIC_GetProximityDistance();
	float STATIC_GetPersistPulseTime();
	float GetPersistTime();
	float STATIC_GetVisionRange();
	float STATIC_GetProjectileSpeed();
	float STATIC_GetDeployTime();
	float STATIC_GetPetControlRange();
	float STATIC_GetPetLifeSpan();
	float STATIC_GetEffectiveRadius();
	float STATIC_GetRemoteActivationTime();
	float STATIC_GetAIScalingDamage();
	float STATIC_GetAIBaseDamage();
	float STATIC_GetAIRadius();
	float STATIC_GetAIRange();
	float STATIC_GetDamageRadius();
	float STATIC_GetTargetAccuracy();
	float STATIC_GetAccuracy();
	bool WillFireTrackingMissile();
	bool WillSpawnStickyProjectile();
	bool LogDebugInfo();
	void VerifyProjectile();
	struct FString STATIC_GetDeviceFireName();
	bool IsBlockedByGeometry(class AActor* SourceActor, class AActor* TargetActor);
	struct FName STATIC_QueryClass(int nMode);
	class UTgEffectGroup* STATIC_GetEffectGroup(int nType, int* nIndex);
	float STATIC_GetPropertyValueById(int nPropertyId, int nPropertyIndex);
	float STATIC_GetPropertyValue(int nPropertyId);
	void STATIC_TeleportFire();
	void STATIC_CustomFire();
	class ATgPawn* STATIC_SpawnPet(bool bPet);
	void STATIC_Deploy();
	void STATIC_InitializeProjectile(class AProjectile* Proj);
	class UClass* STATIC_GetProjectileClass();
};


// Class TgGame.TgDeviceFire_AdjustEffectValue
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_AdjustEffectValue : public UTgDeviceFire
{
public:
	float                                              m_fHealOverride;                                          // 0x01C0(0x0004)
	float                                              m_fDamageOverride;                                        // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AdjustEffectValue");
		return ptr;
	}


	bool AdjustDamageEffect(class UTgEffectDamage* effectDamage, const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	bool AdjustHealEffect(class UTgEffectHeal* effectHeal, const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_AlignedMonsterCamp
// 0x0010 (0x01D0 - 0x01C0)
class UTgDeviceFire_AlignedMonsterCamp : public UTgDeviceFire
{
public:
	TArray<int>                                        m_ValidBotRanks;                                          // 0x01C0(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AlignedMonsterCamp");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_ArcingBeam
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_ArcingBeam : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ArcingBeam");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_ArcMeleeRanged
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_ArcMeleeRanged : public UTgDeviceFire_ArcingBeam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ArcMeleeRanged");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_ArcingBeam_PVE
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_ArcingBeam_PVE : public UTgDeviceFire_ArcMeleeRanged
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ArcingBeam_PVE");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_AssassinsBlessing
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_AssassinsBlessing : public UTgDeviceFire
{
public:
	float                                              m_fHealOverride;                                          // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AssassinsBlessing");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_Blink
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Blink : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Blink");
		return ptr;
	}


	void STATIC_TeleportFire();
};


// Class TgGame.TgDeviceFire_NGM3Blink
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_NGM3Blink : public UTgDeviceFire_Blink
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NGM3Blink");
		return ptr;
	}


	void STATIC_TeleportFire();
};


// Class TgGame.TgDeviceFire_BotPointerSetup
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_BotPointerSetup : public UTgDeviceFire
{
public:
	struct FPointer                                    m_pBotSetup;                                              // 0x01C0(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BotPointerSetup");
		return ptr;
	}


	class ATgPawn* STATIC_SpawnPetAtLocation(bool bPet, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
};


// Class TgGame.TgDeviceFire_Breath_Inhand
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Breath_Inhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Breath_Inhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_BulwarkHope
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_BulwarkHope : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BulwarkHope");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	float STATIC_GetShieldBonus(class AActor* HitActor);
};


// Class TgGame.TgDeviceFire_CH05_BrittleBlast
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_CH05_BrittleBlast : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CH05_BrittleBlast");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_CH05_RemoveEffectOnHit
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_CH05_RemoveEffectOnHit : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CH05_RemoveEffectOnHit");
		return ptr;
	}


	void STATIC_RemoveCustomEffect(class AActor* TargetActor);
	void ApplyHitSpecial(class AActor* Target, const struct FImpactInfo& Impact, int nHitSpecialSituationalType, int StackCount);
	void STATIC_SubmitHitEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact, int nType);
};


// Class TgGame.TgDeviceFire_CH05_Steam
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_CH05_Steam : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CH05_Steam");
		return ptr;
	}


	void RemoveHitSpecial(class AActor* Target, bool bForceRemove, int nHitSpecialSituationalType, int StackCount);
	void ApplyHitSpecial(class AActor* Target, const struct FImpactInfo& Impact, int nHitSpecialSituationalType, int StackCount);
};


// Class TgGame.TgDeviceFire_CH05_WaterGun
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_CH05_WaterGun : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CH05_WaterGun");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcRollingLinearFire(const struct FRollingLineAttack& lineAttack, class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseProximityDistance, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_CH06_JaggedPillars
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_CH06_JaggedPillars : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CH06_JaggedPillars");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_ConditionalHitType
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_ConditionalHitType : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ConditionalHitType");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	bool STATIC_ShouldUseHitSpecial(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Deploy
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Deploy : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Deploy");
		return ptr;
	}


	void OnDeployableDeployComplete(class ATgDeployable* deployable);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_Apep_BasicAttack
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Apep_BasicAttack : public UTgDeviceFire_Deploy
{
public:
	struct FPointer                                    m_pDepSetup;                                              // 0x01C0(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Apep_BasicAttack");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_AutoPortal
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_AutoPortal : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AutoPortal");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_CH06_DropsOfSunlight
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_CH06_DropsOfSunlight : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CH06_DropsOfSunlight");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_DeployFromDeploy
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_DeployFromDeploy : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DeployFromDeploy");
		return ptr;
	}


	void STATIC_DeployAt(const struct FVector& vLocation, class AActor* FiringActor, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgDeviceFire_FireGiantGC2015a_MultiDeployable
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_FireGiantGC2015a_MultiDeployable : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_FireGiantGC2015a_MultiDeployable");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_FireGiantPVERounds_MultiDeployable
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_FireGiantPVERounds_MultiDeployable : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_FireGiantPVERounds_MultiDeployable");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_Hydra_Barrage
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Hydra_Barrage : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hydra_Barrage");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_Hydra_Mark
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Hydra_Mark : public UTgDeviceFire_Deploy
{
public:
	struct FPointer                                    m_pDepSetup;                                              // 0x01C0(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hydra_Mark");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_MultiDeploy
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_MultiDeploy : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MultiDeploy");
		return ptr;
	}


	class ATgDeployable* STATIC_SpawnDeployable(int nDeployIndex);
	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_DistanceThreshold
// 0x0010 (0x01D0 - 0x01C0)
class UTgDeviceFire_DistanceThreshold : public UTgDeviceFire
{
public:
	float                                              m_fDistanceThreshold;                                     // 0x01C0(0x0004) (Const)
	TEnumAsByte<EDistanceThresholdCheckType>           m_eCheckType;                                             // 0x01C4(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01C5(0x0003) MISSED OFFSET
	int                                                m_nThresholdHitType;                                      // 0x01C8(0x0004) (Const)
	int                                                m_nThresholdSituationalType;                              // 0x01CC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DistanceThreshold");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	bool STATIC_CheckHitSpecialThreshold(float fDistanceTraveled);
	float STATIC_GetDistanceThreshold();
};


// Class TgGame.TgDeviceFire_EvolvedHideOfUrchin_S5
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_EvolvedHideOfUrchin_S5 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_EvolvedHideOfUrchin_S5");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceFire_Flickering
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Flickering : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Flickering");
		return ptr;
	}


	void STATIC_TeleportFire();
};


// Class TgGame.TgDeviceFire_Fountain
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Fountain : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Fountain");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Gateway
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Gateway : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Gateway");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_GroundTarget_LockOn
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_GroundTarget_LockOn : public UTgDeviceFire
{
public:
	unsigned long                                      m_bHitsMulti : 1;                                         // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_GroundTarget_LockOn");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Kaldr_Aggro
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_Kaldr_Aggro : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Kaldr_Aggro");
		return ptr;
	}


	bool MatchesLastTarget(class AActor* Target);
};


// Class TgGame.TgDeviceFire_HandOfTheGods
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_HandOfTheGods : public UTgDeviceFire
{
public:
	unsigned long                                      m_IgnoreBosses : 1;                                       // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HandOfTheGods");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_WrathOfTheGods
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_WrathOfTheGods : public UTgDeviceFire_HandOfTheGods
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_WrathOfTheGods");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	bool IsObjectiveMonster(class AActor* TargetActor);
};


// Class TgGame.TgDeviceFire_HitAsInHand
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_HitAsInHand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HitAsInHand");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_HitInMesh
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_HitInMesh : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HitInMesh");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Horus_AltAuto
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Horus_AltAuto : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Horus_AltAuto");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Intoxicate_PVE
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Intoxicate_PVE : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Intoxicate_PVE");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_LayeredBuffEffects
// 0x0001 (0x01C1 - 0x01C0)
class UTgDeviceFire_LayeredBuffEffects : public UTgDeviceFire
{
public:
	TEnumAsByte<ELayeredBuffEffects>                   m_eLayeredBuffEffect;                                     // 0x01C0(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_LayeredBuffEffects");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void STATIC_RemoveLayeredBuffFlag(class ATgPawn* Pawn);
	void ApplyLayeredBuffFlag(class ATgPawn* Pawn);
};


// Class TgGame.TgDeviceFire_LineTarget_LockOn
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_LineTarget_LockOn : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_LineTarget_LockOn");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcLinearFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseProximityDistance, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_LocalTidi
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_LocalTidi : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_LocalTidi");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	float STATIC_GetEnemyTiDi();
	float STATIC_GetFriendlyTiDi();
	void STATIC_RemoveLocalTiDiEffect(class UTgEffectGroup* EffectGroup, class AActor* ATarget, int nStackCount);
	void STATIC_ProcessLocalTiDiEffect(class UTgEffectGroup* EffectGroup, class AActor* ATarget, int nStackCount);
	void STATIC_SubmitTiDiEffect(class UTgEffectGroup* EffectGroup, bool bRemove, int nStackCount, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceFire_MapTargetLockOn
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_MapTargetLockOn : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MapTargetLockOn");
		return ptr;
	}


	void STATIC_TeleportFire();
	bool IsValidTargetRepInfo(class AReplicationInfo* RepInfo);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_MapTargetTeleportGod
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_MapTargetTeleportGod : public UTgDeviceFire_MapTargetLockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MapTargetTeleportGod");
		return ptr;
	}


	void STATIC_TeleportFire();
	bool IsValidTargetRepInfo(class AReplicationInfo* RepInfo);
};


// Class TgGame.TgDeviceFire_RallyingRitual
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_RallyingRitual : public UTgDeviceFire_MapTargetTeleportGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RallyingRitual");
		return ptr;
	}


	bool IsValidTargetRepInfo(class AReplicationInfo* RepInfo);
};


// Class TgGame.TgDeviceFire_MapTargetTeleportTower
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_MapTargetTeleportTower : public UTgDeviceFire_MapTargetLockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MapTargetTeleportTower");
		return ptr;
	}


	bool IsValidTargetRepInfo(class AReplicationInfo* RepInfo);
};


// Class TgGame.TgDeviceFire_MapTargetTeleportWard
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_MapTargetTeleportWard : public UTgDeviceFire_MapTargetLockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MapTargetTeleportWard");
		return ptr;
	}


	bool IsValidTargetRepInfo(class AReplicationInfo* RepInfo);
};


// Class TgGame.TgDeviceFire_TeleportSiegeVariant
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_TeleportSiegeVariant : public UTgDeviceFire_MapTargetLockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_TeleportSiegeVariant");
		return ptr;
	}


	void STATIC_TeleportFire();
};


// Class TgGame.TgDeviceFire_MinionBuff
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_MinionBuff : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MinionBuff");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_MOB_MinionSpawn
// 0x0028 (0x01E8 - 0x01C0)
class UTgDeviceFire_MOB_MinionSpawn : public UTgDeviceFire
{
public:
	int                                                m_nNextSpawnIndex;                                        // 0x01C0(0x0004)
	TArray<class ATgPawn*>                             m_MinionList;                                             // 0x01C4(0x0010) (NeedCtorLink)
	unsigned long                                      m_bCachedPet : 1;                                         // 0x01D4(0x0004)
	int                                                m_nCachedLaneId;                                          // 0x01D8(0x0004)
	class UTgAISquad*                                  m_CachedSquad;                                            // 0x01DC(0x0008)
	float                                              m_fCachedStaggerTime;                                     // 0x01E4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_MOB_MinionSpawn");
		return ptr;
	}


	int STATIC_GetCurrentMinionCount();
	int STATIC_GetSpawnCount();
	void STATIC_ForceRemainderToSpawn();
	class ATgPawn* STATIC_SpawnNext(bool bSetTimer);
	class ATgPawn* STATIC_SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_CH06_MinionSpawn
// 0x0010 (0x01F8 - 0x01E8)
class UTgDeviceFire_CH06_MinionSpawn : public UTgDeviceFire_MOB_MinionSpawn
{
public:
	TArray<int>                                        m_BotIdSpawnQueue;                                        // 0x01E8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CH06_MinionSpawn");
		return ptr;
	}


	int STATIC_GetMaxBotCount();
	void BuildQueue();
};


// Class TgGame.TgDeviceFire_CH06_SummonSword
// 0x0010 (0x01F8 - 0x01E8)
class UTgDeviceFire_CH06_SummonSword : public UTgDeviceFire_MOB_MinionSpawn
{
public:
	TArray<int>                                        m_BotIdSpawnQueue;                                        // 0x01E8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CH06_SummonSword");
		return ptr;
	}


	void SwordDied(class ATgPawn* deadSword);
	class ATgPawn* STATIC_SpawnNext(bool bSetTimer);
	bool STATIC_DoesThisBotExist(int nSpawnIndex);
	int STATIC_GetMaxBotCount();
	void BuildQueue();
};


// Class TgGame.TgDeviceFire_OffsetCone
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_OffsetCone : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_OffsetCone");
		return ptr;
	}


	float STATIC_ConeOffset(float fMinRadius, float fMaxRadius);
	struct FImpactInfo STATIC_CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_PercCurHealthCost
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_PercCurHealthCost : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_PercCurHealthCost");
		return ptr;
	}


	float STATIC_GetShotPowerCost(int nPacingType, bool bBaseOnly);
};


// Class TgGame.TgDeviceFire_Projectile_Radial
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Projectile_Radial : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Projectile_Radial");
		return ptr;
	}


	void STATIC_InitializeProjectile(class AProjectile* Proj);
};


// Class TgGame.TgDeviceFire_Racer_DropBehind
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Racer_DropBehind : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Racer_DropBehind");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Racer_TargetAhead
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Racer_TargetAhead : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Racer_TargetAhead");
		return ptr;
	}


	void ApplyPlaceBasedEffects(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Racer_TargetFirstPlace
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Racer_TargetFirstPlace : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Racer_TargetFirstPlace");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_RadialOffsetCone
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_RadialOffsetCone : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RadialOffsetCone");
		return ptr;
	}


	void STATIC_RadialConeOffset(float fRadius, float fStartingAngle, float fAngleOffset, struct FAimData* Aim);
	struct FImpactInfo STATIC_CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_RadialSweep
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_RadialSweep : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RadialSweep");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_CH05_Seaweed
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_CH05_Seaweed : public UTgDeviceFire_RadialSweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CH05_Seaweed");
		return ptr;
	}


	float GetConeAttackAngleOffset();
	float GetSignedConeAttackAngle();
};


// Class TgGame.TgDeviceFire_RangeBasedHit
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_RangeBasedHit : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RangeBasedHit");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceFire_Rogue_Adv_Dev1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Rogue_Adv_Dev1 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Rogue_Adv_Dev1");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Scout
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Scout : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Scout");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_SentinelsEmbrace
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_SentinelsEmbrace : public UTgDeviceFire
{
public:
	class ATgDevice_SentinelsEmbrace*                  m_devParent;                                              // 0x01C0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SentinelsEmbrace");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_Spline
// 0x0014 (0x01D4 - 0x01C0)
class UTgDeviceFire_Spline : public UTgDeviceFire
{
public:
	struct FPointer                                    VfTable_ITgSplineDeviceModeInterface;                     // 0x01C0(0x0008) (Const, Native, NoExport)
	int                                                m_nNumSections;                                           // 0x01C8(0x0004)
	float                                              m_fGapCorrectionDifference;                               // 0x01CC(0x0004)
	unsigned long                                      m_bEnableGapCompensation : 1;                             // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Spline");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcSplineFire(class AActor* DamageInstigator, bool bUseProximityDistance, bool bPredicting, struct FInterpCurveVector* Spline, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Spline_GapFill
// 0x0000 (0x01D4 - 0x01D4)
class UTgDeviceFire_Spline_GapFill : public UTgDeviceFire_Spline
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Spline_GapFill");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_TwoPhase
// 0x0001 (0x01C1 - 0x01C0)
class UTgDeviceFire_TwoPhase : public UTgDeviceFire
{
public:
	TEnumAsByte<EDeviceTargetMode>                     m_eAltTargetingMode;                                      // 0x01C0(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_TwoPhase");
		return ptr;
	}


	float GetPostHitDelay();
	float GetPreHitDelay();
	float GetBuildupTime();
	float GetRefireTime();
	float STATIC_GetDamageRadius();
	float STATIC_GetRange();
	float STATIC_GetShotPowerCost(int nPacingType, bool bBaseOnly);
	bool UseCustomFiringValues();
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
};


// Class TgGame.TgDeviceFire_WithExemptList
// 0x0010 (0x01D0 - 0x01C0)
class UTgDeviceFire_WithExemptList : public UTgDeviceFire
{
public:
	TArray<class AActor*>                              m_ExemptList;                                             // 0x01C0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_WithExemptList");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceForm
// 0x01D8 (0x0238 - 0x0060)
class UTgDeviceForm : public UObject
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterfaceLite;                             // 0x0060(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_FCallbackEventDevice;                             // 0x0068(0x0008) (Const, Native, NoExport)
	class ATgPawn*                                     PawnOwner;                                                // 0x0070(0x0008)
	int                                                c_nBehaviorType;                                          // 0x0078(0x0004)
	struct FEquipDeviceInfo                            c_EquipDeviceInfo;                                        // 0x007C(0x000C)
	int                                                m_nDeviceType;                                            // 0x0088(0x0004)
	TEnumAsByte<EDeviceTargetMode>                     m_eTargetingMode;                                         // 0x008C(0x0001)
	TEnumAsByte<ETargetingModeStatus>                  c_eTargetingModeStatus;                                   // 0x008D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x008E(0x0002) MISSED OFFSET
	unsigned long                                      c_bDeployed : 1;                                          // 0x0090(0x0004)
	unsigned long                                      c_bHandDevice : 1;                                        // 0x0090(0x0004)
	unsigned long                                      m_bUseOwnerSockets : 1;                                   // 0x0090(0x0004)
	unsigned long                                      m_bUsesWardSkin : 1;                                      // 0x0090(0x0004)
	unsigned long                                      c_bEquipSlotForced : 1;                                   // 0x0090(0x0004)
	unsigned long                                      c_bIsTransitioningToNewMode : 1;                          // 0x0090(0x0004)
	unsigned long                                      c_bIsInFirstPerson : 1;                                   // 0x0090(0x0004)
	unsigned long                                      c_bTargetingModeEnabled : 1;                              // 0x0090(0x0004)
	unsigned long                                      c_bUsesPreFireTargeting : 1;                              // 0x0090(0x0004)
	unsigned long                                      c_bUsesWhileFiringTargeting : 1;                          // 0x0090(0x0004)
	unsigned long                                      c_bTargeterInitializedThisTick : 1;                       // 0x0090(0x0004)
	unsigned long                                      c_bTargeterIsInWorldDPG : 1;                              // 0x0090(0x0004)
	unsigned long                                      c_bUseInstigatorMesh : 1;                                 // 0x0090(0x0004)
	unsigned long                                      c_bIsInHand : 1;                                          // 0x0090(0x0004)
	unsigned long                                      m_bLandWeaponRecovery : 1;                                // 0x0090(0x0004)
	unsigned long                                      m_bInitializingAssets : 1;                                // 0x0090(0x0004)
	unsigned long                                      m_bForceForegroundDepthPriortiy : 1;                      // 0x0090(0x0004)
	class UAnimSet*                                    c_DeviceAnimSetOverride;                                  // 0x0094(0x0008)
	TArray<class UAnimSet*>                            c_PawnAnimSetOverrideList;                                // 0x009C(0x0010) (NeedCtorLink)
	TArray<struct FModeData>                           ModeDatas;                                                // 0x00AC(0x0010) (NeedCtorLink)
	struct FPointer                                    m_pAmSetup;                                               // 0x00BC(0x0008) (Native)
	class UMeshComponent*                              c_Mesh;                                                   // 0x00C4(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              c_AttachedMesh;                                           // 0x00CC(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              c_ThirdPersonMesh;                                        // 0x00D4(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    c_FirstPersonMesh;                                        // 0x00DC(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       c_nmMountPoint;                                           // 0x00E4(0x0008)
	int                                                c_nDamageLevel;                                           // 0x00EC(0x0004)
	class UMaterialInstanceConstant*                   m_DamageMIC;                                              // 0x00F0(0x0008)
	struct FName                                       FormState;                                                // 0x00F8(0x0008)
	int                                                c_nFireMode;                                              // 0x0100(0x0004)
	int                                                c_nEquipSlot;                                             // 0x0104(0x0004)
	float                                              c_fTimeToEquipDevice;                                     // 0x0108(0x0004)
	int                                                c_nLastFxMode;                                            // 0x010C(0x0004)
	int                                                c_nLastSocketIndex;                                       // 0x0110(0x0004)
	struct FVector                                     c_vBaseFirstPersonTranslation;                            // 0x0114(0x000C)
	struct FVector                                     c_vCustomFirstPersonTranslation;                          // 0x0120(0x000C)
	struct FVector                                     c_vCustomFirstPersonRotation;                             // 0x012C(0x000C)
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicator;                             // 0x0138(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFx;                                        // 0x0140(0x0008)
	struct FAimData                                    c_TargetingAim;                                           // 0x0148(0x0030)
	int                                                c_nTargetingModeFxId;                                     // 0x0178(0x0004)
	TArray<int>                                        c_nFiremodeTargeterFXIds;                                 // 0x017C(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_FxList;                                                 // 0x018C(0x0010) (NeedCtorLink)
	float                                              c_fRemainingTransitionTime;                               // 0x019C(0x0004)
	float                                              c_fTotalTransitionTime;                                   // 0x01A0(0x0004)
	class AActor*                                      m_LockedTarget;                                           // 0x01A4(0x0008)
	class UTgSpecialFx*                                c_ArcFx;                                                  // 0x01AC(0x0008)
	class UTgSpecialFx*                                c_ArcFxSuccessfulHit;                                     // 0x01B4(0x0008)
	class UTgSpecialFx*                                c_ReflectTracerFx;                                        // 0x01BC(0x0008)
	class UTgSpecialFx*                                c_ReflectHitFx;                                           // 0x01C4(0x0008)
	float                                              m_LandWeaponBob;                                          // 0x01CC(0x0004)
	float                                              m_JumpWeaponBob;                                          // 0x01D0(0x0004)
	float                                              m_AppliedWeaponBob;                                       // 0x01D4(0x0004)
	float                                              m_WeaponBobTime;                                          // 0x01D8(0x0004)
	struct FVector                                     m_WalkWeaponBob;                                          // 0x01DC(0x000C)
	float                                              m_bLandWeaponShifting;                                    // 0x01E8(0x0004)
	struct FVector                                     m_WeaponRotationNormalized;                               // 0x01EC(0x000C)
	struct FRotator                                    m_MaxDeltaWeaponRotation;                                 // 0x01F8(0x000C)
	float                                              m_fInterpSpeedIntoWeaponRotation;                         // 0x0204(0x0004)
	float                                              m_fInterpSpeedOutOfWeaponRotation;                        // 0x0208(0x0004)
	struct FRotator                                    m_MaxWeaponRotation;                                      // 0x020C(0x000C)
	class UObjectReferencer*                           m_AssetReference;                                         // 0x0218(0x0008)
	class AActor*                                      m_OwnerActor;                                             // 0x0220(0x0008)
	TArray<class UTgAnimNodeChannelFire*>              m_ChannelFireBlendList;                                   // 0x0228(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm");
		return ptr;
	}


	void STATIC_DisableChannelFireBlendNodes();
	void CacheAnimNodes(class UTgSkeletalMeshComponent* SkelComp);
	void OnRetrieveAnimDone();
	struct FVector GetBaseRightVector();
	struct FVector GetBaseForwardVector();
	void GotoFormState(const struct FName& NewState);
	void STATIC_EndCurrentState();
	void AttachAndDeploy_DA();
	void DeviceAnimNotify();
	void DoInterrupt();
	void CooldownComplete();
	void Cooldown(int nFireModeNum);
	void RadialSweep(int nYaw, float fDuration);
	void Reflect(const struct FVector& HitLocation, int nFireMode);
	void SetStagingMultiActiveChild(int nChild);
	void InterruptCharge();
	void EndCharge(bool bHit);
	void BeginCharge();
	void PlayOffhandFx(const struct FVector& HitLocation, const struct FVector& HitDirection, int nSocketIndex);
	void Hit(int nFireMode, class ATgPawn* TargetPawn);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target);
	bool IsCurrentInHandWeapon();
	class UTgDeviceForm* STATIC_InHandWeaponForm();
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void ExitTargetingMode();
	void NotifyTargetingModeStatusChange();
	void NotifyEnterTargetingMode();
	void NotifyExitTargetingMode(bool bDeployed);
	void EnterTargetingMode();
	void STATIC_InitializeTargetingModeFX();
	void STATIC_EndDevicePuttingDown();
	void BeginDeviceTakingOut(bool PlayEquipAnim);
	void BeginActive(int desiredIdleState);
	void PlayTracerFx(const struct FVector& HitLocation, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, const struct FVector& FireOrigin);
	void ApplyTiDi(float fTotalTiDi);
	void UpdateTargeterLocationAndRotation(class UTgSpecialFx* TargetModeFx, const struct FVector& Translation, const struct FVector& AimVector, float UnitsAboveGround);
	int STATIC_GetCustomParticleSystemFilter();
	bool UsesTargetingMode();
	void STATIC_SpawnOffhandFx(const struct FVector& HitLocation, const struct FVector& HitDirection, int nSocket);
	void STATIC_DryFire();
	void UpdateFirstPersonWeaponFOV(const struct FVector2D& Resolution);
	void STATIC_GetCurrentUsedResourceList(TArray<struct FString> List);
	void STATIC_RecalculateMaterial();
	void UpdateTargetingDepthPriority(float fDeltaTime, TArray<class UTgSpecialFx*>* targetingFxs);
	void UpdateTargetingList(TArray<struct FImpactInfo>* ImpactList);
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	class UTgSpecialFx* STATIC_SpawnSpecialFxIndependent(int nSpecialFxId, const struct FParticleChannelContainer& PSysChannels, bool bUseEmitterPool);
	void STATIC_ResetAfterRagDoll();
	void STATIC_Destruct(const struct FVector& vLocation);
	void STATIC_PlaySoundAt(class USoundCue* ASound, const struct FVector& SourceLocation);
	int STATIC_GetFormIndex();
	bool AllowImpactEffects(class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_SpawnReflectFxs(const struct FVector& HitLocation, const struct FVector& HitOrigin);
	void STATIC_SpawnArcingTracer(const struct FVector& HitLocation, const struct FVector& HitOrigin, bool bSuccessfulHit);
	void STATIC_SpawnFxTracer(int nFireModeNum, const struct FVector& HitLocation, int nSocketIndex, bool bHitTracer);
	void STATIC_DeactivateFxGroup(const struct FName& nmGroup);
	class UTgSpecialFx* ActivateFxIndependent(const struct FName& nmGroup, bool bSkipActivate, const struct FParticleChannelContainer& PSysChannels);
	void ActivateFxGroup(const struct FName& nmGroup);
	bool LogDebugInfo();
	void STATIC_InitCameraViewpoint();
	void STATIC_DeviceAddRemoveAnimSet(class UAnimSet* pAnimSet, bool bAdd);
	void STATIC_SetVisibility(bool bVisible);
	void STATIC_DetachInHandDevice_DA();
	void STATIC_DetachDevice_DA(class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh);
	bool AttachInHandDevice_DA(bool bFirstPerson);
	void AttachDevice_DA(class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh, const struct FName& nmSocket);
	void STATIC_SetSkin(class UMaterial* NewMaterial);
	void STATIC_SetFireMode(int nMode);
};


// Class TgGame.TgDeviceForm_72Transformations
// 0x001C (0x0254 - 0x0238)
class UTgDeviceForm_72Transformations : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorLine;                         // 0x0238(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFxLine;                                    // 0x0240(0x0008)
	int                                                c_nTargetingModeFxLineId;                                 // 0x0248(0x0004)
	unsigned long                                      c_bShouldScaleLineTargeter : 1;                           // 0x024C(0x0004)
	float                                              c_fWeaponRange;                                           // 0x0250(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_72Transformations");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_AlternateFX
// 0x0014 (0x024C - 0x0238)
class UTgDeviceForm_AlternateFX : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorB;                            // 0x0238(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFxB;                                       // 0x0240(0x0008)
	int                                                m_TargetingModeFxIdB;                                     // 0x0248(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AlternateFX");
		return ptr;
	}


	void DeactivateAlternateFX();
	void EnterTargetingMode();
	void ExitTargetingMode();
	void STATIC_InitializeAlternateFX();
	bool STATIC_CustomShouldBeActive();
	bool UsesTargetingMode();
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_Arcing
// 0x0004 (0x023C - 0x0238)
class UTgDeviceForm_Arcing : public UTgDeviceForm
{
public:
	int                                                c_nArcTracerFxId;                                         // 0x0238(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Arcing");
		return ptr;
	}


	class UTgSpecialFx* ActivateFxIndependent(const struct FName& nmGroup, bool bSkipActivate, const struct FParticleChannelContainer& PSysChannels);
};


// Class TgGame.TgDeviceForm_AutoPortal
// 0x0050 (0x0288 - 0x0238)
class UTgDeviceForm_AutoPortal : public UTgDeviceForm
{
public:
	unsigned long                                      m_bUseAlternateTargeter : 1;                              // 0x0238(0x0004)
	int                                                m_nFloorTargeterId;                                       // 0x023C(0x0004) (Const)
	class ATgSkeletalMeshActor*                        c_SecondaryTargetingModeMeshIndicator;                    // 0x0240(0x0008)
	class UTgSpecialFx*                                c_SecondaryTargetingModeFx;                               // 0x0248(0x0008)
	TEnumAsByte<ETargetingModeStatus>                  c_eSecondaryTargetingModeStatus;                          // 0x0250(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0251(0x0003) MISSED OFFSET
	struct FAimData                                    c_SecondaryTargetingAim;                                  // 0x0254(0x0030)
	int                                                c_nSecondaryTargetingModeFxId;                            // 0x0284(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AutoPortal");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateSecondaryTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateSecondaryTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_Awilix_BasicAttack
// 0x0004 (0x023C - 0x0238)
class UTgDeviceForm_Awilix_BasicAttack : public UTgDeviceForm
{
public:
	int                                                m_nAOEMode;                                               // 0x0238(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Awilix_BasicAttack");
		return ptr;
	}


	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	bool UsesTargetingMode();
};


// Class TgGame.TgDeviceForm_Beam
// 0x0010 (0x0248 - 0x0238)
class UTgDeviceForm_Beam : public UTgDeviceForm
{
public:
	struct FName                                       c_nmContinuousFire;                                       // 0x0238(0x0008)
	struct FName                                       c_nmContinuousHit;                                        // 0x0240(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Beam");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target);
	void StopContinuousHitFx();
	void UpdateContinuousHitFx(const struct FVector& HitLocation);
	void UpdateContinuousFireFx(const struct FVector& HitLocation);
	void STATIC_DetachDevice_DA(class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh);
};


// Class TgGame.TgDeviceForm_DeathGaze
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_DeathGaze : public UTgDeviceForm_Beam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DeathGaze");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_LockOnBeam
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_LockOnBeam : public UTgDeviceForm_Beam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LockOnBeam");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target);
	void UpdateContinuousFireTarget();
	void UpdateContinuousFireFx(const struct FVector& HitLocation);
};


// Class TgGame.TgDeviceForm_Deployable
// 0x0010 (0x0248 - 0x0238)
class UTgDeviceForm_Deployable : public UTgDeviceForm
{
public:
	class UTgAnimNodeBlendList*                        m_ValidPlacementBlendNode;                                // 0x0238(0x0008)
	class UAnimNodeSequence*                           m_PutawayAnimNode;                                        // 0x0240(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Deployable");
		return ptr;
	}


	void NotifyExitTargetingMode(bool bDeployed);
	void NotifyTargetingModeStatusChange();
};


// Class TgGame.TgDeviceForm_GodTargeter
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_GodTargeter : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_GodTargeter");
		return ptr;
	}


	void NotifyEnterTargetingMode();
	void NotifyExitTargetingMode(bool bDeployed);
	void NotifyTargetingModeStatusChange();
	bool UsesTargetingMode();
};


// Class TgGame.TgDeviceForm_LimitedGroundTarget
// 0x0010 (0x0248 - 0x0238)
class UTgDeviceForm_LimitedGroundTarget : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_LimitedTargetingModeMeshIndicator;                      // 0x0238(0x0008)
	class UTgSpecialFx*                                c_LimitedTargetingModeFx;                                 // 0x0240(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LimitedGroundTarget");
		return ptr;
	}


	void ExitTargetingMode();
	void STATIC_InitializeTargetingModeFX();
	void UpdateLimitedTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgDeviceForm_LineCone
// 0x000C (0x0244 - 0x0238)
class UTgDeviceForm_LineCone : public UTgDeviceForm
{
public:
	class UTgSpecialFx*                                c_ConeTargetModeFx;                                       // 0x0238(0x0008)
	int                                                c_nConeTargetFxId;                                        // 0x0240(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LineCone");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateConeTargetModeLocation(float TranslationX, float TranslationY);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_MultipleTargetIndicator
// 0x001C (0x0254 - 0x0238)
class UTgDeviceForm_MultipleTargetIndicator : public UTgDeviceForm
{
public:
	int                                                c_nTargetFxID;                                            // 0x0238(0x0004)
	struct FName                                       c_TargetSocketName;                                       // 0x023C(0x0008)
	TArray<struct FFormTargetingInfo>                  c_TargetingInfos;                                         // 0x0244(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_MultipleTargetIndicator");
		return ptr;
	}


	void ExitTargetingMode();
	void STATIC_ClearTargetingInfos();
	void UpdateTargetingList(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceForm_HandOfTheGods
// 0x0014 (0x0268 - 0x0254)
class UTgDeviceForm_HandOfTheGods : public UTgDeviceForm_MultipleTargetIndicator
{
public:
	int                                                m_nHandOfGodsMeshAsmId;                                   // 0x0254(0x0004)
	int                                                m_nHandOfGodsFxId;                                        // 0x0258(0x0004)
	struct FName                                       m_nmHandOfGodsSocketName;                                 // 0x025C(0x0008)
	unsigned long                                      m_bWouldKill : 1;                                         // 0x0264(0x0004)
	unsigned long                                      m_bCachedWouldKill : 1;                                   // 0x0264(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HandOfTheGods");
		return ptr;
	}


	void Hit(int nFireMode, class ATgPawn* TargetPawn);
	void STATIC_PlayHandOfGod(class ATgPawn* TargetPawn);
	void UpdateTargetingList(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceForm_MultiTargeters
// 0x0020 (0x0258 - 0x0238)
class UTgDeviceForm_MultiTargeters : public UTgDeviceForm
{
public:
	TArray<class UTgSpecialFx*>                        c_TargetingModeFxList;                                    // 0x0238(0x0010) (NeedCtorLink)
	TArray<int>                                        c_nTargetingModeFxIDs;                                    // 0x0248(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_MultiTargeters");
		return ptr;
	}


	bool ShouldInitializeFx(int nFxTargeterIndex);
	void ExitTargetingMode();
	void EnterTargetingMode();
	void STATIC_DisableFX(class UTgSpecialFx* TargetModeFx);
	void UpdateTargetingDepthPriority(float fDeltaTime, TArray<class UTgSpecialFx*>* targetingFxs);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	class UTgSpecialFx* STATIC_InitializeTargetingModeFXHelper(int nTargetFxId);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_OverlaySelect
// 0x0028 (0x0260 - 0x0238)
class UTgDeviceForm_OverlaySelect : public UTgDeviceForm
{
public:
	int                                                c_nLastOverlaySelect;                                     // 0x0238(0x0004)
	int                                                c_nOverlaySelect;                                         // 0x023C(0x0004)
	TArray<int>                                        c_nOverlayFxIds;                                          // 0x0240(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_OverlayFx;                                              // 0x0250(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_OverlaySelect");
		return ptr;
	}


	void EnableOverlayFx();
	void SetOverlayFx(int nOverlaySelect);
	void DisableOverlayFx();
	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_Racer_Blink
// 0x0004 (0x023C - 0x0238)
class UTgDeviceForm_Racer_Blink : public UTgDeviceForm
{
public:
	unsigned long                                      m_bSpecialTargetingLockout : 1;                           // 0x0238(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Racer_Blink");
		return ptr;
	}


	void EnterTargetingMode();
};


// Class TgGame.TgDeviceForm_RadialSweep
// 0x0010 (0x0248 - 0x0238)
class UTgDeviceForm_RadialSweep : public UTgDeviceForm
{
public:
	int                                                m_nSweepMeshId;                                           // 0x0238(0x0004) (Const)
	class UTgSkeletalMeshComponent*                    c_SweepMeshComponent;                                     // 0x023C(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              m_fMeshRemainTime;                                        // 0x0244(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_RadialSweep");
		return ptr;
	}


	void ActuallyEndSweep();
	void EndRadialSweep();
	void RadialSweep(int nYaw, float fDuration);
	void STATIC_DetachDevice_DA(class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh);
	void LoadAndPlaySweepMesh(int nSweepMeshID, int nYaw);
};


// Class TgGame.TgDeviceForm_ShieldedRecall
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_ShieldedRecall : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShieldedRecall");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
};


// Class TgGame.TgDeviceForm_ShieldOfTheUnderWorld
// 0x0008 (0x0240 - 0x0238)
class UTgDeviceForm_ShieldOfTheUnderWorld : public UTgDeviceForm
{
public:
	int                                                c_nReflectHitFxId;                                        // 0x0238(0x0004)
	int                                                c_nReflectTracerFxId;                                     // 0x023C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ShieldOfTheUnderWorld");
		return ptr;
	}


	class UTgSpecialFx* ActivateFxIndependent(const struct FName& nmGroup, bool bSkipActivate, const struct FParticleChannelContainer& PSysChannels);
};


// Class TgGame.TgDeviceForm_SplineTarget
// 0x0064 (0x029C - 0x0238)
class UTgDeviceForm_SplineTarget : public UTgDeviceForm
{
public:
	int                                                m_NumSplines;                                             // 0x0238(0x0004)
	int                                                m_SplineMeshId;                                           // 0x023C(0x0004)
	int                                                m_SplineMeshStartId;                                      // 0x0240(0x0004)
	int                                                m_SplineMeshEndId;                                        // 0x0244(0x0004)
	int                                                m_nNumSplineActorSections;                                // 0x0248(0x0004) (Const)
	TArray<struct FSplineContainer>                    m_SplineData;                                             // 0x024C(0x0010) (NeedCtorLink)
	TArray<class UStaticMesh*>                         m_DeformMesh;                                             // 0x025C(0x0010) (NeedCtorLink)
	TArray<class UStaticMesh*>                         m_DeformMeshStart;                                        // 0x026C(0x0010) (NeedCtorLink)
	TArray<class UStaticMesh*>                         m_DeformMeshEnd;                                          // 0x027C(0x0010) (NeedCtorLink)
	class UClass*                                      m_DefaultSplineActorClass;                                // 0x028C(0x0008)
	class UClass*                                      m_LinearSplineActorClass;                                 // 0x0294(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SplineTarget");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	class UStaticMesh* STATIC_GetDeformMeshEnd(int nSplineId);
	class UStaticMesh* STATIC_GetDeformMesh(int nSplineId);
	class UStaticMesh* STATIC_GetDeformMeshStart(int nSplineId);
	void STATIC_DestroySplines();
	void STATIC_CreateSplines();
	void STATIC_SetSplineLength(int nSplineIndex, int nLength);
	int STATIC_SetupSplineActors(int nSplineIndex, int nLength);
	void UpdateTargetingModeSplines(const TScriptInterface<class UTgSplineDeviceInterface>& SplineDev, const struct FAimData& Aim);
	void UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	bool UsesTargetingMode();
};


// Class TgGame.TgDeviceForm_TargetIndicator
// 0x0014 (0x024C - 0x0238)
class UTgDeviceForm_TargetIndicator : public UTgDeviceForm
{
public:
	int                                                c_nTargetFxID;                                            // 0x0238(0x0004)
	struct FName                                       c_TargetSocketName;                                       // 0x023C(0x0008)
	class UTgSpecialFx*                                c_TargetFx;                                               // 0x0244(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TargetIndicator");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_TwoPhase
// 0x0010 (0x0248 - 0x0238)
class UTgDeviceForm_TwoPhase : public UTgDeviceForm
{
public:
	unsigned long                                      m_bInSecondaryTargetMode : 1;                             // 0x0238(0x0004)
	TEnumAsByte<EDeviceTargetMode>                     m_ePrimaryTargetMode;                                     // 0x023C(0x0001)
	TEnumAsByte<EDeviceTargetMode>                     m_eSecondaryTargetMode;                                   // 0x023D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x023E(0x0002) MISSED OFFSET
	int                                                m_nPrimaryTargetingFxId;                                  // 0x0240(0x0004)
	int                                                m_nSecondaryTargetingFxId;                                // 0x0244(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_TwoPhase");
		return ptr;
	}


	void ToggleSecondaryTargetMode(bool bOn);
};


// Class TgGame.TgDeviceForm_WhileFiring
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_WhileFiring : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_WhileFiring");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_WorldMapTarget
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_WorldMapTarget : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_WorldMapTarget");
		return ptr;
	}


	void NotifyEnterTargetingMode();
	void NotifyExitTargetingMode(bool bDeployed);
	void NotifyTargetingModeStatusChange();
	bool UsesTargetingMode();
};


// Class TgGame.TgDeviceSurrogateInterface
// 0x0000 (0x0060 - 0x0060)
class UTgDeviceSurrogateInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceSurrogateInterface");
		return ptr;
	}


	class UTgDeviceFire* STATIC_GetCurrentFire();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool IsLockedDown();
	bool STATIC_ShouldUpdateTimer();
	unsigned char STATIC_IncrementFiringInstance();
	bool STATIC_HasBeenTrained();
	int STATIC_GetAllocatedDevicePoints(bool bForceBasePoints);
	int STATIC_GetTotalDevicePoints();
	bool IsDeviceCoolingDown();
	bool STATIC_ShouldUseSurrogateDevice();
	class ATgDevice* STATIC_GetSurrogateDevice();
};


// Class TgGame.TgSplineDeviceInterface
// 0x0000 (0x0060 - 0x0060)
class UTgSplineDeviceInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineDeviceInterface");
		return ptr;
	}


	void GetAdjustedAimSpline(int nShotIndex, struct FAimData* Aim);
	bool STATIC_CalculateFlightPath(int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim);
};


// Class TgGame.TgSplineDeviceModeInterface
// 0x0000 (0x0060 - 0x0060)
class UTgSplineDeviceModeInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineDeviceModeInterface");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcSplineFire(class AActor* DamageInstigator, bool bUseProximityDistance, bool bPredicting, struct FInterpCurveVector* Spline, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable
// 0x0174 (0x03D4 - 0x0260)
class ATgDeployable : public AActor
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterface;                                 // 0x0260(0x0008) (Const, Native, NoExport)
	int                                                r_nDeployableId;                                          // 0x0268(0x0004) (Net)
	int                                                c_nSavedSkinId;                                           // 0x026C(0x0004)
	int                                                c_nSavedSkinLevel;                                        // 0x0270(0x0004)
	int                                                r_nSkinId;                                                // 0x0274(0x0004) (Net)
	unsigned char                                      r_nSkinLevel;                                             // 0x0278(0x0001) (Net)
	unsigned char                                      r_nFlashCount;                                            // 0x0279(0x0001) (Net)
	unsigned char                                      r_nFlashFireCount;                                        // 0x027A(0x0001) (Net)
	unsigned char                                      c_nPreviousFlashFireCount;                                // 0x027B(0x0001)
	unsigned char                                      s_nFiringInstance;                                        // 0x027C(0x0001)
	TEnumAsByte<EDeployableCollisionComponentInitType> m_eCollisionInitType;                                     // 0x027D(0x0001) (Const)
	unsigned char                                      UnknownData00[0x2];                                       // 0x027E(0x0002) MISSED OFFSET
	unsigned long                                      c_bInitialized : 1;                                       // 0x0280(0x0004)
	unsigned long                                      m_bConsumedOnFire : 1;                                    // 0x0280(0x0004)
	unsigned long                                      m_bFireOnDeploy : 1;                                      // 0x0280(0x0004)
	unsigned long                                      m_bHasAlreadyFiredOnce : 1;                               // 0x0280(0x0004)
	unsigned long                                      m_bInstantFire : 1;                                       // 0x0280(0x0004)
	unsigned long                                      m_bForceInstantFire : 1;                                  // 0x0280(0x0004)
	unsigned long                                      c_bMinimapOnlyOwnerSee : 1;                               // 0x0280(0x0004)
	unsigned long                                      r_bTakeDamage : 1;                                        // 0x0280(0x0004) (Net)
	unsigned long                                      m_bInDestroyedState : 1;                                  // 0x0280(0x0004)
	unsigned long                                      s_bDestroyedThisTick : 1;                                 // 0x0280(0x0004)
	unsigned long                                      m_bIsDeployed : 1;                                        // 0x0280(0x0004)
	unsigned long                                      m_bStartLifespanTimerOnDeploy : 1;                        // 0x0280(0x0004) (Const)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x0280(0x0004)
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                           // 0x0280(0x0004)
	unsigned long                                      m_bAdjustMeshToGround : 1;                                // 0x0280(0x0004)
	unsigned long                                      m_bDisableHudInfo : 1;                                    // 0x0280(0x0004)
	unsigned long                                      m_bUsesGenericPIP : 1;                                    // 0x0280(0x0004)
	unsigned long                                      c_bTargeted : 1;                                          // 0x0280(0x0004)
	unsigned long                                      m_bInheritTidiWhileDeploying : 1;                         // 0x0280(0x0004)
	unsigned long                                      m_bOverrideTargetComponentHeight : 1;                     // 0x0280(0x0004) (Edit)
	unsigned long                                      r_bInitialIsEnemy : 1;                                    // 0x0280(0x0004) (Net)
	unsigned long                                      c_bIsSpectateToggleActive : 1;                            // 0x0280(0x0004) (Transient)
	unsigned long                                      m_bInstigatorOwnsProjectile : 1;                          // 0x0280(0x0004)
	int                                                m_nDeployableType;                                        // 0x0284(0x0004)
	int                                                r_nPhysicalType;                                          // 0x0288(0x0004) (Net)
	int                                                r_nHealth;                                                // 0x028C(0x0004) (Net)
	class ATgEffectManager*                            r_EffectManager;                                          // 0x0290(0x0008) (Net)
	TArray<class UTgEffectGroup*>                      m_EquipEffects;                                           // 0x0298(0x0010) (NeedCtorLink)
	TArray<struct FTgPropertyInstance>                 s_Properties;                                             // 0x02A8(0x0010) (NeedCtorLink)
	struct FName                                       c_nmName;                                                 // 0x02B8(0x0008)
	class UTgDeviceForm*                               c_Form;                                                   // 0x02C0(0x0008)
	class UTgSpecialFx*                                c_FireFx;                                                 // 0x02C8(0x0008)
	class UMeshComponent*                              c_Mesh;                                                   // 0x02D0(0x0008) (ExportObject, Component, EditInline)
	class AActor*                                      m_Target;                                                 // 0x02D8(0x0008)
	struct FVector                                     r_vFlashLocation;                                         // 0x02E0(0x000C) (Net)
	class UTgDeviceFire*                               m_FireMode;                                               // 0x02EC(0x0008)
	int                                                m_FireSkillId;                                            // 0x02F4(0x0004)
	float                                              m_fStateTime;                                             // 0x02F8(0x0004)
	int                                                c_nVisibleToLocalPlayer[0x2];                             // 0x02FC(0x0004)
	class UClass*                                      c_cMinimapOnlyClassSee;                                   // 0x0304(0x0008)
	class ATgActorFactory*                             s_DeployFactory;                                          // 0x030C(0x0008)
	int                                                m_TimeCreated;                                            // 0x0314(0x0004)
	class UMeshComponent*                              m_DestroyedMesh;                                          // 0x0318(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fLifeAfterDeathSecs;                                    // 0x0320(0x0004)
	int                                                r_nReplicateDestroyIt;                                    // 0x0324(0x0004) (Net)
	float                                              s_fPersistTime;                                           // 0x0328(0x0004)
	int                                                m_nSensorConfigId;                                        // 0x032C(0x0004)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x0330(0x0008) (Const, ExportObject, Component, EditInline)
	float                                              m_fDefaultDeployAnimLength;                               // 0x0338(0x0004)
	float                                              r_fTimeToDeploySecs;                                      // 0x033C(0x0004) (Net)
	float                                              r_fInitDeployTime;                                        // 0x0340(0x0004) (Net)
	float                                              m_fCurrentDeployPercentage;                               // 0x0344(0x0004)
	float                                              r_fDeployRate;                                            // 0x0348(0x0004) (Net)
	float                                              r_fCurrentDeployTime;                                     // 0x034C(0x0004) (Net)
	float                                              m_fLastDeployedHealth;                                    // 0x0350(0x0004)
	float                                              m_fDamagedDuringDeploy;                                   // 0x0354(0x0004)
	float                                              m_BaseEyeHeight;                                          // 0x0358(0x0004)
	int                                                s_nLootTableId;                                           // 0x035C(0x0004)
	class UTgDeviceFire*                               s_SpawnerDeviceMode;                                      // 0x0360(0x0008)
	class ATgDevice*                                   r_Owner;                                                  // 0x0368(0x0008) (Net)
	int                                                r_nOwnerFireMode;                                         // 0x0370(0x0004) (Net)
	float                                              AlwaysRelevantDistanceSquared;                            // 0x0374(0x0004)
	int                                                r_nCustomParticleSystemFilter;                            // 0x0378(0x0004) (Net)
	class UTgSpecialFx*                                c_WorldBracketFX;                                         // 0x037C(0x0008)
	class UTgTiDiState*                                s_CurrentTiDi;                                            // 0x0384(0x0008)
	float                                              r_fTotalTiDi;                                             // 0x038C(0x0004) (Net)
	int                                                m_nDeployIndex;                                           // 0x0390(0x0004) (Const)
	class UCylinderComponent*                          m_TargetComponent;                                        // 0x0394(0x0008) (Edit, ExportObject, Component, EditInline)
	float                                              m_TargetCollisionTraceDistance;                           // 0x039C(0x0004) (Edit)
	float                                              m_fOverriddenTargetComponentHeight;                       // 0x03A0(0x0004) (Edit)
	class ATgPawn*                                     m_LastDamager;                                            // 0x03A4(0x0008)
	int                                                m_LastDamagerTimeStamp;                                   // 0x03AC(0x0004)
	class ATgRepInfo_Deployable*                       r_DRI;                                                    // 0x03B0(0x0008) (Net)
	class UClass*                                      m_DRIClass;                                               // 0x03B8(0x0008)
	float                                              m_fDisableSpectatorFxTime;                                // 0x03C0(0x0004)
	float                                              m_fDisableSpectatorFxTimeRemaining;                       // 0x03C4(0x0004) (Transient)
	float                                              s_fLiveSpectateRelevancyDist;                             // 0x03C8(0x0004) (Const, Config)
	class AProjectile*                                 m_Projectile;                                             // 0x03CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable");
		return ptr;
	}


	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	void STATIC_OnTeleportToBaseNotify(class AActor* TeleportingActor);
	void DeactivateSpectatorFxTimer();
	void ToggleSpectateFx(bool bForceDisable);
	bool IsBoxExtentInRange(const struct FVector& BoxCenter, const struct FVector& BoxExtent);
	void InitReplicationInfo();
	bool CanBeRepaired();
	bool CanApplyEffects();
	struct FString STATIC_GetDeployableNameById(int deployableId);
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Destroyed();
	void Tick(float DeltaSeconds);
	void DestroyIt(bool bSkipFx);
	void TornOff();
	void SpawningDeviceToggledOff();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_DeployableTimer();
	float STATIC_GetSaveHealthPercent();
	void TickDeploy(float DeltaSeconds);
	void UpdateTimeToDeploySecs(float fValue);
	void STATIC_DeployComplete();
	void STATIC_CalcDeployPercentage();
	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_RefireCheckTimer();
	void StartDeploy();
	void TimeDeviceFiring();
	bool IsFiring();
	void STATIC_FlashFireCountUpdated();
	void FlashLocationUpdated();
	void FlashCountUpdated();
	void PlayFireFx();
	void ClearFlashLocation();
	void STATIC_SetFlashLocation(const struct FVector& NewLoc);
	void ClearFlashCount();
	void STATIC_IncrementFlashCount();
	void STATIC_FireAmmunitionDeployable();
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	struct FVector STATIC_GetPhysicalFireStartLoc();
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	class AProjectile* STATIC_ProjectileFireDeployable();
	float STATIC_GetProjectileIDOverride();
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_InstantFireDeployable();
	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceFired();
	void StopFire();
	void StartFire();
	void STATIC_OnGetTaskForceNumber(class UTgSeqAct_GetTaskForceNumber* Action);
	void ApplyEquipEffects();
	int GetDeployableUniqueId();
	void STATIC_NotifyLocalPlayerTeamReceived();
	void PostBeginPlay();
	void TurnOffInheritLocalTidi();
	void STATIC_ShutdownTiDi();
	void TransmitTiDiClient();
	void TransmitTiDiServer();
	void ApplyTiDi();
	bool STATIC_ShouldUpdateTiDi();
	class UTgTiDiState* STATIC_GetCurrentTiDi();
	void STATIC_InitializeTiDi();
	struct FVector STATIC_GetHudOverlayLocation();
	bool IsHittableToSpecialAI();
	bool IsHittableToAI();
	bool IsInvisibleToSpecialAI(class AActor* TestActor);
	bool STATIC_IsInvisible(class AActor* TestActor);
	void UpdateHealth();
	bool IsFriendlyWithLocalPawn();
	int STATIC_GetSpawnerDeviceId();
	int STATIC_GetFireDeviceSkillId();
	int STATIC_GetSpawnerDeviceInstanceId();
	int STATIC_GetSpawnerDeviceSkillId();
	void SetTaskForceNumber(int nTaskForceId);
	int STATIC_GetTaskForceNumber();
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce();
	void STATIC_SetInitialHealthPercent(float fPercent);
	void UpdateDamagers(class ATgPawn* Damager);
	void UpdateTargetCylinder();
	float STATIC_GetFxScaling();
	float STATIC_CalcMeshOffset();
	void AdjustMeshToGround();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void STATIC_ForceRecalculateMaterial();
	void NotifyGroupChanged();
	int STATIC_GetMaxDeployHealth();
	int STATIC_GetMaxHealth();
	int STATIC_GetDisplayMaxHealth();
	int STATIC_GetDisplayHealth();
	void STATIC_DeployableDestroyed();
	void STATIC_SwapMeshToDestroyed();
	void STATIC_ResetProperties();
	void STATIC_SetProperty(int nPropertyId, float fNewValue);
	void AddProperty(int nPropId, float fBase, float fRaw, float FMin, float FMax);
	void InitializeDefaultProps();
	bool ApplyDeployableSetup();
};


// Class TgGame.TgDeploy_Artillery
// 0x001C (0x03F0 - 0x03D4)
class ATgDeploy_Artillery : public ATgDeployable
{
public:
	float                                              s_fTargetRadius;                                          // 0x03D4(0x0004)
	float                                              s_fStartHeight;                                           // 0x03D8(0x0004)
	float                                              s_fDeflectionDegrees;                                     // 0x03DC(0x0004)
	TEnumAsByte<EArtilleryType>                        s_eArtilleryType;                                         // 0x03E0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03E1(0x0003) MISSED OFFSET
	struct FVector                                     s_fCurrentAimLocation;                                    // 0x03E4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Artillery");
		return ptr;
	}


	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	struct FVector STATIC_GetPhysicalFireStartLoc();
	struct FVector STATIC_CalcAimLocation(class AActor* Target);
	void STATIC_FireAmmunitionDeployable();
	bool STATIC_ShouldStartFire();
	void STATIC_DeployComplete();
	class ATgPawn* STATIC_FindEnemyPlayer();
	class AActor* STATIC_FindTarget();
};


// Class TgGame.TgDeploy_CH05_IceChain
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeploy_CH05_IceChain : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH05_IceChain");
		return ptr;
	}

};


// Class TgGame.TgDeploy_CH07_Portal
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeploy_CH07_Portal : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH07_Portal");
		return ptr;
	}

};


// Class TgGame.TgDeploy_DelayedPulse
// 0x0008 (0x03DC - 0x03D4)
class ATgDeploy_DelayedPulse : public ATgDeployable
{
public:
	unsigned long                                      r_bCanFire : 1;                                           // 0x03D4(0x0004)
	int                                                r_nFireCount;                                             // 0x03D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_DelayedPulse");
		return ptr;
	}


	void STATIC_HandlePulseFire();
	void STATIC_FireAmmunitionDeployable();
	float GetMaxShotCount();
	float GetDelayLength();
	void STATIC_PreventFire();
	void AllowFire();
};


// Class TgGame.TgDeploy_EffectVolume
// 0x0024 (0x03F8 - 0x03D4)
class ATgDeploy_EffectVolume : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_HitActors;                                              // 0x03E4(0x0010) (NeedCtorLink)
	unsigned long                                      m_bHitOnce : 1;                                           // 0x03F4(0x0004)
	unsigned long                                      m_bApplyHitOnTouch : 1;                                   // 0x03F4(0x0004)
	unsigned long                                      m_bApplyHitSpecialOnTouch : 1;                            // 0x03F4(0x0004)
	unsigned long                                      m_bWaitForDeploy : 1;                                     // 0x03F4(0x0004)
	unsigned long                                      m_bApplyHitInitialOnDeploy : 1;                           // 0x03F4(0x0004)
	unsigned long                                      m_bRetouchOnInitUpdate : 1;                               // 0x03F4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectVolume");
		return ptr;
	}


	void STATIC_DeployComplete();
	void STATIC_FireAmmunitionDeployable();
	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void HandleUnTouch(class AActor* Other);
	void UnTouch(class AActor* Other);
	bool STATIC_ShouldHitOnlyOnce(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void ApplyTouchHitSpecial(class AActor* Other, const struct FImpactInfo& Impact);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FindTouchingActorsFromScript();
};


// Class TgGame.TgDeploy_AutoPortal
// 0x00B4 (0x04AC - 0x03F8)
class ATgDeploy_AutoPortal : public ATgDeploy_EffectVolume
{
public:
	class ATgDeploy_AutoPortal*                        r_Twin;                                                   // 0x03F8(0x0008) (Net)
	class ATgRepInfo_Deployable*                       r_TwinDRI;                                                // 0x0400(0x0008) (Net)
	int                                                m_nLinkBeamFxId;                                          // 0x0408(0x0004)
	class UTgSpecialFx*                                c_LinkBeamFx;                                             // 0x040C(0x0008) (Transient)
	float                                              c_LinkBeamOffsetZ;                                        // 0x0414(0x0004)
	float                                              c_fVisibilityCacheTime;                                   // 0x0418(0x0004)
	class APlayerController*                           c_CachedLocalPC;                                          // 0x041C(0x0008)
	unsigned long                                      c_bCachedVisibility : 1;                                  // 0x0424(0x0004)
	unsigned long                                      m_bKillAfterUse : 1;                                      // 0x0424(0x0004)
	unsigned long                                      m_bUsedOnce : 1;                                          // 0x0424(0x0004)
	TEnumAsByte<ETweenState>                           m_ePortalTweenState;                                      // 0x0428(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0429(0x0003) MISSED OFFSET
	TArray<struct FPortalExcludeInfo>                  s_TemporaryCannotTeleport;                                // 0x042C(0x0010) (NeedCtorLink)
	float                                              m_fCannotTeleportTime;                                    // 0x043C(0x0004)
	TArray<struct FPortalPermanentExcludeInfo>         s_PermanentCannotTeleport;                                // 0x0440(0x0010) (NeedCtorLink)
	int                                                m_nMaxTeleportsPerTarget;                                 // 0x0450(0x0004)
	int                                                s_nTotalTeleportUses;                                     // 0x0454(0x0004)
	int                                                m_nMaxTeleportUses;                                       // 0x0458(0x0004)
	TArray<class AActor*>                              s_HitOnNextTouch;                                         // 0x045C(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_MustUnTouch;                                            // 0x046C(0x0010) (NeedCtorLink)
	float                                              m_fTeleportSpeed;                                         // 0x047C(0x0004)
	float                                              m_fMinimumTravelTime;                                     // 0x0480(0x0004)
	float                                              m_fMinKillDelay;                                          // 0x0484(0x0004)
	class UMeshComponent*                              m_OverlayMesh;                                            // 0x0488(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nOverlayMICId;                                          // 0x0490(0x0004)
	int                                                m_nOverLayMICEnemyId;                                     // 0x0494(0x0004)
	class UMaterialInstanceConstant*                   m_OverlayMIC;                                             // 0x0498(0x0008)
	class UMaterialInstanceConstant*                   m_OverlayMICEnemy;                                        // 0x04A0(0x0008)
	float                                              m_fForceOverlayDistance;                                  // 0x04A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_AutoPortal");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_CleanUpLinkFx();
	void AddCannotTeleportEntry(class AActor* Target);
	float TeleportAction(class AActor* Target, const struct FVector& EndPoint);
	void Teleport(class AActor* Target);
	bool CanTeleport(class AActor* Target, bool bCheckPet);
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void SetTwin(class ATgDeploy_AutoPortal* twin);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_FindTeleportLocation(class AActor* TeleportingActor, struct FVector* TeleportLocation);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void STATIC_InitializeLinkBeamFx();
};


// Class TgGame.TgDeploy_EffectVolume_RollingLine
// 0x0048 (0x0440 - 0x03F8)
class ATgDeploy_EffectVolume_RollingLine : public ATgDeploy_EffectVolume
{
public:
	class ATgCollisionProxy_Box*                       s_CollisionProxy;                                         // 0x03F8(0x0008)
	float                                              m_fEffectiveRange;                                        // 0x0400(0x0004) (Const)
	float                                              m_fPersistTime;                                           // 0x0404(0x0004) (Const)
	float                                              m_fBufferSize;                                            // 0x0408(0x0004) (Const)
	float                                              m_fPercentOfRange;                                        // 0x040C(0x0004) (Const)
	struct FVector                                     m_vDirection;                                             // 0x0410(0x000C) (Const)
	float                                              m_fWidth;                                                 // 0x041C(0x0004) (Const)
	struct FVector                                     m_vInitialLocation;                                       // 0x0420(0x000C)
	struct FVector                                     s_vPrevLocation;                                          // 0x042C(0x000C)
	float                                              m_fRollCurrentTime;                                       // 0x0438(0x0004)
	unsigned long                                      m_bHitBehindWalls : 1;                                    // 0x043C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectVolume_RollingLine");
		return ptr;
	}


	void DestroyCollisionProxy();
	void Cleanup();
	void HandleTouch(class AActor* Other);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void BuildProxy();
	bool LineOfSightCheck(class AActor* Other);
	void STATIC_RollCollisionForward(float fDeltaTime);
};


// Class TgGame.TgDeploy_EffectVolume_WithCollision
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeploy_EffectVolume_WithCollision : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectVolume_WithCollision");
		return ptr;
	}

};


// Class TgGame.TgDeploy_CH05_Nightmare_DoomCleanse
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeploy_CH05_Nightmare_DoomCleanse : public ATgDeploy_EffectVolume_WithCollision
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH05_Nightmare_DoomCleanse");
		return ptr;
	}

};


// Class TgGame.TgDeploy_CH05_SteamVent
// 0x0004 (0x03FC - 0x03F8)
class ATgDeploy_CH05_SteamVent : public ATgDeploy_EffectVolume_WithCollision
{
public:
	unsigned long                                      r_bIsActiveVent : 1;                                      // 0x03F8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH05_SteamVent");
		return ptr;
	}


	void STATIC_ChangeVentStatus(bool bTurnedOn);
	void ReplicatedEvent(const struct FName& VarName);
	void EndVenting();
	void HandleUnTouch(class AActor* Other);
	void STATIC_FireAmmunitionDeployable();
};


// Class TgGame.TgDeploy_EffectVolume_WithEncroachment
// 0x003C (0x0434 - 0x03F8)
class ATgDeploy_EffectVolume_WithEncroachment : public ATgDeploy_EffectVolume_WithCollision
{
public:
	float                                              r_fGuardTime;                                             // 0x03F8(0x0004) (Const, Net)
	unsigned long                                      r_bHasSituationalInitialTouch : 1;                        // 0x03FC(0x0004) (Const, Net)
	unsigned long                                      m_bShouldLoopTouchGuard : 1;                              // 0x03FC(0x0004) (Const)
	float                                              m_fMinGuardTime;                                          // 0x0400(0x0004) (Const)
	TArray<class AActor*>                              m_HitInitialList;                                         // 0x0404(0x0010) (NeedCtorLink)
	class UTgTimerManager*                             m_GuardTimers[0x2];                                       // 0x0414(0x0008)
	TArray<class AActor*>                              m_TimerOccupancy;                                         // 0x0424(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_EffectVolume_WithEncroachment");
		return ptr;
	}


	bool STATIC_ShouldLogInfo();
	struct FImpactInfo STATIC_CreateImpactInfo(class AActor* Other);
	int STATIC_GetFirstInactiveTimerIndex();
	int STATIC_GetGuardIndex(class AActor* Other);
	bool STATIC_CanApplySituationalEffectGroup(class ATgPawn* pawnOther);
	void STATIC_EndTimerManager(class UTgTimerManager* timerMgr);
	void DestroyAllTimers();
	void DestroyIt(bool bSkipFx);
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void STATIC_DeployComplete();
	void ApplyTiDi();
};


// Class TgGame.TgDeploy_OccupyToDestroyVolume
// 0x0030 (0x0428 - 0x03F8)
class ATgDeploy_OccupyToDestroyVolume : public ATgDeploy_EffectVolume_WithCollision
{
public:
	float                                              r_fOccupyTime;                                            // 0x03F8(0x0004) (Const, Net)
	int                                                r_nOccupyTimerFlashEvent;                                 // 0x03FC(0x0004) (Net)
	struct FName                                       m_nmOccupyDestroy;                                        // 0x0400(0x0008) (Const)
	struct FName                                       m_nmDistanceScale;                                        // 0x0408(0x0008) (Const)
	TArray<class ATgPawn*>                             s_pawnOccupyTriggers;                                     // 0x0410(0x0010) (NeedCtorLink)
	class UTgEffectTransitions*                        c_effectTransitions;                                      // 0x0420(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_OccupyToDestroyVolume");
		return ptr;
	}


	void STATIC_FlashNotifyOccupyTimerEvent(bool bTimerActive);
	void DestroyIt(bool bSkipFx);
	void STATIC_OccupyDestroy();
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void STATIC_DeployComplete();
	bool IsValidOccupant(class ATgPawn* pawnOccupant);
	void ReplicatedEvent(const struct FName& VarName);
	void LerpOccupyTimer(float fLerpTarget, float fLerpTime);
};


// Class TgGame.TgDeployable_Surtr_LavaPool
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeployable_Surtr_LavaPool : public ATgDeploy_EffectVolume_WithCollision
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Surtr_LavaPool");
		return ptr;
	}


	void Cleanup();
	void HandleTouch(class AActor* Other);
	void HandleUnTouch(class AActor* Other);
};


// Class TgGame.TgDeployable_Surtr_SunderEarth
// 0x0010 (0x0408 - 0x03F8)
class ATgDeployable_Surtr_SunderEarth : public ATgDeploy_EffectVolume_WithCollision
{
public:
	TArray<class ATgDeploy_EffectVolume*>              m_Arms;                                                   // 0x03F8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Surtr_SunderEarth");
		return ptr;
	}


	void Cleanup();
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void BuildArms(class UTgDeviceFire* pMode);
};


// Class TgGame.TgDeploy_MovingEffectVolume
// 0x0084 (0x047C - 0x03F8)
class ATgDeploy_MovingEffectVolume : public ATgDeploy_EffectVolume
{
public:
	struct FVector                                     m_vActualLocation;                                        // 0x03F8(0x000C)
	struct FInterpAnchor                               m_InterpAnchors[0x3];                                     // 0x0404(0x0024)
	unsigned long                                      m_bOnlyAnchorCollision : 1;                               // 0x0470(0x0004)
	float                                              m_fExtentRadius;                                          // 0x0474(0x0004) (Const)
	float                                              m_fExtentHeight;                                          // 0x0478(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_MovingEffectVolume");
		return ptr;
	}


	void STATIC_ResetCollisionAnchors();
};


// Class TgGame.TgDeploy_ExplodingCylinder
// 0x001C (0x0498 - 0x047C)
class ATgDeploy_ExplodingCylinder : public ATgDeploy_MovingEffectVolume
{
public:
	unsigned long                                      r_bExploding : 1;                                         // 0x047C(0x0004) (Net)
	unsigned long                                      m_bExplosionFinished : 1;                                 // 0x047C(0x0004)
	float                                              r_fPersistTime;                                           // 0x0480(0x0004) (Net)
	float                                              m_fStartRadius;                                           // 0x0484(0x0004)
	TArray<class AActor*>                              s_InSlice;                                                // 0x0488(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ExplodingCylinder");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void Cleanup();
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	float AdjustRadiusToTarget(float CurrentRadius, float DeltaRadius, float TargetRadius);
	float STATIC_GetTargetRadius();
	float STATIC_GetExplosionTime();
	void STATIC_GrowCylinder(class UCylinderComponent* cyl, float dSeconds, float MaxRadius);
	void STATIC_FinishExplosion();
};


// Class TgGame.TgDeploy_CylinderPulse
// 0x0014 (0x04AC - 0x0498)
class ATgDeploy_CylinderPulse : public ATgDeploy_ExplodingCylinder
{
public:
	unsigned long                                      s_bWillImplode : 1;                                       // 0x0498(0x0004)
	unsigned long                                      r_bImploding : 1;                                         // 0x0498(0x0004) (Net)
	TArray<class AActor*>                              s_RetractingHits;                                         // 0x049C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CylinderPulse");
		return ptr;
	}


	void STATIC_DeployComplete();
	bool CanApplyHitSpecialOnImplode(class AActor* Other);
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_FinishExplosion();
	void TriggerImplosion();
	float STATIC_GetTargetRadius();
	float STATIC_GetExplosionTime();
};


// Class TgGame.TgDeploy_ExplodingCylinder_ScalingMesh
// 0x0008 (0x04A0 - 0x0498)
class ATgDeploy_ExplodingCylinder_ScalingMesh : public ATgDeploy_ExplodingCylinder
{
public:
	float                                              r_fFXRadius;                                              // 0x0498(0x0004) (Net)
	float                                              r_fExplosionTime;                                         // 0x049C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ExplodingCylinder_ScalingMesh");
		return ptr;
	}


	float STATIC_GetExplosionTime();
	void STATIC_SetFXScaling(float fScale);
	void STATIC_GrowCylinder(class UCylinderComponent* cyl, float dSeconds, float MaxRadius);
};


// Class TgGame.TgDeploy_MovingEffectVolume_CustomCollisionExtent
// 0x0000 (0x047C - 0x047C)
class ATgDeploy_MovingEffectVolume_CustomCollisionExtent : public ATgDeploy_MovingEffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_MovingEffectVolume_CustomCollisionExtent");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Scaling_EffectVolume
// 0x0004 (0x03FC - 0x03F8)
class ATgDeploy_Scaling_EffectVolume : public ATgDeploy_EffectVolume
{
public:
	float                                              r_fScaleFactor;                                           // 0x03F8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Scaling_EffectVolume");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ScaleDisplayGroups();
	float STATIC_GetFxScaling();
};


// Class TgGame.TgDeployable_CTF_Flag
// 0x0048 (0x0440 - 0x03F8)
class ATgDeployable_CTF_Flag : public ATgDeploy_EffectVolume
{
public:
	int                                                r_fDefenderTaskforce;                                     // 0x03F8(0x0004) (Net)
	class ATgDeployable_CTF_FlagBase*                  r_HomeBase;                                               // 0x03FC(0x0008) (Net)
	unsigned long                                      r_bIsHome : 1;                                            // 0x0404(0x0004) (Net)
	unsigned long                                      r_bActiveCollision : 1;                                   // 0x0404(0x0004) (Net)
	class ATgPawn*                                     r_CurrentCarrier;                                         // 0x0408(0x0008) (Net)
	struct FThrowLocationData                          r_ThrowLocationData;                                      // 0x0410(0x001C) (Net)
	float                                              s_fPickedUpAt;                                            // 0x042C(0x0004)
	TArray<struct FCarrierAbilityData>                 m_CarrierAbilityDevices;                                  // 0x0430(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_CTF_Flag");
		return ptr;
	}


	void InitReplicationInfo();
	void ReplicatedEvent(const struct FName& VarName);
	void ManageDropFX();
	void HandleCollisionState();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void DestroyIt(bool bSkipFx);
	void ResetToBase();
	void STATIC_ForceReturn();
	struct FVector STATIC_FindGroundLoc(const struct FVector& vLoc);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void STATIC_SetBaseStatus();
	void STATIC_SetCurrentCarrier();
	bool STATIC_CanReturn(class ATgPawn* TargetPawn);
	bool STATIC_CanAttach(class ATgPawn* TargetPawn);
	void STATIC_RemoveCarrierDevices(class ATgPawn* TargetPawn, const struct FCarrierAbilityData& abilityData);
	void AttachCarrierDevices(class ATgPawn* TargetPawn, const struct FCarrierAbilityData& abilityData);
	void STATIC_RemoveFlag(class ATgPawn* TargetPawn, class UTgDeviceFire* FireMode, bool activateCollision);
	void AttachFlag(class ATgPawn* TargetPawn, class UTgDeviceFire* FireMode);
	void AttemptAttach(class ATgPawn* TargetPawn, class UTgDeviceFire* FireMode);
};


// Class TgGame.TgDeployable_CTF_FlagBase
// 0x0014 (0x040C - 0x03F8)
class ATgDeployable_CTF_FlagBase : public ATgDeploy_EffectVolume
{
public:
	class ATgDeployable_CTF_Flag*                      r_OwnedFlag;                                              // 0x03F8(0x0008) (Net)
	int                                                m_nFlagDeployableId;                                      // 0x0400(0x0004)
	class ATgGame_Battle_CTF*                          m_Game;                                                   // 0x0404(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_CTF_FlagBase");
		return ptr;
	}


	void PostBeginPlay();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	struct FVector STATIC_GetHudOverlayLocation();
	class ATgDeployable_CTF_Flag* STATIC_SpawnDeployable();
};


// Class TgGame.TgDeployable_FloorPortal
// 0x001C (0x0414 - 0x03F8)
class ATgDeployable_FloorPortal : public ATgDeploy_EffectVolume
{
public:
	int                                                c_nExitMeshId;                                            // 0x03F8(0x0004)
	class UMeshComponent*                              c_ExitMesh;                                               // 0x03FC(0x0008) (ExportObject, Component, EditInline)
	TArray<class AActor*>                              s_PendingTeleportActors;                                  // 0x0404(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_FloorPortal");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	bool CanUsePortalNow(class AActor* Other);
};


// Class TgGame.TgDeployable_GroundTrail
// 0x000C (0x0404 - 0x03F8)
class ATgDeployable_GroundTrail : public ATgDeploy_EffectVolume
{
public:
	class UTgTrailComponent_GroundTrail*               m_OwningTrail;                                            // 0x03F8(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      m_bAllowTrailToCallDestroyIt : 1;                         // 0x0400(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_GroundTrail");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void UnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
};


// Class TgGame.TgDeployable_MultiPortal
// 0x0024 (0x041C - 0x03F8)
class ATgDeployable_MultiPortal : public ATgDeploy_EffectVolume
{
public:
	TArray<class AActor*>                              s_IgnoredActors;                                          // 0x03F8(0x0010) (NeedCtorLink)
	TArray<float>                                      s_fTouchTimes;                                            // 0x0408(0x0010) (NeedCtorLink)
	float                                              s_fTimeToActivate;                                        // 0x0418(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_MultiPortal");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void Teleport(int nIndex);
};


// Class TgGame.TgDeployable_TimedMultiPortal
// 0x0008 (0x0424 - 0x041C)
class ATgDeployable_TimedMultiPortal : public ATgDeployable_MultiPortal
{
public:
	float                                              m_fLifeTime;                                              // 0x041C(0x0004)
	float                                              m_fMaxLifeTime;                                           // 0x0420(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_TimedMultiPortal");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void InitReplicationInfo();
};


// Class TgGame.TgDeployable_Surtr_SunderEarthArm
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeployable_Surtr_SunderEarthArm : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Surtr_SunderEarthArm");
		return ptr;
	}


	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
};


// Class TgGame.TgDeployable_Trail
// 0x03E8 (0x07E0 - 0x03F8)
class ATgDeployable_Trail : public ATgDeploy_EffectVolume
{
public:
	struct FVector                                     r_vTrailPoints[0x1E];                                     // 0x03F8(0x000C) (Net)
	float                                              s_fTrailDecayTimes[0x1E];                                 // 0x0560(0x0004)
	class UStaticMeshComponent*                        s_CollisionComps[0x1E];                                   // 0x05D8(0x0008) (ExportObject, Component, EditInline)
	class UTgSpecialFx*                                c_TrailFx[0x1E];                                          // 0x06C8(0x0008)
	int                                                r_nTrailHeadIndex;                                        // 0x07B8(0x0004) (Net)
	int                                                r_nTrailTailIndex;                                        // 0x07BC(0x0004) (Net)
	unsigned long                                      s_bIsStillTrailing : 1;                                   // 0x07C0(0x0004)
	int                                                c_nCurrentFxTailIndex;                                    // 0x07C4(0x0004)
	int                                                c_nCurrentFxHeadIndex;                                    // 0x07C8(0x0004)
	float                                              m_fMinPointDist;                                          // 0x07CC(0x0004)
	float                                              m_fPointFrequency;                                        // 0x07D0(0x0004)
	float                                              m_fPointDuration;                                         // 0x07D4(0x0004)
	float                                              s_fNextPointTime;                                         // 0x07D8(0x0004)
	float                                              m_fTrailWidth;                                            // 0x07DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Trail");
		return ptr;
	}


	void STATIC_InitializeTrail();
	void AddNewPointToTrail();
	void STATIC_DeployComplete();
	void ActivateFxAtIndex(int Index);
	void Tick(float DeltaSeconds);
	bool ShouldTrail();
	class UTgStaticMeshComponent* AddCollisionAtHead();
};


// Class TgGame.TgDeployable_Whirlpool
// 0x0008 (0x0400 - 0x03F8)
class ATgDeployable_Whirlpool : public ATgDeploy_EffectVolume
{
public:
	class ATgCollisionProxy_Vortex_Whirlpool*          m_Vortex;                                                 // 0x03F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Whirlpool");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_CH05_Draugr_Whirlpool
// 0x0000 (0x0400 - 0x0400)
class ATgDeployable_CH05_Draugr_Whirlpool : public ATgDeployable_Whirlpool
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_CH05_Draugr_Whirlpool");
		return ptr;
	}


	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeploy_FireOnTouch
// 0x0014 (0x03E8 - 0x03D4)
class ATgDeploy_FireOnTouch : public ATgDeployable
{
public:
	unsigned long                                      m_Triggered : 1;                                          // 0x03D4(0x0004)
	float                                              r_InitialMeshOffset;                                      // 0x03D8(0x0004) (Net)
	struct FVector                                     m_TargetMeshOffset;                                       // 0x03DC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_FireOnTouch");
		return ptr;
	}


	void TriggerFire();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
};


// Class TgGame.TgDeploy_GrantTeamItem
// 0x0000 (0x03E8 - 0x03E8)
class ATgDeploy_GrantTeamItem : public ATgDeploy_FireOnTouch
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_GrantTeamItem");
		return ptr;
	}


	void TriggerFire();
	void STATIC_DeployComplete();
	void STATIC_GiveLootToTeam(int nLootTableItemId, int nTaskForce);
};


// Class TgGame.TgDeploy_ForceField
// 0x0010 (0x03E4 - 0x03D4)
class ATgDeploy_ForceField : public ATgDeployable
{
public:
	unsigned long                                      m_bBlockFriendlyFire : 1;                                 // 0x03D4(0x0004)
	unsigned long                                      m_bUseMeshAsCollision : 1;                                // 0x03D4(0x0004)
	struct FVector                                     m_vExtent;                                                // 0x03D8(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ForceField");
		return ptr;
	}


	bool AllowPassthrough(bool bFriendly);
	bool CanBeRepaired();
};


// Class TgGame.TgDeploy_Wall
// 0x0028 (0x040C - 0x03E4)
class ATgDeploy_Wall : public ATgDeploy_ForceField
{
public:
	TArray<class AActor*>                              m_OverlappingActors;                                      // 0x03E4(0x0010) (NeedCtorLink)
	TArray<struct FVector>                             m_DesiredPushDirection;                                   // 0x03F4(0x0010) (NeedCtorLink)
	unsigned long                                      m_bPushOverlappingActors : 1;                             // 0x0404(0x0004)
	unsigned long                                      m_bHasRegisteredObstacle : 1;                             // 0x0404(0x0004)
	unsigned long                                      m_bAutoRegisterObstacle : 1;                              // 0x0404(0x0004)
	unsigned long                                      m_bCanBeDestroyed : 1;                                    // 0x0404(0x0004) (Const)
	float                                              m_fPushFactor;                                            // 0x0408(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wall");
		return ptr;
	}


	void STATIC_PushOverlappingActors(float DeltaSeconds);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void CollisionChanged();
	void DestroyIt(bool bSkipFx);
	void Destroyed();
	void STATIC_DeployComplete();
	void UnRegisterObstacle();
	void STATIC_RegisterObstacle();
	bool STATIC_RemoveOverlappingActorByIndex(int Index);
	bool UpdateOverlappingActorByIndex(int Index, const struct FVector& PushDirection);
	void STATIC_RemoveOverlappingActor(class AActor* Other);
	void AddOverlappingActor(class AActor* Other, const struct FVector& PushDirection, bool bForceNewEntry);
	bool IsPushable(class AActor* Other);
	void STATIC_FindOverlappingActors();
	bool STATIC_ShouldSelfDestructWhenTouchedBy(class AActor* Other);
};


// Class TgGame.TgDeploy_CH06_JaggedPillars
// 0x0000 (0x040C - 0x040C)
class ATgDeploy_CH06_JaggedPillars : public ATgDeploy_Wall
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH06_JaggedPillars");
		return ptr;
	}


	bool AllowPassthrough(bool bFriendly);
	void STATIC_SpawnProjectiles();
};


// Class TgGame.TgDeploy_Racer_Wall
// 0x0004 (0x0410 - 0x040C)
class ATgDeploy_Racer_Wall : public ATgDeploy_Wall
{
public:
	unsigned long                                      m_bReadyForDestruction : 1;                               // 0x040C(0x0004)
	unsigned long                                      m_bPendingDestroy : 1;                                    // 0x040C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Racer_Wall");
		return ptr;
	}


	void STATIC_SetReadyForDestruction();
	void STATIC_DeployComplete();
	void AttemptTouchTarget(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeploy_SandPillar
// 0x0034 (0x0440 - 0x040C)
class ATgDeploy_SandPillar : public ATgDeploy_Wall
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x040C(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x041C(0x0008)
	class UMeshComponent*                              m_CollisionMesh;                                          // 0x0424(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nCollisionMeshId;                                       // 0x042C(0x0004)
	class UMeshComponent*                              m_SandMesh;                                               // 0x0430(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nSandMeshId;                                            // 0x0438(0x0004)
	unsigned long                                      m_bApplyHitOnTouch : 1;                                   // 0x043C(0x0004)
	unsigned long                                      m_bApplyHitSpecialOnTouch : 1;                            // 0x043C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_SandPillar");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeploy_Wall_Destructible
// 0x0000 (0x040C - 0x040C)
class ATgDeploy_Wall_Destructible : public ATgDeploy_Wall
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wall_Destructible");
		return ptr;
	}


	void SetTaskForceNumber(int nTaskForceId);
};


// Class TgGame.TgDeploy_CH06_SpearPillar
// 0x0004 (0x0410 - 0x040C)
class ATgDeploy_CH06_SpearPillar : public ATgDeploy_Wall_Destructible
{
public:
	unsigned long                                      m_bBuffIsOnOwner : 1;                                     // 0x040C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH06_SpearPillar");
		return ptr;
	}


	bool AllowPassthrough(bool bFriendly);
	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_Statue
// 0x0028 (0x0434 - 0x040C)
class ATgDeployable_Statue : public ATgDeploy_Wall_Destructible
{
public:
	class ATgPawn_Character*                           r_characterStatue;                                        // 0x040C(0x0008) (Const, Net)
	class ATgPawn*                                     m_pawnInsigator;                                          // 0x0414(0x0008) (Const)
	TArray<class UMaterialInstanceConstant*>           c_matStones;                                              // 0x041C(0x0010) (NeedCtorLink)
	int                                                m_nStoneFxId;                                             // 0x042C(0x0004) (Const)
	unsigned long                                      m_bUseMaterialResourceGroup : 1;                          // 0x0430(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Statue");
		return ptr;
	}


	bool IsPushable(class AActor* Other);
	bool STATIC_IsInvisible(class AActor* TestActor);
	struct FVector STATIC_GetHudOverlayLocation();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void STATIC_CreateStoneMaterials();
	class UMaterialInstanceConstant* STATIC_GetStoneMaterial(int nMaterialIndex);
};


// Class TgGame.TgDeploy_Wall_PushBack
// 0x0018 (0x0424 - 0x040C)
class ATgDeploy_Wall_PushBack : public ATgDeploy_Wall
{
public:
	struct FVector                                     m_vGeneralDirection;                                      // 0x040C(0x000C)
	struct FVector                                     m_vRelativeGeneralDirection;                              // 0x0418(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wall_PushBack");
		return ptr;
	}

};


// Class TgGame.TgDeploy_GiveConsumable
// 0x0004 (0x03D8 - 0x03D4)
class ATgDeploy_GiveConsumable : public ATgDeployable
{
public:
	unsigned long                                      m_Triggered : 1;                                          // 0x03D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_GiveConsumable");
		return ptr;
	}


	void TriggerBuff(class AActor* Other);
	bool STATIC_CanGiveDevice(class AActor* Other, TEnumAsByte<ETG_EQUIP_POINT>* nEqp);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
};


// Class TgGame.TgDeploy_Hydra_Arc
// 0x0018 (0x03EC - 0x03D4)
class ATgDeploy_Hydra_Arc : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Hydra_Arc");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeploy_Hydra_PreDeath
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeploy_Hydra_PreDeath : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Hydra_PreDeath");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void StartDeploy();
};


// Class TgGame.TgDeploy_ProjectileOwner
// 0x0010 (0x03E4 - 0x03D4)
class ATgDeploy_ProjectileOwner : public ATgDeployable
{
public:
	TArray<class ATgProjectile*>                       m_SpawnedProjectiles;                                     // 0x03D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_ProjectileOwner");
		return ptr;
	}


	class AProjectile* STATIC_ProjectileFireDeployable();
	struct FVector STATIC_GetProjTargetLocation();
};


// Class TgGame.TgDeploy_CH05_Sawblade
// 0x0000 (0x03E4 - 0x03E4)
class ATgDeploy_CH05_Sawblade : public ATgDeploy_ProjectileOwner
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH05_Sawblade");
		return ptr;
	}

};


// Class TgGame.TgDeploy_CH05_SpiralSwirl
// 0x0000 (0x03E4 - 0x03E4)
class ATgDeploy_CH05_SpiralSwirl : public ATgDeploy_ProjectileOwner
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH05_SpiralSwirl");
		return ptr;
	}


	struct FVector STATIC_GetPhysicalFireStartLoc();
};


// Class TgGame.TgDeploy_Racer_TargetAhead
// 0x0010 (0x03E4 - 0x03D4)
class ATgDeploy_Racer_TargetAhead : public ATgDeployable
{
public:
	TArray<struct FDelayedImpactByPlace>               m_PendingImpacts;                                         // 0x03D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Racer_TargetAhead");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
	void CalculateRacerTargets();
};


// Class TgGame.TgDeployable_Apep_AcidSpray
// 0x0018 (0x03EC - 0x03D4)
class ATgDeployable_Apep_AcidSpray : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Apep_AcidSpray");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_Apep_Pickup
// 0x0008 (0x03DC - 0x03D4)
class ATgDeployable_Apep_Pickup : public ATgDeployable
{
public:
	int                                                m_ItemAwardId;                                            // 0x03D4(0x0004)
	int                                                m_MaximumItems;                                           // 0x03D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Apep_Pickup");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_GiveDevice(int nItemId, class ATgInventoryManager* TargetInv);
};


// Class TgGame.TgDeployable_Buff_Monster
// 0x001C (0x03F0 - 0x03D4)
class ATgDeployable_Buff_Monster : public ATgDeployable
{
public:
	unsigned long                                      m_Triggered : 1;                                          // 0x03D4(0x0004)
	unsigned long                                      m_bUsesMeshOffset : 1;                                    // 0x03D4(0x0004)
	float                                              r_InitialMeshOffset;                                      // 0x03D8(0x0004) (Net)
	struct FVector                                     m_TargetMeshOffset;                                       // 0x03DC(0x000C)
	class ATgBotFactory*                               s_OriginalFactory;                                        // 0x03E8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Buff_Monster");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void SetSpawnFactory(class ATgBotFactory* Factory);
	bool IsValidBuffTarget(class AActor* actorOther);
	void ApplyBuff(class AActor* Other);
	void TriggerBuff(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void STATIC_InitFxTimer(class UTgSpecialFx* Fx);
	bool STATIC_CanApplyBuff(class AActor* Target);
};


// Class TgGame.TgDeploy_CampToken_PEP
// 0x002C (0x041C - 0x03F0)
class ATgDeploy_CampToken_PEP : public ATgDeployable_Buff_Monster
{
public:
	class ATgBotFactory_PEP_TakenJungleSpawn*          m_SpawnCamp;                                              // 0x03F0(0x0008) (Const)
	class ATgPawn*                                     m_KillerPawn;                                             // 0x03F8(0x0008) (Const)
	struct FPEPRewardMap                               r_RewardMap;                                              // 0x0400(0x001C) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CampToken_PEP");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void StartDeploy();
	void TriggerBuff(class AActor* Other);
	bool STATIC_CanApplyBuff(class AActor* Target);
	void UpdatePortaitTexture();
};


// Class TgGame.TgDeploy_CH05Pickup
// 0x0000 (0x03F0 - 0x03F0)
class ATgDeploy_CH05Pickup : public ATgDeployable_Buff_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH05Pickup");
		return ptr;
	}


	void STATIC_DeviceFired();
	void TriggerBuff(class AActor* Other);
	bool STATIC_CanApplyBuff(class AActor* Target);
};


// Class TgGame.TgDeployable_Buff_Monster_ApplyDevice
// 0x0000 (0x03F0 - 0x03F0)
class ATgDeployable_Buff_Monster_ApplyDevice : public ATgDeployable_Buff_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Buff_Monster_ApplyDevice");
		return ptr;
	}


	void ApplyBuff(class AActor* Other);
	bool STATIC_CanApplyBuff(class AActor* Target);
};


// Class TgGame.TgDeployable_FireGiant_FlamesOfRagnarok
// 0x0004 (0x03D8 - 0x03D4)
class ATgDeployable_FireGiant_FlamesOfRagnarok : public ATgDeployable
{
public:
	float                                              m_fireGiantAggroRange;                                    // 0x03D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_FireGiant_FlamesOfRagnarok");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	bool IsInCustomRange(class AActor* Other);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable_FogWall
// 0x0008 (0x03DC - 0x03D4)
class ATgDeployable_FogWall : public ATgDeployable
{
public:
	unsigned long                                      m_bOneDirectional : 1;                                    // 0x03D4(0x0004) (Edit)
	unsigned long                                      m_bBlockAllowFriendlies : 1;                              // 0x03D4(0x0004) (Edit)
	float                                              m_fBlockMinimumDistance;                                  // 0x03D8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_FogWall");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Jumong_Quiver
// 0x0018 (0x03EC - 0x03D4)
class ATgDeployable_Jumong_Quiver : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Jumong_Quiver");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void Cleanup();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeployable_LimitedGroundTarget
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_LimitedGroundTarget : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_LimitedGroundTarget");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Pickup
// 0x002C (0x0400 - 0x03D4)
class ATgDeployable_Pickup : public ATgDeployable
{
public:
	float                                              r_fPersistTimeAfterPickup;                                // 0x03D4(0x0004) (Const, Net)
	float                                              r_fEffectRadius;                                          // 0x03D8(0x0004) (Const, Net)
	class UTgSkeletalMeshComponent*                    c_SkeletalMesh;                                           // 0x03DC(0x0008) (Const, ExportObject, Component, EditInline)
	class UTgStaticMeshComponent*                      c_StaticMesh;                                             // 0x03E4(0x0008) (Const, ExportObject, Component, EditInline)
	unsigned long                                      m_bInstigatorIsCarrier : 1;                               // 0x03EC(0x0004) (Const)
	unsigned long                                      m_bDestroyOnDrop : 1;                                     // 0x03EC(0x0004) (Const)
	unsigned long                                      m_bResetHitsOnCleanUp : 1;                                // 0x03EC(0x0004) (Const)
	unsigned long                                      m_bApplyHitInitial : 1;                                   // 0x03EC(0x0004) (Const)
	unsigned long                                      m_bApplyHit : 1;                                          // 0x03EC(0x0004) (Const)
	unsigned long                                      m_bIsAOE : 1;                                             // 0x03EC(0x0004) (Const)
	unsigned long                                      m_bHitOnce : 1;                                           // 0x03EC(0x0004) (Const)
	unsigned long                                      r_bHasHitOnce : 1;                                        // 0x03EC(0x0004) (Net)
	class ATgPawn*                                     r_pawnCarrier;                                            // 0x03F0(0x0008) (Net)
	class ATgDevice_Aura*                              s_AuraDevice;                                             // 0x03F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Pickup");
		return ptr;
	}


	void AuraProxyUnTouch(class AActor* Other);
	void AuraProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Cleanup();
	void DestroyIt(bool bSkipFx);
	struct FImpactInfo STATIC_CreateImpactInfo(class AActor* HitActor);
	void STATIC_CreateImpactList(TArray<struct FImpactInfo>* ImpactList);
	void ApplyAuraOnTrigger();
	void ApplyHitsOnTrigger();
	void STATIC_RestoreVisibility();
	void STATIC_RemoveVisibility();
	void STATIC_Drop();
	void STATIC_Pickup();
	void TriggerBuff(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void AdjustLifetime(class UTgSpecialFx* lifetimeFx);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ConfigureFireModeLifetime(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact);
	void STATIC_InitFxTimer(class UTgSpecialFx* Fx);
	bool STATIC_CanApplyBuff(class AActor* Target);
	void STATIC_CacheAuraDevice();
};


// Class TgGame.TgDeployable_PulseEffectVolume
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_PulseEffectVolume : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_PulseEffectVolume");
		return ptr;
	}


	bool STATIC_ShouldHit(class AActor* Other);
	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void Tick(float DeltaSeconds);
	void STATIC_FindTouchingActorsFromScript();
};


// Class TgGame.TgDeployable_Racer_Pickup
// 0x00C8 (0x049C - 0x03D4)
class ATgDeployable_Racer_Pickup : public ATgDeployable
{
public:
	unsigned long                                      r_IsActive : 1;                                           // 0x03D4(0x0004) (Net)
	float                                              m_InactiveDelayTime;                                      // 0x03D8(0x0004)
	int                                                m_LootTableIdsByPlace[0x8];                               // 0x03DC(0x0004)
	struct FRacerLootSet                               m_LootSets[0x8];                                          // 0x03FC(0x0014) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Racer_Pickup");
		return ptr;
	}


	void STATIC_Deactivate();
	void Activate();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ReplicatedEvent(const struct FName& VarName);
	int STATIC_PickRandomItemForRacer(class ATgPawn_Racer* Racer);
};


// Class TgGame.TgDeployable_Scaling
// 0x0004 (0x03D8 - 0x03D4)
class ATgDeployable_Scaling : public ATgDeployable
{
public:
	float                                              r_fScalingFactor;                                         // 0x03D4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Scaling");
		return ptr;
	}


	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_Surtr_FireSpinTrail
// 0x0018 (0x03EC - 0x03D4)
class ATgDeployable_Surtr_FireSpinTrail : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Surtr_FireSpinTrail");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_TidiImmune
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_TidiImmune : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_TidiImmune");
		return ptr;
	}


	void STATIC_InitializeTiDi();
};


// Class TgGame.TgDeployable_Ward
// 0x003C (0x0410 - 0x03D4)
class ATgDeployable_Ward : public ATgDeployable
{
public:
	int                                                m_nKillCreditXpReward;                                    // 0x03D4(0x0004) (Const)
	int                                                m_nKillCreditGoldReward;                                  // 0x03D8(0x0004) (Const)
	float                                              s_MinimapDetectionRange;                                  // 0x03DC(0x0004)
	unsigned long                                      s_bRequireLOS : 1;                                        // 0x03E0(0x0004)
	unsigned long                                      m_Initialized : 1;                                        // 0x03E0(0x0004)
	unsigned long                                      r_bVisibleToEnemies : 1;                                  // 0x03E0(0x0004) (Net)
	unsigned long                                      m_bRevealOtherWards : 1;                                  // 0x03E0(0x0004)
	unsigned long                                      m_bMustBeRevealed : 1;                                    // 0x03E0(0x0004)
	unsigned long                                      m_bStatTrack : 1;                                         // 0x03E0(0x0004)
	unsigned long                                      r_bTeleportIncoming : 1;                                  // 0x03E0(0x0004) (Net)
	unsigned long                                      r_bBeingTouched : 1;                                      // 0x03E0(0x0004) (Net)
	unsigned long                                      r_bInitiallyVisible : 1;                                  // 0x03E0(0x0004) (Net)
	unsigned long                                      m_bHasLoggedPlacement : 1;                                // 0x03E0(0x0004)
	int                                                r_nPhysTriggerType;                                       // 0x03E4(0x0004) (Net)
	int                                                r_nIncomingAttackDirection;                               // 0x03E8(0x0004) (Net)
	int                                                r_nIncomingAttackCount;                                   // 0x03EC(0x0004) (Net)
	int                                                s_nTeleportsIncoming;                                     // 0x03F0(0x0004)
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                                       // 0x03F4(0x0008)
	float                                              m_nInitialVisibility;                                     // 0x03FC(0x0004)
	int                                                m_nOdyssey2017LevelMap[0x4];                              // 0x0400(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ward");
		return ptr;
	}


	void STATIC_HidePostSetup();
	bool StopsProjectile(class AProjectile* P);
	void STATIC_PlayDamageAnim(int Dir);
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UpdateTeleportFX();
	void UpdateClientVisibility();
	void STATIC_RemoveIncomingTeleport();
	void AddIncomingTeleport();
	void STATIC_DeployComplete();
	bool IsTriggerType(int nPhysType);
	void SetVisibleToEnemies(bool Value);
	void InitReplicationInfo();
	void StartDeploy();
	void PostBeginPlay();
	bool CanApplyEffects();
	void DestroyIt(bool bSkipFx);
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateCombatLog();
	void STATIC_CreditKill(class AController* PC);
	void STATIC_SetMinimapDetectionRange(float MinimapDetectionRange);
	void NotifyGroupChanged();
	bool STATIC_IsInvisible(class AActor* TestActor);
};


// Class TgGame.TgDeployable_Portal
// 0x0004 (0x0414 - 0x0410)
class ATgDeployable_Portal : public ATgDeployable_Ward
{
public:
	unsigned long                                      r_bPortalActive : 1;                                      // 0x0410(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Portal");
		return ptr;
	}


	void PostDemoRewind();
	void DestroyIt(bool bSkipFx);
	void UpdatePortalVisuals();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetPortalActive(bool bActive);
	void STATIC_DeployComplete();
	void STATIC_CalcDeployPercentage();
	void UpdateMICState();
};


// Class TgGame.TgDeployable_GatewayEntrance
// 0x0008 (0x041C - 0x0414)
class ATgDeployable_GatewayEntrance : public ATgDeployable_Portal
{
public:
	class ATgDevice_Gateway*                           m_ownerGateway;                                           // 0x0414(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_GatewayEntrance");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
	void StartDeploy();
};


// Class TgGame.TgDeployable_GatewayExit
// 0x0008 (0x041C - 0x0414)
class ATgDeployable_GatewayExit : public ATgDeployable_Portal
{
public:
	class ATgDevice_Gateway*                           m_ownerGateway;                                           // 0x0414(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_GatewayExit");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void StartDeploy();
};


// Class TgGame.TgDeployable_PortalEntrance
// 0x001C (0x0430 - 0x0414)
class ATgDeployable_PortalEntrance : public ATgDeployable_Portal
{
public:
	class ATgDeployable_PortalExit*                    s_Exit;                                                   // 0x0414(0x0008)
	TArray<struct FPortalTimer>                        s_TouchingPawns;                                          // 0x041C(0x0010) (NeedCtorLink)
	unsigned long                                      s_bTeleportsAllowed : 1;                                  // 0x042C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_PortalEntrance");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void STATIC_PortalCooldown();
	void TriggerPortal(class ATgPawn* P);
	void Tick(float fDeltaTime);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeployable_PortalExit
// 0x0008 (0x041C - 0x0414)
class ATgDeployable_PortalExit : public ATgDeployable_Portal
{
public:
	class ATgDeployable_PortalEntrance*                s_Entrance;                                               // 0x0414(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_PortalExit");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
	void StartDeploy();
	void STATIC_DestroyEntrance();
	void STATIC_SpawnEntrance();
};


// Class TgGame.TgDeployable_PortalSiegeGame
// 0x001C (0x0430 - 0x0414)
class ATgDeployable_PortalSiegeGame : public ATgDeployable_Portal
{
public:
	float                                              s_fPortalTriggerTime;                                     // 0x0414(0x0004) (Const)
	float                                              s_fPortalReuseDelay;                                      // 0x0418(0x0004) (Const)
	TArray<struct FPortalTimer>                        s_TouchingPawns;                                          // 0x041C(0x0010) (NeedCtorLink)
	unsigned long                                      s_bTeleportsAllowed : 1;                                  // 0x042C(0x0004)
	unsigned long                                      c_bCooldownEffectsActive : 1;                             // 0x042C(0x0004)
	unsigned long                                      c_bPortalCooldownEffectsInitialized : 1;                  // 0x042C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_PortalSiegeGame");
		return ptr;
	}


	void STATIC_PortalCooldown();
	void TriggerPortal(class ATgPawn* P);
	void STATIC_SetPortalActive(bool bActive);
	class ATgPawn* UpdateActiveState();
	void UpdatePortalVisuals();
	void Tick(float fDeltaTime);
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
	bool STATIC_CanTeleportNow(class AActor* Traveler);
	bool CanTeleport(class AActor* Traveler);
	bool STATIC_CalcTeleportLocation(class AActor* Traveler, class AActor* DestinationActor, struct FVector* BestLocation);
};


// Class TgGame.TgDeployable_TriggerableWard
// 0x0024 (0x0434 - 0x0410)
class ATgDeployable_TriggerableWard : public ATgDeployable_Ward
{
public:
	class ATgCollisionProxy_WardTrigger*               m_TriggerCollisionProxy;                                  // 0x0410(0x0008)
	float                                              m_TriggerRange;                                           // 0x0418(0x0004)
	unsigned long                                      r_IsTriggered : 1;                                        // 0x041C(0x0004) (Net)
	unsigned long                                      m_bApplyRevealEffectOnTrigger : 1;                        // 0x041C(0x0004)
	unsigned long                                      m_bRevealOnlyOnTrigger : 1;                               // 0x041C(0x0004)
	float                                              m_TriggeredLifetime;                                      // 0x0420(0x0004)
	TArray<class ATgRepInfo_Player*>                   m_PotentialTriggers;                                      // 0x0424(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_TriggerableWard");
		return ptr;
	}


	void Destroyed();
	void STATIC_DeployComplete();
	void Tick(float DeltaSeconds);
	void TriggerCollisionProxyUnTouch(class AActor* Other);
	void TriggerCollisionProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_CanTriggerWardNow(class ATgRepInfo_Player* PRI);
	void STATIC_DoTrigger(class ATgRepInfo_Player* TriggererPRI);
	void InitReplicationInfo();
};


// Class TgGame.TgDeployable_WardEnvironment
// 0x0000 (0x0410 - 0x0410)
class ATgDeployable_WardEnvironment : public ATgDeployable_Ward
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_WardEnvironment");
		return ptr;
	}


	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_WardSentry
// 0x0000 (0x0410 - 0x0410)
class ATgDeployable_WardSentry : public ATgDeployable_Ward
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_WardSentry");
		return ptr;
	}

};


// Class TgGame.TgDeployable_WayPoint
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_WayPoint : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_WayPoint");
		return ptr;
	}

};


// Class TgGame.TgDeployable_CustomRanksInterface
// 0x0000 (0x0060 - 0x0060)
class UTgDeployable_CustomRanksInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_CustomRanksInterface");
		return ptr;
	}


	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgTrailComponent_GroundTrail
// 0x0043 (0x00C8 - 0x0085)
class UTgTrailComponent_GroundTrail : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	class UTgDeviceFire*                               m_FireMode;                                               // 0x0088(0x0008)
	TArray<class ATgDeployable*>                       s_Children;                                               // 0x0090(0x0010) (NeedCtorLink)
	float                                              m_fSeperationDistance;                                    // 0x00A0(0x0004)
	float                                              m_fEffectsApplicationPeriod;                              // 0x00A4(0x0004)
	float                                              m_fDeployableLifeSec;                                     // 0x00A8(0x0004)
	TArray<struct FTouchInfo>                          s_MasterTouchList;                                        // 0x00AC(0x0010) (NeedCtorLink)
	float                                              m_fTimeUntilApplyEffects;                                 // 0x00BC(0x0004)
	float                                              m_fTrailLifetime;                                         // 0x00C0(0x0004)
	unsigned long                                      m_bCanSpawnTrail : 1;                                     // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrailComponent_GroundTrail");
		return ptr;
	}


	struct FVector LastDroppedLoc();
	float TraveledDist();
	void STATIC_OnChildUnTouch(class AActor* Other, class ATgDeployable* Child);
	void STATIC_OnChildTouch(class AActor* Other, class ATgDeployable* Child);
	void STATIC_InitializeTrail(class UTgDeviceFire* pMode);
	void STATIC_RemoveGroundTrailByIndex(int I);
	void STATIC_RemoveGroundTrailByActor(class ATgDeployable* GroundTrail);
	bool STATIC_SpawnNewGroundTrail(const struct FVector& DeployLocation, const struct FRotator& DeployRotation);
	bool STATIC_SpawnNewGroundTrailAtOwner();
	void STATIC_PrepareForSelfDetach();
};


// Class TgGame.TgProjectile
// 0x00B0 (0x036C - 0x02BC)
class ATgProjectile : public AProjectile
{
public:
	class UTgDeviceFire*                               s_LastDefaultMode;                                        // 0x02BC(0x0008)
	int                                                r_nProjectileId;                                          // 0x02C4(0x0004) (Net)
	float                                              r_fDuration;                                              // 0x02C8(0x0004) (Net)
	unsigned long                                      m_bCanPulse : 1;                                          // 0x02CC(0x0004)
	unsigned long                                      c_bSuppressExplosionFX : 1;                               // 0x02CC(0x0004)
	unsigned long                                      c_bRotationFollowsVelocity : 1;                           // 0x02CC(0x0004)
	unsigned long                                      m_bStickToWalls : 1;                                      // 0x02CC(0x0004)
	unsigned long                                      m_bTrackTarget : 1;                                       // 0x02CC(0x0004)
	unsigned long                                      m_bTrackToWorldLocation : 1;                              // 0x02CC(0x0004)
	unsigned long                                      m_bHasExploded : 1;                                       // 0x02CC(0x0004)
	unsigned long                                      m_bIgnoreBehindProjCollisions : 1;                        // 0x02CC(0x0004)
	unsigned long                                      m_bIsInitialized : 1;                                     // 0x02CC(0x0004)
	unsigned long                                      m_bIsShutDown : 1;                                        // 0x02CC(0x0004)
	unsigned long                                      m_bPIEInitialized : 1;                                    // 0x02CC(0x0004)
	unsigned long                                      m_bHasPlayedFizzleFX : 1;                                 // 0x02CC(0x0004)
	unsigned long                                      m_bHasPlayedHitWallFX : 1;                                // 0x02CC(0x0004)
	unsigned long                                      m_bHasPlayedHitTargetFX : 1;                              // 0x02CC(0x0004)
	unsigned long                                      m_bProximityDistanceOverridesCollision : 1;               // 0x02CC(0x0004)
	unsigned long                                      m_bUseProximityCollisionOnClient : 1;                     // 0x02CC(0x0004)
	float                                              m_fPersistTime;                                           // 0x02D0(0x0004)
	float                                              m_fPersistHitPulse;                                       // 0x02D4(0x0004)
	int                                                m_nTargetPhysicalType;                                    // 0x02D8(0x0004)
	class UMeshComponent*                              c_Mesh;                                                   // 0x02DC(0x0008) (ExportObject, Component, EditInline)
	class UTgSpecialFx*                                c_ExplosionFx;                                            // 0x02E4(0x0008)
	float                                              r_fAccelRate;                                             // 0x02EC(0x0004) (Net)
	int                                                c_FiringOwnerStatsID;                                     // 0x02F0(0x0004)
	int                                                c_FiringWeaponStatsID;                                    // 0x02F4(0x0004)
	int                                                c_FiringWeaponMode;                                       // 0x02F8(0x0004)
	float                                              m_fTossZ;                                                 // 0x02FC(0x0004)
	class AActor*                                      r_Owner;                                                  // 0x0300(0x0008) (Net)
	int                                                r_nOwnerFireModeId;                                       // 0x0308(0x0004) (Net)
	class UTgDeviceFire*                               s_OwnerFireMode;                                          // 0x030C(0x0008)
	float                                              r_fRange;                                                 // 0x0314(0x0004) (Net)
	float                                              m_fAcquireDistance;                                       // 0x0318(0x0004)
	float                                              m_fProximityDistance;                                     // 0x031C(0x0004)
	class ATgCollisionProxy*                           m_CollisionProxy;                                         // 0x0320(0x0008)
	int                                                s_nSpawnBotId;                                            // 0x0328(0x0004)
	int                                                s_nSpawnDeployableId;                                     // 0x032C(0x0004)
	float                                              m_fDelayTrackSeconds;                                     // 0x0330(0x0004)
	float                                              m_fDamageRadius;                                          // 0x0334(0x0004)
	struct FVector                                     r_vSpawnLocation;                                         // 0x0338(0x000C) (Net)
	struct FVector                                     m_vLocationLastTick;                                      // 0x0344(0x000C)
	float                                              m_fMinTravelRange;                                        // 0x0350(0x0004)
	float                                              s_fSpawnTime;                                             // 0x0354(0x0004)
	unsigned char                                      s_nFiringInstance;                                        // 0x0358(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0359(0x0003) MISSED OFFSET
	float                                              s_fShutdownDestroyDelay;                                  // 0x035C(0x0004)
	float                                              s_fLiveSpectateRelevancyDist;                             // 0x0360(0x0004) (Const, Config)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x0364(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProjectile");
		return ptr;
	}


	struct FName STATIC_GetHitTargetDisplayGroup();
	struct FName STATIC_GetHitWallDisplayGroup();
	void STATIC_PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void PlayHitWallExplosionFX(const struct FVector& HitNormal, const struct FVector& HitLocation);
	class UPhysicalMaterial* TraceWorldPhysicalGeometry(const struct FVector& StartLoc, const struct FVector& EndLoc, struct FVector* TraceHitLocation);
	void STATIC_PlayFizzleFX(const struct FVector& HitLocation, const struct FVector& HitNormal, bool bIsExplosionFizzle);
	void STATIC_PlayLandingSound(class AActor* LandingHitActor);
	void ServerDetonate();
	bool STATIC_ProjectileCalcCamera(float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV);
	void MyOnParticleSystemFinished(class UParticleSystemComponent* PSC);
	void Destroyed();
	void STATIC_ShowProjectile();
	void STATIC_HideProjectile();
	void TornOff();
	void ShutDown();
	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SpawnFlightEffects();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Explode(const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_CalcAoeFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	struct FAimData STATIC_GetApplyHitAim();
	bool STATIC_CheckTeamPassThrough(class AActor* Other);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProcessTouchAsEvent(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void FellOutOfWorld(class UClass* dmgType);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool IsOutsideMinRange(const struct FVector& HitLocation);
	void STATIC_SetAcceleration();
	bool STATIC_ProximityReached(class AActor* A, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_GetHitLocationForProximityTouch(class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal);
	bool IsValidTarget(class AActor* A);
	void STATIC_RangeReached();
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void Init(const struct FVector& Direction);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void TimerExplode();
	void TimerPulse();
	void ClientSetExplode();
	void STATIC_StartPulse();
	void PostProjectileInitialize();
	void PostBeginPlay();
	bool UseAOE();
	void STATIC_ForceTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ProximityDistanceOverridesCollision();
	class ATgDeployable* STATIC_SpawnTheDeployable(const struct FVector& HitLocation, const struct FVector& HitNormal);
	class ATgPawn* STATIC_SpawnTheBot(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_CompleteInitialization();
	bool STATIC_CheckPhysicality(int nPawnType);
	float STATIC_GetBuffedRange();
};


// Class TgGame.TgProj_Bounce
// 0x000C (0x0378 - 0x036C)
class ATgProj_Bounce : public ATgProjectile
{
public:
	float                                              m_fMaxSpeed;                                              // 0x036C(0x0004)
	float                                              m_fMinSpeed;                                              // 0x0370(0x0004)
	float                                              m_fMaxRange;                                              // 0x0374(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Bounce");
		return ptr;
	}


	void Destroyed();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void AdjustedInit(const struct FVector& StartLocation, const struct FVector& HitLocation);
	void STATIC_SetSpeed(float Distance);
	bool STATIC_SuggestProjVelocity(const struct FVector& End, const struct FVector& Start, float projSpeed, float* BaseTossZ);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void MyOnParticleSystemFinished(class UParticleSystemComponent* PSC);
};


// Class TgGame.TgProj_Grapple
// 0x0034 (0x03AC - 0x0378)
class ATgProj_Grapple : public ATgProj_Bounce
{
public:
	class AEmitter*                                    c_GrappleEffect;                                          // 0x0378(0x0008)
	struct FVector                                     r_vTargetLocation;                                        // 0x0380(0x000C) (Net)
	struct FVector                                     m_ClimbDir;                                               // 0x038C(0x000C)
	struct FVector                                     m_LookDir;                                                // 0x0398(0x000C)
	struct FName                                       c_nmBoneName;                                             // 0x03A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Grapple");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_InitGrapple();
	void AdjustedInit(const struct FVector& StartLocation, const struct FVector& HitLocation);
	void PostBeginPlay();
};


// Class TgGame.TgProj_FreeGrenade
// 0x000C (0x0378 - 0x036C)
class ATgProj_FreeGrenade : public ATgProjectile
{
public:
	unsigned long                                      m_bFFTouched : 1;                                         // 0x036C(0x0004)
	class ATgDeploy_ForceField*                        m_touchedFF;                                              // 0x0370(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FreeGrenade");
		return ptr;
	}


	void Destroyed();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void Timer();
	void ShutDown();
	void PostBeginPlay();
};


// Class TgGame.TgProj_Bot
// 0x0000 (0x0378 - 0x0378)
class ATgProj_Bot : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Bot");
		return ptr;
	}


	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_SpawnTheBotOld(const struct FVector& HitLocation, class AActor* TargetActor);
	class ATgPawn* SpawnBot(const struct FVector& vLocation);
};


// Class TgGame.TgProj_Deployable
// 0x0000 (0x0378 - 0x0378)
class ATgProj_Deployable : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Deployable");
		return ptr;
	}


	void STATIC_RangeReached();
	void ServerDetonate();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_SpawnTheDeployableOld(const struct FVector& HitLocation, class AActor* TargetActor, const struct FVector& HitNormal);
	class ATgDeployable* STATIC_SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgProj_Mortar
// 0x0000 (0x0378 - 0x0378)
class ATgProj_Mortar : public ATgProj_FreeGrenade
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Mortar");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
};


// Class TgGame.TgProj_Missile
// 0x0040 (0x03AC - 0x036C)
class ATgProj_Missile : public ATgProjectile
{
public:
	float                                              m_fDefaultExplosionRange;                                 // 0x036C(0x0004)
	struct FVector                                     m_vInitialDir;                                            // 0x0370(0x000C)
	struct FVector                                     m_vInitialPos;                                            // 0x037C(0x000C)
	class AActor*                                      r_aSeeking;                                               // 0x0388(0x0008) (Net)
	int                                                r_nNumBounces;                                            // 0x0390(0x0004) (Net)
	struct FVector                                     r_vTargetWorldLocation;                                   // 0x0394(0x000C) (Net)
	unsigned long                                      s_bInitializedSeekingWorldLocation : 1;                   // 0x03A0(0x0004)
	class UStaticMeshComponent*                        c_PhotonMesh;                                             // 0x03A4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Missile");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	class ATgPlayerController* STATIC_GetLocalPlayerPawn();
	void ShutDown();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void STATIC_CheckAcquireRange();
	void STATIC_CheckSeekingTarget();
	void PostBeginPlay();
	void STATIC_CheckRange();
	void STATIC_SetInitSeekingTarget(class AActor* LockedTarget);
	void SetInitialState();
};


// Class TgGame.TgProj_Rocket
// 0x0034 (0x03A0 - 0x036C)
class ATgProj_Rocket : public ATgProjectile
{
public:
	unsigned char                                      FlockIndex;                                               // 0x036C(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x036D(0x0003) MISSED OFFSET
	class ATgProj_Rocket*                              Flock[0x2];                                               // 0x0370(0x0008)
	float                                              FlockRadius;                                              // 0x0380(0x0004) (Edit)
	float                                              FlockStiffness;                                           // 0x0384(0x0004) (Edit)
	float                                              FlockMaxForce;                                            // 0x0388(0x0004) (Edit)
	float                                              FlockCurlForce;                                           // 0x038C(0x0004) (Edit)
	unsigned long                                      bCurl : 1;                                                // 0x0390(0x0004) (Net)
	struct FVector                                     Dir;                                                      // 0x0394(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Rocket");
		return ptr;
	}


	void STATIC_FlockTimer();
	void ReplicatedEvent(const struct FName& VarName);
	void Destroyed();
	void Init(const struct FVector& Direction);
};


// Class TgGame.TgProj_Simulated
// 0x002C (0x0398 - 0x036C)
class ATgProj_Simulated : public ATgProjectile
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterface;                                 // 0x036C(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bHasFlashedShutdown : 1;                                // 0x0374(0x0004)
	unsigned long                                      m_bHasFlashExploded : 1;                                  // 0x0374(0x0004)
	unsigned long                                      m_bForceInterested : 1;                                   // 0x0374(0x0004)
	unsigned long                                      m_bForceRangeInterestCheck : 1;                           // 0x0374(0x0004)
	unsigned long                                      m_bIsStimmedShotFX : 1;                                   // 0x0374(0x0004)
	unsigned long                                      s_bShouldSendTiDiEventToClients : 1;                      // 0x0374(0x0004)
	int                                                m_nProjectileInstanceId;                                  // 0x0378(0x0004)
	unsigned char                                      m_nPreviousTargets;                                       // 0x037C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x037D(0x0003) MISSED OFFSET
	TArray<class ATgPlayerController*>                 s_InterestedPlayers;                                      // 0x0380(0x0010) (NeedCtorLink)
	class UTgTiDiState*                                s_CurrentTiDi;                                            // 0x0390(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Simulated");
		return ptr;
	}


	bool ClientNeedsTarget(int nOrderedTarget);
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void ClientTargetUpdate(class AActor* TargetActor, const struct FVector& TargetLocation);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void Tick(float DeltaSeconds);
	void Destroyed();
	void ShutDown();
	void ClientHitUpdate(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClientExplode(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Explode(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_SendTiDiEventToClients();
	void STATIC_ShutdownTiDi();
	void TransmitTiDiClient();
	void TransmitTiDiServer();
	void ApplyTiDi();
	bool STATIC_ShouldUpdateTiDi();
	class UTgTiDiState* STATIC_GetCurrentTiDi();
	void STATIC_InitializeTiDi();
	bool IsInterested(class ATgPlayerController* pTgPC);
	void STATIC_SyncProjectileParams();
	void STATIC_FlashNotifyTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void STATIC_FlashNotifyHitWall(class AActor* Wall, const struct FVector& HitNormal, const struct FVector& HitLocation);
	void STATIC_FlashNotifyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FlashNotifyExploded(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FlashNotifyShutdown();
	void STATIC_FlashNotifySpawn();
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_SimulatedGroundTarget
// 0x0024 (0x03BC - 0x0398)
class ATgProj_SimulatedGroundTarget : public ATgProj_Simulated
{
public:
	struct FPointer                                    VfTable_ITgProjGroundTargetInterface;                     // 0x0398(0x0008) (Const, Native, NoExport)
	struct FVector                                     m_GroundTargetLocation;                                   // 0x03A0(0x000C)
	float                                              m_fGravityMultipler;                                      // 0x03AC(0x0004)
	float                                              m_fPredictedTravelTime;                                   // 0x03B0(0x0004)
	class ATgSkeletalMeshActor*                        m_WarningFxMesh;                                          // 0x03B4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedGroundTarget");
		return ptr;
	}


	void STATIC_PlayFizzleFX(const struct FVector& HitLocation, const struct FVector& HitNormal, bool bIsExplosionFizzle);
	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_CheckTargetDistance(const struct FVector& vLocOverride);
	void STATIC_TargetReached();
	void Tick(float DeltaSeconds);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ShutDown();
	void STATIC_PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void SetGroundTarget(const struct FVector& GTLocation);
	void ClientTargetUpdate(class AActor* TargetActor, const struct FVector& TargetLocation);
	void UpdateVisualsOnSetGroundTarget();
	float STATIC_GetGravityZ();
	void STATIC_CompleteInitialization();
	void STATIC_CalculateLob();
};


// Class TgGame.TgProj_SimulatedGroundTarget_FixedAngle
// 0x0004 (0x03C0 - 0x03BC)
class ATgProj_SimulatedGroundTarget_FixedAngle : public ATgProj_SimulatedGroundTarget
{
public:
	float                                              m_LobAngle;                                               // 0x03BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedGroundTarget_FixedAngle");
		return ptr;
	}


	void STATIC_CalculateLob();
};


// Class TgGame.TgProj_SimulatedGroundTarget_FixedTime
// 0x0008 (0x03C4 - 0x03BC)
class ATgProj_SimulatedGroundTarget_FixedTime : public ATgProj_SimulatedGroundTarget
{
public:
	float                                              m_StartTime;                                              // 0x03BC(0x0004)
	float                                              m_AirTime;                                                // 0x03C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedGroundTarget_FixedTime");
		return ptr;
	}


	bool STATIC_CheckTargetDistance(const struct FVector& vLocOverride);
	void SetGroundTarget(const struct FVector& GTLocation);
	void STATIC_CalculateLob();
};


// Class TgGame.TgProj_SimulatedGroundTarget_FixedTime_NoLob
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_SimulatedGroundTarget_FixedTime_NoLob : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedGroundTarget_FixedTime_NoLob");
		return ptr;
	}


	bool STATIC_CheckTargetDistance(const struct FVector& vLocOverride);
	void STATIC_CalculateLob();
};


// Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime");
		return ptr;
	}


	void STATIC_CalculateLob();
};


// Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime_NoLob
// 0x0004 (0x03C8 - 0x03C4)
class ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime_NoLob : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:
	unsigned long                                      m_bDoNotAllowZVelocity : 1;                               // 0x03C4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime_NoLob");
		return ptr;
	}


	bool STATIC_CheckTargetDistance(const struct FVector& vLocOverride);
	void SetGroundTarget(const struct FVector& GTLocation);
	void STATIC_CalculateLob();
};


// Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_NoLob
// 0x0004 (0x03C0 - 0x03BC)
class ATgProj_SimulatedGroundTarget_FixedVelocity_NoLob : public ATgProj_SimulatedGroundTarget
{
public:
	unsigned long                                      m_bDoNotAllowZVelocity : 1;                               // 0x03BC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_NoLob");
		return ptr;
	}


	bool STATIC_CheckTargetDistance(const struct FVector& vLocOverride);
	void STATIC_CalculateLob();
};


// Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_XY
// 0x0000 (0x03BC - 0x03BC)
class ATgProj_SimulatedGroundTarget_FixedVelocity_XY : public ATgProj_SimulatedGroundTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_XY");
		return ptr;
	}


	void STATIC_CalculateLob();
};


// Class TgGame.TgProj_SimulatedPassThrough
// 0x0014 (0x03AC - 0x0398)
class ATgProj_SimulatedPassThrough : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x0398(0x0004)
	unsigned long                                      m_bExplodeOnBlocker : 1;                                  // 0x0398(0x0004)
	unsigned long                                      m_bSkipFriendlies : 1;                                    // 0x0398(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x039C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedPassThrough");
		return ptr;
	}


	void Destroyed();
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ProximityDistanceOverridesCollision();
};


// Class TgGame.TgProj_CTF_ThrownFlag
// 0x0024 (0x03D0 - 0x03AC)
class ATgProj_CTF_ThrownFlag : public ATgProj_SimulatedPassThrough
{
public:
	struct FVector                                     m_vLastValidFlagLocation;                                 // 0x03AC(0x000C)
	struct FVector                                     m_vLastTrackedProjectileLocation;                         // 0x03B8(0x000C)
	unsigned long                                      m_bExplosionAttach : 1;                                   // 0x03C4(0x0004)
	class ATgDeployable_CTF_Flag*                      s_OriginalFlag;                                           // 0x03C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CTF_ThrownFlag");
		return ptr;
	}


	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void HitWall(const struct FVector& HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_CompleteInitialization();
	void AttemptExplosionAttach(class ATgPawn* HitPawn);
};


// Class TgGame.TgProj_Racer_Boulder
// 0x0034 (0x03E0 - 0x03AC)
class ATgProj_Racer_Boulder : public ATgProj_SimulatedPassThrough
{
public:
	struct FVector                                     m_LastBounceLocation;                                     // 0x03AC(0x000C)
	int                                                m_nBounceCount;                                           // 0x03B8(0x0004)
	int                                                m_nMaxBounceCount;                                        // 0x03BC(0x0004)
	unsigned long                                      m_bApplyBounceVelocity : 1;                               // 0x03C0(0x0004)
	struct FVector                                     m_vBounceVelocity;                                        // 0x03C4(0x000C)
	TArray<class AActor*>                              m_TotalHitTargets;                                        // 0x03D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Racer_Boulder");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Simulated_RadialDegree
// 0x0078 (0x0424 - 0x03AC)
class ATgProj_Simulated_RadialDegree : public ATgProj_SimulatedPassThrough
{
public:
	float                                              c_fInterpVal;                                             // 0x03AC(0x0004)
	float                                              c_fInterpRate;                                            // 0x03B0(0x0004)
	float                                              m_fBaseRadius;                                            // 0x03B4(0x0004)
	float                                              m_fCurrentRadius;                                         // 0x03B8(0x0004)
	float                                              m_fRadiusOffset;                                          // 0x03BC(0x0004)
	float                                              c_fCurrentRadius;                                         // 0x03C0(0x0004)
	unsigned long                                      m_bDoesScale : 1;                                         // 0x03C4(0x0004)
	unsigned long                                      m_bDoesRotate : 1;                                        // 0x03C4(0x0004)
	float                                              m_fScaleStartRadius;                                      // 0x03C8(0x0004)
	float                                              m_fScaleEndRadius;                                        // 0x03CC(0x0004)
	float                                              m_fScaleCurrentRadius;                                    // 0x03D0(0x0004)
	float                                              m_fScalePerSec;                                           // 0x03D4(0x0004)
	float                                              m_fTotalScaleTime;                                        // 0x03D8(0x0004)
	float                                              m_fCurrentAngle;                                          // 0x03DC(0x0004)
	float                                              m_fAngleOffset;                                           // 0x03E0(0x0004)
	float                                              c_fCurrentAngle;                                          // 0x03E4(0x0004)
	struct FVector                                     m_CenterLocation;                                         // 0x03E8(0x000C)
	struct FVector                                     m_CachedAimVector;                                        // 0x03F4(0x000C)
	struct FVector                                     m_PreviousLocation;                                       // 0x0400(0x000C)
	TArray<float>                                      m_fClearTimes;                                            // 0x040C(0x0010) (NeedCtorLink)
	float                                              m_fHitClearTime;                                          // 0x041C(0x0004)
	float                                              m_fProjectileSyncRate;                                    // 0x0420(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Simulated_RadialDegree");
		return ptr;
	}


	bool UseAOE();
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ScaleProjectile(float DeltaSeconds);
	void Destroyed();
	void CheckTimeout(float DeltaSeconds);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void SetSyncParams(float fGeneric1, float fGeneric2);
	void GetSyncParams(float* fGeneric1, float* fGeneric2);
	void SetSpawnParams(float fGeneric1, float fGeneric2);
	void GetSpawnParams(float* fGeneric1, float* fGeneric2);
	float GetAngleToOffset(float PercOfAngle);
	struct FRotator CalculateRotation(const struct FVector& centerPoint, const struct FVector& PointOnCircle);
	float CalculateOriginalAngle(const struct FVector& centerPoint, const struct FVector& PointOnCircle);
	float CalculateStartingRadius(const struct FVector& centerPoint, const struct FVector& PointOnCircle);
	struct FVector CalculateCenterPoint(const struct FVector& PointOnCircle, float fRadius, const struct FVector& fProjectileRotationVector);
	void STATIC_CompleteInitialization();
	struct FVector STATIC_GetRadialLocationWorldXY(const struct FVector& centerPoint, float fRadius, float fAngle, bool bIsRadians);
};


// Class TgGame.TgProj_CH05_LokiSaw
// 0x0000 (0x0424 - 0x0424)
class ATgProj_CH05_LokiSaw : public ATgProj_Simulated_RadialDegree
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CH05_LokiSaw");
		return ptr;
	}

};


// Class TgGame.TgProj_Simulated_RadialDegreeSpiral
// 0x0000 (0x0424 - 0x0424)
class ATgProj_Simulated_RadialDegreeSpiral : public ATgProj_Simulated_RadialDegree
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Simulated_RadialDegreeSpiral");
		return ptr;
	}


	void SetSyncParams(float fGeneric1, float fGeneric2);
	void GetSyncParams(float* fGeneric1, float* fGeneric2);
	void SetSpawnParams(float fGeneric1, float fGeneric2);
	void GetSpawnParams(float* fGeneric1, float* fGeneric2);
};


// Class TgGame.TgProj_CH05_SpiralSwirl
// 0x0000 (0x0424 - 0x0424)
class ATgProj_CH05_SpiralSwirl : public ATgProj_Simulated_RadialDegreeSpiral
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CH05_SpiralSwirl");
		return ptr;
	}

};


// Class TgGame.TgProj_CH05_SpiralSwirl_V2
// 0x0000 (0x0424 - 0x0424)
class ATgProj_CH05_SpiralSwirl_V2 : public ATgProj_Simulated_RadialDegreeSpiral
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CH05_SpiralSwirl_V2");
		return ptr;
	}


	float CalculateStartingRadius(const struct FVector& centerPoint, const struct FVector& PointOnCircle);
};


// Class TgGame.TgProj_Simulated_RadialConstantSpiral
// 0x0000 (0x0424 - 0x0424)
class ATgProj_Simulated_RadialConstantSpiral : public ATgProj_Simulated_RadialDegreeSpiral
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Simulated_RadialConstantSpiral");
		return ptr;
	}


	float GetAngleToOffset(float PercOfAngle);
};


// Class TgGame.TgProj_Simulated_DeploySizeConstantSpiral
// 0x0000 (0x0424 - 0x0424)
class ATgProj_Simulated_DeploySizeConstantSpiral : public ATgProj_Simulated_RadialConstantSpiral
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Simulated_DeploySizeConstantSpiral");
		return ptr;
	}


	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_Simulated_RollingLineAttack
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Simulated_RollingLineAttack : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Simulated_RollingLineAttack");
		return ptr;
	}


	void PostProjectileInitialize();
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool UseAOE();
};


// Class TgGame.TgProj_SimulatedBoomerang
// 0x000C (0x03B8 - 0x03AC)
class ATgProj_SimulatedBoomerang : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_fTurnStrength;                                          // 0x03AC(0x0004)
	unsigned long                                      m_bDestroyByDistance : 1;                                 // 0x03B0(0x0004)
	float                                              m_fDistanceToDestroy;                                     // 0x03B4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedBoomerang");
		return ptr;
	}


	struct FVector GetSeekLocation();
	void UpdateSeekingDirection(float fDeltaTime);
	void STATIC_ReturnToOwner();
	void STATIC_RangeReached();
};


// Class TgGame.TgProj_SimulatedPassThrough_GodHitInitial
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_SimulatedPassThrough_GodHitInitial : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedPassThrough_GodHitInitial");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_CH11_Relic_Knockback
// 0x0004 (0x03B0 - 0x03AC)
class ATgProj_CH11_Relic_Knockback : public ATgProj_SimulatedPassThrough_GodHitInitial
{
public:
	unsigned long                                      m_bInitialHitOnly : 1;                                    // 0x03AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CH11_Relic_Knockback");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_PerformWallKnockback(class ATgPawn* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_SimulatedPassThrough_NoAOE
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_SimulatedPassThrough_NoAOE : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedPassThrough_NoAOE");
		return ptr;
	}


	bool UseAOE();
};


// Class TgGame.TgProj_SimulatedPassThrough_SpawnDeployable
// 0x0014 (0x03C0 - 0x03AC)
class ATgProj_SimulatedPassThrough_SpawnDeployable : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_fTravelDistanceOffset;                                  // 0x03AC(0x0004)
	struct FVector                                     m_vDeployableLocation;                                    // 0x03B0(0x000C)
	unsigned long                                      m_bHasDeployableLocation : 1;                             // 0x03BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedPassThrough_SpawnDeployable");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_RangeReached();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	struct FVector STATIC_GetDeployableExtent();
	struct FVector STATIC_GetDeployablePlacement(const struct FVector& HitLoc);
};


// Class TgGame.TgProj_SimulatedPassThroughUntilAlliedGod
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_SimulatedPassThroughUntilAlliedGod : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedPassThroughUntilAlliedGod");
		return ptr;
	}


	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_SimulatedPassThroughUntilGod
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_SimulatedPassThroughUntilGod : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedPassThroughUntilGod");
		return ptr;
	}


	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_SimulatedPassThroughUntilGod_CollidesWorld
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_SimulatedPassThroughUntilGod_CollidesWorld : public ATgProj_SimulatedPassThroughUntilGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedPassThroughUntilGod_CollidesWorld");
		return ptr;
	}

};


// Class TgGame.TgProj_SimulatedSinusoid
// 0x0020 (0x03CC - 0x03AC)
class ATgProj_SimulatedSinusoid : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_fAmplitude;                                             // 0x03AC(0x0004)
	float                                              m_fFrequency;                                             // 0x03B0(0x0004)
	float                                              m_fPhaseOffset;                                           // 0x03B4(0x0004)
	unsigned long                                      m_bMirror : 1;                                            // 0x03B8(0x0004)
	float                                              m_fForwardSpeed;                                          // 0x03BC(0x0004) (Transient)
	struct FVector                                     m_vForwardVector;                                         // 0x03C0(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedSinusoid");
		return ptr;
	}


	void STATIC_FixUpInitialVelocityAndRotation();
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_SimulatedSeeking
// 0x0034 (0x03CC - 0x0398)
class ATgProj_SimulatedSeeking : public ATgProj_Simulated
{
public:
	unsigned long                                      m_IgnoreCollisionWithNonTargets : 1;                      // 0x0398(0x0004)
	unsigned long                                      m_IgnoreCollisionWithWorldIfSeeking : 1;                  // 0x0398(0x0004)
	unsigned long                                      m_IgnoreCollisionWithWorldIfNotSeeking : 1;               // 0x0398(0x0004)
	unsigned long                                      m_bUsePredictiveSeeking : 1;                              // 0x0398(0x0004)
	unsigned long                                      m_bSeekToLocation : 1;                                    // 0x0398(0x0004)
	unsigned long                                      m_bFollowSeekingRotation : 1;                             // 0x0398(0x0004)
	unsigned long                                      m_bExplodeAtGround : 1;                                   // 0x0398(0x0004)
	unsigned long                                      m_bAllowAcceleration : 1;                                 // 0x0398(0x0004)
	unsigned long                                      m_bAllowZeroVelocityStops : 1;                            // 0x0398(0x0004)
	unsigned long                                      m_bAllowInstant180Turns : 1;                              // 0x0398(0x0004)
	struct FVector                                     m_vTargetLocation;                                        // 0x039C(0x000C)
	class AActor*                                      m_Target;                                                 // 0x03A8(0x0008)
	float                                              m_fTurnStrength;                                          // 0x03B0(0x0004)
	float                                              m_fVertTurnStrength;                                      // 0x03B4(0x0004)
	float                                              m_fHitMarginOfErrorSq;                                    // 0x03B8(0x0004)
	float                                              m_fGroundZMarginOfError;                                  // 0x03BC(0x0004)
	struct FRotator                                    m_SeekingRotation;                                        // 0x03C0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedSeeking");
		return ptr;
	}


	bool STATIC_CheckTeamPassThrough(class AActor* Other);
	struct FVector GetSeekLocation();
	void UpdateSeekingDirection(float fDeltaTime);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void Tick(float fDeltaTime);
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_FireGiant_RagnarokFury
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_FireGiant_RagnarokFury : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FireGiant_RagnarokFury");
		return ptr;
	}

};


// Class TgGame.TgProj_ScaleProjectileByHits
// 0x0004 (0x03D0 - 0x03CC)
class ATgProj_ScaleProjectileByHits : public ATgProj_SimulatedSeeking
{
public:
	int                                                m_nHitCount;                                              // 0x03CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ScaleProjectileByHits");
		return ptr;
	}


	void ScaleProjFX();
	void ApplySpawnParams(int nHitCount);
};


// Class TgGame.TgProj_SimulatedArcing
// 0x0040 (0x040C - 0x03CC)
class ATgProj_SimulatedArcing : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bCanBounceOnSame : 1;                                   // 0x03CC(0x0004)
	unsigned long                                      m_bInitialHit : 1;                                        // 0x03CC(0x0004)
	unsigned long                                      m_bRequireLOS : 1;                                        // 0x03CC(0x0004)
	unsigned long                                      m_bAllowInstigatorHit : 1;                                // 0x03CC(0x0004)
	unsigned long                                      m_bIgnorePreviousTargets : 1;                             // 0x03CC(0x0004)
	unsigned long                                      m_bInTargetDelay : 1;                                     // 0x03CC(0x0004)
	int                                                m_nArcingJumps;                                           // 0x03D0(0x0004)
	float                                              m_fDelayOnHit;                                            // 0x03D4(0x0004)
	float                                              m_fArcRange;                                              // 0x03D8(0x0004)
	float                                              m_fArcMaxRange;                                           // 0x03DC(0x0004)
	float                                              m_fAttachRange;                                           // 0x03E0(0x0004)
	struct FVector                                     m_vLastArcLocation;                                       // 0x03E4(0x000C)
	TArray<class AActor*>                              m_PreviousTargets;                                        // 0x03F0(0x0010) (AlwaysInit, NeedCtorLink)
	class AActor*                                      m_LastTarget;                                             // 0x0400(0x0008)
	float                                              m_fLastHitTime;                                           // 0x0408(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedArcing");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float fDeltaTime);
	void SetSeekingTarget(class AActor* LockedTarget);
	void ClientHitUpdate(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClientArcCountUpdate(int ArcCount);
	void ClientTargetUpdate(class AActor* TargetActor, const struct FVector& TargetLocation);
	void STATIC_OverrideSeekingRotation(struct FRotator* SeekingRotation);
	void AdvanceToNextTarget(class AActor* NewTargetOverride);
	void AdvanceTimer();
	void ShutDown();
	void SetAdvanceTimer();
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	class AActor* STATIC_GetNextSeekTarget();
};


// Class TgGame.TgProj_SimulatedReturnStroke
// 0x0004 (0x03D0 - 0x03CC)
class ATgProj_SimulatedReturnStroke : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bKillOnTouchedTarget : 1;                               // 0x03CC(0x0004)
	unsigned long                                      m_bKillWhenReachedTargetLocation : 1;                     // 0x03CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedReturnStroke");
		return ptr;
	}


	void Tick(float fDeltaTime);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_SimulatedReturnStroke_TeleportFX
// 0x0010 (0x03E0 - 0x03D0)
class ATgProj_SimulatedReturnStroke_TeleportFX : public ATgProj_SimulatedReturnStroke
{
public:
	struct FVector                                     m_vTeleportDestination;                                   // 0x03D0(0x000C)
	unsigned long                                      m_bKillWhenReachedTeleportLocation : 1;                   // 0x03DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedReturnStroke_TeleportFX");
		return ptr;
	}


	void SetTeleportDestination(const struct FVector& vDest);
	void Tick(float fDeltaTime);
};


// Class TgGame.TgProj_SimulatedSeekingPassThrough
// 0x0014 (0x03E0 - 0x03CC)
class ATgProj_SimulatedSeekingPassThrough : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x03CC(0x0004)
	unsigned long                                      m_bExplodeOnBlocker : 1;                                  // 0x03CC(0x0004)
	unsigned long                                      m_bSkipFriendlies : 1;                                    // 0x03CC(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x03D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedSeekingPassThrough");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_SimulatedSeekingPassThrough_UntilOwner
// 0x0000 (0x03E0 - 0x03E0)
class ATgProj_SimulatedSeekingPassThrough_UntilOwner : public ATgProj_SimulatedSeekingPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedSeekingPassThrough_UntilOwner");
		return ptr;
	}


	bool UseAOE();
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Tornado
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Tornado : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Tornado");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_SetDuration(float Duration);
};


// Class TgGame.TgProj_TowerScaling
// 0x0004 (0x03D0 - 0x03CC)
class ATgProj_TowerScaling : public ATgProj_SimulatedSeeking
{
public:
	int                                                c_nScale;                                                 // 0x03CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_TowerScaling");
		return ptr;
	}


	void STATIC_HideProjectile();
	struct FName STATIC_GetHitWallDisplayGroup();
	struct FName STATIC_GetHitTargetDisplayGroup();
	void UpdateDisplayGroups();
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_SimulatedWithExemptList
// 0x0010 (0x03A8 - 0x0398)
class ATgProj_SimulatedWithExemptList : public ATgProj_Simulated
{
public:
	TArray<class AActor*>                              m_ExemptList;                                             // 0x0398(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SimulatedWithExemptList");
		return ptr;
	}


	bool IsValidTarget(class AActor* A);
};


// Class TgGame.TgActor_DeathFog
// 0x0070 (0x02D0 - 0x0260)
class ATgActor_DeathFog : public AActor
{
public:
	struct FPointer                                    VfTable_ITgInverseRolloffAudio;                           // 0x0260(0x0008) (Const, Native, NoExport)
	class UTexture2D*                                  m_TextureNormal;                                          // 0x0268(0x0008)
	class ATgRepInfo_DeathFog*                         r_DFRI;                                                   // 0x0270(0x0008) (Net)
	TEnumAsByte<EFogFxType>                            m_FogFxType;                                              // 0x0278(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0279(0x0003) MISSED OFFSET
	int                                                m_FlatFogMeshId;                                          // 0x027C(0x0004) (Edit)
	TArray<struct FFOG_CONFIG>                         m_FogSettings;                                            // 0x0280(0x0010) (Edit, NeedCtorLink)
	int                                                m_FogIndex;                                               // 0x0290(0x0004)
	float                                              m_fFogStartDistance;                                      // 0x0294(0x0004) (Edit)
	int                                                m_fFogDeviceId;                                           // 0x0298(0x0004) (Edit)
	float                                              s_fDefaultFogSpreadRate;                                  // 0x029C(0x0004) (Edit)
	float                                              s_fFogSpreadRate;                                         // 0x02A0(0x0004)
	float                                              s_fDefaultFogTickInterval;                                // 0x02A4(0x0004) (Edit)
	float                                              m_fFogTickInterval;                                       // 0x02A8(0x0004)
	float                                              m_fFogDistance;                                           // 0x02AC(0x0004)
	float                                              m_fFogSafeDistance;                                       // 0x02B0(0x0004)
	unsigned long                                      s_bFogGrowing : 1;                                        // 0x02B4(0x0004)
	unsigned long                                      s_bFogActive : 1;                                         // 0x02B4(0x0004)
	unsigned long                                      s_bIsPaused : 1;                                          // 0x02B4(0x0004)
	class ATgDevice*                                   m_FogDevice;                                              // 0x02B8(0x0008)
	TArray<class ATgPawn*>                             m_PreviousTargets;                                        // 0x02C0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActor_DeathFog");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ClearPreviousTargets();
	void Destroyed();
	void ToggleFogEmitters(class USeqAct_Toggle* ToggleAction, int nFogIndex);
	void UpdateFogSpread();
	void UpdateClientFogTimers();
	void SetTickInterval(float fTickInterval);
	void SetSpreadRate(float fSpreadRate);
	void SetSafeDistance(float fSafeDistance);
	void SetFogDistance(float fFogDistance);
	void SetFogActive(bool bEnabled);
	void InitReplicationInfo();
	float STATIC_GetCurrentRadius();
	void STATIC_DeactivateEmitters(int nFogIndex);
	void ActivateEmitters(int nFogIndex);
	void AdvanceFogSequence();
	void STATIC_ResetFogSequence();
	void STATIC_EndFogSequence();
	void STATIC_StartFogSequence();
	void STATIC_CacheFogDevice();
};


// Class TgGame.TgAudioComponent
// 0x0000 (0x02D0 - 0x02D0)
class UTgAudioComponent : public UAudioComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAudioComponent");
		return ptr;
	}


	void ApplyAdditionalPriority();
};


// Class TgGame.TgCameraShake
// 0x0015 (0x00F5 - 0x00E0)
class UTgCameraShake : public UCameraShake
{
public:
	float                                              m_fShakeScale;                                            // 0x00E0(0x0004) (Edit)
	unsigned long                                      m_bDoControllerVibration : 1;                             // 0x00E4(0x0004) (Edit)
	unsigned long                                      m_bRadialShake : 1;                                       // 0x00E4(0x0004) (Edit)
	unsigned long                                      m_bOrientTowardRadialEpicenter : 1;                       // 0x00E4(0x0004) (Edit)
	float                                              m_fRadialShake_InnerRadius;                               // 0x00E8(0x0004) (Edit)
	float                                              m_fRadialShake_OuterRadius;                               // 0x00EC(0x0004) (Edit)
	float                                              m_fRadialShake_Falloff;                                   // 0x00F0(0x0004) (Edit)
	TEnumAsByte<ECameraAnimPlaySpace>                  m_PlaySpace;                                              // 0x00F4(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraShake");
		return ptr;
	}

};


// Class TgGame.TgDominantDirectionalLightSwitchable
// 0x0000 (0x026C - 0x026C)
class ATgDominantDirectionalLightSwitchable : public ADominantDirectionalLight
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDominantDirectionalLightSwitchable");
		return ptr;
	}


	void STATIC_SetOverrideMode(unsigned char NewMode);
};


// Class TgGame.TgHybridDirectionalLight
// 0x0000 (0x026C - 0x026C)
class ATgHybridDirectionalLight : public ATgDominantDirectionalLightSwitchable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHybridDirectionalLight");
		return ptr;
	}

};


// Class TgGame.TgDominantDirectionalLightSwitchableComponent
// 0x0003 (0x0293 - 0x0290)
class UTgDominantDirectionalLightSwitchableComponent : public UDominantDirectionalLightComponent
{
public:
	TEnumAsByte<ESwitchableDominantLightMode>          m_OverrideMode;                                           // 0x0290(0x0001) (Transient)
	TEnumAsByte<ESwitchableDominantLightMode>          m_PlayInEditorViewMode;                                   // 0x0291(0x0001) (Edit)
	unsigned char                                      m_CachedLightType;                                        // 0x0292(0x0001) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDominantDirectionalLightSwitchableComponent");
		return ptr;
	}


	void STATIC_SetOverrideMode(unsigned char NewMode);
};


// Class TgGame.TgDropShadowDecalComponent
// 0x0010 (0x0320 - 0x0310)
class UTgDropShadowDecalComponent : public UStaticMeshComponent
{
public:
	float                                              LastCachedZ;                                              // 0x0310(0x0004) (Transient)
	struct FVector                                     LastOwnerPos;                                             // 0x0314(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDropShadowDecalComponent");
		return ptr;
	}


	void UpdatePosition(class ATgPawn* TgPOwner, bool bIsInitial, struct FVector* OwnerOffset);
};


// Class TgGame.TgEmitter
// 0x0008 (0x027C - 0x0274)
class ATgEmitter : public AEmitter
{
public:
	struct FName                                       BoneName;                                                 // 0x0274(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitter");
		return ptr;
	}


	void STATIC_ScaleEmitter(float ScaleFactor);
	void AttachTo(class APawn* P, const struct FName& NewBoneName);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgInverseRolloffAudio
// 0x0000 (0x0060 - 0x0060)
class UTgInverseRolloffAudio : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInverseRolloffAudio");
		return ptr;
	}


	float STATIC_GetCurrentRadius();
};


// Class TgGame.TgMusicThemePlayer
// 0x000C (0x00D8 - 0x00CC)
class UTgMusicThemePlayer : public UPComMusicThemePlayer
{
public:
	class UTgManifestGroup*                            c_AssetManifestGroup;                                     // 0x00CC(0x0008) (ExportObject, NeedCtorLink, EditInline)
	int                                                c_nMusicThemeLock;                                        // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMusicThemePlayer");
		return ptr;
	}


	void UnlockMusicTheme();
	void LockMusicTheme();
	void PlayMusicEvent(const struct FName& EventName);
	void LoadThemeByItemId(int nItemId, bool bAsync);
	void LoadDefaultTheme();
	void Init();
};


// Class TgGame.TgParticleModuleTypeDataLight
// 0x0010 (0x0078 - 0x0068)
class UTgParticleModuleTypeDataLight : public UParticleModuleTypeDataBase
{
public:
	class UPointLightComponent*                        m_PointLightComponent;                                    // 0x0068(0x0008) (Edit, ExportObject, Component, EditInline)
	class UPointLightComponent*                        m_PLCDuplicate;                                           // 0x0070(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgParticleModuleTypeDataLight");
		return ptr;
	}

};


// Class TgGame.TgPhysicalMaterialProperty
// 0x0008 (0x0068 - 0x0060)
class UTgPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase
{
public:
	struct FName                                       MaterialType;                                             // 0x0060(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPhysicalMaterialProperty");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_DeathFog
// 0x0070 (0x02D0 - 0x0260)
class ATgRepInfo_DeathFog : public AReplicationInfo
{
public:
	struct FPointer                                    VfTable_ITgInverseRolloffAudio;                           // 0x0260(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bReceivedLocation : 1;                                  // 0x0268(0x0004)
	unsigned long                                      m_bReceivedFxType : 1;                                    // 0x0268(0x0004)
	unsigned long                                      m_bReceivedFlatFogMeshId : 1;                             // 0x0268(0x0004)
	unsigned long                                      m_bFogFxActive : 1;                                       // 0x0268(0x0004)
	struct FVector                                     r_FogCenterLocation;                                      // 0x026C(0x000C) (Net)
	TEnumAsByte<EFogFxType>                            r_FogFxType;                                              // 0x0278(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0279(0x0003) MISSED OFFSET
	int                                                r_FlatFogMeshId;                                          // 0x027C(0x0004) (Net)
	struct FFOG_FX                                     m_FogFx;                                                  // 0x0280(0x0014)
	struct FFOG_GROWTH                                 r_FogGrowthSettings;                                      // 0x0294(0x000C) (Net)
	float                                              c_fCurrentFogDistance;                                    // 0x02A0(0x0004)
	float                                              c_fFogConvergeRate;                                       // 0x02A4(0x0004)
	float                                              r_fFogDistance;                                           // 0x02A8(0x0004) (Net)
	float                                              r_fFogTickInterval;                                       // 0x02AC(0x0004) (Net)
	float                                              r_fGrowTimeRemaining;                                     // 0x02B0(0x0004) (Net)
	float                                              r_fTimeToNextPhase;                                       // 0x02B4(0x0004) (Net)
	class USoundCue*                                   c_FogSoundCue;                                            // 0x02B8(0x0008)
	class UAudioComponent*                             c_AudioComp;                                              // 0x02C0(0x0008) (ExportObject, Component, EditInline)
	class USoundCue*                                   c_FogWarningSound;                                        // 0x02C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_DeathFog");
		return ptr;
	}


	void Destroyed();
	void UpdateFogFx(float fDeltaTime);
	void STATIC_CleanUpFogFx();
	void UpdateFogFxRadius(float fDeltaTime, bool bForceToSafeRadius);
	void STATIC_SetFogFxVisible(bool bVisible);
	void STATIC_InitializeFogFx();
	void STATIC_PlayFogAdvancingCue();
	void SetNextFogPhase(bool bEnabled, float fFogSafeDistance, float fFogSpreadRate);
	void UpdateFogInterval(float fFogInterval);
	void UpdateFogDistance(float fFogDistance);
	void STATIC_SetFlatFogMeshId(int nMeshId);
	void STATIC_SetFogFxType(TEnumAsByte<EFogFxType> eFogFxType);
	void STATIC_SetFogLocation(const struct FVector& vLocation);
	void UpdateGrowTimeUI();
	void UpdateNextPhaseUI();
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	float STATIC_GetCurrentRadius();
	class ATgSkeletalMeshActorSpawnable* STATIC_SpawnFlatFogFx();
};


// Class TgGame.TgScaryPotionPSComponent
// 0x0000 (0x03C8 - 0x03C8)
class UTgScaryPotionPSComponent : public UParticleSystemComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgScaryPotionPSComponent");
		return ptr;
	}

};


// Class TgGame.TgSoundGroup
// 0x0020 (0x0080 - 0x0060)
class UTgSoundGroup : public UObject
{
public:
	TArray<class USoundCue*>                           c_SoundCues;                                              // 0x0060(0x0010) (Const, NeedCtorLink)
	TArray<struct FFootstepSoundInfo>                  c_FootstepSounds;                                         // 0x0070(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundGroup");
		return ptr;
	}


	void PlayFootStepSound(class APawn* P, int FootDown, const struct FName& MaterialType);
	void STATIC_PlaySound(TEnumAsByte<EeTG_SOUNDS> eSound, class APawn* P);
};


// Class TgGame.TgSoundNode_InverseRolloff
// 0x0004 (0x00F4 - 0x00F0)
class UTgSoundNode_InverseRolloff : public USoundNodeAttenuation
{
public:
	float                                              m_fInsetRadius;                                           // 0x00F0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundNode_InverseRolloff");
		return ptr;
	}

};


// Class TgGame.TgSoundNodeMetronome
// 0x0004 (0x0100 - 0x00FC)
class UTgSoundNodeMetronome : public USoundNodeDelay
{
public:
	float                                              m_fMetronomeSeconds;                                      // 0x00FC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundNodeMetronome");
		return ptr;
	}

};


// Class TgGame.TgSpecialFx
// 0x00C4 (0x0124 - 0x0060)
class UTgSpecialFx : public UObject
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterfaceLite;                             // 0x0060(0x0008) (Const, Native, NoExport)
	int                                                c_nFxId;                                                  // 0x0068(0x0004)
	class UMeshComponent*                              c_OwnerMesh;                                              // 0x006C(0x0008) (ExportObject, Component, EditInline)
	class AActor*                                      c_Owner;                                                  // 0x0074(0x0008)
	unsigned long                                      c_bAttached : 1;                                          // 0x007C(0x0004)
	unsigned long                                      c_bAppliesToAllModes : 1;                                 // 0x007C(0x0004)
	unsigned long                                      c_bSelfManage : 1;                                        // 0x007C(0x0004)
	unsigned long                                      c_bFromEffectForm : 1;                                    // 0x007C(0x0004)
	unsigned long                                      c_bVisualComplete : 1;                                    // 0x007C(0x0004)
	unsigned long                                      c_bAudioComplete : 1;                                     // 0x007C(0x0004)
	unsigned long                                      c_bMuteSound : 1;                                         // 0x007C(0x0004)
	unsigned long                                      c_bAttachToGround : 1;                                    // 0x007C(0x0004)
	unsigned long                                      c_bIsDebuff : 1;                                          // 0x007C(0x0004)
	unsigned long                                      c_bHasTeamMaterials : 1;                                  // 0x007C(0x0004)
	unsigned long                                      c_bActive : 1;                                            // 0x007C(0x0004)
	unsigned long                                      c_bIsSpawnFx : 1;                                         // 0x007C(0x0004)
	unsigned long                                      c_bUseBeam : 1;                                           // 0x007C(0x0004)
	unsigned long                                      c_bSkydome : 1;                                           // 0x007C(0x0004)
	unsigned long                                      c_bLocalPawnIsOwner : 1;                                  // 0x007C(0x0004) (AlwaysInit)
	struct FName                                       c_nmSocket;                                               // 0x0080(0x0008)
	struct FName                                       c_nmDisplayGroup;                                         // 0x0088(0x0008)
	int                                                c_nDisplayMode;                                           // 0x0090(0x0004)
	int                                                c_nIndex;                                                 // 0x0094(0x0004)
	int                                                c_nEquipSlot;                                             // 0x0098(0x0004)
	class UMaterialInstanceConstant*                   c_MIC;                                                    // 0x009C(0x0008)
	float                                              c_fTransition;                                            // 0x00A4(0x0004)
	int                                                c_nHitEffectBase;                                         // 0x00A8(0x0004)
	float                                              c_fMaxEffectDistance;                                     // 0x00AC(0x0004)
	struct FParticleChannelContainer                   c_ParticleChannelOverride;                                // 0x00B0(0x0004)
	int                                                c_nSortPriorityOverride;                                  // 0x00B4(0x0004)
	int                                                c_bSortPriorityOverridden;                                // 0x00B8(0x0004)
	int                                                c_nCustomFilterOverride;                                  // 0x00BC(0x0004)
	int                                                c_nCustomSoundFilter;                                     // 0x00C0(0x0004)
	TEnumAsByte<ELightFxState>                         c_LightComponentState;                                    // 0x00C4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00C5(0x0003) MISSED OFFSET
	class ULightComponent*                             c_LightComponent;                                         // 0x00C8(0x0008) (ExportObject, Component, AlwaysInit, EditInline)
	struct FPointer                                    c_ManagedLightEmitter;                                    // 0x00D0(0x0008) (AlwaysInit)
	float                                              c_fCustomTimeDilation;                                    // 0x00D8(0x0004)
	TArray<struct FFx_Sound>                           c_SoundList;                                              // 0x00DC(0x0010) (Component, AlwaysInit, NeedCtorLink)
	TArray<struct FFx_PSC>                             c_PSCList;                                                // 0x00EC(0x0010) (Component, AlwaysInit, NeedCtorLink)
	TArray<struct FFx_Material>                        c_MaterialList;                                           // 0x00FC(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FFx_Decal>                           c_DecalList;                                              // 0x010C(0x0010) (Component, AlwaysInit, NeedCtorLink)
	class UTgCameraShake*                              c_CameraShake;                                            // 0x011C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpecialFx");
		return ptr;
	}


	void InitSkydomeFX();
	void STATIC_SetDepthPriorityGroup(TEnumAsByte<ESceneDepthPriorityGroup> NewDepthPriorityGroup);
	void STATIC_SetKillOnDeactivate();
	void ListSounds();
	void UpdateBeamFx(const struct FVector& HitLocation, const struct FVector& HitOrigin, class AActor* targetOverride);
	class UDecalComponent* SpawnDecal(class AWorldInfo* WorldInfo, bool bUsePool, struct FFx_Decal* Decal);
	void SpawnTracer(const struct FVector& HitLocation, const struct FVector& HitOrigin);
	class AActor* STATIC_GetHitActor(const struct FVector& EffectLocation, const struct FVector& HitLocation);
	bool STATIC_HasSoundCue();
	void STATIC_SetOwner(class AActor* pOwner);
	float STATIC_GetTotalTiDiFromOwner();
	void ApplyTiDi(float fTotalTiDi);
	void STATIC_StopCameraShake();
	void STATIC_PlayCameraShake(const struct FVector& Epicenter, float fRadius);
	void STATIC_DeactivateDecal(struct FFx_Decal* Decal);
	void ActivateDecal(struct FFx_Decal* Decal);
	void STATIC_ImmediatelyStopSound();
	void STATIC_StopSound();
	void STATIC_PlaySound();
	void STATIC_CheckDeactivate();
	void OnAudioFinishedFX(class UAudioComponent* FinishedComponent);
	void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);
	void STATIC_DeactivateAndStopSound(bool bForceDeactivate);
	void STATIC_Deactivate(bool bForceDeactivate);
	float Activate(const struct FVector& HitLocation, bool bSkipRelevantChecking);
	void AdjustFxTransformation(const struct FVector& vNewTranslation, const struct FRotator& rNewRotation, float fScale, bool bAbsolute);
	void AdjustEffectRotation(int nPSCIndex, const struct FRotator& rNewRotation, bool bAbsoluteRotation);
	void AdjustEffectTranslation(int nPSCIndex, const struct FVector& NewTranslation, bool bAbsoluteTranslation);
	void AdjustEffectScale(int nPSCIndex, float fScale);
	void AdjustFxScaleByRadius(float fScale);
	void AdjustEffectRadius(int nPSCIndex, float fScale);
	class ATgPawn* STATIC_FindLocalPlayerPawn();
	class ATgPlayerController* STATIC_FindLocalPlayerController();
	bool IsFxRelevant(const struct FVector& SpawnLocation);
	void STATIC_SetHitEffectScaleBasedOnDamage(int nHealthChange);
	void STATIC_SpawnSound(const struct FVector& Location);
	void STATIC_SpawnEmitter(const struct FVector& HitLocation, const struct FVector& HitNormal, float fScale);
	void STATIC_CleanupRunningState();
	void UpdateSoundPlaying(class UAudioComponent* pacSound);
	bool AreAnySoundsPlaying();
	void STATIC_SetPSCRunning(class UParticleSystemComponent* pPSC, bool bOn);
	bool AreAnyPSCRunning();
	void STATIC_ResetParticles(bool bResetInstances);
	void STATIC_PlaySoundAt(const struct FVector& Location);
	bool STATIC_ShouldShowWhenStealthed();
	void STATIC_SetHidden(bool bNewHidden);
	void AdjustHidden(bool bHidden);
	void STATIC_OnActiveTimeExpired();
	void STATIC_SetActiveTime(float Duration, class ATgPawn* Owner);
	class AActor* STATIC_SpawnActor(class UClass* InClass, const struct FVector& Location, const struct FRotator& Rotation);
	void STATIC_SetPSCChannels(class UParticleSystemComponent* PSC, bool bOnlyAllowNonZeroMask);
	void ActivateLocalPlayerFx(class UParticleSystemComponent* ActivePSC);
	class UMeshComponent* STATIC_GetOwnerMesh(class AActor* pOwner);
	struct FVector STATIC_GetEffectLocation();
	void Detach(bool bWillReattach);
	void AttachToOwner(class AActor* pOwner);
};


// Class TgGame.TgSpecialFxEmitterPool
// 0x0000 (0x02D4 - 0x02D4)
class ATgSpecialFxEmitterPool : public AEmitterPool
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpecialFxEmitterPool");
		return ptr;
	}

};


// Class TgGame.TgSpecialFxLightManager
// 0x0034 (0x0094 - 0x0060)
class UTgSpecialFxLightManager : public UObject
{
public:
	unsigned long                                      c_FxLightsEnabled : 1;                                    // 0x0060(0x0004) (Config)
	unsigned long                                      c_FxLightsUnconstrained : 1;                              // 0x0060(0x0004) (Config)
	int                                                c_FxLightsMaxActive;                                      // 0x0064(0x0004) (Config)
	int                                                c_FxLightsMaxDying;                                       // 0x0068(0x0004) (Config)
	TArray<struct FPointer>                            m_ActiveEmitters;                                         // 0x006C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FPointer>                            m_DyingEmitters;                                          // 0x007C(0x0010) (AlwaysInit, NeedCtorLink)
	class ATgPawn*                                     c_LocalPawn;                                              // 0x008C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpecialFxLightManager");
		return ptr;
	}


	void UserSetLevel(int LightLevel);
	void STATIC_SetLevelInternal(int LightLevel);
	void LightKilledElsewhere(const struct FPointer& FxEmitterKilled);
	void STATIC_SetLightState(const struct FPointer& ExtantFxEmitter, TEnumAsByte<ESpecialFxLightState> NewFxLightState);
	void AddLight(const struct FPointer& NewFxEmitter);
	void STATIC_InitializeFxLightManager();
};


// Class TgGame.TgEffect
// 0x003C (0x009C - 0x0060)
class UTgEffect : public UObject
{
public:
	class UTgEffectGroup*                              m_EffectGroup;                                            // 0x0060(0x0008)
	int                                                m_nPropertyId;                                            // 0x0068(0x0004)
	int                                                m_nCalcMethodCode;                                        // 0x006C(0x0004)
	unsigned long                                      m_bUseOnInterval : 1;                                     // 0x0070(0x0004)
	unsigned long                                      m_bRemovable : 1;                                         // 0x0070(0x0004)
	unsigned long                                      m_bAllowStacking : 1;                                     // 0x0070(0x0004)
	unsigned long                                      m_bApplyToProperty : 1;                                   // 0x0070(0x0004)
	int                                                m_nPropertyValueId;                                       // 0x0074(0x0004)
	float                                              m_fCurrent;                                               // 0x0078(0x0004)
	float                                              m_fBase;                                                  // 0x007C(0x0004)
	float                                              m_fMinimum;                                               // 0x0080(0x0004)
	float                                              m_fMaximum;                                               // 0x0084(0x0004)
	float                                              m_fScalingFactor;                                         // 0x0088(0x0004)
	float                                              m_fStaticValueOffset;                                     // 0x008C(0x0004)
	float                                              m_MaxKnockbackZ;                                          // 0x0090(0x0004)
	float                                              m_MinKnockbackZ;                                          // 0x0094(0x0004)
	float                                              m_KnockbackZMultiplier;                                   // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect");
		return ptr;
	}


	int STATIC_GetDeviceIdFromMode(class UTgDeviceFire* DeviceFireMode);
	class AActor* STATIC_GetTauntTarget();
	void ApplyHitReaction(class ATgPawn* TargetPawn, const struct FImpactInfo& Impact, float TweenDistance);
	int STATIC_GetTopMostDevice(class UTgDeviceFire* devFire);
	void TrackStats(class ATgPawn* Instigator, class AActor* Target, const struct FImpactInfo& Impact, float fDamage, int iTargetDeviceModeId, bool bIsEnemy, float fMissingHealth, float fMitigatedDamage);
	void Remove(class AActor* Target, bool bResetToFollow);
	void STATIC_Reapply(class AActor* Target);
	float STATIC_GetProratedValue();
	void ApplyToProperty(class AActor* Target, int nPropertyId, float fProratedAmount, bool bRemove);
	bool STATIC_RemoveStacks(class AActor* Target, int nNumStacks);
	bool ApplyStacks(class AActor* Target, int nNumStacks, int nRequestedStacks);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
	bool IsValidInstigator(class ATgPawn* InstigatorPawn);
	void STATIC_SetProperty(class AActor* Target, int nPropertyId, float fNewValue);
	TEnumAsByte<EApplyEffectResult> STATIC_CanBeApplied(class AActor* Target);
	void STATIC_PowerScalingModifier(class ATgPawn* pawnInstigator, class ATgPawn* PawnTarget, const struct FImpactInfo& Impact, float* fAmount);
	class UTgEffect* STATIC_CloneEffect();
};


// Class TgGame.TgEffect_Listener
// 0x0008 (0x00A4 - 0x009C)
class UTgEffect_Listener : public UTgEffect
{
public:
	class UTgInventoryObject*                          s_InvObject;                                              // 0x009C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect_Listener");
		return ptr;
	}


	void Remove(class AActor* Target, bool bResetToFollow);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
};


// Class TgGame.TgEffect_VGS
// 0x0000 (0x009C - 0x009C)
class UTgEffect_VGS : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect_VGS");
		return ptr;
	}


	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
};


// Class TgGame.TgEffectDamage
// 0x001C (0x00B8 - 0x009C)
class UTgEffectDamage : public UTgEffect
{
public:
	int                                                m_nSimplifiedPropertyId;                                  // 0x009C(0x0004)
	class UClass*                                      m_DamageTypeClass;                                        // 0x00A0(0x0008)
	class UClass*                                      m_DefaultDamageTypeClass;                                 // 0x00A8(0x0008)
	float                                              m_fDamageInitial;                                         // 0x00B0(0x0004)
	unsigned long                                      m_bApplyEveryInterval : 1;                                // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage");
		return ptr;
	}


	bool ApplyOnThisInterval();
	bool STATIC_RemoveStacks(class AActor* Target, int nNumStacks);
	bool ApplyStacks(class AActor* Target, int nNumStacks, int nRequestedStacks);
	void STATIC_ReturnLifeSteal(class ATgPawn* InstigatorPawn, const struct FImpactInfo& Impact, float fProratedAmount);
	bool AddCriticalStrikeDamage(class ATgPawn* InstigatorPawn, const struct FImpactInfo& Impact, float* fProratedAmount);
	void AddInstigatorScaling(class ATgPawn* InstigatorPawn, class AActor* Target, const struct FImpactInfo& Impact, float* fProratedAmount);
	void STATIC_PropertyModifier(class ATgPawn* PawnTarget, float* fProratedAmount);
	void STATIC_ProtectionModifier(const struct FImpactInfo& Impact, float* NewValue, float* fPercReduction);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
	TEnumAsByte<EApplyEffectResult> STATIC_CanBeApplied(class AActor* Target);
	void STATIC_SendKillingBlowMessage(class AActor* Source, class AActor* Target, float fDamage, float fMitigated, const struct FImpactInfo& thisImpact, bool bWasCritical);
	void STATIC_SendDamageMessages(class AActor* Source, class AActor* Target, float fDamage, float fMitigated, const struct FImpactInfo& thisImpact, bool bWasCritical);
	void UnmitigatedDamageReflectHandler(class AActor* pTarget, class ATgPawn* pInstigator, float fReflectableDamage);
	void STATIC_DamageReflectHandler(class AActor* pTarget, class ATgPawn* pInstigator, float fReflectableDamage);
	void STATIC_PostDamageHandler(class AActor* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float fPrevHealth, float fHealthChange, float fBuffedDamage, float fMitigatedDamage, bool bCritical);
	void STATIC_DamageRedirectHandler(class ATgPawn* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float* NewValue);
	void STATIC_PreDamageRedirectMitigation(class ATgPawn* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float* NewValue);
	void STATIC_SetDamageTypeClass(bool WasCritical);
	class UTgEffect* STATIC_CloneEffect();
};


// Class TgGame.TgEffectDamage_Distance
// 0x0014 (0x00CC - 0x00B8)
class UTgEffectDamage_Distance : public UTgEffectDamage
{
public:
	class UTgEffectDamage_DistanceApplyComponent*      m_ApplyComponent;                                         // 0x00B8(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fApplyDistance;                                         // 0x00C0(0x0004)
	int                                                m_nApplyMax;                                              // 0x00C4(0x0004)
	int                                                m_nAppliesLeft;                                           // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_Distance");
		return ptr;
	}


	void Remove(class AActor* Target, bool bResetToFollow);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
	class UTgEffect* STATIC_CloneEffect();
};


// Class TgGame.TgEffectDamage_ExposeEvil
// 0x0004 (0x00BC - 0x00B8)
class UTgEffectDamage_ExposeEvil : public UTgEffectDamage
{
public:
	float                                              m_fPortionToApplyOnRemove;                                // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_ExposeEvil");
		return ptr;
	}


	void Remove(class AActor* Target, bool bResetToFollow);
};


// Class TgGame.TgEffectDamage_MegaKill
// 0x000C (0x00C4 - 0x00B8)
class UTgEffectDamage_MegaKill : public UTgEffectDamage
{
public:
	int                                                m_nMegaKillDamageType;                                    // 0x00B8(0x0004)
	float                                              m_fMegaKillDamageAmount;                                  // 0x00BC(0x0004)
	unsigned long                                      m_bAllowCrowdControlImmuneTargets : 1;                    // 0x00C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_MegaKill");
		return ptr;
	}


	float STATIC_GetProratedValue();
	void STATIC_SendKillingBlowMessage(class AActor* Source, class AActor* Target, float fDamage, float fMitigated, const struct FImpactInfo& thisImpact, bool bWasCritical);
	void STATIC_SendDamageMessages(class AActor* Source, class AActor* Target, float fDamage, float fMitigated, const struct FImpactInfo& thisImpact, bool bWasCritical);
	void STATIC_ReturnLifeSteal(class ATgPawn* InstigatorPawn, const struct FImpactInfo& Impact, float fProratedAmount);
	bool AddCriticalStrikeDamage(class ATgPawn* InstigatorPawn, const struct FImpactInfo& Impact, float* fProratedAmount);
	void AddInstigatorScaling(class ATgPawn* InstigatorPawn, class AActor* Target, const struct FImpactInfo& Impact, float* fProratedAmount);
	void STATIC_ProtectionModifier(const struct FImpactInfo& Impact, float* NewValue, float* fPercReduction);
	void STATIC_PowerScalingModifier(class ATgPawn* pawnInstigator, class ATgPawn* PawnTarget, const struct FImpactInfo& Impact, float* fAmount);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
	void UnmitigatedDamageReflectHandler(class AActor* pTarget, class ATgPawn* pInstigator, float fReflectableDamage);
	void STATIC_DamageReflectHandler(class AActor* pTarget, class ATgPawn* pInstigator, float fReflectableDamage);
	void STATIC_DamageRedirectHandler(class ATgPawn* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float* NewValue);
	void STATIC_PreDamageRedirectMitigation(class ATgPawn* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float* NewValue);
};


// Class TgGame.TgEffectDamage_UnstoppableKill
// 0x0000 (0x00C4 - 0x00C4)
class UTgEffectDamage_UnstoppableKill : public UTgEffectDamage_MegaKill
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_UnstoppableKill");
		return ptr;
	}

};


// Class TgGame.TgEffectDamage_NoLifeSteal
// 0x0000 (0x00B8 - 0x00B8)
class UTgEffectDamage_NoLifeSteal : public UTgEffectDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_NoLifeSteal");
		return ptr;
	}


	void STATIC_ReturnLifeSteal(class ATgPawn* InstigatorPawn, const struct FImpactInfo& Impact, float fProratedAmount);
};


// Class TgGame.TgEffectDamage_ReducedLifeSteal
// 0x0000 (0x00B8 - 0x00B8)
class UTgEffectDamage_ReducedLifeSteal : public UTgEffectDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_ReducedLifeSteal");
		return ptr;
	}


	void STATIC_ReturnLifeSteal(class ATgPawn* InstigatorPawn, const struct FImpactInfo& Impact, float fProratedAmount);
};


// Class TgGame.TgEffectDamage_SelfExecute
// 0x0000 (0x00B8 - 0x00B8)
class UTgEffectDamage_SelfExecute : public UTgEffectDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_SelfExecute");
		return ptr;
	}


	void STATIC_PreDamageRedirectMitigation(class ATgPawn* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float* NewValue);
	void STATIC_SendDamageMessages(class AActor* Source, class AActor* Target, float fDamage, float fMitigated, const struct FImpactInfo& thisImpact, bool bWasCritical);
};


// Class TgGame.TgEffectDamage_Shield
// 0x0000 (0x00B8 - 0x00B8)
class UTgEffectDamage_Shield : public UTgEffectDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_Shield");
		return ptr;
	}


	void STATIC_PropertyModifier(class ATgPawn* PawnTarget, float* fProratedAmount);
	void STATIC_ProtectionModifier(const struct FImpactInfo& Impact, float* NewValue, float* fPercReduction);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
};


// Class TgGame.TgEffectHeal
// 0x000C (0x00A8 - 0x009C)
class UTgEffectHeal : public UTgEffect
{
public:
	float                                              m_MissingHealthInitial;                                   // 0x009C(0x0004)
	int                                                m_nSimplifiedPropertyId;                                  // 0x00A0(0x0004)
	unsigned long                                      m_bAcceptsHealingReduction : 1;                           // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectHeal");
		return ptr;
	}


	void STATIC_HealScalingModifier(class ATgPawn* pawnInstigator, class ATgPawn* PawnTarget, const struct FImpactInfo& Impact, float* fAmount);
	class UTgEffect* STATIC_CloneEffect();
	void STATIC_PostHealHandler(class AActor* pTarget, class ATgPawn* pInstigator, const struct FImpactInfo& Impact, float fHealthChange, float fHealAmount);
	bool STATIC_RemoveStacks(class AActor* Target, int nNumStacks);
	bool ApplyStacks(class AActor* Target, int nNumStacks, int nRequestedStacks);
	void AddInstigatorScaling(class ATgPawn* InstigatorPawn, class AActor* Target, const struct FImpactInfo& Impact, float* fProratedAmount);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
	bool STATIC_CanTargetBeRepaired(class AActor* Target);
	TEnumAsByte<EApplyEffectResult> STATIC_CanBeApplied(class AActor* Target);
};


// Class TgGame.TgEffectScalable
// 0x0000 (0x009C - 0x009C)
class UTgEffectScalable : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectScalable");
		return ptr;
	}


	bool ApplyStacks(class AActor* Target, int nNumStacks, int nRequestedStacks);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
};


// Class TgGame.TgEffectDamage_DistanceApplyComponent
// 0x001B (0x00A0 - 0x0085)
class UTgEffectDamage_DistanceApplyComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	class UTgEffectDamage_Distance*                    m_OwningEffect;                                           // 0x0088(0x0008)
	struct FVector                                     m_fLastLocation;                                          // 0x0090(0x000C)
	float                                              m_fDistanceCache;                                         // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_DistanceApplyComponent");
		return ptr;
	}

};


// Class TgGame.TgEffectForm
// 0x00B0 (0x0110 - 0x0060)
class UTgEffectForm : public UObject
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterfaceLite;                             // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<class UTgSpecialFx*>                        c_AppliedFxArray;                                         // 0x0068(0x0010) (NeedCtorLink)
	struct FPointer                                    c_pwzEffectName;                                          // 0x0078(0x0008) (Native)
	struct FPointer                                    c_pwzDescription;                                         // 0x0080(0x0008) (Native)
	class AActor*                                      c_Owner;                                                  // 0x0088(0x0008)
	class ATgPawn*                                     m_OwnerPawn;                                              // 0x0090(0x0008)
	class ATgPawn*                                     m_InstigatorPawn;                                         // 0x0098(0x0008)
	TArray<struct FMicFxInfo>                          m_micFxList;                                              // 0x00A0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceConstant*>           m_micAppliedList;                                         // 0x00B0(0x0010) (NeedCtorLink)
	TArray<struct FMicList>                            m_micExtraMeshAppliedList;                                // 0x00C0(0x0010) (NeedCtorLink)
	struct FVector                                     m_HitLocation;                                            // 0x00D0(0x000C)
	struct FVector                                     m_HitNormal;                                              // 0x00DC(0x000C)
	float                                              c_fApplyInterval;                                         // 0x00E8(0x0004)
	int                                                c_nEffectGroupId;                                         // 0x00EC(0x0004)
	int                                                c_nType;                                                  // 0x00F0(0x0004)
	int                                                c_nEffectIconId;                                          // 0x00F4(0x0004)
	int                                                c_PostureID;                                              // 0x00F8(0x0004)
	int                                                c_nSkinId;                                                // 0x00FC(0x0004)
	int                                                c_nCustomParticleSystemFilter;                            // 0x0100(0x0004)
	int                                                c_nInstigatorId;                                          // 0x0104(0x0004)
	TEnumAsByte<ETG_POSTURE>                           c_Posture;                                                // 0x0108(0x0001)
	unsigned char                                      c_nSkinLevel;                                             // 0x0109(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x010A(0x0002) MISSED OFFSET
	unsigned long                                      c_bHiddenDueToStealth : 1;                                // 0x010C(0x0004)
	unsigned long                                      c_bHiddenDueToFirstPerson : 1;                            // 0x010C(0x0004)
	unsigned long                                      c_bMICApplied : 1;                                        // 0x010C(0x0004)
	unsigned long                                      m_bSpawnAtHitLocation : 1;                                // 0x010C(0x0004)
	unsigned long                                      m_bSpawnAtGround : 1;                                     // 0x010C(0x0004)
	unsigned long                                      m_bTiDiImmune : 1;                                        // 0x010C(0x0004)
	unsigned long                                      m_bTiDiFromInstigator : 1;                                // 0x010C(0x0004)
	unsigned long                                      c_bIsDebuff : 1;                                          // 0x010C(0x0004)
	unsigned long                                      c_bIsCrit : 1;                                            // 0x010C(0x0004)
	unsigned long                                      c_bLocal : 1;                                             // 0x010C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm");
		return ptr;
	}


	void ApplyTiDi(float fTotalTiDi);
	void STATIC_OnRevive();
	void STATIC_OnRemovingEffect();
	bool STATIC_ShouldShowEffectForm();
	void AdjustHidden();
	void Detach();
	void STATIC_Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_RefreshEffectForm();
	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgEffectForm_BeamTether
// 0x0038 (0x0148 - 0x0110)
class UTgEffectForm_BeamTether : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0110(0x0008) (Const, Native, NoExport)
	struct FName                                       c_nmInstigatorLocMICParam;                                // 0x0118(0x0008) (Const)
	struct FName                                       c_nmTertheredPawnLocMICParam;                             // 0x0120(0x0008) (Const)
	struct FName                                       c_nmInstigatorTetherSocket;                               // 0x0128(0x0008) (Const)
	struct FName                                       c_nmTetherPawnTetherSocket;                               // 0x0130(0x0008) (Const)
	class UTgSpecialFx*                                c_fxTether;                                               // 0x0138(0x0008)
	class UMaterialInstanceConstant*                   c_tetherMIC;                                              // 0x0140(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_BeamTether");
		return ptr;
	}


	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
	void UpdateTether();
	void STATIC_DeactivateTether();
	void ActivateTether();
	void STATIC_SetTetherMIC();
};


// Class TgGame.TgEffectForm_BuffBelt
// 0x001D (0x012D - 0x0110)
class UTgEffectForm_BuffBelt : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0110(0x0008) (Const, Native, NoExport)
	float                                              m_OrbitAngleYawOffset;                                    // 0x0118(0x0004)
	float                                              m_OrbitHeightOffset;                                      // 0x011C(0x0004)
	float                                              m_fBeltHeight;                                            // 0x0120(0x0004)
	unsigned long                                      m_bFirstUpdate : 1;                                       // 0x0124(0x0004)
	float                                              m_OrbitRotationSpeed;                                     // 0x0128(0x0004)
	TEnumAsByte<EBuffBeltPriority>                     Priority;                                                 // 0x012C(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_BuffBelt");
		return ptr;
	}


	bool STATIC_ShouldShowEffectForm();
};


// Class TgGame.TgEffectForm_BulwarkOfHope
// 0x000C (0x011C - 0x0110)
class UTgEffectForm_BulwarkOfHope : public UTgEffectForm
{
public:
	int                                                m_OutroFXId;                                              // 0x0110(0x0004)
	struct FName                                       m_OutroDisplayGroup;                                      // 0x0114(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_BulwarkOfHope");
		return ptr;
	}


	void STATIC_HideEffectForm();
};


// Class TgGame.TgEffectForm_ChangeFiltersAfterDelay
// 0x0004 (0x0114 - 0x0110)
class UTgEffectForm_ChangeFiltersAfterDelay : public UTgEffectForm
{
public:
	unsigned long                                      m_bCustomFilter3 : 1;                                     // 0x0110(0x0004)
	unsigned long                                      m_bCustomFilter4 : 1;                                     // 0x0110(0x0004)
	unsigned long                                      m_bCustomFilter5 : 1;                                     // 0x0110(0x0004)
	unsigned long                                      m_bCustomFilter6 : 1;                                     // 0x0110(0x0004)
	unsigned long                                      m_bCustomFilter7 : 1;                                     // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_ChangeFiltersAfterDelay");
		return ptr;
	}


	void STATIC_DelayedChangeFilters();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_DisablePawn
// 0x0004 (0x0114 - 0x0110)
class UTgEffectForm_DisablePawn : public UTgEffectForm
{
public:
	unsigned long                                      m_bPauseAnims : 1;                                        // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_DisablePawn");
		return ptr;
	}


	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_Freeze
// 0x0004 (0x0118 - 0x0114)
class UTgEffectForm_Freeze : public UTgEffectForm_DisablePawn
{
public:
	int                                                m_BurstingIceFXId;                                        // 0x0114(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Freeze");
		return ptr;
	}


	void STATIC_HideEffectForm();
};


// Class TgGame.TgEffectForm_DispatchUI
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_DispatchUI : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_DispatchUI");
		return ptr;
	}


	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_FlashOnRemove
// 0x0004 (0x0114 - 0x0110)
class UTgEffectForm_FlashOnRemove : public UTgEffectForm
{
public:
	unsigned long                                      m_bEvenWhileHidden : 1;                                   // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_FlashOnRemove");
		return ptr;
	}


	void STATIC_OnRemovingEffect();
};


// Class TgGame.TgEffectForm_HideNameplates
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_HideNameplates : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_HideNameplates");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_LockVision
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_LockVision : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_LockVision");
		return ptr;
	}


	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_OnHitInterval
// 0x0004 (0x0114 - 0x0110)
class UTgEffectForm_OnHitInterval : public UTgEffectForm
{
public:
	float                                              c_fRefreshInterval;                                       // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_OnHitInterval");
		return ptr;
	}


	void STATIC_OnRemovingEffect();
	void RefreshEffectFormInterval();
};


// Class TgGame.TgEffectForm_Osiris_SoulRip
// 0x0008 (0x0118 - 0x0110)
class UTgEffectForm_Osiris_SoulRip : public UTgEffectForm
{
public:
	class ATgProj_Osiris_SoulRipDummy*                 m_Projectile;                                             // 0x0110(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Osiris_SoulRip");
		return ptr;
	}


	void AdjustHidden();
	void Detach();
	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_Phoenix_Weakened
// 0x0004 (0x0114 - 0x0110)
class UTgEffectForm_Phoenix_Weakened : public UTgEffectForm
{
public:
	int                                                m_MatIndex;                                               // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Phoenix_Weakened");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Portrait
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_Portrait : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Portrait");
		return ptr;
	}


	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_PostProcess
// 0x0044 (0x0154 - 0x0110)
class UTgEffectForm_PostProcess : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0110(0x0008) (Const, Native, NoExport)
	int                                                c_nPostProcessChainResourceStringId;                      // 0x0118(0x0004) (Const)
	class UPostProcessChain*                           c_PostProcess;                                            // 0x011C(0x0008) (Const)
	struct FName                                       m_nmMasterOpacity;                                        // 0x0124(0x0008) (Const)
	float                                              m_fMaxDuration;                                           // 0x012C(0x0004) (Const)
	float                                              m_fOpacityTransitionTime;                                 // 0x0130(0x0004) (Const)
	TArray<class UMaterialInstanceConstant*>           m_mics;                                                   // 0x0134(0x0010) (NeedCtorLink)
	class ATgPlayerController*                         c_CachedController;                                       // 0x0144(0x0008)
	float                                              m_fActiveTimeRemaining;                                   // 0x014C(0x0004)
	unsigned long                                      c_bPostProcessActive : 1;                                 // 0x0150(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_PostProcess");
		return ptr;
	}


	void STATIC_HideEffectForm();
	void STATIC_RefreshEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_Reactivate
// 0x0004 (0x0114 - 0x0110)
class UTgEffectForm_Reactivate : public UTgEffectForm
{
public:
	unsigned long                                      m_bHidden : 1;                                            // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Reactivate");
		return ptr;
	}


	bool STATIC_ShouldShowEffectForm();
};


// Class TgGame.TgEffectForm_ReactivateOnRevive
// 0x0000 (0x0114 - 0x0114)
class UTgEffectForm_ReactivateOnRevive : public UTgEffectForm_Reactivate
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_ReactivateOnRevive");
		return ptr;
	}


	void STATIC_OnRevive();
	bool STATIC_ShouldShowEffectForm();
};


// Class TgGame.TgEffectForm_ScaryPotion
// 0x0010 (0x0120 - 0x0110)
class UTgEffectForm_ScaryPotion : public UTgEffectForm
{
public:
	TArray<int>                                        m_OutroFXIds;                                             // 0x0110(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_ScaryPotion");
		return ptr;
	}


	void STATIC_HideEffectForm();
};


// Class TgGame.TgEffectForm_Soul
// 0x0010 (0x0120 - 0x0110)
class UTgEffectForm_Soul : public UTgEffectForm
{
public:
	int                                                m_SoulFXSetIds[0x3];                                      // 0x0110(0x0004) (Const)
	unsigned long                                      c_bAppliedSoulMICFx : 1;                                  // 0x011C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Soul");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Stacks
// 0x0002 (0x0112 - 0x0110)
class UTgEffectForm_Stacks : public UTgEffectForm
{
public:
	unsigned char                                      c_nMaxStacks;                                             // 0x0110(0x0001) (Const)
	unsigned char                                      c_nCurrentStacks;                                         // 0x0111(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Stacks");
		return ptr;
	}


	void STATIC_SetCurrentStacks(unsigned char nStacks);
	void STATIC_RefreshEffectForm();
};


// Class TgGame.TgEffectForm_Stacks_DirectionalTargets
// 0x0012 (0x0124 - 0x0112)
class UTgEffectForm_Stacks_DirectionalTargets : public UTgEffectForm_Stacks
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x0112(0x0002) MISSED OFFSET
	TArray<struct FRotator>                            c_rTargetDirections;                                      // 0x0114(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Stacks_DirectionalTargets");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Stacks_RegularSpacing
// 0x0002 (0x0114 - 0x0112)
class UTgEffectForm_Stacks_RegularSpacing : public UTgEffectForm_Stacks
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x0112(0x0002) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Stacks_RegularSpacing");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Stacks_Threshold
// 0x0022 (0x0134 - 0x0112)
class UTgEffectForm_Stacks_Threshold : public UTgEffectForm_Stacks
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x0112(0x0002) MISSED OFFSET
	TArray<int>                                        c_nThresholdList;                                         // 0x0114(0x0010) (NeedCtorLink)
	struct FScriptDelegate                             __SortTargetDelegate__Delegate;                           // 0x0124(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0124(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Stacks_Threshold");
		return ptr;
	}


	int SortTargetDelegate(int A, int B);
	void SortThresholdList();
	int STATIC_GetCurrentThresholdIndex();
	void STATIC_SetCurrentStacks(unsigned char nStacks);
};


// Class TgGame.TgEffectForm_Stealth
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_Stealth : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Stealth");
		return ptr;
	}


	void AdjustHidden();
	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_TeleportToBase
// 0x0008 (0x0118 - 0x0110)
class UTgEffectForm_TeleportToBase : public UTgEffectForm
{
public:
	int                                                c_DefaultFxId;                                            // 0x0110(0x0004)
	int                                                m_FxOverrideId;                                           // 0x0114(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_TeleportToBase");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_TidiImmune_LifeTime
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_TidiImmune_LifeTime : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_TidiImmune_LifeTime");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_UniqueForSelf
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_UniqueForSelf : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_UniqueForSelf");
		return ptr;
	}


	void STATIC_RefreshEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_WithDuration
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_WithDuration : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_WithDuration");
		return ptr;
	}


	float STATIC_GetEffectGroupDuration();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_WithMeshes
// 0x0010 (0x0120 - 0x0110)
class UTgEffectForm_WithMeshes : public UTgEffectForm
{
public:
	TArray<struct FEffectMeshInfo>                     m_EffectMeshInfos;                                        // 0x0110(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_WithMeshes");
		return ptr;
	}


	void STATIC_DetachMeshes();
	void AttachMeshes(class AActor* pOwner);
	void AdjustHidden();
	void Detach();
	void STATIC_Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgEffectForm_AbsoluteTranslation
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_AbsoluteTranslation : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_AbsoluteTranslation");
		return ptr;
	}


	void AttachMeshes(class AActor* pOwner);
};


// Class TgGame.TgEffectForm_Mummify
// 0x0008 (0x0128 - 0x0120)
class UTgEffectForm_Mummify : public UTgEffectForm_WithMeshes
{
public:
	int                                                m_BurstingBandagesFXId;                                   // 0x0120(0x0004)
	unsigned long                                      m_bPauseAnims : 1;                                        // 0x0124(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Mummify");
		return ptr;
	}


	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_Mummify_V2
// 0x0000 (0x0128 - 0x0128)
class UTgEffectForm_Mummify_V2 : public UTgEffectForm_Mummify
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Mummify_V2");
		return ptr;
	}

};


// Class TgGame.TgEffectGroup
// 0x0144 (0x01A4 - 0x0060)
class UTgEffectGroup : public UObject
{
public:
	int                                                m_nType;                                                  // 0x0060(0x0004)
	class AActor*                                      m_Target;                                                 // 0x0064(0x0008)
	class AActor*                                      m_Instigator;                                             // 0x006C(0x0008)
	int                                                m_nEffectGroupId;                                         // 0x0074(0x0004)
	float                                              m_fLifeTime;                                              // 0x0078(0x0004)
	float                                              m_fModLifeTime;                                           // 0x007C(0x0004)
	float                                              m_fApplyInterval;                                         // 0x0080(0x0004)
	TArray<class UTgEffect*>                           m_Effects;                                                // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nDamageType;                                            // 0x0094(0x0004)
	TEnumAsByte<EAttackType>                           m_eAttackType;                                            // 0x0098(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	unsigned long                                      m_bIsManaged : 1;                                         // 0x009C(0x0004)
	unsigned long                                      m_bSkillEffect : 1;                                       // 0x009C(0x0004)
	unsigned long                                      m_bItemEffect : 1;                                        // 0x009C(0x0004)
	unsigned long                                      m_bEfficiencyEffect : 1;                                  // 0x009C(0x0004)
	unsigned long                                      m_bHasSlowEffect : 1;                                     // 0x009C(0x0004)
	unsigned long                                      m_bHasStealthEffect : 1;                                  // 0x009C(0x0004)
	unsigned long                                      m_bHasSlowToHaltEffect : 1;                               // 0x009C(0x0004)
	unsigned long                                      m_bHasPortalFallEffect : 1;                               // 0x009C(0x0004)
	unsigned long                                      m_bHasAttackSpeedDebuff : 1;                              // 0x009C(0x0004)
	unsigned long                                      m_bDoesDamage : 1;                                        // 0x009C(0x0004)
	unsigned long                                      m_bIrreducible : 1;                                       // 0x009C(0x0004)
	unsigned long                                      m_bContagious : 1;                                        // 0x009C(0x0004)
	unsigned long                                      s_bActiveFlag : 1;                                        // 0x009C(0x0004)
	unsigned long                                      s_bCriticalHitFlag : 1;                                   // 0x009C(0x0004)
	unsigned long                                      m_bDeviceSpecificFlag : 1;                                // 0x009C(0x0004)
	unsigned long                                      m_bReflectDamage : 1;                                     // 0x009C(0x0004)
	unsigned long                                      m_bHasVisual : 1;                                         // 0x009C(0x0004)
	unsigned long                                      m_bOwnerOnlyRelevant : 1;                                 // 0x009C(0x0004)
	unsigned long                                      m_bTidiImmuneLifeTime : 1;                                // 0x009C(0x0004) (Const)
	float                                              m_fPercAbsorbedDamage;                                    // 0x00A0(0x0004)
	float                                              m_fPercIncreasedDamage;                                   // 0x00A4(0x0004)
	int                                                m_nApplicationType;                                       // 0x00A8(0x0004)
	float                                              m_fApplicationValue;                                      // 0x00AC(0x0004)
	float                                              m_fApplicationChance;                                     // 0x00B0(0x0004)
	int                                                m_nApplicationCategoryCode;                               // 0x00B4(0x0004)
	int                                                m_nBehaviorCategoryCode;                                  // 0x00B8(0x0004)
	int                                                m_nReqDeviceInstanceId;                                   // 0x00BC(0x0004)
	float                                              m_fBuffValue;                                             // 0x00C0(0x0004)
	float                                              m_fPhysicalPowerScaling;                                  // 0x00C4(0x0004)
	float                                              m_fMagicalPowerScaling;                                   // 0x00C8(0x0004)
	float                                              m_fLifetimeScaling;                                       // 0x00CC(0x0004)
	float                                              m_fLifetimeMax;                                           // 0x00D0(0x0004)
	int                                                m_nScalingType;                                           // 0x00D4(0x0004)
	int                                                m_nTargetType;                                            // 0x00D8(0x0004)
	int                                                m_nTargetAffectsType;                                     // 0x00DC(0x0004)
	int                                                m_nHitSpecialSituationalType;                             // 0x00E0(0x0004)
	int                                                m_nNumStacks;                                             // 0x00E4(0x0004)
	int                                                m_nNumMaxStacks;                                          // 0x00E8(0x0004)
	class UTgEffectGroup*                              s_NonContagiousEffectGroup;                               // 0x00EC(0x0008)
	struct FImpactInfo                                 m_Impact;                                                 // 0x00F4(0x0078) (Component)
	int                                                m_nPosture;                                               // 0x016C(0x0004)
	int                                                m_nFxAppliedId;                                           // 0x0170(0x0004)
	struct FName                                       m_nmDisplayGroup;                                         // 0x0174(0x0008)
	int                                                s_ManagedEffectListIndex;                                 // 0x017C(0x0004)
	class ATgEffectManager*                            s_OwnerEffectManager;                                     // 0x0180(0x0008)
	struct FName                                       m_nmDamageTypeClass;                                      // 0x0188(0x0008)
	int                                                m_nSourceDeviceSkillId;                                   // 0x0190(0x0004)
	int                                                m_nSourceDeviceInstId;                                    // 0x0194(0x0004)
	int                                                m_nSourceItemId;                                          // 0x0198(0x0004)
	float                                              s_fEGShieldHealth;                                        // 0x019C(0x0004)
	float                                              s_fEGShieldHealthMax;                                     // 0x01A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectGroup");
		return ptr;
	}


	float STATIC_HealShield(float fHeal);
	float STATIC_DamageShield(float fDamage);
	float STATIC_GetShieldMaxHealth();
	float STATIC_GetShieldHealth();
	bool STATIC_HasShield();
	void STATIC_QueueRemovalOnManagerTick();
	float STATIC_GetUtilityPower();
	float STATIC_GetLifeTime(bool bModifiers);
	void LifeDone();
	void ApplyInterval();
	bool ApplyEffects();
	float STATIC_GetIntervalTimeRemaining();
	float STATIC_GetPercentTimeRemaining();
	float STATIC_GetTimeRemaining();
	float STATIC_GetTimeElapsed();
	void SetActive(bool bActive, bool bRemoving);
	bool IsActive();
	bool STATIC_HasCategoryCode(int nCategoryCode, bool bBehaviorOnly);
	bool STATIC_OnlyRelevantToOwner();
	bool Irreducible();
	bool STATIC_DoesDamage();
	bool STATIC_CanCountAsAssist();
	bool IsTiDiDebuff();
	bool IsAttackSpeedDebuff();
	bool IsPortalFall();
	bool IsCrit();
	bool IsSlowToHalt();
	bool IsStealth();
	bool IsSlow();
	bool IsInstantaneous();
	bool STATIC_PersistsThroughRevive();
	bool STATIC_PersistsThroughDeath();
	bool IsBuff();
	float STATIC_CalcAttackTypeProtection(class AActor* Target, float fValue, float* fPercReduction);
	float STATIC_CalcDamageTypeProtection(class AActor* Target, float fValue, int nPropertyId, float* fPercReduction);
	float STATIC_CalcProtection(class AActor* Target, int nProtectionType, float fValue, bool bDamageReduction, int nDamagedPropertyId, float* fPercReduction);
	float STATIC_CalcCategoryProtection(class AActor* Target, float fValue, float* fPercReduction);
	bool STATIC_EffectExists(int nPropId);
	float STATIC_QueryFxTransitionTime();
	float TotalPropertyEffectAmt(int nPropertyId);
	void STATIC_RemoveEffects(bool bClearTimers);
	class UTgEffectGroup* STATIC_CloneEffectGroup(bool bCloneAllEffects);
};


// Class TgGame.TgEffectManager
// 0x0968 (0x0BC8 - 0x0260)
class ATgEffectManager : public AActor
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterface;                                 // 0x0260(0x0008) (Const, Native, NoExport)
	struct FEffectListEntry                            r_ManagedEffectList[0x10];                                // 0x0268(0x0018) (Net)
	struct FEffectListEntry                            r_OwnerManagedEffectList[0x10];                           // 0x03E8(0x0018) (Net)
	struct FEffectListEntry                            c_OwnerManagedEffectList[0x10];                           // 0x0568(0x0018)
	unsigned char                                      c_byCounterList[0x10];                                    // 0x06E8(0x0001)
	TEnumAsByte<EStunType>                             s_eCachedStunType;                                        // 0x06F8(0x0001)
	unsigned char                                      s_CachedReveal[0x6];                                      // 0x06F9(0x0001)
	unsigned char                                      s_CachedSurpressRevealSound[0x6];                         // 0x06FF(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0705(0x0003) MISSED OFFSET
	float                                              m_fTimeRemaining[0x20];                                   // 0x0708(0x0004)
	class UTgEffectForm*                               c_Forms[0x10];                                            // 0x0788(0x0008)
	unsigned long                                      c_ActiveTimers : 1;                                       // 0x0808(0x0004)
	unsigned long                                      r_bRelevancyNotify : 1;                                   // 0x0808(0x0004) (Net)
	struct FEffectQueueEntry                           r_EventQueue[0x10];                                       // 0x080C(0x0024) (Net)
	int                                                r_nNextQueueIndex;                                        // 0x0A4C(0x0004) (Net)
	int                                                c_nLastQueueIndex;                                        // 0x0A50(0x0004)
	TArray<class UTgEffectGroup*>                      s_AppliedEffectGroups;                                    // 0x0A54(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_TrackedTimeDilatedEffectGroups;                         // 0x0A64(0x0010) (NeedCtorLink)
	TArray<class UTgEffectForm*>                       c_TrackedTimeDilatedEffectForms;                          // 0x0A74(0x0010) (NeedCtorLink)
	class AActor*                                      r_Owner;                                                  // 0x0A84(0x0008) (Net)
	class UTgEffectGroup*                              m_ApplyDamageEffectGroup;                                 // 0x0A8C(0x0008)
	class UTgEffect*                                   m_ApplyDamageEffect;                                      // 0x0A94(0x0008)
	class UTgEffectGroup*                              m_ApplyUnstoppableKillEffectGroup;                        // 0x0A9C(0x0008)
	class UTgEffect*                                   m_ApplyUnstoppableKillEffect;                             // 0x0AA4(0x0008)
	class UTgEffectGroup*                              m_ApplyHealthEffectGroup;                                 // 0x0AAC(0x0008)
	class UTgEffect*                                   m_ApplyHealthEffect;                                      // 0x0AB4(0x0008)
	class UTgEffectGroup*                              m_ApplyManaEffectGroup;                                   // 0x0ABC(0x0008)
	class UTgEffect*                                   m_ApplyManaEffect;                                        // 0x0AC4(0x0008)
	class UTgEffectGroup*                              m_ApplyEnergyEffectGroup;                                 // 0x0ACC(0x0008)
	class UTgEffect*                                   m_ApplyEnergyEffect;                                      // 0x0AD4(0x0008)
	class UTgEffectGroup*                              m_ApplySelfExecuteEffectGroup;                            // 0x0ADC(0x0008)
	class UTgEffect*                                   m_ApplySelfExecuteEffect;                                 // 0x0AE4(0x0008)
	TArray<struct FStunStackEntry>                     s_StunStack;                                              // 0x0AEC(0x0010) (NeedCtorLink)
	TArray<struct FRevealStackEntry>                   s_RevealStack;                                            // 0x0AFC(0x0010) (NeedCtorLink)
	TArray<class UTgEffect*>                           s_TiDiStack;                                              // 0x0B0C(0x0010) (NeedCtorLink)
	int                                                r_nInvulnerableCount;                                     // 0x0B1C(0x0004) (Net)
	int                                                s_nSilenceCount;                                          // 0x0B20(0x0004)
	int                                                s_nBeadsSilenceCount;                                     // 0x0B24(0x0004)
	int                                                s_nDisarmCount;                                           // 0x0B28(0x0004)
	int                                                s_nCrippleCount;                                          // 0x0B2C(0x0004)
	int                                                s_nSpellAbsorbCount;                                      // 0x0B30(0x0004)
	int                                                s_nBasicAttackAbsorbCount;                                // 0x0B34(0x0004)
	int                                                s_nStealthCount;                                          // 0x0B38(0x0004)
	int                                                s_nNoWardStealthCount;                                    // 0x0B3C(0x0004)
	int                                                s_nIntoxicateCount;                                       // 0x0B40(0x0004)
	int                                                s_nImmortalCount;                                         // 0x0B44(0x0004)
	int                                                s_nSlowToHaltCount;                                       // 0x0B48(0x0004)
	int                                                s_nCannotAutoPortalCount;                                 // 0x0B4C(0x0004)
	int                                                s_nSlideCount;                                            // 0x0B50(0x0004)
	int                                                s_nAnyoneCanCritCount;                                    // 0x0B54(0x0004)
	TArray<int>                                        s_nEntrapCountMap;                                        // 0x0B58(0x0010) (NeedCtorLink)
	int                                                s_nHardCCCount;                                           // 0x0B68(0x0004)
	TArray<class UTgDeviceFire*>                       s_HardCCModesThisTick;                                    // 0x0B6C(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveSpellAbsorbs;                                     // 0x0B7C(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveBasicAttackAbsorbs;                               // 0x0B8C(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_ActiveDamageRedirects;                                  // 0x0B9C(0x0010) (NeedCtorLink)
	TArray<struct FSlowToHaltMode>                     s_ActiveSlowToHaltModes;                                  // 0x0BAC(0x0010) (NeedCtorLink)
	class UTgTiDiState*                                s_CurrentTiDi;                                            // 0x0BBC(0x0008)
	float                                              r_fTotalTiDi;                                             // 0x0BC4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectManager");
		return ptr;
	}


	int STATIC_ShieldTakeDamage(int nDamage);
	void PostDemoRewind();
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void STATIC_ClientRemoveTrackedInstigatorTimeDilation(class UTgEffectForm* effectform);
	void STATIC_ClientTrackInstigatorTimeDilation(class UTgEffectForm* effectform);
	void STATIC_ClientApplyInstigatorTimeDilation(class UTgEffectForm* effectform);
	void STATIC_RemoveTrackedInstigatorTimeDilation(class UTgEffectGroup* eg);
	void TrackInstigatorTimeDilation(class UTgEffectGroup* eg);
	void ApplyInstigatorTimeDilation(class UTgEffectGroup* eg);
	void STATIC_ShutdownTiDi();
	void TransmitTiDiClient();
	void TransmitTiDiServer();
	void ApplyTiDi();
	bool STATIC_ShouldUpdateTiDi();
	class UTgTiDiState* STATIC_GetCurrentTiDi();
	void STATIC_InitializeTiDi();
	void UpdateTiDi();
	bool STATIC_GetClientEffect(int nEffectGroupId, struct FEffectListEntry* effectEntry, int* nIndex);
	bool STATIC_ClientHasEffect(int nEffectGroupId);
	class ATgEffectManager* STATIC_GetEffectManagerFor(class AActor* ManagerOwner);
	class UTgEffectGroup* STATIC_ProcessEffect(class UTgEffectGroup* EffectGroup, class AActor* aInstigator, int nNumStacks, const struct FImpactInfo& Impact);
	void STATIC_RemoveProperty(class UTgEffectGroup* EffectGroup);
	class UTgEffectGroup* ApplyProperty(float nValue, int nPropId, class AActor* aInstigator, const struct FImpactInfo& Impact, int nCategory, bool bApplyAsPercent);
	void ApplyTiDiEffect(float fDilation, float fDuration, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact);
	void ApplyStasis(int nValue, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyStun(float fDuration, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact);
	void ApplySelfExecute(class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyEnergy(int nEnergy, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyMana(int nMana, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyHealth(int nHealth, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyUnstoppableKill(int nDamage, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void ApplyDamage(float fDamage, class AActor* aInstigator, int nAttackType, int nDamageType, const struct FImpactInfo& Impact, int nEffectGroupCategory);
	void InventoryManagerOnCommittedSell(class UTgInventoryObject* invobj);
	void ApplyHaltEffectGroups();
	bool STATIC_Dodge(class UTgDeviceFire* FireMode, class AActor* Source);
	bool AbsorbBasicAttack(class UTgDeviceFire* FireMode, class AActor* Source);
	bool AbsorbSpell(class UTgDeviceFire* FireMode, class AActor* Source);
	int STATIC_GetHardCCCount(class UTgDeviceFire* DeviceMode);
	void STATIC_ResetCCEvents();
	void AddCCEvent(class UTgEffectGroup* EffectGroup);
	void STATIC_RecalculateBeltFx();
	void STATIC_RecalculateFx();
	int STATIC_GetCombatMsgIdFromEffectGroup(class UTgEffectGroup* EffectGroup);
	bool STATIC_CanAnyoneCrit();
	bool IsSliding();
	bool IsIntoxicated();
	bool IsStunned();
	bool IsInvulnerable();
	void STATIC_ClearAllClientEffectForms();
	void UpdateEffectFormVisibility();
	class UTgEffectGroup* STATIC_GetEffectGroupByCategory(int nCategoryCode, class AActor* theInstigator, int nNumToSkip);
	class UTgEffectGroup* STATIC_GetEffectGroup(int nEffectGroupId, class AActor* theInstigator);
	void MarkAllPortalFallEffectsAsNonRemovable();
	void STATIC_RemoveAllStealthEffects();
	void STATIC_RemoveAllEffectsOnRevive();
	void STATIC_RemoveAllEffectsOnDeath();
	void STATIC_RemoveAllEffects();
	class UTgEffectGroup* STATIC_GetNextStrongest(class UTgEffectGroup* eg);
	bool IsStrongest(class UTgEffectGroup* eg, bool bConsiderLifetime, bool bConsiderStacks, int nNumStacks, class UTgEffectGroup** prevStrongest);
	void STATIC_HardCleanseEffects();
	bool STATIC_ResetEffectGroupLifeTimeByCategory(int nCategoryCode, float Lifetime);
	bool STATIC_ResetEffectGroupLifeTimeById(int nEffectGroupId, float Lifetime);
	bool STATIC_RemoveAllEffectGroups(class UTgEffectGroup* eg);
	bool STATIC_RemoveEffectGroupsByCategory(int nCategoryCode, int nNumStacks, class AActor* theInstigator);
	bool STATIC_RemoveEffectGroupById(int nEffectGroupId, int nNumStacks, class AActor* theInstigator);
	void UpdateOwnerEffectIcons();
	void UpdateManagedEffectForms();
	void UpdateQueueEffectForms();
	void UpdateEffectForms();
	void STATIC_ClearEffectRep(class UTgEffectGroup* Group);
	void UpdateEffectRep(class UTgEffectGroup* eg);
	int STATIC_SetEffectRep(class UTgEffectGroup* eg, int nSkinId, int nSkinLevel, int nCustomFilter);
};


// Class TgGame.TgActorFactory
// 0x0044 (0x02A4 - 0x0260)
class ATgActorFactory : public AActor
{
public:
	int                                                m_nMapObjectId;                                           // 0x0260(0x0004) (Edit, EditConst)
	unsigned long                                      s_bAutoSpawn : 1;                                         // 0x0264(0x0004) (Edit)
	int                                                s_nTeamNumber;                                            // 0x0268(0x0004) (EditConst)
	unsigned char                                      s_nTaskForce;                                             // 0x026C(0x0001) (Edit)
	TEnumAsByte<EMinimapFactoryType>                   m_MinimapType;                                            // 0x026D(0x0001) (Edit)
	TEnumAsByte<EeSelectionMethod>                     s_eSelectionMethod;                                       // 0x026E(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x026F(0x0001) MISSED OFFSET
	int                                                s_nSelectionListId;                                       // 0x0270(0x0004)
	int                                                s_nSelectedObjectId;                                      // 0x0274(0x0004)
	int                                                m_nSelectionListPropId;                                   // 0x0278(0x0004)
	int                                                s_nNameId;                                                // 0x027C(0x0004)
	float                                              m_fPlacementTraceDistance;                                // 0x0280(0x0004) (Edit)
	int                                                s_nFactoryId;                                             // 0x0284(0x0004) (Transient)
	class ATgRepInfo_Factory*                          m_FRI;                                                    // 0x0288(0x0008) (Transient)
	class UClass*                                      m_FRIClass;                                               // 0x0290(0x0008)
	int                                                s_nCurListIndex;                                          // 0x0298(0x0004)
	class USpriteComponent*                            m_WorldIconSprite;                                        // 0x029C(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActorFactory");
		return ptr;
	}


	class AActor* STATIC_GetLastActor();
	void Destroyed();
	void PostBeginPlay();
	void PreBeginPlay();
	struct FVector STATIC_GetSpawnPlacementStartLocation();
	void SetTaskForceNumber(int nNewTaskForce);
	void STATIC_CalcFactoryPlacement(const struct FVector& Extent, bool bCenterOnGround, struct FVector* OutLocation, struct FRotator* OutRotation);
	void STATIC_SpawnObject();
	void LoadObjectConfig();
};


// Class TgGame.TgBotFactory
// 0x015C (0x0400 - 0x02A4)
class ATgBotFactory : public ATgActorFactory
{
public:
	TEnumAsByte<EeBotSelection>                        LocationSelection;                                        // 0x02A4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02A5(0x0003) MISSED OFFSET
	TArray<class ANavigationPoint*>                    LocationList;                                             // 0x02A8(0x0010) (Edit, Const, NeedCtorLink)
	int                                                s_nCurLocationIndex;                                      // 0x02B8(0x0004)
	class ANavigationPoint*                            SafetyLocation;                                           // 0x02BC(0x0008) (Edit)
	unsigned long                                      ShouldTraceSpawnLocationToFloor : 1;                      // 0x02C4(0x0004) (Edit)
	unsigned long                                      bStaggerSpawning : 1;                                     // 0x02C4(0x0004) (Edit)
	unsigned long                                      bSpawnAsSquad : 1;                                        // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bTriggerClearWithActor : 1;                             // 0x02C4(0x0004) (Edit)
	unsigned long                                      bAutoSpawn : 1;                                           // 0x02C4(0x0004)
	unsigned long                                      m_bFirstSpawn : 1;                                        // 0x02C4(0x0004)
	unsigned long                                      bBulkSpawn : 1;                                           // 0x02C4(0x0004) (Edit)
	unsigned long                                      bRespawn : 1;                                             // 0x02C4(0x0004) (Edit)
	unsigned long                                      bUseRespawnCaching : 1;                                   // 0x02C4(0x0004) (Edit)
	unsigned long                                      delayRespawnIndicator : 1;                                // 0x02C4(0x0004)
	unsigned long                                      bHideDuringDespawn : 1;                                   // 0x02C4(0x0004) (Edit)
	unsigned long                                      bStartBotsInIntroState : 1;                               // 0x02C4(0x0004) (Edit)
	unsigned long                                      bHasDifferentInitialIntro : 1;                            // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bFirstSpawnWave : 1;                                    // 0x02C4(0x0004)
	unsigned long                                      m_bRespawnRebuildMeshEnabled : 1;                         // 0x02C4(0x0004)
	unsigned long                                      m_bIgnoreCollisionOnSpawn : 1;                            // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bForceTracking : 1;                                     // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bSpawnPaused : 1;                                       // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bIsAggrod : 1;                                          // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bUseProceduralHitReaction : 1;                          // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bAllowCombatDuringIntro : 1;                            // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bOverridesBotLevelRate : 1;                             // 0x02C4(0x0004) (Edit)
	unsigned long                                      bCachedRespawn : 1;                                       // 0x02C4(0x0004)
	unsigned long                                      m_bUseCollisionHeightForSpawnPlacement : 1;               // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bForcesLightOverrides : 1;                              // 0x02C4(0x0004) (Edit)
	unsigned long                                      m_bFullStateVisibility : 1;                               // 0x02C4(0x0004) (Edit)
	int                                                nBotCount;                                                // 0x02C8(0x0004)
	int                                                nCurrentCount;                                            // 0x02CC(0x0004)
	int                                                nActiveCount;                                             // 0x02D0(0x0004) (Edit)
	int                                                nTotalSpawns;                                             // 0x02D4(0x0004)
	int                                                nLane;                                                    // 0x02D8(0x0004) (Edit)
	int                                                nNavPointsToSkipForPathing;                               // 0x02DC(0x0004) (Edit)
	class UTgAISquad*                                  s_CurrentSquad;                                           // 0x02E0(0x0008) (Transient)
	class UClass*                                      m_SquadClass;                                             // 0x02E8(0x0008) (Edit)
	int                                                m_nLocationId;                                            // 0x02F0(0x0004) (Edit)
	int                                                nSpawnTableId;                                            // 0x02F4(0x0004) (Edit)
	int                                                nDefaultSpawnTableId;                                     // 0x02F8(0x0004) (Edit)
	float                                              fSpawnDelay;                                              // 0x02FC(0x0004) (Edit)
	TArray<struct FSpawnQueueEntry>                    m_SpawnQueue;                                             // 0x0300(0x0010) (NeedCtorLink)
	class ATgBotEncounterVolume*                       m_SpawnVolume;                                            // 0x0310(0x0008)
	int                                                m_nLastGroup;                                             // 0x0318(0x0004)
	float                                              fSpawnHealthPercent;                                      // 0x031C(0x0004) (Edit)
	float                                              fPreSpawnTimerTime;                                       // 0x0320(0x0004) (Edit)
	float                                              fIntroductionDuration;                                    // 0x0324(0x0004) (Edit)
	float                                              fInitialIntroductionDuration;                             // 0x0328(0x0004) (Edit)
	class UStaticMeshComponent*                        m_RespawnIndicator;                                       // 0x032C(0x0008) (Edit, ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   m_RespawnIndicatorMIC;                                    // 0x0334(0x0008) (Transient)
	class UMeshComponent*                              m_RespawnRebuildMesh;                                     // 0x033C(0x0008) (Edit, ExportObject, Component, EditInline)
	class UAnimNodeSequence*                           m_RespawnRebuildAnimNode;                                 // 0x0344(0x0008) (Transient)
	class ULightEnvironmentComponent*                  RespawnRebuildLightEnvironment;                           // 0x034C(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)
	class UTexture2D*                                  m_TextureNormal;                                          // 0x0354(0x0008)
	float                                              fLastKillTime;                                            // 0x035C(0x0004)
	float                                              fRespawnDelay;                                            // 0x0360(0x0004) (Edit)
	float                                              m_fIntroCombatDelay;                                      // 0x0364(0x0004) (Edit)
	float                                              m_fBotLevelRateOverride;                                  // 0x0368(0x0004) (Edit)
	TArray<int>                                        m_nUnalignedTaskforceNums;                                // 0x036C(0x0010) (NeedCtorLink)
	TArray<struct FBuffMap>                            m_BuffMap;                                                // 0x037C(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTeamBuffMap>                        m_TeamBuffMap;                                            // 0x038C(0x0010) (Edit, NeedCtorLink)
	TArray<class ATgBotFactory*>                       m_NextFactories;                                          // 0x039C(0x0010) (Edit, NeedCtorLink)
	TArray<class ATgBotFactory*>                       m_PreviousFactories;                                      // 0x03AC(0x0010) (NeedCtorLink)
	TArray<struct FFactorySpawnModifier>               m_SpawnModifiers;                                         // 0x03BC(0x0010) (NeedCtorLink)
	TArray<TScriptInterface<class UTgOwnedPlaceableMesh>> c_OwnedMeshActors;                                        // 0x03CC(0x0010) (NeedCtorLink)
	TArray<struct FAccoladeMap>                        s_AccoladeMap;                                            // 0x03DC(0x0010) (Edit, NeedCtorLink)
	struct FLightingChannelContainer                   c_LightingChannels;                                       // 0x03EC(0x0004) (Edit)
	TArray<struct FRewardModifiers>                    m_RewardModifiers;                                        // 0x03F0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory");
		return ptr;
	}


	void Tick(float DeltaTime);
	void UpdateRespawnTimeIndicator(float fPct);
	void STATIC_OnBotDamaged(class ATgPawn* Bot, class AController* DamageInstigator, class UClass* DamageType, int DamageAmount);
	void STATIC_OnGetBot(class UTgSeqAct_GetBot* inAction);
	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_OnTriggerBots(class UTgSeqAct_TriggerBots* Action);
	void KillBots(bool bDespawn);
	void Despawn();
	void StartEncounter(class ATgBotEncounterVolume* Volume);
	void ContinueEncounter();
	void EndEncounter();
	void STATIC_OnModifyFactorySpawn(class UTgSeqAct_ModifyFactorySpawn* inAction);
	void STATIC_OnDespawnBots(class UTgSeqAct_DespawnBots* inAction);
	void STATIC_OnKillBots(class UTgSeqAct_KillBots* inAction);
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void PostBeginPlay();
	void STATIC_ResetVariables();
	void UnpauseTrackedBots();
	int STATIC_GetFactoryAdjustedXp(int nXPReward, struct FScoreKillData* Data);
	int STATIC_GetFactoryAdjustedGold(int nGoldReward, struct FScoreKillData* Data);
	int STATIC_GetTimeAdjustedTeamBuff(int nBotId);
	void STATIC_InitPawnCommunication(class ATgPawn* SpawnedPawn);
	bool WantsCommunicationWithPawn(class ATgPawn* SpawnedPawn);
	void AdjustMeshOwnership(class ATgPawn* NewOwner);
	void RegisterOwnedPlaceableMesh(const TScriptInterface<class UTgOwnedPlaceableMesh>& tgMeshActor);
	void LinkedFactoryEmptied(class ATgBotFactory* botFact);
	void LinkedFactorySpawnedBot(class ATgBotFactory* botFact);
	void STATIC_RegisterLinkedFactory(class ATgBotFactory* botFact);
	void ApplySpawnModifierToPawn(class ATgPawn* ModifiedPawn, int ItemId, int NumStacks);
	void STATIC_RemoveSpawnModifier(int ModifierIndex);
	void ApplyNewSpawnModifier(int ModifierItemId, int NumStacks, float ModifierDuration, bool UsesIndicator);
	void TriggerFactoryEmptiedKismet(class AActor* DeadBot, int nNewEmpties, class AActor* Killer);
	void TriggerBotDiedKismet(class AActor* DeadBot, class AActor* Killer, int nNewDeaths);
	void TriggerBotSpawnedKismet(class AActor* SpawnedBot, int nNewSpawns);
	float STATIC_GetRespawnDelay();
	void STATIC_ReInitLight();
	int STATIC_GetRemainingTotalSpawns();
	void STATIC_SquadDied(class UTgAISquad* squad);
	void BotDied(class ATgPawn* Pawn, class ATgAIController* aic);
	class AActor* UseSpawnTable();
	void STATIC_CalcFactoryPlacement(const struct FVector& Extent, bool bCenterOnGround, struct FVector* OutLocation, struct FRotator* OutRotation);
	class AActor* STATIC_SpawnBotAdjusted(const struct FSpawnQueueEntry& Entry);
	class AActor* STATIC_SpawnBotId(int nBotId, int nSkinId);
	class AActor* STATIC_SpawnNextBot();
	class AActor* SpawnBot();
	void ClearQueue();
	void BuildQueue();
	void STATIC_ResetQueue();
	void LoadObjectConfig();
};


// Class TgGame.TgBotFactory_Adventure
// 0x003C (0x043C - 0x0400)
class ATgBotFactory_Adventure : public ATgBotFactory
{
public:
	float                                              m_fAggroRadiusOverride;                                   // 0x0400(0x0004) (Edit)
	unsigned long                                      m_bUsePresetDeployables : 1;                              // 0x0404(0x0004) (Edit)
	unsigned long                                      m_bIgnoreAggro : 1;                                       // 0x0404(0x0004) (Edit)
	TArray<struct FVector>                             m_vDepLocs;                                               // 0x0408(0x0010) (Edit, NeedCtorLink)
	int                                                m_nDeployLootTable;                                       // 0x0418(0x0004) (Edit)
	int                                                m_nGoldLootTable;                                         // 0x041C(0x0004) (Edit)
	int                                                m_nGearLootTable;                                         // 0x0420(0x0004) (Edit)
	int                                                m_nNumLootRolls;                                          // 0x0424(0x0004) (Edit)
	int                                                m_nSpawnItemTable;                                        // 0x0428(0x0004) (Edit)
	class UTgLootTable*                                s_SelectedSpawnItem;                                      // 0x042C(0x0008)
	TEnumAsByte<EChestType>                            m_eChestType;                                             // 0x0434(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0435(0x0003) MISSED OFFSET
	int                                                m_nDamageCategory;                                        // 0x0438(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Adventure");
		return ptr;
	}


	void STATIC_OnForceFactoryTables(class UTgSeqAct_ForceFactoryTables* FFT_Action);
	void KillBots(bool bDespawn);
	void PostBeginPlay();
	void LoadLootTables();
	void STATIC_GiveLoot(int nTaskForce);
	void STATIC_GrantGold(int nTaskForce);
	void BotAggrod(class ATgPawn* Pawn);
	void BotDied(class ATgPawn* Pawn, class ATgAIController* aic);
	void STATIC_SpawnPickup(class APawn* depOwner, int nDepId, const struct FVector& vInitialLoc, const struct FVector& vFinalLoc, const struct FRotator& rRot);
	class AActor* STATIC_SpawnNextBot();
	void STATIC_ResetQueue();
};


// Class TgGame.TgBotFactory_BonusTrigger
// 0x0000 (0x0400 - 0x0400)
class ATgBotFactory_BonusTrigger : public ATgBotFactory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_BonusTrigger");
		return ptr;
	}

};


// Class TgGame.TgBotFactory_BotShop
// 0x0000 (0x0400 - 0x0400)
class ATgBotFactory_BotShop : public ATgBotFactory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_BotShop");
		return ptr;
	}


	class ATgRepInfo_Player_BotShop* STATIC_GetPRIBotShop();
	class AActor* STATIC_SpawnBotAdjusted(const struct FSpawnQueueEntry& Entry);
	void BuildQueue();
};


// Class TgGame.TgBotFactory_Leashed
// 0x002C (0x042C - 0x0400)
class ATgBotFactory_Leashed : public ATgBotFactory
{
public:
	struct FVector                                     LeashLocation;                                            // 0x0400(0x000C) (Edit)
	float                                              LeashRange;                                               // 0x040C(0x0004) (Edit)
	class AVolume*                                     LeashVolume;                                              // 0x0410(0x0008) (Edit)
	unsigned long                                      m_bAttackOnSight : 1;                                     // 0x0418(0x0004) (Edit)
	TArray<int>                                        m_nAttackOnSightIgnoredCategoryCodes;                     // 0x041C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Leashed");
		return ptr;
	}


	class AActor* STATIC_SpawnBotAdjusted(const struct FSpawnQueueEntry& Entry);
};


// Class TgGame.TgBotFactory_ClearCampScore
// 0x003C (0x0468 - 0x042C)
class ATgBotFactory_ClearCampScore : public ATgBotFactory_Leashed
{
public:
	TArray<int>                                        m_nItemAwardIds;                                          // 0x042C(0x0010) (Edit, NeedCtorLink)
	float                                              m_fTimeoutPeriod;                                         // 0x043C(0x0004) (Edit)
	int                                                m_nCurrentSpawnGroup;                                     // 0x0440(0x0004)
	TArray<int>                                        m_nSpawnTableIds;                                         // 0x0444(0x0010) (Edit, NeedCtorLink)
	TArray<float>                                      m_fRespawnDelays;                                         // 0x0454(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bShouldLoop : 1;                                        // 0x0464(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_ClearCampScore");
		return ptr;
	}


	void STATIC_OnKillBots(class UTgSeqAct_KillBots* inAction);
	void Tick(float DeltaTime);
	void ApplyNewModifer(class ATgRepInfo_TaskForce* Winner);
	void AwardItemToWinners();
	void TriggerFactoryEmptiedKismet(class AActor* DeadBot, int nNewEmpties, class AActor* Killer);
	void TriggerBotDiedKismet(class AActor* DeadBot, class AActor* Killer, int nNewDeaths);
};


// Class TgGame.TgBotFactory_LeashedConfigurable
// 0x0050 (0x047C - 0x042C)
class ATgBotFactory_LeashedConfigurable : public ATgBotFactory_Leashed
{
public:
	TArray<struct FLeashedBotEntry>                    s_BotEntries;                                             // 0x042C(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<EQUEUEPROFILESELECTION>                s_ProfileSelectionType;                                   // 0x043C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x043D(0x0003) MISSED OFFSET
	TArray<struct FQueueProfile>                       s_QueueProfiles;                                          // 0x0440(0x0010) (Edit, NeedCtorLink)
	int                                                s_nProfileIndex;                                          // 0x0450(0x0004)
	int                                                s_nQueueIndex;                                            // 0x0454(0x0004)
	TArray<struct FIndicatorEntry>                     m_FactoryVisuals;                                         // 0x0458(0x0010) (Edit, NeedCtorLink)
	TArray<class AStaticMeshActor*>                    m_FactoryVisualMeshes;                                    // 0x0468(0x0010) (Edit, NeedCtorLink)
	int                                                m_nVisualIndex;                                           // 0x0478(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_LeashedConfigurable");
		return ptr;
	}


	void SetVisualIndex(int nVisIndex);
	void STATIC_SetMinimapType();
	void STATIC_PickNewSpawnQueue();
	void BuildQueue();
	void STATIC_ResetQueue();
	float STATIC_GetRespawnDelay();
};


// Class TgGame.TgBotFactory_JungleShrine
// 0x0020 (0x049C - 0x047C)
class ATgBotFactory_JungleShrine : public ATgBotFactory_LeashedConfigurable
{
public:
	TArray<class ANavigationPoint*>                    m_ChaliceLocations;                                       // 0x047C(0x0010) (Edit, NeedCtorLink)
	int                                                m_nChaliceGoldThreshold;                                  // 0x048C(0x0004) (Edit)
	int                                                m_nTotemTaskForce;                                        // 0x0490(0x0004) (Edit)
	float                                              m_fConsecutiveHitTimer;                                   // 0x0494(0x0004) (Edit)
	int                                                m_nHitsToConsumeAll;                                      // 0x0498(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_JungleShrine");
		return ptr;
	}

};


// Class TgGame.TgBotFactory_LeashedConfigurable_PEP
// 0x001C (0x0498 - 0x047C)
class ATgBotFactory_LeashedConfigurable_PEP : public ATgBotFactory_LeashedConfigurable
{
public:
	class ATgBotFactory_PEP_TakenJungleSpawn*          LinkedTakenJungleSpawner;                                 // 0x047C(0x0008) (Edit)
	struct FLeashedBotQueueEntry                       TotemBotQueueEntry;                                       // 0x0484(0x0010) (Edit)
	unsigned long                                      m_bUseGlobalRespawnTimer : 1;                             // 0x0494(0x0004) (Edit)
	unsigned long                                      m_bShowRespawnIndicator : 1;                              // 0x0494(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_LeashedConfigurable_PEP");
		return ptr;
	}


	void BuildQueue();
	void STATIC_OnGetPEPInfo(class UTgSeqAct_GetPEPInfo* inAction);
	void STATIC_SpawnCampRewardToken(class ATgPawn* KillerPawn, const struct FPEPRewardMap& rewardMap, class ATgBotFactory_PEP_TakenJungleSpawn* leashedCamp);
	TEnumAsByte<EPEPRewardType> STATIC_GetCurrentCampRewardType();
	void TriggerBotSpawnedKismet(class AActor* SpawnedBot, int nNewSpawns);
	void TriggerFactoryEmptiedKismet(class AActor* DeadBot, int nNewEmpties, class AActor* Killer);
};


// Class TgGame.TgBotFactory_PointCapture
// 0x0008 (0x0434 - 0x042C)
class ATgBotFactory_PointCapture : public ATgBotFactory_Leashed
{
public:
	class ATgCapturePoint_WithBot*                     m_CapturePoint;                                           // 0x042C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_PointCapture");
		return ptr;
	}


	void BotDied(class ATgPawn* Pawn, class ATgAIController* aic);
};


// Class TgGame.TgBotFactory_Titan
// 0x0000 (0x042C - 0x042C)
class ATgBotFactory_Titan : public ATgBotFactory_Leashed
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Titan");
		return ptr;
	}


	bool AllPhoenixesUp();
};


// Class TgGame.TgBotFactory_Minions
// 0x001C (0x041C - 0x0400)
class ATgBotFactory_Minions : public ATgBotFactory
{
public:
	TEnumAsByte<EMinionFactoryType>                    m_eFactoryType;                                           // 0x0400(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0401(0x0003) MISSED OFFSET
	unsigned long                                      m_OverrideShouldSpawnSuperMinions : 1;                    // 0x0404(0x0004) (Transient)
	int                                                m_nWaveNumber;                                            // 0x0408(0x0004) (Transient)
	int                                                m_nLastBonusWave;                                         // 0x040C(0x0004) (Transient)
	int                                                m_nLanePushersInQueue;                                    // 0x0410(0x0004) (Transient)
	float                                              m_fLastBonusActivationTime;                               // 0x0414(0x0004) (Transient)
	float                                              m_fSuperMinionEndTime;                                    // 0x0418(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Minions");
		return ptr;
	}


	void BuildQueue();
	bool STATIC_ShouldSpawnBonusMinions();
	bool STATIC_ShouldSpawnSuperMinions();
	void STATIC_SetSuperMinionsActive(float fSeconds);
};


// Class TgGame.TgBotFactory_Minions_Configurable
// 0x0038 (0x0454 - 0x041C)
class ATgBotFactory_Minions_Configurable : public ATgBotFactory_Minions
{
public:
	TArray<struct FBotEntryData>                       m_BotEntries;                                             // 0x041C(0x0010) (Edit, NeedCtorLink)
	TArray<struct FSpawnQueueData>                     m_SpawnTables;                                            // 0x042C(0x0010) (Edit, NeedCtorLink)
	int                                                s_nCurrentQueue;                                          // 0x043C(0x0004)
	int                                                s_nCurrentQueueEntry;                                     // 0x0440(0x0004)
	TArray<struct FAdditionalBotData>                  s_AdditionalQueue;                                        // 0x0444(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Minions_Configurable");
		return ptr;
	}


	void STATIC_OnAddToSpawnQueue(class UTgSeqAct_AddToSpawnQueue* AddToQueueAct);
	void BuildQueue();
};


// Class TgGame.TgBotFactory_PEP
// 0x0001 (0x0401 - 0x0400)
class ATgBotFactory_PEP : public ATgBotFactory
{
public:
	TEnumAsByte<EPEPRewardType>                        eRewardType;                                              // 0x0400(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_PEP");
		return ptr;
	}


	class ATgRepInfo_TaskForce_PEP* STATIC_GetTaskForceRepInfoPEP();
	void BuildQueue();
};


// Class TgGame.TgBotFactory_PEP_TakenJungleSpawn
// 0x0027 (0x0428 - 0x0401)
class ATgBotFactory_PEP_TakenJungleSpawn : public ATgBotFactory_PEP
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0401(0x0003) MISSED OFFSET
	class ATgBotFactory_LeashedConfigurable_PEP*       m_LinkedLeashedCamp;                                      // 0x0404(0x0008) (Edit)
	float                                              m_fBotRespawnTime;                                        // 0x040C(0x0004) (Edit)
	class ATgPawn*                                     m_KillerPawn;                                             // 0x0410(0x0008)
	TArray<struct FPEPRewardEntry>                     m_RewardsQueue;                                           // 0x0418(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_PEP_TakenJungleSpawn");
		return ptr;
	}


	void TriggerBotDiedKismet(class AActor* DeadBot, class AActor* Killer, int nNewDeaths);
	void TriggerBotSpawnedKismet(class AActor* SpawnedBot, int nNewSpawns);
	void BuildQueue();
	void STATIC_SpawnRewardsAtBase();
	void STATIC_SpawnRewards();
	void STATIC_ClearRewards();
	void STATIC_QueueReward(class ATgPawn* Killer, const struct FPEPRewardMap& rewardMap);
};


// Class TgGame.TgBotFactory_SplineCart
// 0x0008 (0x0408 - 0x0400)
class ATgBotFactory_SplineCart : public ATgBotFactory
{
public:
	class ATgSplineActor*                              m_CartSpline;                                             // 0x0400(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_SplineCart");
		return ptr;
	}


	class AActor* STATIC_SpawnBotAdjusted(const struct FSpawnQueueEntry& Entry);
};


// Class TgGame.TgBotFactory_Tower
// 0x0014 (0x0414 - 0x0400)
class ATgBotFactory_Tower : public ATgBotFactory
{
public:
	class ATgStaticMeshActor_TowerPad*                 m_TowerPadMesh;                                           // 0x0400(0x0008) (Edit)
	class ATgNavigationPoint*                          m_TeleportPoint;                                          // 0x0408(0x0008) (Edit)
	unsigned long                                      m_bLocked : 1;                                            // 0x0410(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_Tower");
		return ptr;
	}


	class AActor* STATIC_SpawnNextBot();
	void LinkedFactoryEmptied(class ATgBotFactory* botFact);
	void LinkedFactorySpawnedBot(class ATgBotFactory* botFact);
};


// Class TgGame.TgBotFactorySpawnable
// 0x0000 (0x0400 - 0x0400)
class ATgBotFactorySpawnable : public ATgBotFactory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactorySpawnable");
		return ptr;
	}

};


// Class TgGame.TgDeployableFactory
// 0x0024 (0x02C8 - 0x02A4)
class ATgDeployableFactory : public ATgActorFactory
{
public:
	int                                                nCurrentCount;                                            // 0x02A4(0x0004)
	float                                              s_fLastSpawnTime;                                         // 0x02A8(0x0004)
	unsigned long                                      s_bSpawnOnce : 1;                                         // 0x02AC(0x0004) (Edit)
	unsigned long                                      s_bTimeoutDeployable : 1;                                 // 0x02AC(0x0004) (Edit)
	unsigned long                                      m_bDeployableStartRespawnTimer : 1;                       // 0x02AC(0x0004) (Edit)
	unsigned long                                      s_bUseMinimapIcon : 1;                                    // 0x02AC(0x0004) (Edit)
	unsigned long                                      s_bDeployIsAlwaysRelevant : 1;                            // 0x02AC(0x0004) (Edit)
	unsigned long                                      m_bFullStateVisibility : 1;                               // 0x02AC(0x0004) (Edit)
	int                                                s_nDeployableId;                                          // 0x02B0(0x0004) (Edit)
	float                                              s_fDeployableLifetime;                                    // 0x02B4(0x0004) (Edit)
	float                                              s_fTimeToDeploy;                                          // 0x02B8(0x0004) (Edit)
	float                                              s_fRespawnTime;                                           // 0x02BC(0x0004) (Edit)
	class ATgActorFactory*                             s_InstigatorFactory;                                      // 0x02C0(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployableFactory");
		return ptr;
	}


	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_OnKillBots(class UTgSeqAct_KillBots* inAction);
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void STATIC_SetFactoryState(TEnumAsByte<EReplicatedFactoryState> eNewState);
	void STATIC_DeployableDied();
	void STATIC_RespawnTimer();
	void ResetRespawnTimer();
	void PostBeginPlay();
	void STATIC_SpawnObject();
};


// Class TgGame.TgDeployableFactory_Moveable
// 0x0000 (0x02C8 - 0x02C8)
class ATgDeployableFactory_Moveable : public ATgDeployableFactory
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployableFactory_Moveable");
		return ptr;
	}

};


// Class TgGame.TgDeployableFactory_PlayerDeath
// 0x0010 (0x02D8 - 0x02C8)
class ATgDeployableFactory_PlayerDeath : public ATgDeployableFactory
{
public:
	unsigned long                                      m_bSpawnFromPlayers : 1;                                  // 0x02C8(0x0004) (Edit)
	unsigned long                                      m_bSpawnFromBots : 1;                                     // 0x02C8(0x0004) (Edit)
	unsigned long                                      m_bGodsOnly : 1;                                          // 0x02C8(0x0004) (Edit)
	struct FVector                                     m_vLastPlayerDeathLocation;                               // 0x02CC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployableFactory_PlayerDeath");
		return ptr;
	}


	void STATIC_ReactToPawnDeath(class ATgPawn* DeadPawn);
	struct FVector STATIC_GetSpawnPlacementStartLocation();
};


// Class TgGame.TgDeployableFactory_Portal
// 0x0024 (0x02EC - 0x02C8)
class ATgDeployableFactory_Portal : public ATgDeployableFactory
{
public:
	TArray<class ATgDeployableFactory*>                s_Receivers;                                              // 0x02C8(0x0010) (Edit, NeedCtorLink)
	TArray<class ATgDeployable*>                       s_Portals;                                                // 0x02D8(0x0010) (NeedCtorLink)
	float                                              m_fTimeToActivate;                                        // 0x02E8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployableFactory_Portal");
		return ptr;
	}


	void STATIC_DeployableDied();
};


// Class TgGame.TgDestructibleFactory
// 0x0008 (0x02AC - 0x02A4)
class ATgDestructibleFactory : public ATgActorFactory
{
public:
	class ULightEnvironmentComponent*                  LightEnvironment;                                         // 0x02A4(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDestructibleFactory");
		return ptr;
	}


	void STATIC_SpawnObject();
};


// Class TgGame.TgBotFactoryComponent
// 0x0000 (0x024C - 0x024C)
class UTgBotFactoryComponent : public UPrimitiveComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactoryComponent");
		return ptr;
	}

};


// Class TgGame.TgDroppedItem
// 0x002C (0x028C - 0x0260)
class ATgDroppedItem : public AActor
{
public:
	float                                              m_fLifeSpan;                                              // 0x0260(0x0004)
	unsigned long                                      m_bFadeOut : 1;                                           // 0x0264(0x0004)
	struct FName                                       m_nmPickUpState;                                          // 0x0268(0x0008)
	int                                                r_nItemId;                                                // 0x0270(0x0004) (Net)
	class UMeshComponent*                              c_Mesh;                                                   // 0x0274(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgEffectGroup*>                      s_EffectGroupList;                                        // 0x027C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDroppedItem");
		return ptr;
	}


	bool ValidTouch(class APawn* Other);
	void STATIC_GiveTo(class ATgPawn* P);
	void ReplicatedEvent(const struct FName& VarName);
	bool ApplyItemSetup();
	class UTgEffectGroup* STATIC_GetEffectGroup(int nType, int* nIndex);
};


// Class TgGame.TgInventory_BuildCache
// 0x0080 (0x00E0 - 0x0060)
class UTgInventory_BuildCache : public UObject
{
public:
	struct FBuildLibrary                               m_BuildLibrary;                                           // 0x0060(0x0010) (NeedCtorLink)
	struct FBuildMap                                   m_BuildMap;                                               // 0x0070(0x0018) (NeedCtorLink)
	TArray<struct FTeamComp>                           m_TeamComps;                                              // 0x0088(0x0010) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0098(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventory_BuildCache.m_QueueToModeMap

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventory_BuildCache");
		return ptr;
	}


	int STATIC_GetBuildForRole(int nBotId, TEnumAsByte<EConquestRole> eRole, int nGameMode);
	TArray<int> STATIC_GetBuild(int nBuildIndex);
	void LoadBuildData();
	void STATIC_InitTeamComps();
};


// Class TgGame.TgInventory_RandomizedBotShop
// 0x0008 (0x0268 - 0x0260)
class ATgInventory_RandomizedBotShop : public AActor
{
public:
	class ATgGameConfig_BotShop*                       s_GameConfig;                                             // 0x0260(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventory_RandomizedBotShop");
		return ptr;
	}


	void STATIC_InitializeAccumulativeWeights();
	void STATIC_InitializeGameConfig(class ATgGameConfig_BotShop* Config);
	void STATIC_SelectRandomBots(TArray<struct FBotUnit>* BotUnits);
};


// Class TgGame.TgInventory_RandomizedShop
// 0x0118 (0x0378 - 0x0260)
class ATgInventory_RandomizedShop : public AActor
{
public:
	class ATgGameConfig_MultiRounds*                   s_GameConfig;                                             // 0x0260(0x0008)
	struct FInventoryList                              s_Banned;                                                 // 0x0268(0x0010) (NeedCtorLink)
	struct FInventoryList                              s_Physical[0x3];                                          // 0x0278(0x0010) (NeedCtorLink)
	struct FInventoryList                              s_Magical[0x3];                                           // 0x02A8(0x0010) (NeedCtorLink)
	struct FInventoryList                              s_Consumable[0x3];                                        // 0x02D8(0x0010) (NeedCtorLink)
	struct FInventoryList                              s_Relic[0x3];                                             // 0x0308(0x0010) (NeedCtorLink)
	TArray<class UTgInventory_RandomizedShop_Transaction*> s_ShopTransactions;                                       // 0x0338(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             s_CurrentUnderdogs;                                       // 0x0348(0x0010) (NeedCtorLink)
	TArray<float>                                      s_fCurrentChances;                                        // 0x0358(0x0010) (NeedCtorLink)
	float                                              s_fCurrentTotalChance;                                    // 0x0368(0x0004)
	int                                                s_nCurrentBuyer;                                          // 0x036C(0x0004)
	TEnumAsByte<ERandomizedShopItemTier>               s_eCurrentTier;                                           // 0x0370(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0371(0x0003) MISSED OFFSET
	unsigned long                                      s_bPopulated : 1;                                         // 0x0374(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventory_RandomizedShop");
		return ptr;
	}


	TArray<int> STATIC_GetRelicList(TEnumAsByte<ERandomizedShopItemTier> eTier);
	TArray<int> STATIC_GetConsumableList(TEnumAsByte<ERandomizedShopItemTier> eTier);
	TArray<int> STATIC_GetMagicalItemList(TEnumAsByte<ERandomizedShopItemTier> eTier);
	TArray<int> STATIC_GetPhysicalItemList(TEnumAsByte<ERandomizedShopItemTier> eTier);
	TArray<int> STATIC_SelectRandomItems(class ATgPawn* pawnBuyer);
	void UpdateUnderdogList(TArray<class ATgPawn*> pawnUnderdogs);
	void STATIC_PopulateAvailableInventory(class ATgGameConfig_MultiRounds* Config);
};


// Class TgGame.TgInventory_RandomizedShop_Transaction
// 0x0028 (0x0088 - 0x0060)
class UTgInventory_RandomizedShop_Transaction : public UObject
{
public:
	class ATgPawn*                                     m_pawnBuyer;                                              // 0x0060(0x0008) (Const)
	unsigned long                                      m_bIsPhysical : 1;                                        // 0x0068(0x0004) (Const)
	TArray<int>                                        m_nPrevSelectedItems;                                     // 0x006C(0x0010) (NeedCtorLink)
	int                                                m_nPrevSelectedTierCount[0x3];                            // 0x007C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventory_RandomizedShop_Transaction");
		return ptr;
	}

};


// Class TgGame.TgInventoryManager
// 0x04D8 (0x0764 - 0x028C)
class ATgInventoryManager : public AInventoryManager
{
public:
	struct FCourierTransaction                         r_CourierTransaction;                                     // 0x028C(0x0020) (Net)
	int                                                s_CourierUpgradeRetryCount;                               // 0x02AC(0x0004)
	class AActor*                                      s_CourierBackupTimerActor;                                // 0x02B0(0x0008)
	unsigned long                                      r_bTransacting : 1;                                       // 0x02B8(0x0004) (Net)
	unsigned long                                      m_bHasDoneAutoPurchase : 1;                               // 0x02B8(0x0004)
	unsigned long                                      m_ShouldSuppressHitProcs : 1;                             // 0x02B8(0x0004)
	unsigned long                                      m_ShouldSuppressDamageProcs : 1;                          // 0x02B8(0x0004)
	unsigned long                                      m_ShouldSuppressCritProcs : 1;                            // 0x02B8(0x0004)
	unsigned long                                      m_bNeedsInvUpdate : 1;                                    // 0x02B8(0x0004)
	unsigned long                                      s_bPurchasesRestricted : 1;                               // 0x02B8(0x0004)
	unsigned long                                      r_bBlessingLockout : 1;                                   // 0x02B8(0x0004) (Net)
	TArray<struct FInventoryTransaction>               s_InventoryTransactions;                                  // 0x02BC(0x0010) (AlwaysInit, NeedCtorLink)
	struct FInventoryTransaction                       r_ReplicatedTransactions[0x20];                           // 0x02CC(0x001C) (Net)
	int                                                r_nTransactionCount;                                      // 0x064C(0x0004) (Net)
	TArray<struct FItemStatsDetail>                    s_CharStatsTransactions;                                  // 0x0650(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                r_ItemCount;                                              // 0x0660(0x0004) (Net)
	int                                                m_nPreviousDeviceInstanceId;                              // 0x0664(0x0004)
	TArray<struct FAutoPurchaseItem>                   m_bCustomAutoPurchaseList;                                // 0x0668(0x0010) (NeedCtorLink)
	int                                                m_last_role_item_index;                                   // 0x0678(0x0004)
	unsigned char                                      UnknownData00[0x48];                                      // 0x067C(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.m_InventoryMap
	unsigned char                                      UnknownData01[0x48];                                      // 0x06C4(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.s_ReplicateMap
	unsigned char                                      UnknownData02[0x48];                                      // 0x070C(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.s_DeletionMap
	TArray<struct FsInventoryStackItem>                m_InventoryStack;                                         // 0x0754(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryManager");
		return ptr;
	}


	void InstantConsumeDevice(class ATgDevice* Consumable);
	void ServerSetCurrentWeapon(class ATgDevice* NewWeapon);
	void STATIC_ClientSetCurrentWeapon(class ATgDevice* NewWeapon);
	bool STATIC_SetCurrentWeapon(class ATgDevice* DesiredWeapon, bool bMessageFromNetwork, bool bForceFastClear);
	void STATIC_ChangedWeapon(class ATgDevice* DesiredWeapon);
	void ReplicatedEvent(const struct FName& VarName);
	void ServerSetInventoryDirty();
	void ServerTestShowInventory();
	void Destroyed();
	void PostBeginPlay();
	void STATIC_CommitTransaction();
	void BeginTransaction();
	bool WasItemPurchasedInTransaction(int nInventoryId, int* nExistingInventoryId);
	void STATIC_OnCanPurchaseFlagSet(bool bCanPurchase);
	bool STATIC_DoesPassGodEnabledItemCheck(int nItemId);
	bool STATIC_CanCourierPurchaseItems();
	void STATIC_CourierPhaseChanged(TEnumAsByte<ECourierPetPhase> Phase);
	void STATIC_DeliverCourierItem();
	void STATIC_CancelCourierItem();
	void UpdateCourierUI();
	void STATIC_ForwardPawnOnVisiblityVolumeChange();
	void InventoryCleanup();
	void STATIC_TestShowInventory();
	void ApplyAllPassiveItemEffects(bool bRemove);
	void STATIC_RequestInventory();
	void UpdateBroadcastedItems();
	class UTgInventoryObject_Device* STATIC_GetDeviceByEquipPoint(TEnumAsByte<ETG_EQUIP_POINT> ePoint);
	void STATIC_SetInventoryDirty();
	bool IsValid();
	class UTgInventoryObject* STATIC_GetFirstByListener(class UClass* ClassName, bool bOnlyEquipped);
	class UTgInventoryObject* STATIC_GetInventoryByName(const struct FString& sName);
	class UTgInventoryObject* STATIC_GetInventoryByEquipPoint(TEnumAsByte<ETG_EQUIP_POINT> ePoint, int nItemType);
	class UTgInventoryObject* STATIC_GetInventoryById(int nInventoryId);
	class ATgDevice* STATIC_GetDeviceByInstanceId(int nDeviceInstanceId);
	void STATIC_PopDevice(class UTgInventoryObject_Device* pInv, int nEquipPoint);
	void STATIC_PushDevice(class UTgInventoryObject_Device* pInv, int nEquipPoint);
	void STATIC_SwapDevices(class UTgInventoryObject_Device* pInv, int nEquipPoint);
	void STATIC_SwapDeviceEquipPoints(int nEquipPoint1, int nEquipPoint2);
	void STATIC_RemoveDevice(class UTgInventoryObject_Device* pInv);
	class ATgDevice* AddDevice(int nDeviceId, int nEquipPoint, class ATgDevice* parentDevice, bool bWhollyOwnedByParent);
};


// Class TgGame.TgInventoryManager_Adventure
// 0x0000 (0x0764 - 0x0764)
class ATgInventoryManager_Adventure : public ATgInventoryManager
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryManager_Adventure");
		return ptr;
	}

};


// Class TgGame.TgInventoryManager_GameStore
// 0x0000 (0x0764 - 0x0764)
class ATgInventoryManager_GameStore : public ATgInventoryManager
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryManager_GameStore");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject
// 0x0040 (0x00A0 - 0x0060)
class UTgInventoryObject : public UObject
{
public:
	struct FInventoryData                              m_InventoryData;                                          // 0x0060(0x001C)
	int                                                m_nRefData;                                               // 0x007C(0x0004)
	class ATgInventoryManager*                         m_InvManager;                                             // 0x0080(0x0008)
	unsigned long                                      m_bTemporary : 1;                                         // 0x0088(0x0004)
	unsigned long                                      s_bEquippedAsEffectListener : 1;                          // 0x0088(0x0004)
	unsigned long                                      m_bForceUnequipped : 1;                                   // 0x0088(0x0004)
	unsigned long                                      m_bCommittedSell : 1;                                     // 0x0088(0x0004)
	TEnumAsByte<EReplicatedState>                      s_ReplicatedState;                                        // 0x008C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x008D(0x0003) MISSED OFFSET
	struct FPointer                                    m_pAmItem;                                                // 0x0090(0x0008) (Const, Native)
	int                                                c_nNbrAcquired;                                           // 0x0098(0x0004)
	float                                              c_fTimeAcquired;                                          // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject");
		return ptr;
	}


	float STATIC_GetUIBonusAttackDamage(float attackDamage);
	int STATIC_GetInstanceCount();
	void STATIC_SetInstanceCount(int nInstanceCount);
	struct FInventoryData STATIC_GetInventoryData();
	bool IsEquippableType();
	bool IsUsableType();
};


// Class TgGame.TgInventoryObject_Device
// 0x002C (0x00CC - 0x00A0)
class UTgInventoryObject_Device : public UTgInventoryObject
{
public:
	class ATgDevice*                                   s_Device;                                                 // 0x00A0(0x0008)
	int                                                m_nDeviceInstanceId;                                      // 0x00A8(0x0004)
	int                                                c_nNumFindDeviceFails;                                    // 0x00AC(0x0004)
	int                                                m_nStackCount;                                            // 0x00B0(0x0004)
	struct FPointer                                    m_pAmDevice;                                              // 0x00B4(0x0008) (Const, Native)
	TArray<class UTgInventoryObject_Device*>           s_WhollyOwnedChildDevices;                                // 0x00BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Device");
		return ptr;
	}


	void AddStackCount(int nStackCount);
	void STATIC_SetInstanceCount(int nInstanceCount);
};


// Class TgGame.TgInventoryObject_Listen
// 0x0004 (0x00D0 - 0x00CC)
class UTgInventoryObject_Listen : public UTgInventoryObject_Device
{
public:
	unsigned long                                      m_bHearsOwnDevice : 1;                                    // 0x00CC(0x0004)
	unsigned long                                      m_bRemoveAllEffectGroupsOnSell : 1;                       // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AchillesSpear
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_AchillesSpear : public UTgInventoryObject_Listen
{
public:
	int                                                m_nAchillesCategoryCode;                                  // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AchillesSpear");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Ancile_S3
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Ancile_S3 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Ancile_S3");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Animosity
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Animosity : public UTgInventoryObject_Listen
{
public:
	float                                              m_fStructureDamageIncrease;                               // 0x00D0(0x0004) (Const)
	float                                              m_fCharacterDamageIncrease;                               // 0x00D4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Animosity");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AOEOnCreepAssist
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AOEOnCreepAssist : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AOEOnCreepAssist");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AOEOnDamageType
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_AOEOnDamageType : public UTgInventoryObject_Listen
{
public:
	int                                                m_nDamageType;                                            // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AOEOnDamageType");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Damage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Damage : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Damage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_Chance_On_Damage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_Chance_On_Damage : public UTgInventoryObject_Listen_Apply_On_Damage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_Chance_On_Damage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Duel
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Duel : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Duel");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Heal
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Heal : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bHealthOnly : 1;                                        // 0x00D0(0x0004)
	unsigned long                                      m_bOffhandOnly : 1;                                       // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Heal");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LotusCrown
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_LotusCrown : public UTgInventoryObject_Listen_Apply_On_Heal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LotusCrown");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Healed
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Healed : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bHealthOnly : 1;                                        // 0x00D0(0x0004)
	unsigned long                                      m_bFromSelfOnly : 1;                                      // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Healed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_PlayerCount
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_PlayerCount : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_PlayerCount");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_AbilityDamage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Take_AbilityDamage : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Take_AbilityDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_Damage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Take_Damage : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Take_Damage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_Damage_GodsOnly
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Take_Damage_GodsOnly : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Take_Damage_GodsOnly");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_InHandDamage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Take_InHandDamage : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Take_InHandDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_MagDamage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Take_MagDamage : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Take_MagDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_PhysDamage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_Take_PhysDamage : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_Take_PhysDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ApplyEffectPostOtherEffect
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_ApplyEffectPostOtherEffect : public UTgInventoryObject_Listen
{
public:
	int                                                m_nParentEffectID;                                        // 0x00D0(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyEffectPostOtherEffect");
		return ptr;
	}


	void ApplyPostEffect();
};


// Class TgGame.TgInventoryObject_Listen_ApplyPenOffCooldown
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_ApplyPenOffCooldown : public UTgInventoryObject_Listen
{
public:
	float                                              m_fPercentPenetrationToApply;                             // 0x00D0(0x0004) (Const)
	struct FDeviceInstanceTracker                      m_ApplicationDeviceInstance;                              // 0x00D4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ApplyPenOffCooldown");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ArthurianItemBase
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_ArthurianItemBase : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bTriggerOnStopFire : 1;                                 // 0x00D0(0x0004)
	unsigned long                                      m_bTriggerOnCooldown : 1;                                 // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ArthurianItemBase");
		return ptr;
	}


	void TriggerArthurianItem();
};


// Class TgGame.TgInventoryObject_Listen_Arondight
// 0x0014 (0x00E8 - 0x00D4)
class UTgInventoryObject_Listen_Arondight : public UTgInventoryObject_Listen_ArthurianItemBase
{
public:
	unsigned long                                      s_bIsActive : 1;                                          // 0x00D4(0x0004) (Const)
	unsigned long                                      s_bHasAppliedSpeedBuff : 1;                               // 0x00D4(0x0004) (Const)
	TArray<struct FRevealedPawn>                       s_RevealedPawns;                                          // 0x00D8(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Arondight");
		return ptr;
	}


	void TriggerArthurianItem();
};


// Class TgGame.TgInventoryObject_Listen_Failnot
// 0x0004 (0x00D8 - 0x00D4)
class UTgInventoryObject_Listen_Failnot : public UTgInventoryObject_Listen_ArthurianItemBase
{
public:
	unsigned long                                      s_bIsActive : 1;                                          // 0x00D4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Failnot");
		return ptr;
	}


	void TriggerArthurianItem();
};


// Class TgGame.TgInventoryObject_Listen_Pridwen
// 0x0018 (0x00EC - 0x00D4)
class UTgInventoryObject_Listen_Pridwen : public UTgInventoryObject_Listen_ArthurianItemBase
{
public:
	float                                              m_fProtectionsToShieldConversionRate;                     // 0x00D4(0x0004) (Const)
	float                                              m_fShieldToDamageConversionRate;                          // 0x00D8(0x0004) (Const)
	float                                              m_fDamageRadius;                                          // 0x00DC(0x0004) (Const)
	class ATgPawn*                                     m_pawnInstigator;                                         // 0x00E0(0x0008)
	int                                                s_nCurrentShield;                                         // 0x00E8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Pridwen");
		return ptr;
	}


	void TriggerArthurianItem();
};


// Class TgGame.TgInventoryObject_Listen_StaffOfMyrddin
// 0x001C (0x00F0 - 0x00D4)
class UTgInventoryObject_Listen_StaffOfMyrddin : public UTgInventoryObject_Listen_ArthurianItemBase
{
public:
	unsigned long                                      s_bIsActive : 1;                                          // 0x00D4(0x0004) (Const)
	unsigned long                                      s_bResetCooldownOnStopFire : 1;                           // 0x00D4(0x0004) (Const)
	unsigned long                                      s_bProperlyEquipped : 1;                                  // 0x00D4(0x0004)
	struct FAffectedDevice                             s_AffectedDevice;                                         // 0x00D8(0x000C) (Const)
	float                                              s_fReducedCooldown;                                       // 0x00E4(0x0004) (Const)
	float                                              s_fDamageModifier;                                        // 0x00E8(0x0004) (Const)
	float                                              s_fHealModifier;                                          // 0x00EC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StaffOfMyrddin");
		return ptr;
	}


	void TriggerArthurianItem();
};


// Class TgGame.TgInventoryObject_Listen_AuraInCombat
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AuraInCombat : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AuraInCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Benevolence
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Benevolence : public UTgInventoryObject_Listen
{
public:
	float                                              m_fPercToGive;                                            // 0x00D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Benevolence");
		return ptr;
	}


	void UpdateScalingValues();
};


// Class TgGame.TgInventoryObject_Listen_BerserkersShield
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_BerserkersShield : public UTgInventoryObject_Listen
{
public:
	float                                              s_fHealthPctThreashold;                                   // 0x00D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BerserkersShield");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BlindBlade
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_BlindBlade : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BlindBlade");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BookOfDead
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_BookOfDead : public UTgInventoryObject_Listen
{
public:
	float                                              m_NextHealthShieldValue;                                  // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BookOfDead");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BulwarkOfHope
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_BulwarkOfHope : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BulwarkOfHope");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BumbasHammer
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_BumbasHammer : public UTgInventoryObject_Listen
{
public:
	float                                              m_nReduceCooldownTime;                                    // 0x00D0(0x0004) (Const)
	struct FDeviceInstanceTracker                      m_deviceInstanceTracker;                                  // 0x00D4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BumbasHammer");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CollisionProxyPawnListener_Cast
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_CollisionProxyPawnListener_Cast : public UTgInventoryObject_Listen
{
public:
	class ATgCollisionProxy_PawnListener*              m_CPPawnListener;                                         // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CollisionProxyPawnListener_Cast");
		return ptr;
	}


	void UninitializeCollisionProxyListener();
	void InitializeCollisionProxyListener();
	void STATIC_CollisionDeviceOnStopFire(class ATgPawn* Other, class ATgDevice* OtherDevice, bool bWasInterrupted);
};


// Class TgGame.TgInventoryObject_Listen_Combat
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Combat : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Combat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FountainBuff
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_FountainBuff : public UTgInventoryObject_Listen_Combat
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FountainBuff");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CritStacker
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_CritStacker : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CritStacker");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DamageBuff
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_DamageBuff : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DamageBuff");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DamageCap
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_DamageCap : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bDamageTypeOnly : 1;                                    // 0x00D0(0x0004)
	unsigned long                                      m_bGodsOnly : 1;                                          // 0x00D0(0x0004)
	unsigned long                                      m_bOffhandOnly : 1;                                       // 0x00D0(0x0004)
	int                                                m_nDamageType;                                            // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DamageCap");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DeviceCooldown
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_DeviceCooldown : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeviceCooldown");
		return ptr;
	}


	bool AdjustsDeviceCooldown(class ATgDevice* Dev);
};


// Class TgGame.TgInventoryObject_Listen_DeviceTracked
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_DeviceTracked : public UTgInventoryObject_Listen
{
public:
	TArray<struct FDTFireInstanceData>                 m_TrackedFireInstances;                                   // 0x00D0(0x0010) (NeedCtorLink)
	int                                                m_nMaxTrackedFiringInstances;                             // 0x00E0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DeviceTracked");
		return ptr;
	}


	bool IsDeviceInstanceTracked(class ATgDevice* Dev, int nFiringInstance);
	void STATIC_ClearTrackedInstances(int nLength);
	void TrackFiringInstance(class ATgDevice* Dev, int nFiringInstance);
};


// Class TgGame.TgInventoryObject_Listen_BlueBuff
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_BlueBuff : public UTgInventoryObject_Listen_DeviceTracked
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BlueBuff");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Conquest_ManaBuff_S7
// 0x0014 (0x00F8 - 0x00E4)
class UTgInventoryObject_Listen_Conquest_ManaBuff_S7 : public UTgInventoryObject_Listen_BlueBuff
{
public:
	int                                                m_nMP5StackThreshold;                                     // 0x00E4(0x0004) (Const)
	int                                                m_nMaxMP5Stacks;                                          // 0x00E8(0x0004) (Const)
	class ATgPawn*                                     m_pawnOwner;                                              // 0x00EC(0x0008) (Const)
	int                                                m_nCurrentMP5Stacks;                                      // 0x00F4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Conquest_ManaBuff_S7");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DiamondArrow
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_DiamondArrow : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DiamondArrow");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Dominance_S8
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Dominance_S8 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Dominance_S8");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Dont_Die
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_Dont_Die : public UTgInventoryObject_Listen
{
public:
	float                                              m_fLengthOfEffect;                                        // 0x00D0(0x0004)
	float                                              m_fHP5Added;                                              // 0x00D4(0x0004)
	float                                              m_fMP5Added;                                              // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Dont_Die");
		return ptr;
	}


	void STATIC_EffectDone();
};


// Class TgGame.TgInventoryObject_Listen_DynastyPlateHelm
// 0x002C (0x00FC - 0x00D0)
class UTgInventoryObject_Listen_DynastyPlateHelm : public UTgInventoryObject_Listen
{
public:
	TArray<struct FBUFFED_AUTO_INFO>                   s_BuffedAutos;                                            // 0x00D0(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               s_CachedFireMode;                                         // 0x00E0(0x0008)
	float                                              s_fConsumeStackTimer;                                     // 0x00E8(0x0004)
	class ATgPawn*                                     m_pawnInstigator;                                         // 0x00EC(0x0008) (Const)
	float                                              m_fBonusDamagePct;                                        // 0x00F4(0x0004) (Const)
	int                                                m_nMaxStacks;                                             // 0x00F8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DynastyPlateHelm");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_Effect : public UTgInventoryObject_Listen
{
public:
	class UTgEffectGroup*                              s_OwningEffectGroup;                                      // 0x00D0(0x0008)
	class ATgPawn*                                     s_InstigatorPawn;                                         // 0x00D8(0x0008)
	unsigned long                                      m_bEquippedWhileApplied : 1;                              // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect");
		return ptr;
	}


	void STATIC_OnRemovedAsListener();
	void STATIC_OnAppliedAsListener();
};


// Class TgGame.TgInventoryObject_Listen_Ancile_S3_6
// 0x0010 (0x00F4 - 0x00E4)
class UTgInventoryObject_Listen_Ancile_S3_6 : public UTgInventoryObject_Listen_Effect
{
public:
	TArray<struct FCooldownModifierInfo>               s_ModifiedCooldowns;                                      // 0x00E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Ancile_S3_6");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CursedAnkh_S5_Sub
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_CursedAnkh_S5_Sub : public UTgInventoryObject_Listen_Effect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CursedAnkh_S5_Sub");
		return ptr;
	}


	void STATIC_OnRemovedAsListener();
};


// Class TgGame.TgInventoryObject_Listen_DamageTakenConditional
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_DamageTakenConditional : public UTgInventoryObject_Listen_Effect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DamageTakenConditional");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Runeforged_S3_6
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_Runeforged_S3_6 : public UTgInventoryObject_Listen_DamageTakenConditional
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Runeforged_S3_6");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect_AdjustOffhandHealingPerc
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_Effect_AdjustOffhandHealingPerc : public UTgInventoryObject_Listen_Effect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_AdjustOffhandHealingPerc");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect_AgainstBotRank
// 0x0034 (0x0118 - 0x00E4)
class UTgInventoryObject_Listen_Effect_AgainstBotRank : public UTgInventoryObject_Listen_Effect
{
public:
	int                                                nBotRanks[0xD];                                           // 0x00E4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_AgainstBotRank");
		return ptr;
	}


	bool IsValidBotRank(class ATgPawn* BotPawn);
};


// Class TgGame.TgInventoryObject_Listen_Effect_Compassion
// 0x0010 (0x00F4 - 0x00E4)
class UTgInventoryObject_Listen_Effect_Compassion : public UTgInventoryObject_Listen_Effect
{
public:
	class ATgPawn*                                     m_pawnOwner;                                              // 0x00E4(0x0008) (Const)
	float                                              m_fHealthMitigatedPct;                                    // 0x00EC(0x0004) (Const)
	float                                              m_fMaxDamageMitigated;                                    // 0x00F0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_Compassion");
		return ptr;
	}


	void STATIC_OnAppliedAsListener();
};


// Class TgGame.TgInventoryObject_Listen_Effect_ConditionalTarget
// 0x0024 (0x0108 - 0x00E4)
class UTgInventoryObject_Listen_Effect_ConditionalTarget : public UTgInventoryObject_Listen_Effect
{
public:
	TEnumAsByte<ETargetAcceptedType>                   m_eTargetAcceptedType;                                    // 0x00E4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00E5(0x0003) MISSED OFFSET
	TArray<int>                                        m_PhysicalityAcceptedList;                                // 0x00E8(0x0010) (Const, NeedCtorLink)
	TArray<int>                                        m_BotRankAcceptedList;                                    // 0x00F8(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_ConditionalTarget");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect_ConditionalDamageMitigation
// 0x0000 (0x0108 - 0x0108)
class UTgInventoryObject_Listen_Effect_ConditionalDamageMitigation : public UTgInventoryObject_Listen_Effect_ConditionalTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_ConditionalDamageMitigation");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect_StructureDamageMitigation
// 0x0000 (0x0108 - 0x0108)
class UTgInventoryObject_Listen_Effect_StructureDamageMitigation : public UTgInventoryObject_Listen_Effect_ConditionalDamageMitigation
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_StructureDamageMitigation");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect_HerosAxe
// 0x0014 (0x00F8 - 0x00E4)
class UTgInventoryObject_Listen_Effect_HerosAxe : public UTgInventoryObject_Listen_Effect
{
public:
	int                                                m_nHeroesAxeDeviceId;                                     // 0x00E4(0x0004) (Const)
	class ATgPawn*                                     s_pawnOwner;                                              // 0x00E8(0x0008) (Const)
	class ATgDevice*                                   s_devHerosAxe;                                            // 0x00F0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_HerosAxe");
		return ptr;
	}


	void STATIC_OnAppliedAsListener();
};


// Class TgGame.TgInventoryObject_Listen_Effect_ProcOnDamaged
// 0x0010 (0x00F4 - 0x00E4)
class UTgInventoryObject_Listen_Effect_ProcOnDamaged : public UTgInventoryObject_Listen_Effect
{
public:
	float                                              s_fHealthPercent;                                         // 0x00E4(0x0004)
	float                                              s_fLastProcTime;                                          // 0x00E8(0x0004)
	float                                              s_fProcFreq;                                              // 0x00EC(0x0004)
	unsigned long                                      bInitialized : 1;                                         // 0x00F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_ProcOnDamaged");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect_RemoveOnCombat
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_Effect_RemoveOnCombat : public UTgInventoryObject_Listen_Effect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_RemoveOnCombat");
		return ptr;
	}


	void STATIC_OnRemovedAsListener();
	void STATIC_OnAppliedAsListener();
};


// Class TgGame.TgInventoryObject_Listen_Effect_Shockwave_OnHitHigherLevel
// 0x0010 (0x00F4 - 0x00E4)
class UTgInventoryObject_Listen_Effect_Shockwave_OnHitHigherLevel : public UTgInventoryObject_Listen_Effect
{
public:
	TArray<struct FTGHHL_HITINFO>                      s_TrackedTriggers;                                        // 0x00E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_Shockwave_OnHitHigherLevel");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect_TaintedAmulet
// 0x0004 (0x00E8 - 0x00E4)
class UTgInventoryObject_Listen_Effect_TaintedAmulet : public UTgInventoryObject_Listen_Effect
{
public:
	float                                              m_fHealStealModifier;                                     // 0x00E4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_TaintedAmulet");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PotionOfMagMight
// 0x0020 (0x0104 - 0x00E4)
class UTgInventoryObject_Listen_PotionOfMagMight : public UTgInventoryObject_Listen_Effect
{
public:
	TArray<struct FTGHHL_HITINFO>                      s_TrackedTriggers;                                        // 0x00E4(0x0010) (NeedCtorLink)
	TArray<struct FDeviceToReduce>                     CooldownDevices;                                          // 0x00F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PotionOfMagMight");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PotionOfPhysMight
// 0x0010 (0x00F4 - 0x00E4)
class UTgInventoryObject_Listen_PotionOfPhysMight : public UTgInventoryObject_Listen_Effect
{
public:
	TArray<struct FTGHHL_HITINFO>                      s_TrackedTriggers;                                        // 0x00E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PotionOfPhysMight");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EffectGroupTrigger
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_EffectGroupTrigger : public UTgInventoryObject_Listen
{
public:
	TArray<int>                                        m_nTriggerCategoryIds;                                    // 0x00D0(0x0010) (Const, NeedCtorLink)
	unsigned long                                      m_bTriggerActive : 1;                                     // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EffectGroupTrigger");
		return ptr;
	}


	void TriggerRemoved(bool bRemovedEarly);
	void TriggerApplied();
};


// Class TgGame.TgInventoryObject_Listen_EvolvedHideOfTheUrchin_S5
// 0x0020 (0x00F0 - 0x00D0)
class UTgInventoryObject_Listen_EvolvedHideOfTheUrchin_S5 : public UTgInventoryObject_Listen
{
public:
	float                                              m_fShieldTimer;                                           // 0x00D0(0x0004)
	float                                              m_fMaxShieldTime;                                         // 0x00D4(0x0004)
	float                                              m_fCurrentShieldAmount;                                   // 0x00D8(0x0004)
	float                                              m_fMaxShieldAmount;                                       // 0x00DC(0x0004)
	float                                              m_fShieldGainAmount;                                      // 0x00E0(0x0004)
	unsigned long                                      m_bHasMaxShield : 1;                                      // 0x00E4(0x0004)
	unsigned long                                      m_bOwnerWasDead : 1;                                      // 0x00E4(0x0004)
	int                                                m_nOwnerLevel;                                            // 0x00E8(0x0004)
	int                                                m_nShieldEffectID;                                        // 0x00EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EvolvedHideOfTheUrchin_S5");
		return ptr;
	}


	void AttemptTimerStart();
	void STATIC_CalculateShieldValues();
	void STATIC_CheckCurrentShieldAmount(class AActor* TargetActor, bool bRemoveGroup);
	void ApplyShield();
};


// Class TgGame.TgInventoryObject_Listen_EyeOfTheJungle
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_EyeOfTheJungle : public UTgInventoryObject_Listen
{
public:
	float                                              m_fDamageIncrease;                                        // 0x00D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EyeOfTheJungle");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Genji
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Genji : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Genji");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GildedArrow
// 0x0024 (0x00F4 - 0x00D0)
class UTgInventoryObject_Listen_GildedArrow : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bTargetFound : 1;                                       // 0x00D0(0x0004)
	TArray<class ATgPawn*>                             m_minionHealthList;                                       // 0x00D4(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_appliedMarkList;                                        // 0x00E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GildedArrow");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GlobalOutOfCombat
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_GlobalOutOfCombat : public UTgInventoryObject_Listen
{
public:
	float                                              m_fTimeRemoved;                                           // 0x00D0(0x0004) (Const)
	float                                              m_fAntiHealPerc;                                          // 0x00D4(0x0004) (Const)
	struct FName                                       m_nmApplyAntiHeal;                                        // 0x00D8(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GlobalOutOfCombat");
		return ptr;
	}


	void STATIC_RemoveAntiHeal();
	void ApplyAntiHeal();
	void STATIC_ResetTimer();
};


// Class TgGame.TgInventoryObject_Listen_HandOfTheGods
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_HandOfTheGods : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_ReduceCooldown : 1;                                     // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HandOfTheGods");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitByOffhand
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_HitByOffhand : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bProcOncePerCast : 1;                                   // 0x00D0(0x0004) (Const)
	TArray<struct FCastTrackingHitInfo>                m_CastTracking;                                           // 0x00D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitByOffhand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HitByOffhandOncePerCast
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_HitByOffhandOncePerCast : public UTgInventoryObject_Listen_HitByOffhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HitByOffhandOncePerCast");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InfusedSigil
// 0x000C (0x00F0 - 0x00E4)
class UTgInventoryObject_Listen_InfusedSigil : public UTgInventoryObject_Listen_HitByOffhandOncePerCast
{
public:
	float                                              m_fStacksToExplode;                                       // 0x00E4(0x0004) (Const)
	class ATgPawn*                                     m_pawnOwner;                                              // 0x00E8(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InfusedSigil");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HydraMark
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_HydraMark : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HydraMark");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InAndOutOfCombat
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InAndOutOfCombat : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InAndOutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_Aoe
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_Aoe : public UTgInventoryObject_Listen_InHand
{
public:
	TArray<class ATgPawn*>                             s_HitPawns;                                               // 0x00D0(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_Aoe");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_CategoryCheck
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_CategoryCheck : public UTgInventoryObject_Listen_InHand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_CategoryCheck");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_ChanceOnHit
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_InHand_ChanceOnHit : public UTgInventoryObject_Listen_InHand
{
public:
	float                                              m_fPercentChance;                                         // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_ChanceOnHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_HitXTimes
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_InHand_HitXTimes : public UTgInventoryObject_Listen_InHand
{
public:
	int                                                m_nTimesToProc;                                           // 0x00D0(0x0004)
	int                                                m_nCurrentHits;                                           // 0x00D4(0x0004)
	class ATgDevice*                                   m_LastHitDevice;                                          // 0x00D8(0x0008)
	int                                                m_nLastHitFiringInstance;                                 // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_HitXTimes");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_TargetSlowed
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_TargetSlowed : public UTgInventoryObject_Listen_InHand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_TargetSlowed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_TargetSlowRootCripple
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_TargetSlowRootCripple : public UTgInventoryObject_Listen_InHand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_TargetSlowRootCripple");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Manikin
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Manikin : public UTgInventoryObject_Listen_InHand
{
public:
	float                                              m_nDamageJungle;                                          // 0x00D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Manikin");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_QinsBlades2
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_QinsBlades2 : public UTgInventoryObject_Listen_InHand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_QinsBlades2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_Crit
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_Crit : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_Crit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_Crit_Self
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_Crit_Self : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_Crit_Self");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MaliceS5
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_MaliceS5 : public UTgInventoryObject_Listen_InHand_Crit_Self
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MaliceS5");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_Kill
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_Kill : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_Kill");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_Melee_Ranged
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_Melee_Ranged : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_Melee_Ranged");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_MeleeOrRanged_CanSelfProc
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_MeleeOrRanged_CanSelfProc : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_MeleeOrRanged_CanSelfProc");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_Nth_Hit
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_Nth_Hit : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_Nth_Hit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_SuccessfulHit
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_SuccessfulHit : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_SuccessfulHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_OncePerCast
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_OncePerCast : public UTgInventoryObject_Listen_InHand_SuccessfulHit
{
public:
	TArray<struct FDEV_INST_INFO>                      s_AlreadyHit;                                             // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_OncePerCast");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_OncePerCast_Humanoids
// 0x0000 (0x00E0 - 0x00E0)
class UTgInventoryObject_Listen_InHand_OncePerCast_Humanoids : public UTgInventoryObject_Listen_InHand_OncePerCast
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_OncePerCast_Humanoids");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_SuccessfulHitOnGod
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_SuccessfulHitOnGod : public UTgInventoryObject_Listen_InHand_SuccessfulHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_SuccessfulHitOnGod");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_SuccessfulHitOnEnemyGod
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_SuccessfulHitOnEnemyGod : public UTgInventoryObject_Listen_InHand_SuccessfulHitOnGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_SuccessfulHitOnEnemyGod");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TankStarter
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_TankStarter : public UTgInventoryObject_Listen_InHand_SuccessfulHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TankStarter");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_WarriorsTabi
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_WarriorsTabi : public UTgInventoryObject_Listen_InHand_SuccessfulHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_WarriorsTabi");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InHand_Towers
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InHand_Towers : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InHand_Towers");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InhandMitigation
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_InhandMitigation : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InhandMitigation");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_JungleStarter
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_JungleStarter : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_JungleStarter");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_JungleStarter_3
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_JungleStarter_3 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_JungleStarter_3");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Apply_On_HitJungle
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Apply_On_HitJungle : public UTgInventoryObject_Listen_JungleStarter_3
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Apply_On_HitJungle");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_JungleStarter_S4
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_JungleStarter_S4 : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bAssistsAllowed : 1;                                    // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_JungleStarter_S4");
		return ptr;
	}


	void STATIC_HandleJungleCampDied(class AActor* Victim, bool bAssist, int* xpGain, int* goldGain);
};


// Class TgGame.TgInventoryObject_Listen_Kaldr_Dev2
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Kaldr_Dev2 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Kaldr_Dev2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_LimitDamageReflect
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_LimitDamageReflect : public UTgInventoryObject_Listen
{
public:
	float                                              s_fCurrentReflectVal;                                     // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LimitDamageReflect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Magi_Blessing
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Magi_Blessing : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Magi_Blessing");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MissingPoolStack
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_MissingPoolStack : public UTgInventoryObject_Listen
{
public:
	int                                                m_CurrentStacks;                                          // 0x00D0(0x0004)
	int                                                m_MaxStacks;                                              // 0x00D4(0x0004)
	float                                              m_fPercPerStack;                                          // 0x00D8(0x0004)
	int                                                m_nPoolType;                                              // 0x00DC(0x0004)
	unsigned long                                      m_bInitializedValues : 1;                                 // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MissingPoolStack");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MitigateOverDamage
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_MitigateOverDamage : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bDamageTypeOnly : 1;                                    // 0x00D0(0x0004)
	unsigned long                                      m_bGodsOnly : 1;                                          // 0x00D0(0x0004)
	unsigned long                                      m_bOffhandOnly : 1;                                       // 0x00D0(0x0004)
	int                                                m_nDamageType;                                            // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MitigateOverDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ModifyAdventure
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_ModifyAdventure : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      s_bModApplied : 1;                                        // 0x00D0(0x0004)
	int                                                s_nPlayerItemApplied;                                     // 0x00D4(0x0004)
	int                                                s_nBotItemApplied;                                        // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ModifyAdventure");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NearbyCountOnDamage
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_NearbyCountOnDamage : public UTgInventoryObject_Listen
{
public:
	int                                                m_nNearbyRequired;                                        // 0x00D0(0x0004)
	unsigned long                                      m_bIncludeDamaged : 1;                                    // 0x00D4(0x0004)
	unsigned long                                      m_bIncludeSelf : 1;                                       // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NearbyCountOnDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NextAbility
// 0x0009 (0x00D9 - 0x00D0)
class UTgInventoryObject_Listen_NextAbility : public UTgInventoryObject_Listen
{
public:
	class UTgMarkComponent*                            m_MarkComponent;                                          // 0x00D0(0x0008) (ExportObject, Transient, Component, EditInline)
	unsigned char                                      m_nNextAbilityItemCooldown;                               // 0x00D8(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NextAbility");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NextAuto
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Listen_NextAuto : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bConsumeOnMiss : 1;                                     // 0x00D0(0x0004) (Const)
	unsigned long                                      m_bReadyToApply : 1;                                      // 0x00D0(0x0004)
	int                                                m_nMarkSituationalType;                                   // 0x00D4(0x0004) (Const)
	int                                                m_nMarkCategoryCode;                                      // 0x00D8(0x0004) (Const)
	struct FDeviceInstanceTracker                      m_trackerDeviceInstance;                                  // 0x00DC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NextAuto");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NextAuto_AdjustDamage
// 0x0004 (0x00EC - 0x00E8)
class UTgInventoryObject_Listen_NextAuto_AdjustDamage : public UTgInventoryObject_Listen_NextAuto
{
public:
	float                                              m_fNextAutoDamageModifier;                                // 0x00E8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NextAuto_AdjustDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HydrasLament
// 0x0008 (0x00F4 - 0x00EC)
class UTgInventoryObject_Listen_HydrasLament : public UTgInventoryObject_Listen_NextAuto_AdjustDamage
{
public:
	int                                                m_CurrentStacks;                                          // 0x00EC(0x0004)
	int                                                m_MaxStacks;                                              // 0x00F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HydrasLament");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NextAuto_OnDamaged
// 0x0000 (0x00E8 - 0x00E8)
class UTgInventoryObject_Listen_NextAuto_OnDamaged : public UTgInventoryObject_Listen_NextAuto
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NextAuto_OnDamaged");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OffHand
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_OffHand : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bProcOncePerCast : 1;                                   // 0x00D0(0x0004) (Const)
	TArray<struct FCastTrackingInfo>                   m_CastTracking;                                           // 0x00D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OffHand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BluestonePendant
// 0x0010 (0x00F4 - 0x00E4)
class UTgInventoryObject_Listen_BluestonePendant : public UTgInventoryObject_Listen_OffHand
{
public:
	TArray<int>                                        m_DeviceExceptionList;                                    // 0x00E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BluestonePendant");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_CorruptedBluestone
// 0x0010 (0x0104 - 0x00F4)
class UTgInventoryObject_Listen_CorruptedBluestone : public UTgInventoryObject_Listen_BluestonePendant
{
public:
	TArray<class ATgPawn*>                             m_AppliedList;                                            // 0x00F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CorruptedBluestone");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OffHand_IncrementalDamage
// 0x0018 (0x00FC - 0x00E4)
class UTgInventoryObject_Listen_OffHand_IncrementalDamage : public UTgInventoryObject_Listen_OffHand
{
public:
	TArray<struct FIncrementalDamageTracker>           s_IncrementalDamageTracker;                               // 0x00E4(0x0010) (NeedCtorLink)
	float                                              s_fPctIncreasedDamagePerStack;                            // 0x00F4(0x0004) (Const)
	int                                                s_nMaxStacks;                                             // 0x00F8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OffHand_IncrementalDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Offhand_TargetSlowRootCripple
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_Offhand_TargetSlowRootCripple : public UTgInventoryObject_Listen_OffHand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Offhand_TargetSlowRootCripple");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OffhandOncePerCast
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_OffhandOncePerCast : public UTgInventoryObject_Listen_OffHand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OffhandOncePerCast");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ConduitGem
// 0x0034 (0x0118 - 0x00E4)
class UTgInventoryObject_Listen_ConduitGem : public UTgInventoryObject_Listen_OffhandOncePerCast
{
public:
	TArray<struct FStacksTrackingInfo>                 m_StackTracking;                                          // 0x00E4(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_pawnOwner;                                              // 0x00F4(0x0008) (Const)
	float                                              m_fInterval;                                              // 0x00FC(0x0004) (Const)
	float                                              m_fDamagePerStack;                                        // 0x0100(0x0004) (Const)
	float                                              m_bIsMagicalDamage;                                       // 0x0104(0x0004) (Const)
	struct FName                                       m_nmActivateStack;                                        // 0x0108(0x0008) (Const)
	struct FName                                       m_nmActivateInterval;                                     // 0x0110(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ConduitGem");
		return ptr;
	}


	void ActivateStack();
	void ActivateInterval();
};


// Class TgGame.TgInventoryObject_Listen_EtherealStaff
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_EtherealStaff : public UTgInventoryObject_Listen_OffhandOncePerCast
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EtherealStaff");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HeartSeeker_S6
// 0x0018 (0x00FC - 0x00E4)
class UTgInventoryObject_Listen_HeartSeeker_S6 : public UTgInventoryObject_Listen_OffhandOncePerCast
{
public:
	float                                              m_fDamageReductionPercent;                                // 0x00E4(0x0004) (Const)
	float                                              m_fMaxTrackTime;                                          // 0x00E8(0x0004) (Const)
	TArray<struct FHeartSeekerHitTracker>              m_trackers;                                               // 0x00EC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HeartSeeker_S6");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OffHandOncePerCast_GodsOnly
// 0x0010 (0x00F4 - 0x00E4)
class UTgInventoryObject_Listen_OffHandOncePerCast_GodsOnly : public UTgInventoryObject_Listen_OffhandOncePerCast
{
public:
	TArray<int>                                        m_DeviceExceptionList;                                    // 0x00E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OffHandOncePerCast_GodsOnly");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GladiatorsShield
// 0x0024 (0x0118 - 0x00F4)
class UTgInventoryObject_Listen_GladiatorsShield : public UTgInventoryObject_Listen_OffHandOncePerCast_GodsOnly
{
public:
	float                                              m_fPawnBasePhysicalProtection;                            // 0x00F4(0x0004) (Const)
	float                                              m_fPawnBaseMagicalProtection;                             // 0x00F8(0x0004) (Const)
	float                                              m_fPawnLevelUpPhysicalProtection;                         // 0x00FC(0x0004) (Const)
	float                                              m_fPawnLevelUpMagicalProtection;                          // 0x0100(0x0004) (Const)
	float                                              m_fHealthPctThreashold;                                   // 0x0104(0x0004) (Const)
	float                                              m_fProtectionPctToAdd;                                    // 0x0108(0x0004) (Const)
	class ATgPawn*                                     m_pawnOwner;                                              // 0x010C(0x0008)
	int                                                m_damageType;                                             // 0x0114(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GladiatorsShield");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_InhandOrOffHandOncePerCast_GodsOnly
// 0x0010 (0x0104 - 0x00F4)
class UTgInventoryObject_Listen_InhandOrOffHandOncePerCast_GodsOnly : public UTgInventoryObject_Listen_OffHandOncePerCast_GodsOnly
{
public:
	TArray<struct FDEV_INST_INFO>                      s_AlreadyHit;                                             // 0x00F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_InhandOrOffHandOncePerCast_GodsOnly");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OffhandOnceTotalPerCast
// 0x0000 (0x00F4 - 0x00F4)
class UTgInventoryObject_Listen_OffhandOnceTotalPerCast : public UTgInventoryObject_Listen_OffHandOncePerCast_GodsOnly
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OffhandOnceTotalPerCast");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ShamanRingAchieved
// 0x0010 (0x00F4 - 0x00E4)
class UTgInventoryObject_Listen_ShamanRingAchieved : public UTgInventoryObject_Listen_OffhandOncePerCast
{
public:
	TArray<int>                                        s_ExceptionsList;                                         // 0x00E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ShamanRingAchieved");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SoulReaverS6
// 0x001C (0x0100 - 0x00E4)
class UTgInventoryObject_Listen_SoulReaverS6 : public UTgInventoryObject_Listen_OffhandOncePerCast
{
public:
	TArray<struct FSRPrevHitInfo>                      s_PrevHits;                                               // 0x00E4(0x0010) (NeedCtorLink)
	float                                              s_fDecayDuration;                                         // 0x00F4(0x0004)
	int                                                s_nMaxStacks;                                             // 0x00F8(0x0004)
	float                                              s_fStackDecay;                                            // 0x00FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SoulReaverS6");
		return ptr;
	}


	int STATIC_GetStackCount(class ATgPawn* TargetPawn);
	void STATIC_PurgePrevHits();
	void TrackHitTarget(class ATgPawn* HitTarget);
};


// Class TgGame.TgInventoryObject_Listen_VampiricShroud_S4
// 0x0020 (0x0104 - 0x00E4)
class UTgInventoryObject_Listen_VampiricShroud_S4 : public UTgInventoryObject_Listen_OffhandOncePerCast
{
public:
	TArray<int>                                        s_ExceptionsList;                                         // 0x00E4(0x0010) (NeedCtorLink)
	TArray<int>                                        s_DeployableExceptions;                                   // 0x00F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_VampiricShroud_S4");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OffHand_Cast
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OffHand_Cast : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OffHand_Cast");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GemOfFocus
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_GemOfFocus : public UTgInventoryObject_Listen_OffHand_Cast
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GemOfFocus");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OffHand_SuccessfulHit
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OffHand_SuccessfulHit : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OffHand_SuccessfulHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BootsOfTheMagi
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_BootsOfTheMagi : public UTgInventoryObject_Listen_OffHand_SuccessfulHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BootsOfTheMagi");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OffHand_SuccessfulHitOnGod
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OffHand_SuccessfulHitOnGod : public UTgInventoryObject_Listen_OffHand_SuccessfulHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OffHand_SuccessfulHitOnGod");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_On_Spell_Shield
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_On_Spell_Shield : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_On_Spell_Shield");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnCrit
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OnCrit : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnCrit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnDealtDamage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OnDealtDamage : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnDealtDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TaintedAmulet
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_TaintedAmulet : public UTgInventoryObject_Listen_OnDealtDamage
{
public:
	class ATgPawn*                                     m_pawnOwner;                                              // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TaintedAmulet");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnEffectCategoryRemoved
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_OnEffectCategoryRemoved : public UTgInventoryObject_Listen
{
public:
	TArray<int>                                        m_nEffectGroupCategoryCodes;                              // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnEffectCategoryRemoved");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnExitStore
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_OnExitStore : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bIsInBase : 1;                                          // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnExitStore");
		return ptr;
	}


	bool OnEnterStore();
	bool OnExitStore();
};


// Class TgGame.TgInventoryObject_Listen_OnHit_or_HitBy
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_OnHit_or_HitBy : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bProcOncePerCast : 1;                                   // 0x00D0(0x0004) (Const)
	unsigned long                                      m_bProcOncePerTick : 1;                                   // 0x00D0(0x0004) (Const)
	unsigned long                                      m_bHitAppliedThisTick : 1;                                // 0x00D0(0x0004)
	TArray<struct FDEV_INST_INFO>                      s_AlreadyHit;                                             // 0x00D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnHit_or_HitBy");
		return ptr;
	}


	void ToggleSupressProcs(bool bSupressProcs);
};


// Class TgGame.TgInventoryObject_Listen_OnLeaveFountain
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OnLeaveFountain : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnLeaveFountain");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnLifestealAgainst
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OnLifestealAgainst : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnLifestealAgainst");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnRelicFire
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OnRelicFire : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnRelicFire");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnSuccessfulDodge
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OnSuccessfulDodge : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnSuccessfulDodge");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OutOfCombat
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OutOfCombat : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ManikinHiddenBlade
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_ManikinHiddenBlade : public UTgInventoryObject_Listen_OutOfCombat
{
public:
	unsigned long                                      s_bInitiatedLastCombat : 1;                               // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ManikinHiddenBlade");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RewardBoots
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_RewardBoots : public UTgInventoryObject_Listen_OutOfCombat
{
public:
	TArray<struct FRewardHitInfo>                      m_RewardTrackedHit;                                       // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RewardBoots");
		return ptr;
	}


	void STATIC_GiveOwnerRewards();
	void UpdateTracking(const struct FImpactInfo& Impact, class ATgDevice* Dev);
	bool STATIC_ShouldRecordDevice(class ATgDevice* Dev);
	bool IsValidHit(const struct FImpactInfo& Impact);
};


// Class TgGame.TgInventoryObject_Listen_OutOfJungle
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_OutOfJungle : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OutOfJungle");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PocketWatch
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_PocketWatch : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_HasStarted : 1;                                         // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PocketWatch");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PowerScaleAgainstLowHealth
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_PowerScaleAgainstLowHealth : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PowerScaleAgainstLowHealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_PowerScalePCTAgainstLowHealth
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_PowerScalePCTAgainstLowHealth : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PowerScalePCTAgainstLowHealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RodOfTahuti_S5
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_RodOfTahuti_S5 : public UTgInventoryObject_Listen_PowerScalePCTAgainstLowHealth
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RodOfTahuti_S5");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Proc_AboveBelow_ManaPCT
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Proc_AboveBelow_ManaPCT : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Proc_AboveBelow_ManaPCT");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Proc_At_Health
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Proc_At_Health : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Proc_At_Health");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Proc_At_HealthPCT
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Proc_At_HealthPCT : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Proc_At_HealthPCT");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BookOfDead_S5
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_BookOfDead_S5 : public UTgInventoryObject_Listen_Proc_At_HealthPCT
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BookOfDead_S5");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Proc_On_Kill
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Proc_On_Kill : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Proc_On_Kill");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Proc_On_Assist
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Proc_On_Assist : public UTgInventoryObject_Listen_Proc_On_Kill
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Proc_On_Assist");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SpeedBuff
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_SpeedBuff : public UTgInventoryObject_Listen_Proc_On_Assist
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SpeedBuff");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ProtectorOfTheJungle
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_ProtectorOfTheJungle : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bInJungle : 1;                                          // 0x00D0(0x0004)
	class ATgPawn*                                     m_pawnOwner;                                              // 0x00D4(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ProtectorOfTheJungle");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RacerDriftBoost
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_RacerDriftBoost : public UTgInventoryObject_Listen
{
public:
	float                                              m_Timer;                                                  // 0x00D0(0x0004)
	unsigned long                                      m_AppliedDriftReadyFx : 1;                                // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RacerDriftBoost");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RangeDamageAdjust
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_RangeDamageAdjust : public UTgInventoryObject_Listen
{
public:
	float                                              m_fCachedRangeMultipler;                                  // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RangeDamageAdjust");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Reflect
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Reflect : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Reflect");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RelicCooldown
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_RelicCooldown : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RelicCooldown");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RelicCooldown_Flat
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_RelicCooldown_Flat : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RelicCooldown_Flat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ReliquaryBlade
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ReliquaryBlade : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ReliquaryBlade");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RemoveTicketsOnDeath
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_RemoveTicketsOnDeath : public UTgInventoryObject_Listen
{
public:
	class ATgPawn*                                     m_LastDamaged;                                            // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RemoveTicketsOnDeath");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RingOfHecate
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_RingOfHecate : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RingOfHecate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RuneforgedHammer
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_RuneforgedHammer : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RuneforgedHammer");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_S8_JungleSeer
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_S8_JungleSeer : public UTgInventoryObject_Listen
{
public:
	float                                              s_fJungleDamageIncreasePercent;                           // 0x00D0(0x0004) (Const)
	class ATgPawn_Character*                           s_characterOwner;                                         // 0x00D4(0x0008) (Const)
	float                                              s_fWardRevealTime;                                        // 0x00DC(0x0004) (Const)
	float                                              s_fWardRevealRange;                                       // 0x00E0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_S8_JungleSeer");
		return ptr;
	}


	void STATIC_DeactivateWardReveal();
	void ActivateWardReveal();
	bool STATIC_CanActivateWardReveal(class ATgPawn* pawnKilled);
};


// Class TgGame.TgInventoryObject_Listen_SacrificialShroud
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_SacrificialShroud : public UTgInventoryObject_Listen
{
public:
	float                                              m_fPercHealthLost;                                        // 0x00D0(0x0004) (Const)
	float                                              m_fDamagePerc;                                            // 0x00D4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SacrificialShroud");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ScalingPenAgainstProts
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ScalingPenAgainstProts : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ScalingPenAgainstProts");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SentinelsGift
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_SentinelsGift : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_SentinelsGift*                     s_devCached;                                              // 0x00D0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SentinelsGift");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ShieldOverTime
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Listen_ShieldOverTime : public UTgInventoryObject_Listen
{
public:
	float                                              m_fShieldTimer;                                           // 0x00D0(0x0004)
	float                                              m_fMaxShieldTime;                                         // 0x00D4(0x0004)
	float                                              m_fCurrentShieldAmount;                                   // 0x00D8(0x0004)
	float                                              m_fMaxShieldAmount;                                       // 0x00DC(0x0004)
	float                                              m_fShieldGainAmount;                                      // 0x00E0(0x0004)
	unsigned long                                      m_bHasMaxShield : 1;                                      // 0x00E4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ShieldOverTime");
		return ptr;
	}


	float STATIC_GetMaxShieldTimer();
	float STATIC_GetMaxShieldValue();
	float STATIC_GetShieldTimer();
	float STATIC_GetShieldGainValue();
	void STATIC_RemoveShield();
	void ClearTimer();
	void AttemptTimerStart();
	void STATIC_CalculateShieldValues();
	void STATIC_CheckCurrentShieldAmount(class AActor* TargetActor, bool bRemoveGroup);
	void ApplyShield();
};


// Class TgGame.TgInventoryObject_Listen_ShockwaveOnAbilityDamage
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ShockwaveOnAbilityDamage : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ShockwaveOnAbilityDamage");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ShockwaveOnDamagePerc
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ShockwaveOnDamagePerc : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ShockwaveOnDamagePerc");
		return ptr;
	}


	void TriggerShockwave();
	void STATIC_StartShockwaveWarmUp();
};


// Class TgGame.TgInventoryObject_Listen_Slowed
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Slowed : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Slowed");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SoulStone
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_SoulStone : public UTgInventoryObject_Listen
{
public:
	class ATgDevice*                                   m_TrackedDevice;                                          // 0x00D0(0x0008)
	int                                                m_nTrackedFireInstance;                                   // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SoulStone");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SpartanFlag
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_SpartanFlag : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SpartanFlag");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Stack
// 0x0050 (0x0120 - 0x00D0)
class UTgInventoryObject_Listen_Stack : public UTgInventoryObject_Listen
{
public:
	struct FPointer                                    VfTable_ITgInventoryStacking;                             // 0x00D0(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EDevAcceptedType>                      m_eDevAcceptedStackType;                                  // 0x00D8(0x0001)
	TEnumAsByte<EDevAcceptedType>                      m_eDevAcceptedTriggerType;                                // 0x00D9(0x0001)
	TEnumAsByte<ETargetAcceptedType>                   m_eTargetAcceptedStackType;                               // 0x00DA(0x0001)
	TEnumAsByte<ETargetAcceptedType>                   m_eTargetAcceptedTriggerType;                             // 0x00DB(0x0001)
	TArray<int>                                        m_PhysicalityAcceptedStackList;                           // 0x00DC(0x0010) (Const, NeedCtorLink)
	TArray<int>                                        m_PhysicalityAcceptedTriggerList;                         // 0x00EC(0x0010) (Const, NeedCtorLink)
	TArray<int>                                        m_BotRankAcceptedStackList;                               // 0x00FC(0x0010) (Const, NeedCtorLink)
	TArray<int>                                        m_BotRankAcceptedTriggerList;                             // 0x010C(0x0010) (Const, NeedCtorLink)
	unsigned long                                      m_bMustBeCritStack : 1;                                   // 0x011C(0x0004)
	unsigned long                                      m_bMustBeCritTrigger : 1;                                 // 0x011C(0x0004)
	unsigned long                                      m_bUseExtraChecksStack : 1;                               // 0x011C(0x0004)
	unsigned long                                      m_bUseExtraChecksTrigger : 1;                             // 0x011C(0x0004)
	unsigned long                                      m_bStacksAreTransient : 1;                                // 0x011C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Stack");
		return ptr;
	}


	int STATIC_GetCurrentStacks();
	void STATIC_RemoveStackCount(int nStackCount);
	void AddStackCount(int nStackCount);
};


// Class TgGame.TgInventoryObject_Listen_AchieveItem
// 0x0008 (0x0128 - 0x0120)
class UTgInventoryObject_Listen_AchieveItem : public UTgInventoryObject_Listen_Stack
{
public:
	int                                                m_nAchieveItemId;                                         // 0x0120(0x0004)
	unsigned long                                      m_bAchieveItemStartsOnCooldown : 1;                       // 0x0124(0x0004) (Const)
	unsigned long                                      m_bIsEvolvingItem : 1;                                    // 0x0124(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AchieveItem");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AchieveOnMitigate
// 0x0004 (0x012C - 0x0128)
class UTgInventoryObject_Listen_AchieveOnMitigate : public UTgInventoryObject_Listen_AchieveItem
{
public:
	float                                              s_fMitigatedCurrent;                                      // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AchieveOnMitigate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AssassinsBlessing
// 0x0000 (0x0128 - 0x0128)
class UTgInventoryObject_Listen_AssassinsBlessing : public UTgInventoryObject_Listen_AchieveItem
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AssassinsBlessing");
		return ptr;
	}


	void STATIC_HandleMinionAssist(class AActor* Victim, bool bAssist, int* xpGain, int* goldGain);
	void ApplyKillAssistStacks(class ATgPawn* VictimPawn);
};


// Class TgGame.TgInventoryObject_Listen_BumbasDagger
// 0x0004 (0x012C - 0x0128)
class UTgInventoryObject_Listen_BumbasDagger : public UTgInventoryObject_Listen_AssassinsBlessing
{
public:
	float                                              m_fBonusPercent;                                          // 0x0128(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BumbasDagger");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BumbasSpear
// 0x0000 (0x012C - 0x012C)
class UTgInventoryObject_Listen_BumbasSpear : public UTgInventoryObject_Listen_BumbasDagger
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BumbasSpear");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DamageOrHeal
// 0x0018 (0x0140 - 0x0128)
class UTgInventoryObject_Listen_DamageOrHeal : public UTgInventoryObject_Listen_AchieveItem
{
public:
	TArray<struct FDOHFireInstanceData>                m_TrackedFireInstances;                                   // 0x0128(0x0010) (NeedCtorLink)
	int                                                m_nMaxTrackedFiringInstances;                             // 0x0138(0x0004) (Const)
	int                                                m_nMaxStacksPerInstance;                                  // 0x013C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DamageOrHeal");
		return ptr;
	}


	int STATIC_GetDeviceInstanceAbilityCount(class ATgDevice* Dev, int nFiringInstance);
	bool IsDeviceInstanceTracked(class ATgDevice* Dev, int nFiringInstance);
	void STATIC_ClearTrackedInstances(int nLength);
	void TrackFiringInstance(class ATgDevice* Dev, int nFiringInstance, int nAbilityCount);
};


// Class TgGame.TgInventoryObject_Listen_DamageStacksPerHp
// 0x000C (0x0134 - 0x0128)
class UTgInventoryObject_Listen_DamageStacksPerHp : public UTgInventoryObject_Listen_AchieveItem
{
public:
	float                                              m_fStacksPerGodDamage;                                    // 0x0128(0x0004)
	float                                              m_fStacksPerMinionDamage;                                 // 0x012C(0x0004)
	float                                              m_fAccumulatedStacks;                                     // 0x0130(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DamageStacksPerHp");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DamageThreshold
// 0x0008 (0x0130 - 0x0128)
class UTgInventoryObject_Listen_DamageThreshold : public UTgInventoryObject_Listen_AchieveItem
{
public:
	float                                              m_fDamagePerStack;                                        // 0x0128(0x0004)
	float                                              m_fAccumulatedDamage;                                     // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DamageThreshold");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DamageThreshold_Mitigated
// 0x0000 (0x0130 - 0x0130)
class UTgInventoryObject_Listen_DamageThreshold_Mitigated : public UTgInventoryObject_Listen_DamageThreshold
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DamageThreshold_Mitigated");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GuardiansBlessing
// 0x0000 (0x0128 - 0x0128)
class UTgInventoryObject_Listen_GuardiansBlessing : public UTgInventoryObject_Listen_AchieveItem
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GuardiansBlessing");
		return ptr;
	}


	void ApplyAssistStacks(class ATgPawn* VictimPawn);
};


// Class TgGame.TgInventoryObject_Listen_HuntersBlessing
// 0x0000 (0x0128 - 0x0128)
class UTgInventoryObject_Listen_HuntersBlessing : public UTgInventoryObject_Listen_AchieveItem
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HuntersBlessing");
		return ptr;
	}


	void ApplyKillAssistStacks(class ATgPawn* VictimPawn);
};


// Class TgGame.TgInventoryObject_Listen_KillsAchieved
// 0x0000 (0x0128 - 0x0128)
class UTgInventoryObject_Listen_KillsAchieved : public UTgInventoryObject_Listen_AchieveItem
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_KillsAchieved");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GauntletOfThebes_S5
// 0x0000 (0x0128 - 0x0128)
class UTgInventoryObject_Listen_GauntletOfThebes_S5 : public UTgInventoryObject_Listen_KillsAchieved
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GauntletOfThebes_S5");
		return ptr;
	}


	void ApplyAssistStacks(class ATgPawn* VictimPawn);
};


// Class TgGame.TgInventoryObject_Listen_KillStackRandom
// 0x0024 (0x014C - 0x0128)
class UTgInventoryObject_Listen_KillStackRandom : public UTgInventoryObject_Listen_KillsAchieved
{
public:
	TArray<struct FStackTypeProps>                     s_StackTypes;                                             // 0x0128(0x0010) (NeedCtorLink)
	TArray<struct FStackTypeProps>                     s_CachedStackTypes;                                       // 0x0138(0x0010) (NeedCtorLink)
	unsigned long                                      s_bAddedThisTick : 1;                                     // 0x0148(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_KillStackRandom");
		return ptr;
	}


	int STATIC_GetCurrentStacks();
	void STATIC_RemoveStackCount(int nStackCount);
	void AddStackCount(int nStackCount);
};


// Class TgGame.TgInventoryObject_Listen_LonosMask
// 0x0000 (0x0128 - 0x0128)
class UTgInventoryObject_Listen_LonosMask : public UTgInventoryObject_Listen_AchieveItem
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_LonosMask");
		return ptr;
	}


	void STATIC_HandleMinionAssist(class AActor* Victim, bool bAssist, int* xpGain, int* goldGain);
};


// Class TgGame.TgInventoryObject_Listen_MagesBlessing
// 0x002C (0x0154 - 0x0128)
class UTgInventoryObject_Listen_MagesBlessing : public UTgInventoryObject_Listen_AchieveItem
{
public:
	class ATgPawn*                                     m_CachedPawnOwner;                                        // 0x0128(0x0008)
	int                                                m_nCurrentManaStacks;                                     // 0x0130(0x0004)
	TArray<struct FCastTrackingInfo>                   m_CastTracking;                                           // 0x0134(0x0010) (NeedCtorLink)
	TArray<int>                                        m_DeviceExceptionList;                                    // 0x0144(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MagesBlessing");
		return ptr;
	}


	void ApplyKillAssistStacks(class ATgPawn* VictimPawn);
	void UpdatePassiveManaRegen();
};


// Class TgGame.TgInventoryObject_Listen_WarriorsBlessing
// 0x0008 (0x0130 - 0x0128)
class UTgInventoryObject_Listen_WarriorsBlessing : public UTgInventoryObject_Listen_AchieveItem
{
public:
	float                                              m_fLastDamageStackTime;                                   // 0x0128(0x0004)
	float                                              m_fLastKillStackTime;                                     // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_WarriorsBlessing");
		return ptr;
	}


	void ApplyGodKillStacks(class ATgPawn* VictimPawn);
};


// Class TgGame.TgInventoryObject_Listen_CelestialLegionHelm_S4
// 0x0010 (0x0130 - 0x0120)
class UTgInventoryObject_Listen_CelestialLegionHelm_S4 : public UTgInventoryObject_Listen_Stack
{
public:
	float                                              m_fNextStackTime;                                         // 0x0120(0x0004)
	float                                              m_fStackInterval;                                         // 0x0124(0x0004) (Const)
	float                                              m_fDamageWaitInterval;                                    // 0x0128(0x0004) (Const)
	int                                                m_nStackRemovalCount;                                     // 0x012C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_CelestialLegionHelm_S4");
		return ptr;
	}


	void STATIC_RemoveStackCount(int nStackCount);
};


// Class TgGame.TgInventoryObject_Listen_HideOfTheNemean
// 0x001C (0x013C - 0x0120)
class UTgInventoryObject_Listen_HideOfTheNemean : public UTgInventoryObject_Listen_Stack
{
public:
	float                                              m_fPawnBasePhysicalProtection;                            // 0x0120(0x0004) (Const)
	float                                              m_fPawnBaseMagicalProtection;                             // 0x0124(0x0004) (Const)
	float                                              m_fPawnLevelUpPhysicalProtection;                         // 0x0128(0x0004) (Const)
	float                                              m_fPawnLevelUpMagicalProtection;                          // 0x012C(0x0004) (Const)
	int                                                m_nProtectionsPerStack;                                   // 0x0130(0x0004) (Const)
	class ATgPawn*                                     m_pawnOwner;                                              // 0x0134(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HideOfTheNemean");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Kill_Stack
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_Kill_Stack : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Kill_Stack");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Assist_Stack
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_Assist_Stack : public UTgInventoryObject_Listen_Kill_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Assist_Stack");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Kill_Stack_Lifetime
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_Kill_Stack_Lifetime : public UTgInventoryObject_Listen_Kill_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Kill_Stack_Lifetime");
		return ptr;
	}


	void AddStackCount(int nStackCount);
};


// Class TgGame.TgInventoryObject_Listen_Kill_Stack_Remove_On_Death
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_Kill_Stack_Remove_On_Death : public UTgInventoryObject_Listen_Kill_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Kill_Stack_Remove_On_Death");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TieredStack
// 0x0024 (0x0144 - 0x0120)
class UTgInventoryObject_Listen_TieredStack : public UTgInventoryObject_Listen_Kill_Stack
{
public:
	TArray<int>                                        m_TierSituationalType;                                    // 0x0120(0x0010) (NeedCtorLink)
	TArray<int>                                        m_TierStacks;                                             // 0x0130(0x0010) (NeedCtorLink)
	int                                                m_nCurrentTier;                                           // 0x0140(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TieredStack");
		return ptr;
	}


	void UpdateTier();
	void STATIC_RemoveStackCount(int nStackCount);
	void AddStackCount(int nStackCount);
};


// Class TgGame.TgInventoryObject_Listen_Rage4_8
// 0x0000 (0x0144 - 0x0144)
class UTgInventoryObject_Listen_Rage4_8 : public UTgInventoryObject_Listen_TieredStack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Rage4_8");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OniHunter
// 0x0004 (0x0124 - 0x0120)
class UTgInventoryObject_Listen_OniHunter : public UTgInventoryObject_Listen_Stack
{
public:
	float                                              m_fStackInterval;                                         // 0x0120(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OniHunter");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OrnateArrow
// 0x0010 (0x0130 - 0x0120)
class UTgInventoryObject_Listen_OrnateArrow : public UTgInventoryObject_Listen_Stack
{
public:
	class ATgPlayerController*                         m_controllerOwner;                                        // 0x0120(0x0008) (Const)
	int                                                m_nGoldForStack;                                          // 0x0128(0x0004) (Const)
	int                                                m_nMaxStacks;                                             // 0x012C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OrnateArrow");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SerratedEdge
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_SerratedEdge : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SerratedEdge");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SilverbranchBow
// 0x0004 (0x0124 - 0x0120)
class UTgInventoryObject_Listen_SilverbranchBow : public UTgInventoryObject_Listen_Stack
{
public:
	float                                              m_fAmountPerStack;                                        // 0x0120(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SilverbranchBow");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SoulEaterS3
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_SoulEaterS3 : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SoulEaterS3");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SoulStone_S3
// 0x0014 (0x0134 - 0x0120)
class UTgInventoryObject_Listen_SoulStone_S3 : public UTgInventoryObject_Listen_Stack
{
public:
	TArray<struct FSoulStoneTrackingData>              m_TrackedDevices;                                         // 0x0120(0x0010) (NeedCtorLink)
	int                                                m_damageType;                                             // 0x0130(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SoulStone_S3");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Heartseeker_S3_6
// 0x0000 (0x0134 - 0x0134)
class UTgInventoryObject_Listen_Heartseeker_S3_6 : public UTgInventoryObject_Listen_SoulStone_S3
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Heartseeker_S3_6");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Stack_ConsumeStacks
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_Stack_ConsumeStacks : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Stack_ConsumeStacks");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Malice_S5
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_Malice_S5 : public UTgInventoryObject_Listen_Stack_ConsumeStacks
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Malice_S5");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Stack_BonusDamageAtMax
// 0x0004 (0x0124 - 0x0120)
class UTgInventoryObject_Listen_Stack_BonusDamageAtMax : public UTgInventoryObject_Listen_Stack_ConsumeStacks
{
public:
	int                                                m_damageType;                                             // 0x0120(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Stack_BonusDamageAtMax");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Heartseeker_S4
// 0x0024 (0x0148 - 0x0124)
class UTgInventoryObject_Listen_Heartseeker_S4 : public UTgInventoryObject_Listen_Stack_BonusDamageAtMax
{
public:
	unsigned long                                      m_bHasApplied : 1;                                        // 0x0124(0x0004)
	unsigned long                                      s_bApplyingOnTick : 1;                                    // 0x0124(0x0004)
	TArray<struct FFireInstanceData>                   m_TrackedFireInstances;                                   // 0x0128(0x0010) (NeedCtorLink)
	TArray<struct FOnDamagedParams>                    s_TrackedDamageParams;                                    // 0x0138(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Heartseeker_S4");
		return ptr;
	}


	bool IsDeviceInstanceTracked(class ATgDevice* Dev, int nFiringInstance);
	void STATIC_ClearTrackedInstances();
	void TrackFiringInstance(class ATgDevice* Dev);
};


// Class TgGame.TgInventoryObject_Listen_Masamune_S4
// 0x0004 (0x0128 - 0x0124)
class UTgInventoryObject_Listen_Masamune_S4 : public UTgInventoryObject_Listen_Stack_BonusDamageAtMax
{
public:
	int                                                m_bHasApplied;                                            // 0x0124(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Masamune_S4");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SoulStone_S4
// 0x0000 (0x0124 - 0x0124)
class UTgInventoryObject_Listen_SoulStone_S4 : public UTgInventoryObject_Listen_Stack_BonusDamageAtMax
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SoulStone_S4");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Stack_BonusDamageAtMax_DeviceTracked
// 0x0018 (0x013C - 0x0124)
class UTgInventoryObject_Listen_Stack_BonusDamageAtMax_DeviceTracked : public UTgInventoryObject_Listen_Stack_BonusDamageAtMax
{
public:
	unsigned long                                      m_bHasApplied : 1;                                        // 0x0124(0x0004)
	TArray<struct FBDAMFireInstanceData>               m_TrackedFireInstances;                                   // 0x0128(0x0010) (NeedCtorLink)
	int                                                m_nMaxTrackedFiringInstances;                             // 0x0138(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Stack_BonusDamageAtMax_DeviceTracked");
		return ptr;
	}


	bool IsDeviceInstanceTracked(class ATgDevice* Dev, int nFiringInstance);
	void STATIC_ClearTrackedInstances(int nLength);
	void TrackFiringInstance(class ATgDevice* Dev, int nFiringInstance);
};


// Class TgGame.TgInventoryObject_Listen_SoulGem_S5
// 0x0038 (0x0174 - 0x013C)
class UTgInventoryObject_Listen_SoulGem_S5 : public UTgInventoryObject_Listen_Stack_BonusDamageAtMax_DeviceTracked
{
public:
	struct FBDAMFireInstanceData                       m_BonusDamagerData;                                       // 0x013C(0x0014) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_BonusDamagedPawns;                                      // 0x0150(0x0010) (NeedCtorLink)
	TArray<struct FOnDamagedParams>                    m_ParamsToRecheckOnHit;                                   // 0x0160(0x0010) (Component, NeedCtorLink)
	int                                                m_nPreviousTrackedFireInstancesLength;                    // 0x0170(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SoulGem_S5");
		return ptr;
	}


	void ApplyAOEHits();
	void STATIC_CleanUpLogic();
	bool STATIC_CheckIfDamagerData(class ATgDevice* Dev, int nFiringInstance);
	void TrackDamagerData(class ATgDevice* Dev, int nFiringInstance);
};


// Class TgGame.TgInventoryObject_Listen_StackOutOfCombat
// 0x0004 (0x0124 - 0x0120)
class UTgInventoryObject_Listen_StackOutOfCombat : public UTgInventoryObject_Listen_Stack
{
public:
	float                                              s_fOutOfCombatTimer;                                      // 0x0120(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StackOutOfCombat");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TalismanOfTheRelentless
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_TalismanOfTheRelentless : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TalismanOfTheRelentless");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Timed_Stack
// 0x0004 (0x0124 - 0x0120)
class UTgInventoryObject_Listen_Timed_Stack : public UTgInventoryObject_Listen_Stack
{
public:
	float                                              m_fStackTimer;                                            // 0x0120(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Timed_Stack");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Staging
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Staging : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Staging");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StoneOfBinding
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_StoneOfBinding : public UTgInventoryObject_Listen
{
public:
	TArray<class ATgPawn*>                             s_VortexedPawnsList;                                      // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StoneOfBinding");
		return ptr;
	}


	void FireDevice();
};


// Class TgGame.TgInventoryObject_Listen_StoneOfBinding_S6
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_StoneOfBinding_S6 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StoneOfBinding_S6");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_StoneOfGaia
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_StoneOfGaia : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_StoneOfGaia");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SuccessfulHit
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_SuccessfulHit : public UTgInventoryObject_Listen
{
public:
	TArray<class ATgDevice*>                           m_AppliedThisFire;                                        // 0x00D0(0x0010) (NeedCtorLink)
	unsigned long                                      m_bHitAppliedThisTick : 1;                                // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SuccessfulHit");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SunderingAxe
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_SunderingAxe : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SunderingAxe");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SwiftWing
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_SwiftWing : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SwiftWing");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SyncCooldownStart
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_SyncCooldownStart : public UTgInventoryObject_Listen
{
public:
	TArray<int>                                        m_nTriggeringDeviceIds;                                   // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SyncCooldownStart");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SyncCooldownStartWithChild
// 0x0000 (0x00E0 - 0x00E0)
class UTgInventoryObject_Listen_SyncCooldownStartWithChild : public UTgInventoryObject_Listen_SyncCooldownStart
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SyncCooldownStartWithChild");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TalismanOfEnergy_S5
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_TalismanOfEnergy_S5 : public UTgInventoryObject_Listen
{
public:
	int                                                m_nStacksFromMinions;                                     // 0x00D0(0x0004)
	int                                                m_nStacksFromGods;                                        // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TalismanOfEnergy_S5");
		return ptr;
	}


	void STATIC_GiveEnergy(class AActor* Victim);
};


// Class TgGame.TgInventoryObject_Listen_TeamBuff
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Listen_TeamBuff : public UTgInventoryObject_Listen
{
public:
	class UTgEffectGroup*                              s_TeamBuffEffectGroup;                                    // 0x00D0(0x0008)
	class ATgRepInfo_TaskForce*                        r_TaskForce;                                              // 0x00D8(0x0008)
	unsigned long                                      r_bTeamBuffApplied : 1;                                   // 0x00E0(0x0004)
	unsigned long                                      m_bBuffTeamOnlyWhenAlive : 1;                             // 0x00E0(0x0004)
	int                                                m_nTeamBuffEffectGroupId;                                 // 0x00E4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TeamBuff");
		return ptr;
	}


	void UpdateTaskForce();
	void RemoveTeamBuff();
	void ApplyTeamBuff();
};


// Class TgGame.TgInventoryObject_Listen_TheAlternateTimeline
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_TheAlternateTimeline : public UTgInventoryObject_Listen
{
public:
	struct FName                                       m_nmApplyHeal;                                            // 0x00D0(0x0008) (Const)
	float                                              m_fTimeWaitToHeal;                                        // 0x00D8(0x0004) (Const)
	float                                              m_fAmountToHeal;                                          // 0x00DC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TheAlternateTimeline");
		return ptr;
	}


	void ApplyHeal();
};


// Class TgGame.TgInventoryObject_Listen_TyphonsFang
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_TyphonsFang : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TyphonsFang");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_UndoRelic
// 0x0024 (0x00F4 - 0x00D0)
class UTgInventoryObject_Listen_UndoRelic : public UTgInventoryObject_Listen
{
public:
	TArray<struct FHistoryElement>                     m_healthHistory;                                          // 0x00D0(0x0010) (NeedCtorLink)
	TArray<struct FHistoryElement>                     m_manaHistory;                                            // 0x00E0(0x0010) (NeedCtorLink)
	unsigned long                                      m_RecordHealth : 1;                                       // 0x00F0(0x0004)
	unsigned long                                      m_RecordMana : 1;                                         // 0x00F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_UndoRelic");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_WrathOfTheGods
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_WrathOfTheGods : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_WrathOfTheGods");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_StagedHealth
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_StagedHealth : public UTgInventoryObject_Listen
{
public:
	float                                              s_fLockedPct;                                             // 0x00D0(0x0004)
	int                                                s_nCurrentLevel;                                          // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_StagedHealth");
		return ptr;
	}

};


// Class TgGame.TgInventoryStacking
// 0x0000 (0x0060 - 0x0060)
class UTgInventoryStacking : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryStacking");
		return ptr;
	}


	int STATIC_GetCurrentStacks();
	void STATIC_RemoveStackCount(int nStackCount);
	void AddStackCount(int nStackCount);
};


// Class TgGame.TgPickupFactory
// 0x0030 (0x03B4 - 0x0384)
class ATgPickupFactory : public APickupFactory
{
public:
	unsigned long                                      bRotatingPickup : 1;                                      // 0x0384(0x0004)
	float                                              YawRotationRate;                                          // 0x0388(0x0004)
	class AController*                                 TeamOwner[0x4];                                           // 0x038C(0x0008)
	class UPrimitiveComponent*                         BaseMesh;                                                 // 0x03AC(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPickupFactory");
		return ptr;
	}


	bool StopsProjectile(class AProjectile* P);
	void STATIC_RespawnEffect();
	void UpdateHUD(class ATgHUD* H);
	bool STATIC_ShouldCamp(class ATgAIController* B, float MaxWait);
};


// Class TgGame.TgSeqAct_AddPercentVitals
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_AddPercentVitals : public USequenceAction
{
public:
	float                                              percentHealth;                                            // 0x0108(0x0004) (Edit)
	float                                              percentMana;                                              // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AddPercentVitals");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AddStacks
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_AddStacks : public USequenceAction
{
public:
	int                                                m_nStackCount;                                            // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AddStacks");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AddTimeAdventure
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_AddTimeAdventure : public USequenceAction
{
public:
	float                                              m_fNumSecs;                                               // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AddTimeAdventure");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AddToSpawnQueue
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_AddToSpawnQueue : public USequenceAction
{
public:
	int                                                m_nBotId;                                                 // 0x0108(0x0004) (Edit)
	int                                                m_nSkinId;                                                // 0x010C(0x0004) (Edit)
	int                                                m_nQueueIndex;                                            // 0x0110(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AddToSpawnQueue");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_Adventure_PauseRespawns
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_Adventure_PauseRespawns : public USequenceAction
{
public:
	unsigned long                                      m_bPause : 1;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_Adventure_PauseRespawns");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_Adventure_TweenForward
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_Adventure_TweenForward : public USequenceAction
{
public:
	float                                              m_fTweenDist;                                             // 0x0108(0x0004) (Edit)
	float                                              m_fTweenTime;                                             // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_Adventure_TweenForward");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AdventureOver
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_AdventureOver : public USequenceAction
{
public:
	int                                                m_nWinningTaskForce;                                      // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AdventureOver");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIAssignLane
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_AIAssignLane : public USequenceAction
{
public:
	int                                                Lane;                                                     // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIAssignLane");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIFreeze
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_AIFreeze : public USequenceAction
{
public:
	int                                                TaskForceNumber;                                          // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIFreeze");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIMoveToActor
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_AIMoveToActor : public USequenceAction
{
public:
	class AActor*                                      Destination;                                              // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIMoveToActor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AITargetActor
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_AITargetActor : public USequenceAction
{
public:
	class AActor*                                      CombatTarget;                                             // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AITargetActor");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ArenaTraining_EnableCompletion
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ArenaTraining_EnableCompletion : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ArenaTraining_EnableCompletion");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ArenaTraining_UseTickets
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_ArenaTraining_UseTickets : public USequenceAction
{
public:
	int                                                m_nTaskForce;                                             // 0x0108(0x0004) (Edit)
	int                                                m_nTickets;                                               // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ArenaTraining_UseTickets");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_CartDefenseOver
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_CartDefenseOver : public USequenceAction
{
public:
	int                                                m_nWinningTaskForce;                                      // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_CartDefenseOver");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_CH06_EndRoundAndRecordScore
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_CH06_EndRoundAndRecordScore : public USequenceAction
{
public:
	float                                              fDifficultyWeight;                                        // 0x0108(0x0004) (Edit, EditConst)
	unsigned long                                      bShouldShowUI : 1;                                        // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_CH06_EndRoundAndRecordScore");
		return ptr;
	}


	void STATIC_EndRound();
	void Activated();
};


// Class TgGame.TgSeqAct_ChangeGameMod
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_ChangeGameMod : public USequenceAction
{
public:
	unsigned long                                      m_bRemove : 1;                                            // 0x0108(0x0004) (Edit)
	int                                                m_nItemId;                                                // 0x010C(0x0004) (Edit)
	int                                                m_nStacks;                                                // 0x0110(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ChangeGameMod");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ClientLoadDevices
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_ClientLoadDevices : public USequenceAction
{
public:
	TArray<int>                                        m_DeviceIdList;                                           // 0x0108(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bClearExistingLoads : 1;                                // 0x0118(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ClientLoadDevices");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_CurrencySpooling
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_CurrencySpooling : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_CurrencySpooling");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DeathFogActivate
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_DeathFogActivate : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DeathFogActivate");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DeathFogDeactivate
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_DeathFogDeactivate : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DeathFogDeactivate");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DefenseWaveSpawner
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_DefenseWaveSpawner : public USequenceAction
{
public:
	int                                                m_nRoundNumber;                                           // 0x0108(0x0004)
	float                                              m_fSpawnFrequency;                                        // 0x010C(0x0004)
	float                                              m_fNextSpawnTime;                                         // 0x0110(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DefenseWaveSpawner");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DialogPlay
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_DialogPlay : public USequenceAction
{
public:
	unsigned long                                      bPlayImmediately : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bFlushOthers : 1;                                         // 0x0108(0x0004) (Edit)
	class USoundCue*                                   SoundCue;                                                 // 0x010C(0x0008) (Edit)
	int                                                nImageId;                                                 // 0x0114(0x0004) (Edit)
	float                                              fTextSpeedMultiplier;                                     // 0x0118(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DialogPlay");
		return ptr;
	}


	int GetObjClassVersion();
	void Activated();
};


// Class TgGame.TgSeqAct_DialogToggle
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_DialogToggle : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DialogToggle");
		return ptr;
	}


	int GetObjClassVersion();
	void Activated();
};


// Class TgGame.TgSeqAct_EndMission
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_EndMission : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_EndMission");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ForceClientTutorialAction
// 0x0002 (0x010A - 0x0108)
class UTgSeqAct_ForceClientTutorialAction : public USequenceAction
{
public:
	TEnumAsByte<EeForcedClientTutorialAction>          ForcedAction;                                             // 0x0108(0x0001) (Edit)
	TEnumAsByte<EeTutorialForceableElements>           GameUIElement;                                            // 0x0109(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ForceClientTutorialAction");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ForceFactoryTables
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_ForceFactoryTables : public USequenceAction
{
public:
	int                                                m_nNewSpawnTable;                                         // 0x0108(0x0004) (Edit)
	unsigned long                                      m_bOverrideSpawnItems : 1;                                // 0x010C(0x0004) (Edit)
	int                                                m_nNewSpawnItemTable;                                     // 0x0110(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ForceFactoryTables");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ForceRespawns
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ForceRespawns : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ForceRespawns");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetGodRole
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetGodRole : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetGodRole");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetLocalFactoryRespawnVisibility
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetLocalFactoryRespawnVisibility : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetLocalFactoryRespawnVisibility");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetLocalTaskForce
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_GetLocalTaskForce : public USequenceAction
{
public:
	int                                                m_nLocalTaskForce;                                        // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetLocalTaskForce");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetMaterialInst
// 0x001C (0x0124 - 0x0108)
class UTgSeqAct_GetMaterialInst : public USequenceAction
{
public:
	class UMaterialInstance*                           MatInst;                                                  // 0x0108(0x0008) (Edit)
	struct FString                                     MatInstName;                                              // 0x0110(0x0010) (Edit, NeedCtorLink)
	int                                                MaterialIndex;                                            // 0x0120(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetMaterialInst");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetMissionTime
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_GetMissionTime : public USequenceAction
{
public:
	float                                              m_fElapsedSeconds;                                        // 0x0108(0x0004)
	float                                              m_fRemainingSeconds;                                      // 0x010C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetMissionTime");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetObjectListCount
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_GetObjectListCount : public USequenceAction
{
public:
	int                                                m_nListCount;                                             // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetObjectListCount");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetPlayedConquestRole
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetPlayedConquestRole : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetPlayedConquestRole");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetPlayerCount
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_GetPlayerCount : public USequenceAction
{
public:
	int                                                m_nTaskForce;                                             // 0x0108(0x0004) (Edit)
	float                                              m_fPlayerCount;                                           // 0x010C(0x0004)
	float                                              m_fAssaultCount;                                          // 0x0110(0x0004)
	float                                              m_fMedicCount;                                            // 0x0114(0x0004)
	float                                              m_fReconCount;                                            // 0x0118(0x0004)
	float                                              m_fRoboticsCount;                                         // 0x011C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetPlayerCount");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetPropVal
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_GetPropVal : public USequenceAction
{
public:
	int                                                m_nPropertyId;                                            // 0x0108(0x0004) (Edit)
	float                                              m_fValue;                                                 // 0x010C(0x0004)
	float                                              m_fMin;                                                   // 0x0110(0x0004)
	float                                              m_fMax;                                                   // 0x0114(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetPropVal");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetRandomPlayer
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_GetRandomPlayer : public USequenceAction
{
public:
	int                                                m_nTaskForce;                                             // 0x0108(0x0004) (Edit)
	class ATgPawn*                                     m_Target;                                                 // 0x010C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetRandomPlayer");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTaskForceCount
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_GetTaskForceCount : public USequenceAction
{
public:
	int                                                TaskForce;                                                // 0x0108(0x0004) (Edit)
	unsigned long                                      bExcludeAlivePlayers : 1;                                 // 0x010C(0x0004) (Edit)
	unsigned long                                      bExcludeDeadPlayers : 1;                                  // 0x010C(0x0004) (Edit)
	unsigned long                                      bExcludeAliveBots : 1;                                    // 0x010C(0x0004) (Edit)
	unsigned long                                      bExcludeDeadBots : 1;                                     // 0x010C(0x0004) (Edit)
	int                                                m_nPlayerCount;                                           // 0x0110(0x0004)
	int                                                m_nBotCount;                                              // 0x0114(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTaskForceCount");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTaskForceList
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_GetTaskForceList : public USequenceAction
{
public:
	int                                                TaskForce;                                                // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTaskForceList");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GiveFullVitals
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GiveFullVitals : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GiveFullVitals");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GivePercentVitals
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_GivePercentVitals : public USequenceAction
{
public:
	float                                              percentHealth;                                            // 0x0108(0x0004) (Edit)
	float                                              percentMana;                                              // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GivePercentVitals");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_HidePawns
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_HidePawns : public USequenceAction
{
public:
	TArray<int>                                        m_nBotRanks;                                              // 0x0108(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bAllRanks : 1;                                          // 0x0118(0x0004) (Edit)
	unsigned long                                      m_bSetHidden : 1;                                         // 0x0118(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_HidePawns");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_LoadNewDefaultMusicTheme
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_LoadNewDefaultMusicTheme : public USequenceAction
{
public:
	int                                                newDefaultMusicThemeId;                                   // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LoadNewDefaultMusicTheme");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_LockCapturePoint
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_LockCapturePoint : public USequenceAction
{
public:
	unsigned long                                      m_bLock : 1;                                              // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LockCapturePoint");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_LockDevice
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_LockDevice : public USequenceAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eEqpPoint;                                              // 0x0108(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0109(0x0003) MISSED OFFSET
	unsigned long                                      m_bUnlock : 1;                                            // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LockDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ModifyFactoryBuffMap
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_ModifyFactoryBuffMap : public USequenceAction
{
public:
	int                                                m_nBuffModifyIndex;                                       // 0x0108(0x0004) (Const)
	int                                                m_nBuffIdOverride;                                        // 0x010C(0x0004) (Const)
	unsigned long                                      m_bModifyTeamBuff : 1;                                    // 0x0110(0x0004) (Const)
	unsigned long                                      m_bEnableBuff : 1;                                        // 0x0110(0x0004) (Const)
	unsigned long                                      m_bModifyBuffsOnActiveMobs : 1;                           // 0x0110(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ModifyFactoryBuffMap");
		return ptr;
	}


	void ModifyActiveMobsBuff(class ATgBotFactory_LeashedConfigurable* factoryToModify);
	void ModifyFactoryBuffMap(class ATgBotFactory_LeashedConfigurable* factoryToModify);
};


// Class TgGame.TgSeqAct_ModifyPropValue
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_ModifyPropValue : public USequenceAction
{
public:
	int                                                m_nPropertyId;                                            // 0x0108(0x0004) (Edit)
	TEnumAsByte<ETgPropValueType>                      m_ePropertyValueType;                                     // 0x010C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x010D(0x0003) MISSED OFFSET
	float                                              m_fNewValue;                                              // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ModifyPropValue");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_NavIndicator
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_NavIndicator : public USequenceAction
{
public:
	class AActor*                                      m_NavTarget;                                              // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_NavIndicator");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PingMinimap
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_PingMinimap : public USequenceAction
{
public:
	class AActor*                                      m_PingTarget;                                             // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PingMinimap");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PlayAnnouncement
// 0x0020 (0x0128 - 0x0108)
class UTgSeqAct_PlayAnnouncement : public USequenceAction
{
public:
	unsigned long                                      bPlayImmediately : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      bFlushOthers : 1;                                         // 0x0108(0x0004) (Edit)
	int                                                SoundIndex;                                               // 0x010C(0x0004) (Deprecated)
	class USoundCue*                                   OptionalCue;                                              // 0x0110(0x0008) (Deprecated)
	class USoundCue*                                   DefaultSoundCue;                                          // 0x0118(0x0008) (Edit)
	class USoundCue*                                   ConsoleOverrideCue;                                       // 0x0120(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayAnnouncement");
		return ptr;
	}


	int GetObjClassVersion();
	void Activated();
};


// Class TgGame.TgSeqAct_PlayFullBodyAnim
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_PlayFullBodyAnim : public USequenceAction
{
public:
	struct FName                                       c_AnimName;                                               // 0x0108(0x0008) (Edit)
	float                                              c_fRate;                                                  // 0x0110(0x0004) (Edit)
	float                                              c_fBlendInTime;                                           // 0x0114(0x0004) (Edit)
	float                                              c_fBlendOutTime;                                          // 0x0118(0x0004) (Edit)
	unsigned long                                      c_bLooping : 1;                                           // 0x011C(0x0004) (Edit)
	unsigned long                                      c_bOverride : 1;                                          // 0x011C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayFullBodyAnim");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ProgressTo
// 0x0008 (0x013C - 0x0134)
class UTgSeqAct_ProgressTo : public USeqAct_Delay
{
public:
	class ATgPawn*                                     m_Instigator;                                             // 0x0134(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ProgressTo");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PushMatinee
// 0x000C (0x0228 - 0x021C)
class UTgSeqAct_PushMatinee : public USeqAct_Interp
{
public:
	float                                              m_fCheckpoint1Time;                                       // 0x021C(0x0004) (Edit, Const)
	float                                              m_fCheckpoint2Time;                                       // 0x0220(0x0004) (Edit, Const)
	int                                                m_nDefenderTaskForce;                                     // 0x0224(0x0004) (Edit, Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PushMatinee");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_PushNewStoreId
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_PushNewStoreId : public USequenceAction
{
public:
	int                                                m_nStoreId;                                               // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PushNewStoreId");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_RequestMission
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_RequestMission : public USequenceAction
{
public:
	int                                                m_nMapGameId;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_RequestMission");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_RespawnFactory
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_RespawnFactory : public USequenceAction
{
public:
	float                                              m_fRespawnTimerOverride;                                  // 0x0108(0x0004) (Const)
	TArray<int>                                        m_nRespawnVisibilityTaskforces;                           // 0x010C(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_RespawnFactory");
		return ptr;
	}


	void STATIC_SetFactoryRespawnTimer(class ATgBotFactory* factoryRespawn);
};


// Class TgGame.TgSeqAct_SendPlayerTrackingEvent
// 0x001C (0x0124 - 0x0108)
class UTgSeqAct_SendPlayerTrackingEvent : public USequenceAction
{
public:
	int                                                m_nEventId;                                               // 0x0108(0x0004) (Edit)
	int                                                m_nSubEventID;                                            // 0x010C(0x0004) (Edit)
	struct FString                                     m_ReferenceName;                                          // 0x0110(0x0010) (Edit, NeedCtorLink)
	int                                                m_nReferenceValue;                                        // 0x0120(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SendPlayerTrackingEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetCapturePointOwner
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetCapturePointOwner : public USequenceAction
{
public:
	float                                              m_nOwningTaskForce;                                       // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetCapturePointOwner");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetCapturePointPct
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetCapturePointPct : public USequenceAction
{
public:
	float                                              m_fNewPercent;                                            // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetCapturePointPct");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetHexState
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetHexState : public USequenceAction
{
public:
	unsigned long                                      m_bChallengerWon : 1;                                     // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetHexState");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetMissionTime
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_SetMissionTime : public USequenceAction
{
public:
	float                                              m_fMissionTimeSecs;                                       // 0x0108(0x0004) (Edit)
	float                                              m_fIncrementSecs;                                         // 0x010C(0x0004) (Edit)
	float                                              m_fMissionTimeRemaining;                                  // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetMissionTime");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetObjectList
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_SetObjectList : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetObjectList");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetPlayerLevel
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetPlayerLevel : public USequenceAction
{
public:
	int                                                m_nLevel;                                                 // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetPlayerLevel");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetPlayerMesh
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetPlayerMesh : public USequenceAction
{
public:
	int                                                m_nMeshAsmId;                                             // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetPlayerMesh");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetUIClock
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetUIClock : public USequenceAction
{
public:
	unsigned long                                      ShowAlarmTexture : 1;                                     // 0x0108(0x0004) (Edit)
	unsigned long                                      UseProgressBar : 1;                                       // 0x0108(0x0004) (Edit)
	unsigned long                                      IsCountingDown : 1;                                       // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetUIClock");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetUITextBox
// 0x0009 (0x0111 - 0x0108)
class UTgSeqAct_SetUITextBox : public USequenceAction
{
public:
	int                                                TextBox_MessageID;                                        // 0x0108(0x0004) (Edit)
	unsigned long                                      TextBox_TargetSecondary : 1;                              // 0x010C(0x0004) (Edit)
	unsigned long                                      TextBox_UseDuration : 1;                                  // 0x010C(0x0004) (Edit)
	unsigned long                                      TextBox_AllowEscape : 1;                                  // 0x010C(0x0004) (Edit)
	TEnumAsByte<EAlertType>                            TextBox_MessageType;                                      // 0x0110(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetUITextBox");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ShuffleObjectList
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ShuffleObjectList : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ShuffleObjectList");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SwitchCamera
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_SwitchCamera : public USequenceAction
{
public:
	struct FName                                       m_nmCamName;                                              // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SwitchCamera");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TemporaryAddDevice
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_TemporaryAddDevice : public USequenceAction
{
public:
	int                                                m_nDeviceId;                                              // 0x0108(0x0004) (Edit)
	int                                                m_nEquipPoint;                                            // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TemporaryAddDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TemporaryRemoveDevice
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_TemporaryRemoveDevice : public USequenceAction
{
public:
	int                                                m_nEquipPoint;                                            // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TemporaryRemoveDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ToggleWaypoint
// 0x0024 (0x012C - 0x0108)
class UTgSeqAct_ToggleWaypoint : public USequenceAction
{
public:
	int                                                m_nWaypointDeployableId;                                  // 0x0108(0x0004) (Edit, Const)
	unsigned long                                      m_bPingMinimap : 1;                                       // 0x010C(0x0004) (Edit, Const)
	unsigned long                                      c_bIsWaypointActive : 1;                                  // 0x010C(0x0004)
	class AActor*                                      m_aWaypointInstigatorController;                          // 0x0110(0x0008) (Const)
	class AActor*                                      m_aWaypointDestination;                                   // 0x0118(0x0008) (Const)
	class ATgDeployable*                               c_deployWaypoint;                                         // 0x0120(0x0008)
	int                                                c_nCurrentWaypointId;                                     // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ToggleWaypoint");
		return ptr;
	}


	void STATIC_DeactivateWaypoint();
	void ActivateWaypoint();
};


// Class TgGame.TgSeqAct_Training_StartQuest
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_Training_StartQuest : public USequenceAction
{
public:
	int                                                m_nEventId;                                               // 0x0108(0x0004) (Edit)
	TEnumAsByte<ETrainingQuest>                        m_eObjectiveType;                                         // 0x010C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x010D(0x0003) MISSED OFFSET
	int                                                m_nQuestCount;                                            // 0x0110(0x0004) (Edit)
	class UClass*                                      m_KillType;                                               // 0x0114(0x0008) (Edit)
	int                                                m_nQuestMsgID;                                            // 0x011C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_Training_StartQuest");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_Training_UpdateQuest
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_Training_UpdateQuest : public USequenceAction
{
public:
	int                                                m_nEventId;                                               // 0x0108(0x0004) (Edit)
	int                                                m_nUpdateAmount;                                          // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_Training_UpdateQuest");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TrainingAwards
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TrainingAwards : public USequenceAction
{
public:
	float                                              m_fGoldTime;                                              // 0x0108(0x0004) (Edit)
	float                                              m_fSilverTime;                                            // 0x010C(0x0004) (Edit)
	float                                              m_fBronzeTime;                                            // 0x0110(0x0004) (Edit)
	float                                              m_fPassTime;                                              // 0x0114(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TrainingAwards");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TriggerBots
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_TriggerBots : public USequenceAction
{
public:
	unsigned long                                      bUseDestination : 1;                                      // 0x0108(0x0004) (Edit)
	class AActor*                                      TargetActor;                                              // 0x010C(0x0008) (Edit)
	class AActor*                                      destActor;                                                // 0x0114(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TriggerBots");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialHighlighter
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_TutorialHighlighter : public USequenceAction
{
public:
	TEnumAsByte<EeTutorialHighlighterElement>          GameUIElement;                                            // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialHighlighter");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialImage
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TutorialImage : public USequenceAction
{
public:
	TEnumAsByte<EeTutorialImageActionEnum>             ImageAction;                                              // 0x0108(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0109(0x0003) MISSED OFFSET
	int                                                HeaderMsgId;                                              // 0x010C(0x0004) (Edit)
	int                                                ImageId;                                                  // 0x0110(0x0004) (Edit)
	int                                                msgId;                                                    // 0x0114(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialImage");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialInstruction
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_TutorialInstruction : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialInstruction");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TutorialTips
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_TutorialTips : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TutorialTips");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UIAlert
// 0x0024 (0x012C - 0x0108)
class UTgSeqAct_UIAlert : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)
	TArray<int>                                        Taskforces;                                               // 0x010C(0x0010) (NeedCtorLink)
	TArray<unsigned long>                              Broadcast;                                                // 0x011C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UIAlert");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UINotify
// 0x004C (0x0154 - 0x0108)
class UTgSeqAct_UINotify : public USequenceAction
{
public:
	int                                                nMsgId;                                                   // 0x0108(0x0004) (Edit)
	int                                                nSubMsgId;                                                // 0x010C(0x0004) (Edit)
	int                                                nTextColor;                                               // 0x0110(0x0004) (Edit)
	int                                                nSubTextColor;                                            // 0x0114(0x0004) (Edit)
	int                                                nTextSize;                                                // 0x0118(0x0004) (Edit)
	int                                                nSubTextSize;                                             // 0x011C(0x0004) (Edit)
	int                                                nDelay;                                                   // 0x0120(0x0004) (Edit)
	TArray<int>                                        Taskforces;                                               // 0x0124(0x0010) (NeedCtorLink)
	TArray<unsigned long>                              Broadcast;                                                // 0x0134(0x0010) (NeedCtorLink)
	TArray<int>                                        FillInt;                                                  // 0x0144(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UINotify");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UpdateDVMapInfoIndex
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_UpdateDVMapInfoIndex : public USequenceAction
{
public:
	int                                                m_nIndex;                                                 // 0x0108(0x0004) (Edit)
	class ATgDeviceVolume*                             m_DeviceVolume;                                           // 0x010C(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UpdateDVMapInfoIndex");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UpdateGameScore
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_UpdateGameScore : public USequenceAction
{
public:
	unsigned long                                      bIsFloat : 1;                                             // 0x0108(0x0004) (Edit)
	int                                                nIndex;                                                   // 0x010C(0x0004) (Edit)
	float                                              fValue;                                                   // 0x0110(0x0004) (Edit)
	int                                                nValue;                                                   // 0x0114(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UpdateGameScore");
		return ptr;
	}


	int GetObjClassVersion();
};


// Class TgGame.TgSeqAct_UpdateGameVals
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_UpdateGameVals : public USequenceAction
{
public:
	int                                                m_nIndex;                                                 // 0x0108(0x0004) (Edit)
	float                                              m_fValue;                                                 // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UpdateGameVals");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UpdateRoundState
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_UpdateRoundState : public USequenceAction
{
public:
	int                                                m_nRoundNumber;                                           // 0x0108(0x0004)
	int                                                m_nTipId;                                                 // 0x010C(0x0004)
	int                                                m_nTitleId;                                               // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UpdateRoundState");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UpdateSiegeBattlePhase
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_UpdateSiegeBattlePhase : public USequenceAction
{
public:
	unsigned long                                      m_bIsDayPhase : 1;                                        // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UpdateSiegeBattlePhase");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UpdateTFVals
// 0x000C (0x0114 - 0x0108)
class UTgSeqAct_UpdateTFVals : public USequenceAction
{
public:
	int                                                m_nIndex;                                                 // 0x0108(0x0004) (Edit)
	float                                              m_fValue;                                                 // 0x010C(0x0004) (Edit)
	int                                                m_nTaskForce;                                             // 0x0110(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UpdateTFVals");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_UpdateVortexVolume
// 0x0020 (0x0128 - 0x0108)
class UTgSeqAct_UpdateVortexVolume : public USequenceAction
{
public:
	unsigned long                                      m_bEnable : 1;                                            // 0x0108(0x0004) (Edit)
	unsigned long                                      m_bDisable : 1;                                           // 0x0108(0x0004) (Edit)
	unsigned long                                      m_bUpdateDirection : 1;                                   // 0x0108(0x0004) (Edit)
	unsigned long                                      m_bRadiallyIn : 1;                                        // 0x0108(0x0004) (Edit)
	unsigned long                                      m_bUpdateIntensity : 1;                                   // 0x0108(0x0004) (Edit)
	unsigned long                                      m_bStayOn : 1;                                            // 0x0108(0x0004) (Edit)
	struct FVector                                     m_vDirection;                                             // 0x010C(0x000C) (Edit)
	float                                              m_fIntensity;                                             // 0x0118(0x0004) (Edit)
	float                                              m_fWarmupTime;                                            // 0x011C(0x0004) (Edit)
	float                                              m_fPersistTime;                                           // 0x0120(0x0004) (Edit)
	float                                              m_fRampdownTime;                                          // 0x0124(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_UpdateVortexVolume");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_XpSpooling
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_XpSpooling : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_XpSpooling");
		return ptr;
	}

};


// Class TgGame.TgSeqCon_GetLocalFactoryRespawnVisibility
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCon_GetLocalFactoryRespawnVisibility : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCon_GetLocalFactoryRespawnVisibility");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_And
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_And : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_And");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_HasCategory
// 0x000C (0x00F8 - 0x00EC)
class UTgSeqCond_HasCategory : public USequenceCondition
{
public:
	int                                                m_nCategoryCode;                                          // 0x00EC(0x0004) (Edit)
	class UObject*                                     m_CategoryTarget;                                         // 0x00F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_HasCategory");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_HasCondition
// 0x0001 (0x00ED - 0x00EC)
class UTgSeqCond_HasCondition : public USequenceCondition
{
public:
	TEnumAsByte<EConditionType>                        ConditionList;                                            // 0x00EC(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_HasCondition");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsHuman
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsHuman : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsHuman");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsIdle
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsIdle : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsIdle");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_IsSecuring
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_IsSecuring : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_IsSecuring");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_LoginPageSelect
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_LoginPageSelect : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_LoginPageSelect");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_Or
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_Or : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_Or");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_PlayingDemo
// 0x0000 (0x00EC - 0x00EC)
class UTgSeqCond_PlayingDemo : public USequenceCondition
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_PlayingDemo");
		return ptr;
	}

};


// Class TgGame.TgSeqCond_WorldDetail
// 0x0004 (0x00F0 - 0x00EC)
class UTgSeqCond_WorldDetail : public USequenceCondition
{
public:
	int                                                MinWorldSetting;                                          // 0x00EC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqCond_WorldDetail");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_Adventure_ModTrigger
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_Adventure_ModTrigger : public USequenceEvent
{
public:
	int                                                s_nModTrigger;                                            // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Adventure_ModTrigger");
		return ptr;
	}


	void TriggerPickup(int nPickup);
};


// Class TgGame.TgSeqEvent_AdventureFactoryAggrod
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_AdventureFactoryAggrod : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_AdventureFactoryAggrod");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_AdvOwnership
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_AdvOwnership : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_AdvOwnership");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_AIEvent
// 0x0010 (0x0138 - 0x0128)
class UTgSeqEvent_AIEvent : public USequenceEvent
{
public:
	class ATgPawn*                                     m_AITarget;                                               // 0x0128(0x0008)
	int                                                m_nGeneralInt;                                            // 0x0130(0x0004)
	float                                              m_fGeneralFloat;                                          // 0x0134(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_AIEvent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_AllInVolume
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_AllInVolume : public USequenceEvent
{
public:
	int                                                m_nTaskForce;                                             // 0x0128(0x0004) (Edit)
	unsigned long                                      m_bPlayersOnly : 1;                                       // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_AllInVolume");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_BotBelowHealthPerc
// 0x0004 (0x015C - 0x0158)
class UTgSeqEvent_BotBelowHealthPerc : public USeqEvent_TakeDamage
{
public:
	unsigned long                                      m_bAlreadyFired : 1;                                      // 0x0158(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BotBelowHealthPerc");
		return ptr;
	}


	void STATIC_HandleDamage(class AActor* InOriginator, class AActor* InInstigator, class UClass* inDamageType, int inAmount);
};


// Class TgGame.TgSeqEvent_ChestOpened
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ChestOpened : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ChestOpened");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ClientGameOver
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_ClientGameOver : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ClientGameOver");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_DeployableFired
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_DeployableFired : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_DeployableFired");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_Escort_Despawn_Success
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_Escort_Despawn_Success : public USequenceEvent
{
public:
	int                                                DefendersTaskForce;                                       // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Escort_Despawn_Success");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_FiringDevice
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_FiringDevice : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_FiringDevice");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LevelFadedIn
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LevelFadedIn : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LevelFadedIn");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LobbyCamEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LobbyCamEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LobbyCamEvent");
		return ptr;
	}


	void TriggerLobbyCamEvent(int nEventType, int nTarget);
};


// Class TgGame.TgSeqEvent_LobbyEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LobbyEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LobbyEvent");
		return ptr;
	}


	void TriggerLobbyEvent(int nEventType, int nTarget);
};


// Class TgGame.TgSeqEvent_LocalPlayerDroppedFlag
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerDroppedFlag : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerDroppedFlag");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayerPickedUpFlag
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayerPickedUpFlag : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayerPickedUpFlag");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LocalPlayersTeamCapturedFlag
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LocalPlayersTeamCapturedFlag : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LocalPlayersTeamCapturedFlag");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_MissionTimer
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_MissionTimer : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MissionTimer");
		return ptr;
	}


	void UpdateTaskForceWonValue(int iValue);
	void UpdateChallengerWonValue(bool bValue);
};


// Class TgGame.TgSeqEvent_MultiRoundsTimer
// 0x0001 (0x0129 - 0x0128)
class UTgSeqEvent_MultiRoundsTimer : public UTgSeqEvent_MissionTimer
{
public:
	TEnumAsByte<EGameMultiRoundState>                  m_eCurrentRoundState;                                     // 0x0128(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MultiRoundsTimer");
		return ptr;
	}


	void UpdateSeqRoundState(TEnumAsByte<EGameMultiRoundState> eState);
	void UpdateTaskForceWonValue(int nValue);
	void UpdateChallengerWonValue(bool bValue);
};


// Class TgGame.TgSeqEvent_MissionTimeRemaining
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_MissionTimeRemaining : public USequenceEvent
{
public:
	float                                              SecsRemaining;                                            // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_MissionTimeRemaining");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_Named
// 0x0001 (0x0129 - 0x0128)
class UTgSeqEvent_Named : public USequenceEvent
{
public:
	TEnumAsByte<ETSE_NAME>                             NamedEvent;                                               // 0x0128(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Named");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_PVEDifficultySet
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_PVEDifficultySet : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_PVEDifficultySet");
		return ptr;
	}


	void UpdateDifficulty(int Difficulty);
};


// Class TgGame.TgSeqEvent_SpawnLanePusher
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_SpawnLanePusher : public USequenceEvent
{
public:
	int                                                TaskForce;                                                // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnLanePusher");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SpawnWise
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_SpawnWise : public USequenceEvent
{
public:
	int                                                TaskForce;                                                // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SpawnWise");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TaskForceInactive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TaskForceInactive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TaskForceInactive");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TaskForcePlayerStates
// 0x0018 (0x0140 - 0x0128)
class UTgSeqEvent_TaskForcePlayerStates : public USequenceEvent
{
public:
	int                                                m_nTaskForce;                                             // 0x0128(0x0004) (Edit)
	int                                                m_nP1State;                                               // 0x012C(0x0004)
	int                                                m_nP2State;                                               // 0x0130(0x0004)
	int                                                m_nP3State;                                               // 0x0134(0x0004)
	int                                                m_nP4State;                                               // 0x0138(0x0004)
	int                                                m_nP5State;                                               // 0x013C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TaskForcePlayerStates");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TeamInactive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TeamInactive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TeamInactive");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TicketCountUpdated
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_TicketCountUpdated : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TicketCountUpdated");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_UpdateLanePusherCount
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_UpdateLanePusherCount : public USequenceEvent
{
public:
	int                                                TaskForce;                                                // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_UpdateLanePusherCount");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_Used
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_Used : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Used");
		return ptr;
	}

};


// Class TgGame.TgSeqOp_MathCalc
// 0x0004 (0x00F0 - 0x00EC)
class UTgSeqOp_MathCalc : public USequenceCondition
{
public:
	float                                              m_fResult;                                                // 0x00EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqOp_MathCalc");
		return ptr;
	}

};


// Class TgGame.TgSeqVar_Player
// 0x004C (0x0128 - 0x00DC)
class UTgSeqVar_Player : public USeqVar_Player
{
public:
	TArray<class UObject*>                             HumanPlayers;                                             // 0x00DC(0x0010) (Transient, NeedCtorLink)
	TArray<class UObject*>                             BotPlayers;                                               // 0x00EC(0x0010) (Transient, NeedCtorLink)
	TArray<class UObject*>                             PetPlayers;                                               // 0x00FC(0x0010) (Transient, NeedCtorLink)
	TArray<class UObject*>                             RolePlayers;                                              // 0x010C(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bAllBots : 1;                                             // 0x011C(0x0004) (Edit)
	unsigned long                                      bAllHumans : 1;                                           // 0x011C(0x0004) (Edit)
	unsigned long                                      bAllHumansAndPets : 1;                                    // 0x011C(0x0004) (Edit)
	unsigned long                                      bSingleBot : 1;                                           // 0x011C(0x0004) (Edit)
	TEnumAsByte<EGodRole>                              DesiredRole;                                              // 0x0120(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0121(0x0003) MISSED OFFSET
	int                                                nTaskForceNumber;                                         // 0x0124(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqVar_Player");
		return ptr;
	}

};


// Class TgGame.TgSeqVar_RouteNumber
// 0x0000 (0x00A4 - 0x00A4)
class UTgSeqVar_RouteNumber : public USeqVar_Int
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqVar_RouteNumber");
		return ptr;
	}

};


// Class TgGame.TgTrigger_Instance
// 0x0018 (0x0288 - 0x0270)
class ATgTrigger_Instance : public ATrigger
{
public:
	int                                                m_nMapId;                                                 // 0x0270(0x0004) (Edit, EditInline)
	unsigned long                                      m_nPreload : 1;                                           // 0x0274(0x0004) (Edit, EditInline)
	unsigned long                                      m_nTaskForce : 1;                                         // 0x0274(0x0004) (Edit, EditInline)
	struct FString                                     m_SpawnPointName;                                         // 0x0278(0x0010) (Edit, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_Instance");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HandleTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgTrigger_Use
// 0x0030 (0x02A0 - 0x0270)
class ATgTrigger_Use : public ATrigger
{
public:
	struct FString                                     m_sDisplayText;                                           // 0x0270(0x0010) (Edit, NeedCtorLink, EditInline)
	struct FString                                     m_sInactiveText;                                          // 0x0280(0x0010) (Edit, NeedCtorLink, EditInline)
	int                                                m_nInteractDistance;                                      // 0x0290(0x0004) (Edit, EditInline)
	unsigned long                                      m_bAimToInteract : 1;                                     // 0x0294(0x0004) (Edit, EditInline)
	int                                                m_nDisplayMsgId;                                          // 0x0298(0x0004) (Edit, EditInline)
	int                                                m_nInactiveMsgId;                                         // 0x029C(0x0004) (Edit, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrigger_Use");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	int STATIC_GetMsgIdToDisplay();
	bool IsUsedEnabled();
	void UsedByPawn(class ATgPawn* User);
};


// Class TgGame.TgLanePylon
// 0x0004 (0x0474 - 0x0470)
class ATgLanePylon : public APylon
{
public:
	int                                                m_nLane;                                                  // 0x0470(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLanePylon");
		return ptr;
	}

};


// Class TgGame.TgTeamBlocker
// 0x0004 (0x027C - 0x0278)
class ATgTeamBlocker : public ATgMeshAssembly
{
public:
	unsigned long                                      m_bBlockFlagCarrier : 1;                                  // 0x0278(0x0004) (Edit)
	unsigned long                                      m_bBlockFriendlyFire : 1;                                 // 0x0278(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeamBlocker");
		return ptr;
	}

};


// Class TgGame.TgDoorMarker
// 0x0020 (0x029C - 0x027C)
class ATgDoorMarker : public ATgTeamBlocker
{
public:
	TEnumAsByte<EDoorStatus>                           r_eStatus;                                                // 0x027C(0x0001) (Net)
	TEnumAsByte<EDoorStatus>                           m_eInitStatus;                                            // 0x027D(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x027E(0x0002) MISSED OFFSET
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x0280(0x0008)
	float                                              m_fProximity;                                             // 0x0288(0x0004) (Edit)
	int                                                m_nTeamThatControlsDoor;                                  // 0x028C(0x0004) (Edit)
	int                                                m_nMeshAssemblyId;                                        // 0x0290(0x0004) (Edit)
	class USkeletalMeshComponent*                      m_DoorSMC;                                                // 0x0294(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDoorMarker");
		return ptr;
	}


	void STATIC_SetDoorStatus(TEnumAsByte<EDoorStatus> eStatus);
	void STATIC_CalculateDoorStatus();
	bool STATIC_ShouldDoorBeClosed();
	bool STATIC_ShouldDoorBeOpened();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ClientOnStatusChange();
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
	void LoadMesh();
};


// Class TgGame.TgNavigationPoint
// 0x0004 (0x035C - 0x0358)
class ATgNavigationPoint : public ANavigationPoint
{
public:
	int                                                m_nMapObjectId;                                           // 0x0358(0x0004) (Edit, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavigationPoint");
		return ptr;
	}

};


// Class TgGame.TgActionPoint
// 0x0008 (0x0364 - 0x035C)
class ATgActionPoint : public ATgNavigationPoint
{
public:
	TEnumAsByte<EeActionPointType>                     ActionType;                                               // 0x035C(0x0001) (Edit)
	unsigned char                                      nObjectiveNum;                                            // 0x035D(0x0001) (Edit)
	unsigned char                                      nTaskForce;                                               // 0x035E(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x035F(0x0001) MISSED OFFSET
	unsigned long                                      bUseRotation : 1;                                         // 0x0360(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgActionPoint");
		return ptr;
	}

};


// Class TgGame.TgBotStart
// 0x0000 (0x035C - 0x035C)
class ATgBotStart : public ATgNavigationPoint
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotStart");
		return ptr;
	}

};


// Class TgGame.TgBotStart_Formation
// 0x0001 (0x035D - 0x035C)
class ATgBotStart_Formation : public ATgBotStart
{
public:
	TEnumAsByte<EBotStartFormation_Position>           m_PositionTag;                                            // 0x035C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotStart_Formation");
		return ptr;
	}

};


// Class TgGame.TgCoverPoint
// 0x0030 (0x038C - 0x035C)
class ATgCoverPoint : public ATgNavigationPoint
{
public:
	unsigned long                                      m_bLeanLeft : 1;                                          // 0x035C(0x0004) (Edit)
	unsigned long                                      m_bLeanRight : 1;                                         // 0x035C(0x0004) (Edit)
	unsigned long                                      m_bAllowPopup : 1;                                        // 0x035C(0x0004) (Edit)
	unsigned long                                      m_bAllowMantle : 1;                                       // 0x035C(0x0004) (Edit)
	struct FVector                                     m_vLeanLeft;                                              // 0x0360(0x000C)
	struct FVector                                     m_vLeanRight;                                             // 0x036C(0x000C)
	struct FVector                                     m_vPopUp;                                                 // 0x0378(0x000C)
	class APawn*                                       m_pClaimedBy;                                             // 0x0384(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCoverPoint");
		return ptr;
	}


	void PostBeginPlay();
	void Claim(class APawn* pClaimedBy);
	class APawn* STATIC_GetClaimedBy();
};


// Class TgGame.TgNavigationPointSpawnable
// 0x0000 (0x035C - 0x035C)
class ATgNavigationPointSpawnable : public ATgNavigationPoint
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavigationPointSpawnable");
		return ptr;
	}

};


// Class TgGame.TgPointOfInterest
// 0x0014 (0x0370 - 0x035C)
class ATgPointOfInterest : public ATgNavigationPoint
{
public:
	int                                                m_nNameMsgId;                                             // 0x035C(0x0004) (Edit)
	struct FString                                     m_sDebugName;                                             // 0x0360(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPointOfInterest");
		return ptr;
	}

};


// Class TgGame.TgNavMeshPath_AlongLane
// 0x0004 (0x007C - 0x0078)
class UTgNavMeshPath_AlongLane : public UNavMeshPathConstraint
{
public:
	int                                                m_nLane;                                                  // 0x0078(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavMeshPath_AlongLane");
		return ptr;
	}


	void Recycle();
	bool AlongLane(class UNavigationHandle* NavHandle, int nLane);
};


// Class TgGame.TgPathfinder
// 0x004C (0x02AC - 0x0260)
class ATgPathfinder : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x0260(0x0008) (Const, Native, NoExport)
	float                                              m_fMaxSpeed;                                              // 0x0268(0x0004) (Edit)
	TArray<struct FVector>                             m_vWaypoints;                                             // 0x026C(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              m_fPathCheckRadius;                                       // 0x027C(0x0004)
	class UNavigationHandle*                           m_NavigationHandle;                                       // 0x0280(0x0008)
	class ASplineActor*                                m_Spline;                                                 // 0x0288(0x0008)
	class ASplineActor*                                m_CurrentSpline;                                          // 0x0290(0x0008)
	float                                              m_fCurrentSplineDist;                                     // 0x0298(0x0004)
	struct FScriptDelegate                             __OnFinishedPathing__Delegate;                            // 0x029C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x029C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPathfinder");
		return ptr;
	}


	void Destroyed();
	void NotifyPathChanged();
	void FindNavHandlePath(class AActor* destActor, float Dist);
	void STATIC_SetupPathProperties(float PathCheckRadius, float PathSpeed);
	void PostBeginPlay();
	bool STATIC_SetRouteTo(class AActor* destActor, bool bDrawDebugPath);
	void OnFinishedPathing();
};


// Class TgGame.TgSkeletalMeshActor
// 0x0044 (0x030C - 0x02C8)
class ATgSkeletalMeshActor : public ASkeletalMeshActor
{
public:
	struct FMeshAssets                                 c_MeshAssets;                                             // 0x02C8(0x0040) (NeedCtorLink)
	unsigned long                                      c_bLoadMeshAssetts : 1;                                   // 0x0308(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor");
		return ptr;
	}


	void DoKismetAttachment(class AActor* Attachment, class USeqAct_AttachToActor* Action);
	void STATIC_OnParentAnimComponent(class UTgSeqAct_ParentAnimComponent* Action);
	void LoadClientOnlyMeshAssets();
	class UMeshComponent* STATIC_CreateMeshComponent(int MeshAsmId, class UMeshComponent* DestComponent, bool bPartialFixup);
	class UTgStaticMeshComponent* STATIC_CreateStaticMeshComponent(int MeshAsmId, class UTgStaticMeshComponent* DestComponent);
	class UTgSkeletalMeshComponent* STATIC_CreateSkeletalMeshComponent(int MeshAsmId, class UTgSkeletalMeshComponent* DestComponent, bool bPartialFixup);
	bool AttachToSocket(class AActor* Attachment, const struct FName& BoneName);
};


// Class TgGame.TgSkeletalMeshActorSpawnable
// 0x0010 (0x031C - 0x030C)
class ATgSkeletalMeshActorSpawnable : public ATgSkeletalMeshActor
{
public:
	TArray<class UParticleSystemComponent*>            c_ManagedPSCs;                                            // 0x030C(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable");
		return ptr;
	}


	void STATIC_EndParticleSystem(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void ForceEndParticleSystems();
	void ManagedParticleSystemFinished(class UParticleSystemComponent* PSC);
	bool PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	bool STATIC_ShouldManageParticleFX(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void STATIC_ForceRecalculateMaterial();
};


// Class TgGame.TgNavRouteIndicator
// 0x004C (0x0368 - 0x031C)
class ATgNavRouteIndicator : public ATgSkeletalMeshActorSpawnable
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;                      // 0x031C(0x0008) (Const, Native, NoExport)
	TArray<struct FVector>                             WayPoints;                                                // 0x0324(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                Position;                                                 // 0x0334(0x0004)
	float                                              m_fPositionStartTime;                                     // 0x0338(0x0004)
	float                                              m_fPositionMaxSeekTime;                                   // 0x033C(0x0004)
	float                                              m_fSpinUpTime;                                            // 0x0340(0x0004)
	float                                              m_fSpinDownTime;                                          // 0x0344(0x0004)
	class UTgSpecialFx*                                m_SpinUpFx;                                               // 0x0348(0x0008)
	class UTgSpecialFx*                                m_PathingFx;                                              // 0x0350(0x0008)
	class UTgSpecialFx*                                m_SpinDownFx;                                             // 0x0358(0x0008)
	class UNavigationHandle*                           NavigationHandle;                                         // 0x0360(0x0008) (EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgNavRouteIndicator");
		return ptr;
	}


	void NotifyPathChanged();
	float STATIC_GetMaxSpeed();
	void STATIC_StartNextPath();
	void STATIC_StartSeeking();
	void FindNavHandlePath(class AActor* destActor, float Dist);
	TEnumAsByte<EeSetRouteResult> STATIC_SetRouteTo(class AActor* destActor);
	void Destroyed();
	void PostBeginPlay();
	void UpdateRotation(float fDeltaSeconds);
	bool AdvanceWayPoint();
	struct FVector STATIC_GetCurrentWayPoint();
	TEnumAsByte<EeSetRouteResult> STATIC_SetRoute(class AActor* destActor);
	void STATIC_DeactivatePathingFx();
	void STATIC_DeactivateFx();
	void ActivatePathingFx();
	void ActivateSpinDownFx();
	void ActivateSpinUpFx();
};


// Class TgGame.TgSplineActor
// 0x0008 (0x02D0 - 0x02C8)
class ATgSplineActor : public ASplineActor
{
public:
	TEnumAsByte<ESplineCartActionPoint>                m_ActionPoint;                                            // 0x02C8(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C9(0x0003) MISSED OFFSET
	unsigned long                                      m_bPreview : 1;                                           // 0x02CC(0x0004) (Edit, Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineActor");
		return ptr;
	}


	void OnSplineActorReached(class ATgPawn_SplineCart* Other);
	float STATIC_DistanceToActionPoint(TEnumAsByte<ESplineCartActionPoint> ActionPoint);
	float STATIC_DistanceToEndOfSplineChain();
	void UpdateSplineComponents();
};


// Class TgGame.TgStartPoint
// 0x0034 (0x039C - 0x0368)
class ATgStartPoint : public APlayerStart
{
public:
	int                                                m_nMapObjectId;                                           // 0x0368(0x0004) (Edit, EditConst)
	int                                                m_nStartGroup;                                            // 0x036C(0x0004) (Edit)
	int                                                m_nReturnMapType;                                         // 0x0370(0x0004) (Edit)
	float                                              m_fStartRating;                                           // 0x0374(0x0004) (Edit)
	float                                              m_fCurrentRating;                                         // 0x0378(0x0004) (Edit)
	float                                              m_fResetRating;                                           // 0x037C(0x0004) (Edit)
	float                                              m_fDecreaseRate;                                          // 0x0380(0x0004) (Edit)
	TArray<class UClass*>                              m_ArrayOfFloats;                                          // 0x0384(0x0010) (Edit, NeedCtorLink)
	class ATgTeleporter*                               m_TgTeleporter;                                           // 0x0394(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStartPoint");
		return ptr;
	}


	int STATIC_GetStartGroupNumber();
	void AdjustRating();
	float STATIC_GetRating(class AController* Player);
	void PreBeginPlay();
	void LoadObjectConfig();
};


// Class TgGame.TgTeamPlayerStart
// 0x0034 (0x03D0 - 0x039C)
class ATgTeamPlayerStart : public ATgStartPoint
{
public:
	unsigned char                                      m_nTaskForce;                                             // 0x039C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x039D(0x0003) MISSED OFFSET
	int                                                m_nPriority;                                              // 0x03A0(0x0004) (Edit)
	int                                                nPrevPriority;                                            // 0x03A4(0x0004) (Edit)
	int                                                m_nTeamIndex;                                             // 0x03A8(0x0004) (Edit)
	int                                                m_nMinLevel;                                              // 0x03AC(0x0004) (EditConst)
	class ATgPawn*                                     s_pawnOwner;                                              // 0x03B0(0x0008)
	TArray<TScriptInterface<class UTgOwnedPlaceableMesh>> c_OwnedMeshActors;                                        // 0x03B8(0x0010) (NeedCtorLink)
	class ATgRepInfo_OwnedMesh*                        r_OMRI;                                                   // 0x03C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeamPlayerStart");
		return ptr;
	}


	void ClearOwnedMeshRepInfo();
	class ATgRepInfo_OwnedMesh* SpawnOwnedMeshRepInfo();
	void STATIC_SetPawnOwner(class ATgPawn* tgPawnOwner);
	void RegisterOwnedPlaceableMesh(const TScriptInterface<class UTgOwnedPlaceableMesh>& tgMeshActor);
	float STATIC_GetRating(class AController* Player);
	void LoadObjectConfig();
};


// Class TgGame.TgDynamicSpawnPoint
// 0x003C (0x040C - 0x03D0)
class ATgDynamicSpawnPoint : public ATgTeamPlayerStart
{
public:
	unsigned long                                      m_bInitialSpawn : 1;                                      // 0x03D0(0x0004) (Edit)
	unsigned long                                      s_bTF1Near : 1;                                           // 0x03D0(0x0004)
	unsigned long                                      s_bTF1Visible : 1;                                        // 0x03D0(0x0004)
	unsigned long                                      s_bTF2Near : 1;                                           // 0x03D0(0x0004)
	unsigned long                                      s_bTF2Visible : 1;                                        // 0x03D0(0x0004)
	int                                                m_nFriendlyWeight;                                        // 0x03D4(0x0004) (Edit)
	int                                                m_nEnemyWeight;                                           // 0x03D8(0x0004) (Edit)
	float                                              m_fDetectRadius;                                          // 0x03DC(0x0004) (Edit)
	int                                                m_nNearbyFriendlyWeight;                                  // 0x03E0(0x0004) (Edit)
	int                                                m_nNearbyEnemyWeight;                                     // 0x03E4(0x0004) (Edit)
	int                                                m_nEnemyLOSWeight;                                        // 0x03E8(0x0004) (Edit)
	int                                                m_nRecentUseWeight;                                       // 0x03EC(0x0004) (Edit)
	float                                              m_fRecentUseTime;                                         // 0x03F0(0x0004) (Edit)
	float                                              m_fDeathRadius;                                           // 0x03F4(0x0004) (Edit)
	int                                                m_nNearbyDeathWeight;                                     // 0x03F8(0x0004) (Edit)
	int                                                m_nInitialDistanceWeight;                                 // 0x03FC(0x0004) (Edit)
	float                                              m_fMaxDistanceWeightRadius;                               // 0x0400(0x0004) (Edit)
	float                                              s_fLastUseTime;                                           // 0x0404(0x0004)
	float                                              s_fDetectRadiusSquared;                                   // 0x0408(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDynamicSpawnPoint");
		return ptr;
	}


	float GetScoreFor(class ATgPawn* Target, const struct FVector& vDeathLoc);
	void STATIC_RecalcBaseWeight();
	void STATIC_SpawnUsed();
	void PostBeginPlay();
	bool STATIC_HasLineOfSightTo(class AActor* Target);
};


// Class TgGame.TgTeleporter
// 0x000E (0x0392 - 0x0384)
class ATgTeleporter : public ATeleporter
{
public:
	int                                                m_nMapObjectId;                                           // 0x0384(0x0004) (Edit, EditConst)
	int                                                m_nMapId;                                                 // 0x0388(0x0004) (Edit, EditConst)
	unsigned long                                      m_nPreload : 1;                                           // 0x038C(0x0004) (Edit, EditConst)
	unsigned long                                      m_bSetTaskForce : 1;                                      // 0x038C(0x0004) (Edit, EditConst)
	unsigned long                                      m_bBalanceTaskForce : 1;                                  // 0x038C(0x0004) (Edit, EditConst)
	unsigned long                                      m_bIgnoreNonMembers : 1;                                  // 0x038C(0x0004) (Edit, EditConst)
	unsigned long                                      m_bUsePlayerStart : 1;                                    // 0x038C(0x0004) (Edit, EditConst)
	unsigned long                                      m_bRequestMission : 1;                                    // 0x038C(0x0004) (Edit, EditConst)
	unsigned char                                      m_nStartGroup;                                            // 0x0390(0x0001) (Edit, EditConst)
	unsigned char                                      m_nTaskForce;                                             // 0x0391(0x0001) (Edit, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeleporter");
		return ptr;
	}


	bool UsePlayerStart(class AActor* Other);
	void PostTouch(class AActor* Other);
	void PostBeginPlay();
	void PreBeginPlay();
	void LoadObjectConfig();
	bool STATIC_HandlePostTouch(class AActor* Other);
};


// Class TgGame.TgExecuteVictimInterface
// 0x0000 (0x0060 - 0x0060)
class UTgExecuteVictimInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgExecuteVictimInterface");
		return ptr;
	}


	bool STATIC_CanBeExecuted();
};


// Class TgGame.TgFadingStaticMeshActor
// 0x0020 (0x0294 - 0x0274)
class ATgFadingStaticMeshActor : public AStaticMeshActor
{
public:
	unsigned long                                      m_bFaded : 1;                                             // 0x0274(0x0004) (Transient)
	unsigned long                                      bShowFadedInEditor : 1;                                   // 0x0274(0x0004) (Edit)
	float                                              m_fFadeProgress;                                          // 0x0278(0x0004) (Transient)
	float                                              FadeOutTime;                                              // 0x027C(0x0004) (Edit, Const)
	float                                              FadeInTime;                                               // 0x0280(0x0004) (Edit, Const)
	class UMaterialInterface*                          FadingMaterial;                                           // 0x0284(0x0008) (Edit, Const)
	class UStaticMeshComponent*                        m_FadingStaticMeshComponent;                              // 0x028C(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFadingStaticMeshActor");
		return ptr;
	}


	void STATIC_SetFading(bool bShouldBeFaded, bool bImmediate);
	void UpdateFadeStatus(float DeltaTime);
};


// Class TgGame.TgMeshPool
// 0x0034 (0x0094 - 0x0060)
class UTgMeshPool : public UObject
{
public:
	TArray<struct FMeshPool>                           m_meshPools;                                              // 0x0060(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_pawnInstigator;                                         // 0x0070(0x0008) (Const)
	class ATgPawn*                                     m_pawnMeshOwner;                                          // 0x0078(0x0008) (Const)
	class UClass*                                      m_classMeshType;                                          // 0x0080(0x0008) (Const)
	int                                                m_nPoolPopulateSize;                                      // 0x0088(0x0004) (Const)
	int                                                m_nPoolCount;                                             // 0x008C(0x0004) (Const)
	unsigned long                                      m_bCreateNewMeshesAsNeeded : 1;                           // 0x0090(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMeshPool");
		return ptr;
	}


	void STATIC_CleanupPools();
	void STATIC_ReturnMeshToPool(class ATgSkeletalMeshActorSpawnable* Mesh, unsigned char nPoolType);
	class ATgSkeletalMeshActorSpawnable* STATIC_ObtainMeshFromPool(unsigned char nPoolType);
	void STATIC_InitializePools(class ATgPawn* pawnInstigator, class ATgPawn* PawnOwner);
};


// Class TgGame.TgOwnedPlaceableMesh
// 0x0000 (0x0060 - 0x0060)
class UTgOwnedPlaceableMesh : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgOwnedPlaceableMesh");
		return ptr;
	}


	bool IsLinkedToTaskForce(int nTaskForce);
	int STATIC_GetDefaultMeshId();
	void STATIC_SetNewMeshAssembly(int nMshAsm);
	void STATIC_SetActorOwner(class ATgPawn* tgOwner);
	TEnumAsByte<EOwnedMeshSkinType> STATIC_GetSkinType();
};


// Class TgGame.TgPawn
// 0x1E84 (0x2400 - 0x057C)
class ATgPawn : public AGamePawn
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterface;                                 // 0x057C(0x0008) (Const, Native, NoExport)
	int                                                r_nMovementState;                                         // 0x0584(0x0004) (Net)
	struct FVector                                     r_vPhysTweenTarget;                                       // 0x0588(0x000C) (Net)
	class ATgPawn*                                     r_pawnPhysTweenInstigator;                                // 0x0594(0x0008) (Net)
	TEnumAsByte<ETweenState>                           r_eTweenState;                                            // 0x059C(0x0001) (Net)
	TEnumAsByte<ETweenState>                           m_eLocalTweenState;                                       // 0x059D(0x0001)
	TEnumAsByte<ELevitateType>                         r_LevitationType;                                         // 0x059E(0x0001) (Net, Transient)
	unsigned char                                      s_BitPackedHitReaction;                                   // 0x059F(0x0001)
	TEnumAsByte<EGrabState>                            r_eGrabState;                                             // 0x05A0(0x0001) (Net)
	TEnumAsByte<EGrabState>                            m_eLocalGrabState;                                        // 0x05A1(0x0001)
	TEnumAsByte<EChargeState>                          r_eChargeState;                                           // 0x05A2(0x0001) (Net)
	unsigned char                                      m_nBlockingBitCounter[0x8];                               // 0x05A3(0x0001)
	unsigned char                                      r_bIgnoreBlockingFlags;                                   // 0x05AB(0x0001) (Net)
	TEnumAsByte<ECollisionTransitionState>             s_eCollisionTransition;                                   // 0x05AC(0x0001)
	TEnumAsByte<EEmote>                                c_eCurrentActiveEmote;                                    // 0x05AD(0x0001)
	unsigned char                                      c_nActiveEmoteReplayState;                                // 0x05AE(0x0001)
	unsigned char                                      r_nSkinLevel;                                             // 0x05AF(0x0001) (Net)
	TEnumAsByte<ESkinLevelMechanic>                    c_SkinLevelMechanic;                                      // 0x05B0(0x0001)
	TEnumAsByte<ETG_DEATH_REASON>                      r_eDeathReason;                                           // 0x05B1(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eDesiredInHand;                                         // 0x05B2(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eEquippedInHand;                                        // 0x05B3(0x0001)
	TEnumAsByte<ETargetingPreviewStyle>                c_GroundTargetPreviewStyle;                               // 0x05B4(0x0001)
	TEnumAsByte<ETargetingLineStyle>                   c_GroundTargetRulerStyle;                                 // 0x05B5(0x0001)
	unsigned char                                      m_byFlashNextUpValue;                                     // 0x05B6(0x0001)
	TEnumAsByte<ESTEALTH_TYPE>                         r_eIsStealthed;                                           // 0x05B7(0x0001) (Net)
	TEnumAsByte<ETG_POSTURE>                           m_ePosture;                                               // 0x05B8(0x0001)
	unsigned char                                      m_byPushbackCompletedCounter;                             // 0x05B9(0x0001)
	TEnumAsByte<EStunType>                             r_eCurrentStunType;                                       // 0x05BA(0x0001) (Net)
	TEnumAsByte<EOverlayMICType>                       m_OverlayCurrentType;                                     // 0x05BB(0x0001)
	TEnumAsByte<EHitReactionType>                      r_HitReactionType;                                        // 0x05BC(0x0001) (Edit, Net)
	TEnumAsByte<ETweenState>                           m_MegaKillTweenState;                                     // 0x05BD(0x0001)
	TEnumAsByte<ETG_DEATH_REASON>                      m_MegaKillDeathReason;                                    // 0x05BE(0x0001)
	unsigned char                                      m_nIsInIntroState;                                        // 0x05BF(0x0001)
	float                                              m_fPhysTweenDist;                                         // 0x05C0(0x0004)
	float                                              r_fPhysTweenDuration;                                     // 0x05C4(0x0004) (Net)
	int                                                m_nPhysTweenPostureId;                                    // 0x05C8(0x0004)
	unsigned long                                      r_bPhysTweenInterrupted : 1;                              // 0x05CC(0x0004) (Net)
	unsigned long                                      m_InLevitation : 1;                                       // 0x05CC(0x0004)
	unsigned long                                      m_bInAutoSkillUp : 1;                                     // 0x05CC(0x0004)
	unsigned long                                      s_bIsKnockedUp : 1;                                       // 0x05CC(0x0004)
	unsigned long                                      r_bIsKnockedStraightBack : 1;                             // 0x05CC(0x0004) (Net)
	unsigned long                                      s_bIsHercSpecialKnockedUp : 1;                            // 0x05CC(0x0004)
	unsigned long                                      r_bIsSuspended : 1;                                       // 0x05CC(0x0004) (Net)
	unsigned long                                      r_bGrabInterrupted : 1;                                   // 0x05CC(0x0004) (Net)
	unsigned long                                      m_PreGrabCollideActors : 1;                               // 0x05CC(0x0004)
	unsigned long                                      m_PreGrabBlockActors : 1;                                 // 0x05CC(0x0004)
	unsigned long                                      s_bIsMidStartGrab : 1;                                    // 0x05CC(0x0004)
	unsigned long                                      r_bChargeIgnoreHumanoidBlocking : 1;                      // 0x05CC(0x0004) (Net)
	unsigned long                                      m_bWantsCharge : 1;                                       // 0x05CC(0x0004)
	unsigned long                                      m_bForceIgnoreBlockingFalse : 1;                          // 0x05CC(0x0004)
	unsigned long                                      s_bDestroysWalls : 1;                                     // 0x05CC(0x0004)
	unsigned long                                      m_bHasDestroyedMesh : 1;                                  // 0x05CC(0x0004)
	unsigned long                                      c_bSkinLevelFxPlayed : 1;                                 // 0x05CC(0x0004)
	unsigned long                                      c_bGlobalEmoteUsed : 1;                                   // 0x05CC(0x0004)
	unsigned long                                      m_bVXGUsesSupress : 1;                                    // 0x05CC(0x0004)
	unsigned long                                      m_bAffectedByVortices : 1;                                // 0x05CC(0x0004)
	unsigned long                                      s_LoadMeshServerSide : 1;                                 // 0x05CC(0x0004)
	unsigned long                                      c_bDeviceHiddenDueToFullBodyAnim : 1;                     // 0x05CC(0x0004)
	unsigned long                                      c_bMeshHiddenDueToDeath : 1;                              // 0x05CC(0x0004)
	unsigned long                                      c_bHideMeshFromCameraPenetration : 1;                     // 0x05CC(0x0004)
	unsigned long                                      m_bNeverHideFromCameraPenetration : 1;                    // 0x05CC(0x0004)
	unsigned long                                      c_bMeshHiddenDueToAbility : 1;                            // 0x05CC(0x0004)
	unsigned long                                      r_bInGlobalOffhandCooldown : 1;                           // 0x05CC(0x0004) (Net)
	unsigned long                                      bInGlobalOffhandCooldownClient : 1;                       // 0x05CC(0x0004)
	unsigned long                                      m_bInFireLock : 1;                                        // 0x05CC(0x0004)
	unsigned long                                      r_bOffhandFireLock : 1;                                   // 0x05CC(0x0004) (Net)
	unsigned long                                      m_bClampAttackDamage : 1;                                 // 0x05CC(0x0004) (Const)
	unsigned long                                      bCanLeavePathNetwork : 1;                                 // 0x05CC(0x0004)
	unsigned long                                      r_bVisibilityRestricted : 1;                              // 0x05D0(0x0004) (Net)
	unsigned long                                      m_bPreProcessPendingHits : 1;                             // 0x05D0(0x0004)
	unsigned long                                      c_bIsVolumeStealthed : 1;                                 // 0x05D0(0x0004)
	unsigned long                                      c_bInAStealthVolume : 1;                                  // 0x05D0(0x0004)
	unsigned long                                      m_bPlayingStealth : 1;                                    // 0x05D0(0x0004)
	unsigned long                                      m_bPlayingDetected : 1;                                   // 0x05D0(0x0004)
	unsigned long                                      c_bHiddenDueToStealth : 1;                                // 0x05D0(0x0004)
	unsigned long                                      m_bApplyDistanceFade : 1;                                 // 0x05D0(0x0004)
	unsigned long                                      r_bIsBot : 1;                                             // 0x05D0(0x0004) (Net)
	unsigned long                                      s_bInvisibleToPets : 1;                                   // 0x05D0(0x0004)
	unsigned long                                      s_bCanSeePets : 1;                                        // 0x05D0(0x0004)
	unsigned long                                      c_bIsFrametestZombie : 1;                                 // 0x05D0(0x0004) (Transient)
	unsigned long                                      m_bTargetModifierReached : 1;                             // 0x05D0(0x0004)
	unsigned long                                      m_bIgnoreSpeedDiminishingReturns : 1;                     // 0x05D0(0x0004)
	unsigned long                                      r_bIsAnimInStrafeMode : 1;                                // 0x05D0(0x0004) (Net)
	unsigned long                                      m_ReachedTargetSoKillRootMotion : 1;                      // 0x05D0(0x0004)
	unsigned long                                      s_bCanApplyEffects : 1;                                   // 0x05D0(0x0004)
	unsigned long                                      m_bInitialized : 1;                                       // 0x05D0(0x0004)
	unsigned long                                      m_bWantsDeathAim : 1;                                     // 0x05D0(0x0004)
	unsigned long                                      m_bUseInterrupted : 1;                                    // 0x05D0(0x0004)
	unsigned long                                      c_bIgnoreInterruption : 1;                                // 0x05D0(0x0004)
	unsigned long                                      r_bNoEnergyCost : 1;                                      // 0x05D0(0x0004) (Net)
	unsigned long                                      r_bCheatUseNoEnergy : 1;                                  // 0x05D0(0x0004) (Net)
	unsigned long                                      m_bCheatNoRecharge : 1;                                   // 0x05D0(0x0004)
	unsigned long                                      m_bIsInvisibleToAI : 1;                                   // 0x05D0(0x0004)
	unsigned long                                      m_bIsHittableToAI : 1;                                    // 0x05D0(0x0004)
	unsigned long                                      m_bIsHittableToSpecialAI : 1;                             // 0x05D0(0x0004)
	unsigned long                                      m_bTargetable : 1;                                        // 0x05D0(0x0004)
	unsigned long                                      r_bInCombatFlag : 1;                                      // 0x05D0(0x0004) (Net)
	unsigned long                                      r_bIsAFK : 1;                                             // 0x05D0(0x0004) (Net)
	unsigned long                                      c_bHandIKEnabledFromAnimSet : 1;                          // 0x05D0(0x0004)
	unsigned long                                      c_bCanDoTurnInPlaceAnim : 1;                              // 0x05D0(0x0004)
	unsigned long                                      c_bIsPlayingTurnAnim : 1;                                 // 0x05D4(0x0004)
	unsigned long                                      m_bCanBeKnockedBack : 1;                                  // 0x05D4(0x0004)
	unsigned long                                      m_bCanBePushedBack : 1;                                   // 0x05D4(0x0004)
	unsigned long                                      m_bCausesPushblock : 1;                                   // 0x05D4(0x0004)
	unsigned long                                      m_bPushblockAffectsFriendlies : 1;                        // 0x05D4(0x0004)
	unsigned long                                      m_bPushblockAffectsEnemies : 1;                           // 0x05D4(0x0004)
	unsigned long                                      m_bUseSmoothNetReceiveRotation : 1;                       // 0x05D4(0x0004)
	unsigned long                                      c_bUpdateSkelMeshWhenNotRendered : 1;                     // 0x05D4(0x0004)
	unsigned long                                      r_bSilenced : 1;                                          // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bBeadsSilenced : 1;                                     // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bDisarmed : 1;                                          // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bCrippled : 1;                                          // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bIsInStasis : 1;                                        // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bCanBePulled : 1;                                       // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bCanBeVortexed : 1;                                     // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bCanBeHardDisplaced : 1;                                // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bCanSlide : 1;                                          // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bCanBreakableTweenHit : 1;                              // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bCanBreakableGrabHit : 1;                               // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bImmortal : 1;                                          // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bCannotUseAutoPortal : 1;                               // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bIsPreparingTeleport : 1;                               // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bAnyoneCanCrit : 1;                                     // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bIsEntrapped : 1;                                       // 0x05D4(0x0004) (Net)
	unsigned long                                      s_bHasCrippleEffect : 1;                                  // 0x05D4(0x0004)
	unsigned long                                      c_bEnemyMatLoaded : 1;                                    // 0x05D4(0x0004)
	unsigned long                                      r_bIsJumping : 1;                                         // 0x05D4(0x0004) (Net)
	unsigned long                                      s_bApplyHealthCap : 1;                                    // 0x05D4(0x0004)
	unsigned long                                      r_bIsIntoxicated : 1;                                     // 0x05D4(0x0004) (Net)
	unsigned long                                      r_bIsSliding : 1;                                         // 0x05D4(0x0004) (Net)
	unsigned long                                      c_bServerEndedSlide : 1;                                  // 0x05D4(0x0004)
	unsigned long                                      bHasPlayedDeathAnimation : 1;                             // 0x05D4(0x0004)
	unsigned long                                      r_bApplyWhiteoutHUDFx : 1;                                // 0x05D8(0x0004) (Net)
	unsigned long                                      r_bApplyFogHUDFx : 1;                                     // 0x05D8(0x0004) (Net)
	unsigned long                                      r_bApplyEmotePostProcessFx : 1;                           // 0x05D8(0x0004) (Net)
	unsigned long                                      r_bEmotePostProcessFxWasActive : 1;                       // 0x05D8(0x0004) (Net)
	unsigned long                                      r_bTeleportIncoming : 1;                                  // 0x05D8(0x0004) (Net)
	unsigned long                                      c_bHiddenDueToRelevancy : 1;                              // 0x05D8(0x0004) (Transient)
	unsigned long                                      m_bForceDeathAnim : 1;                                    // 0x05D8(0x0004)
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                           // 0x05D8(0x0004)
	unsigned long                                      r_bNeedPlaySpawnFx : 1;                                   // 0x05D8(0x0004) (Net)
	unsigned long                                      c_bSpawnFxPlayed : 1;                                     // 0x05D8(0x0004)
	unsigned long                                      c_bTargeted : 1;                                          // 0x05D8(0x0004)
	unsigned long                                      c_bTargetedLightup : 1;                                   // 0x05D8(0x0004)
	unsigned long                                      r_bAcceptsTargeting : 1;                                  // 0x05D8(0x0004) (Net)
	unsigned long                                      c_bShowDecalRing : 1;                                     // 0x05D8(0x0004)
	unsigned long                                      c_bShowTargetedRing : 1;                                  // 0x05D8(0x0004)
	unsigned long                                      c_bTargetedRingActive : 1;                                // 0x05D8(0x0004)
	unsigned long                                      c_bApplyDropShadow : 1;                                   // 0x05D8(0x0004)
	unsigned long                                      s_bIsHealStealing : 1;                                    // 0x05D8(0x0004)
	unsigned long                                      m_bBlockFallingPawns : 1;                                 // 0x05D8(0x0004)
	unsigned long                                      m_bForceBlockActors : 1;                                  // 0x05D8(0x0004)
	unsigned long                                      r_bOverrideFixedPitchMode : 1;                            // 0x05D8(0x0004) (Net)
	unsigned long                                      r_bForceIgnoreFaceRot : 1;                                // 0x05D8(0x0004) (Net)
	unsigned long                                      m_bShowNameplate : 1;                                     // 0x05D8(0x0004)
	unsigned long                                      r_bHiddenDueToRevive : 1;                                 // 0x05D8(0x0004) (Net)
	unsigned long                                      r_bHiddenDueToPolymorph : 1;                              // 0x05D8(0x0004) (Net)
	unsigned long                                      r_bHiddenDueToPolymorphHera : 1;                          // 0x05D8(0x0004) (Net)
	unsigned long                                      r_bInitialIsEnemy : 1;                                    // 0x05D8(0x0004) (Net)
	unsigned long                                      c_bNeedsAssetLoad : 1;                                    // 0x05D8(0x0004)
	unsigned long                                      m_bTiDiAffectsEffectManager : 1;                          // 0x05D8(0x0004)
	unsigned long                                      r_bDebugShowAIDebug : 1;                                  // 0x05D8(0x0004) (Net)
	unsigned long                                      m_bDebugShowVisionRange : 1;                              // 0x05D8(0x0004)
	unsigned long                                      m_SwapToDestroyedMeshOnTick : 1;                          // 0x05D8(0x0004)
	unsigned long                                      m_bUsesBaseMagicalScaling : 1;                            // 0x05DC(0x0004)
	unsigned long                                      m_bUsesBasePhysicalScaling : 1;                           // 0x05DC(0x0004)
	unsigned long                                      m_bBlockCamera : 1;                                       // 0x05DC(0x0004) (Edit)
	unsigned long                                      m_bOverlaysVisible : 1;                                   // 0x05DC(0x0004)
	unsigned long                                      m_bForceFullOverlayMesh : 1;                              // 0x05DC(0x0004)
	unsigned long                                      c_bUsesGenericPIP : 1;                                    // 0x05DC(0x0004)
	unsigned long                                      m_bIgnoreTearOffMomentum : 1;                             // 0x05DC(0x0004) (Edit)
	unsigned long                                      m_bAcceptsHitReactions : 1;                               // 0x05DC(0x0004) (Edit)
	unsigned long                                      m_bIsFadingOut : 1;                                       // 0x05DC(0x0004)
	unsigned long                                      m_bUseDamageTypeForDeathAnim : 1;                         // 0x05DC(0x0004)
	unsigned long                                      m_bAllowRagdollDeathAnim : 1;                             // 0x05DC(0x0004)
	unsigned long                                      r_bDemoCanPurchaseItems : 1;                              // 0x05DC(0x0004) (Net)
	unsigned long                                      m_bCanPurchaseExtraConsumables : 1;                       // 0x05DC(0x0004) (Const)
	unsigned long                                      s_bHasInteractedWithStore : 1;                            // 0x05DC(0x0004)
	unsigned long                                      m_bDoSmoothCorrectionThisTick : 1;                        // 0x05DC(0x0004)
	unsigned long                                      m_bShouldCommunicateWithBotFactory : 1;                   // 0x05DC(0x0004) (Const)
	unsigned long                                      m_bInMegaKill : 1;                                        // 0x05DC(0x0004)
	unsigned long                                      m_bMegaKillShouldKill : 1;                                // 0x05DC(0x0004)
	unsigned long                                      r_bAllowCombatDuringIntro : 1;                            // 0x05DC(0x0004) (Edit, Net)
	unsigned long                                      r_bFirstSpawnWave : 1;                                    // 0x05DC(0x0004) (Net)
	unsigned long                                      m_bWaitForIntroAnimToEnd : 1;                             // 0x05DC(0x0004)
	unsigned long                                      m_bIntroAnimFinished : 1;                                 // 0x05DC(0x0004)
	unsigned long                                      m_bAllowIntroWhiteOut : 1;                                // 0x05DC(0x0004)
	unsigned long                                      m_bIntroWhiteOutActive : 1;                               // 0x05DC(0x0004)
	unsigned long                                      m_bTutorialPlayerKillOnly : 1;                            // 0x05DC(0x0004)
	unsigned long                                      m_bSpectatorHideOverlayMesh : 1;                          // 0x05DC(0x0004)
	unsigned long                                      r_bCanBeSpectated : 1;                                    // 0x05DC(0x0004) (Net)
	unsigned long                                      s_bCanAssistScorer : 1;                                   // 0x05DC(0x0004)
	unsigned long                                      s_bInKumbhakarnaUltKnockup : 1;                           // 0x05DC(0x0004)
	unsigned long                                      m_bShowEnergyOnUI : 1;                                    // 0x05DC(0x0004)
	unsigned long                                      m_bRelevantIntro : 1;                                     // 0x05DC(0x0004)
	unsigned long                                      m_original_bAlwaysRelevant : 1;                           // 0x05DC(0x0004)
	unsigned long                                      m_original_bApplyDistanceFade : 1;                        // 0x05E0(0x0004)
	unsigned long                                      r_bG84Debug : 1;                                          // 0x05E0(0x0004) (Net)
	unsigned long                                      r_bInBlinkLockout : 1;                                    // 0x05E0(0x0004) (Net)
	unsigned long                                      r_bPreformPhysicTweeningSimulated : 1;                    // 0x05E0(0x0004) (Net)
	unsigned long                                      s_bIsOrbiting : 1;                                        // 0x05E0(0x0004)
	class AActor*                                      r_TweenTarget;                                            // 0x05E4(0x0008) (Net)
	struct FName                                       r_TweenSocketTarget;                                      // 0x05EC(0x0008) (Net)
	struct FVector                                     r_vInitialCircularTweenDir;                               // 0x05F4(0x000C)
	TArray<class ATgPawn*>                             m_ChainedTweenInstigators;                                // 0x0600(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<ETweenState>>                   m_eChainedTweenStates;                                    // 0x0610(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fChainedTweenDurations;                                 // 0x0620(0x0010) (NeedCtorLink)
	class ATgPawn*                                     s_KnockUpInitiator;                                       // 0x0630(0x0008)
	struct FGravityModifierInfo                        r_HercSmashGravityModifier;                               // 0x0638(0x0008) (Net)
	class ATgPawn*                                     s_DeathCachedKnockupInitiator;                            // 0x0640(0x0008)
	int                                                r_nSuspendedByGodID;                                      // 0x0648(0x0004) (Net)
	class ATgPawn*                                     r_GrabSource;                                             // 0x064C(0x0008) (Net)
	float                                              r_fGrabDuration;                                          // 0x0654(0x0004) (Net)
	struct FName                                       r_GrabAttachSocket;                                       // 0x0658(0x0008) (Net)
	struct FVector                                     r_vGrabLocationOffset;                                    // 0x0660(0x000C) (Net)
	struct FRotator                                    r_rGrabRotationOffset;                                    // 0x066C(0x000C) (Net)
	struct FVector                                     m_vGrabDestRelLocation;                                   // 0x0678(0x000C)
	struct FRotator                                    m_rGrabDestRelRotation;                                   // 0x0684(0x000C)
	int                                                m_nPhysGrabPostureId;                                     // 0x0690(0x0004)
	TArray<class ATgPawn*>                             s_ConnectedGrabChain;                                     // 0x0694(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             s_GrabbedTargets;                                         // 0x06A4(0x0010) (NeedCtorLink)
	int                                                r_nCannotBeGrabSource;                                    // 0x06B4(0x0004) (Net)
	struct FVector                                     m_vLastValidGrabLoc;                                      // 0x06B8(0x000C)
	TArray<class AActor*>                              m_TeleportNotifyList;                                     // 0x06C4(0x0010) (NeedCtorLink)
	float                                              r_fChargeInitialYaw;                                      // 0x06D4(0x0004) (Net)
	struct FVector                                     r_vChargeInitialLocation;                                 // 0x06D8(0x000C) (Net)
	float                                              r_fChargeSpeed;                                           // 0x06E4(0x0004) (Net)
	float                                              r_fChargeRange;                                           // 0x06E8(0x0004) (Net)
	class ATgPawn*                                     r_ChargeTarget;                                           // 0x06EC(0x0008) (Net)
	int                                                m_nBodyMeshAsmId;                                         // 0x06F4(0x0004)
	struct FPointer                                    m_BodyMeshAssembly;                                       // 0x06F8(0x0008) (Native)
	struct FPointer                                    m_DestroyedMeshAssembly;                                  // 0x0700(0x0008) (Native)
	int                                                r_nPawnId;                                                // 0x0708(0x0004) (Net)
	float                                              c_fLastUpdateTime;                                        // 0x070C(0x0004)
	class ATgEffectManager*                            r_EffectManager;                                          // 0x0710(0x0008) (Net)
	TArray<struct FTgPropertyInstance>                 m_Properties;                                             // 0x0718(0x0010) (NeedCtorLink)
	class UTgEffectGroup*                              s_ProcessingDamageEffectGroup;                            // 0x0728(0x0008)
	float                                              r_CurrentPropValues[0x72];                                // 0x0730(0x0004) (Net)
	float                                              s_DefaultPropValues[0x72];                                // 0x08F8(0x0004)
	float                                              r_fCachedMaxHealth;                                       // 0x0AC0(0x0004) (Net)
	float                                              r_fCachedMaxMana;                                         // 0x0AC4(0x0004) (Net)
	TArray<int>                                        m_nAdditionalAttackProperties;                            // 0x0AC8(0x0010) (NeedCtorLink)
	float                                              s_fGodKillEmoteTime;                                      // 0x0AD8(0x0004)
	class UTgEmoteConfigResource*                      m_EmoteConfig;                                            // 0x0ADC(0x0008)
	int                                                r_nProfileId;                                             // 0x0AE4(0x0004) (Net)
	int                                                r_nSettingsOverrideId;                                    // 0x0AE8(0x0004) (Net)
	int                                                c_nSavedSkinId;                                           // 0x0AEC(0x0004)
	int                                                c_nSavedSkinLevel;                                        // 0x0AF0(0x0004)
	int                                                r_nSkinId;                                                // 0x0AF4(0x0004) (Net)
	int                                                r_nWardSkinId;                                            // 0x0AF8(0x0004) (Net)
	int                                                r_nRecallSkinId;                                          // 0x0AFC(0x0004) (Net)
	int                                                r_nJumpStampSkinId;                                       // 0x0B00(0x0004) (Net)
	int                                                r_nLevelUpSkinId;                                         // 0x0B04(0x0004) (Net)
	int                                                r_nInStoreSkinId;                                         // 0x0B08(0x0004) (Net)
	int                                                r_nTeamBadgeSkinId;                                       // 0x0B0C(0x0004) (Net)
	int                                                r_nDeathStampSkinId;                                      // 0x0B10(0x0004) (Net)
	int                                                r_nPlayerTitleMsgId;                                      // 0x0B14(0x0004) (Net)
	struct FDeathStampFlashInfo                        r_DeathStampFlashInfo;                                    // 0x0B18(0x0008) (Net)
	float                                              m_fSkinLevelDelay;                                        // 0x0B20(0x0004)
	float                                              m_fSkinLevelWindTime;                                     // 0x0B24(0x0004)
	float                                              m_fSkinLevelFxPoint;                                      // 0x0B28(0x0004)
	float                                              c_fSkinLevelDelayProgress;                                // 0x0B2C(0x0004)
	struct FName                                       m_SkinLevelMaterialParamName;                             // 0x0B30(0x0008)
	int                                                c_nSkinLevelUpFxId;                                       // 0x0B38(0x0004)
	class UTgSpecialFx*                                c_SkinLevelUpFx;                                          // 0x0B3C(0x0008) (Transient)
	TArray<int>                                        m_nSkinLevelGates;                                        // 0x0B44(0x0010) (NeedCtorLink)
	struct FGlobalEmoteInfo                            c_NextGlobalEmoteInfo;                                    // 0x0B54(0x0008)
	struct FGlobalEmoteInfo                            r_GlobalEmoteInfo;                                        // 0x0B5C(0x0008) (Net)
	class UTgSpecialFx*                                c_GlobalEmoteFx;                                          // 0x0B64(0x0008) (Transient)
	float                                              m_fGlobalEmoteSupressTime;                                // 0x0B6C(0x0004) (Const)
	float                                              m_fGlobalEmoteNextCastTime;                               // 0x0B70(0x0004)
	float                                              m_fVXGNextCastTime;                                       // 0x0B74(0x0004)
	float                                              m_fVXGSupressTime;                                        // 0x0B78(0x0004)
	int                                                r_nAnnouncerPackId;                                       // 0x0B7C(0x0004) (Net)
	float                                              s_nSpawnTime;                                             // 0x0B80(0x0004)
	int                                                r_nPhysicalType;                                          // 0x0B84(0x0004) (Net)
	TArray<class AActor*>                              m_CurrentVortexList;                                      // 0x0B88(0x0010) (NeedCtorLink)
	TArray<class ATgCollisionProxy_PawnListener*>      CurrentProxyListenerList;                                 // 0x0B98(0x0010) (NeedCtorLink)
	TArray<struct FDeployWallPushingInfo>              m_OverlappingDeployableWalls;                             // 0x0BA8(0x0010) (NeedCtorLink)
	float                                              m_fOverlappingWallPushoutAccel;                           // 0x0BB8(0x0004)
	class UClass*                                      m_DeathDamageType;                                        // 0x0BBC(0x0008)
	struct FVector                                     m_DeathHitLocation;                                       // 0x0BC4(0x000C)
	struct FEquipDeviceInfo                            r_EquipDeviceInfo[0x1F];                                  // 0x0BD0(0x000C) (Net)
	class ATgDevice*                                   m_EquippedDevices[0x1F];                                  // 0x0D44(0x0008)
	class ATgDevice*                                   m_EquippedBuffDevice;                                     // 0x0E3C(0x0008)
	class UTgDeviceForm*                               c_EquipForm[0x1F];                                        // 0x0E44(0x0008)
	struct FName                                       c_EquipFormState[0x1F];                                   // 0x0F3C(0x0008)
	struct FName                                       c_nmInHandSocket;                                         // 0x1034(0x0008)
	int                                                m_nAttackDamageMode;                                      // 0x103C(0x0004) (Const)
	class ATgDevice*                                   c_CurrentTargetingDevice;                                 // 0x1040(0x0008)
	class ATgDevice*                                   c_CurrentStartActionDevice;                               // 0x1048(0x0008)
	float                                              c_fShouldStartActionTimeStamp;                            // 0x1050(0x0004)
	class ATgDevice*                                   m_CurrentInHandDevice;                                    // 0x1054(0x0008)
	int                                                c_nLockInHandToTargetingDevice;                           // 0x105C(0x0004)
	class ATgSkeletalMeshActor*                        c_GroundTargetPreviewActor;                               // 0x1060(0x0008)
	class UTgSpecialFx*                                c_GroundTargetPreviewFX;                                  // 0x1068(0x0008)
	class ATgSkeletalMeshActor*                        c_GroundTargetRulerActor;                                 // 0x1070(0x0008)
	class UTgSpecialFx*                                c_GroundTargetRulerFX;                                    // 0x1078(0x0008)
	class UTgSpecialFx*                                c_WorldBracketFX;                                         // 0x1080(0x0008)
	class ATgSkeletalMeshActor*                        c_GroundTargetContextNotifyActor;                         // 0x1088(0x0008)
	class UTgSpecialFx*                                c_GroundTargetContextNotifyFX;                            // 0x1090(0x0008)
	struct FTG_HUD_INFO                                c_ReticlePreviewEndHudInfo;                               // 0x1098(0x0140) (NeedCtorLink)
	struct FTG_HUD_INFO                                c_ReticlePreviewLockHudInfo;                              // 0x11D8(0x0140) (NeedCtorLink)
	float                                              r_fHUDOverlayHeightOverride;                              // 0x1318(0x0004) (Net)
	class ATgVisibilityVolume*                         r_CurrentVisibilityVolumes[0x2];                          // 0x131C(0x0008) (Net)
	class ATgVisionRestrictionVolume*                  r_VisionRestrictionVolumes[0xA];                          // 0x132C(0x0008) (Net)
	int                                                c_nNumVisionLocks;                                        // 0x137C(0x0004)
	class UTgSpecialFx*                                c_VisibilityFx;                                           // 0x1380(0x0008)
	float                                              r_fPetLifetime;                                           // 0x1388(0x0004) (Net)
	float                                              c_fPetLifeRemaining;                                      // 0x138C(0x0004)
	int                                                r_nFlashQueIndex;                                         // 0x1390(0x0004) (Net)
	int                                                c_nFlashPriorEvent[0x20];                                 // 0x1394(0x0004)
	int                                                r_nFlashEvent[0x20];                                      // 0x1414(0x0004) (Net)
	struct FVector                                     r_vFlashLocation[0x20];                                   // 0x1494(0x000C) (Net)
	struct FVector                                     r_vFlashRayDir[0x20];                                     // 0x1614(0x000C) (Net)
	float                                              r_vFlashRefireTime[0x20];                                 // 0x1794(0x0004) (Net)
	class AActor*                                      r_pFlashTarget[0x20];                                     // 0x1814(0x0008) (Net)
	int                                                r_nFlashFireInfo[0x20];                                   // 0x1914(0x0004) (Net)
	float                                              s_fTauntAmount;                                           // 0x1994(0x0004)
	float                                              m_fLastPainSound;                                         // 0x1998(0x0004)
	class ULightEnvironmentComponent*                  LightEnvironment;                                         // 0x199C(0x0008) (Edit, Const, ExportObject, Component, EditInline)
	struct FVector                                     FireLocationOffsets[0x1F];                                // 0x19A4(0x000C)
	float                                              r_fAttackSpeed;                                           // 0x1B18(0x0004) (Net)
	float                                              r_fStealthFadeRate;                                       // 0x1B1C(0x0004) (Net)
	float                                              s_fLastVolumeAttackTime;                                  // 0x1B20(0x0004)
	float                                              c_fVolumeFadeValue;                                       // 0x1B24(0x0004) (Transient)
	float                                              c_fDistanceFadeValue;                                     // 0x1B28(0x0004) (Transient)
	float                                              c_fStealthFadeValue;                                      // 0x1B2C(0x0004) (Transient)
	float                                              c_fCurrentFadeValue;                                      // 0x1B30(0x0004) (Transient)
	float                                              c_fDistanceLastCollidingVisionRange;                      // 0x1B34(0x0004) (Transient)
	float                                              c_fLocalStealthFadeRate;                                  // 0x1B38(0x0004)
	class UTgSpecialFx*                                c_TeleporterEnterFX;                                      // 0x1B3C(0x0008)
	class UTgSpecialFx*                                c_TeleporterExitFX;                                       // 0x1B44(0x0008)
	class UTgSpecialFx*                                c_BlinkEnterFX;                                           // 0x1B4C(0x0008)
	class UTgSpecialFx*                                c_BlinkExitFX;                                            // 0x1B54(0x0008)
	class UTgSpecialFx*                                c_TeleportRelicEnterFX;                                   // 0x1B5C(0x0008)
	class UTgSpecialFx*                                c_TeleportRelicExitFX;                                    // 0x1B64(0x0008)
	class UTgSpecialFx*                                c_DetectedFx;                                             // 0x1B6C(0x0008)
	class UTgSpecialFx*                                c_SiegeTeleportExitFX;                                    // 0x1B74(0x0008)
	class UTgSpecialFx*                                c_BasicAttackAbsorbFX;                                    // 0x1B7C(0x0008)
	float                                              m_fLifeAfterDeathSecs;                                    // 0x1B84(0x0004)
	class AActor*                                      r_aDebugTarget;                                           // 0x1B88(0x0008) (Net)
	class AActor*                                      r_aDebugDestination;                                      // 0x1B90(0x0008) (Net)
	class AActor*                                      r_aDebugNextNav;                                          // 0x1B98(0x0008) (Net)
	struct FVector                                     r_vDebugNextNavMeshPoint;                                 // 0x1BA0(0x000C) (Net)
	struct FVector                                     r_vDebugSpreadoutLocation;                                // 0x1BAC(0x000C) (Net)
	int                                                r_nDebugHearingRange;                                     // 0x1BB8(0x0004) (Net)
	int                                                r_nDebugSightRange;                                       // 0x1BBC(0x0004) (Net)
	int                                                r_nDebugFOV;                                              // 0x1BC0(0x0004) (Net)
	struct FString                                     r_sDebugAction;                                           // 0x1BC4(0x0010) (Net, NeedCtorLink)
	struct FString                                     r_sDebugName;                                             // 0x1BD4(0x0010) (Net, NeedCtorLink)
	struct FString                                     r_sDebugFactory;                                          // 0x1BE4(0x0010) (Net, NeedCtorLink)
	struct FVector                                     s_vOneWayMovement;                                        // 0x1BF4(0x000C)
	struct FVector                                     r_vDown;                                                  // 0x1C00(0x000C) (Net)
	float                                              m_fBackpedalPct;                                          // 0x1C0C(0x0004)
	float                                              m_fBaseModifier;                                          // 0x1C10(0x0004)
	float                                              m_fTargetModifier;                                        // 0x1C14(0x0004)
	float                                              m_fModifierTweenRate;                                     // 0x1C18(0x0004)
	float                                              r_fDeployRate;                                            // 0x1C1C(0x0004) (Net)
	class AActor*                                      r_TargetActor;                                            // 0x1C20(0x0008) (Net)
	class AActor*                                      r_LockedTarget;                                           // 0x1C28(0x0008) (Net)
	int                                                c_TargetMethod;                                           // 0x1C30(0x0004)
	class ATgPawn*                                     r_Pet;                                                    // 0x1C34(0x0008) (Net)
	class AActor*                                      s_LastAttacker;                                           // 0x1C3C(0x0008)
	class ATgDevice*                                   s_LastAttackerDevice;                                     // 0x1C44(0x0008)
	class AActor*                                      s_LastAttacked;                                           // 0x1C4C(0x0008)
	class ATgDevice*                                   s_LastAttackedDevice;                                     // 0x1C54(0x0008)
	class AActor*                                      m_CurrentMeleeTarget;                                     // 0x1C5C(0x0008)
	class ATgPawn*                                     r_Owner;                                                  // 0x1C64(0x0008) (Net)
	int                                                s_nSpawnerDeviceInstId;                                   // 0x1C6C(0x0004)
	int                                                s_nSpawnerDeviceModeId;                                   // 0x1C70(0x0004)
	int                                                r_nReplicateDying;                                        // 0x1C74(0x0004) (Net)
	int                                                r_nResetCharacter;                                        // 0x1C78(0x0004) (Net)
	struct FName                                       DyingStateName;                                           // 0x1C7C(0x0008)
	int                                                m_nSpawnLocationId;                                       // 0x1C84(0x0004)
	int                                                m_nSpawnTableId;                                          // 0x1C88(0x0004)
	int                                                m_nSpawnTableDetailId;                                    // 0x1C8C(0x0004)
	struct FName                                       m_nmCurrentStateName;                                     // 0x1C90(0x0008)
	int                                                r_nReplicateHit;                                          // 0x1C98(0x0004) (Net)
	float                                              m_fStandingHeight;                                        // 0x1C9C(0x0004)
	float                                              m_fStandingRadius;                                        // 0x1CA0(0x0004)
	float                                              m_fTargetCylinderHeight;                                  // 0x1CA4(0x0004)
	float                                              m_fTargetCylinderRadius;                                  // 0x1CA8(0x0004)
	int                                                r_nPacingType;                                            // 0x1CAC(0x0004) (Net)
	float                                              m_CurrentAccuracy;                                        // 0x1CB0(0x0004)
	class AActor*                                      m_CurrentUseActor;                                        // 0x1CB4(0x0008)
	class ATgDevice*                                   m_ActiveDevice;                                           // 0x1CBC(0x0008)
	float                                              m_fBaseTranslationOffset;                                 // 0x1CC4(0x0004)
	float                                              m_fCrouchTranslationOffset;                               // 0x1CC8(0x0004)
	float                                              m_fPhaseChangeTime;                                       // 0x1CCC(0x0004)
	float                                              m_fPhaseChangedTimeStamp;                                 // 0x1CD0(0x0004)
	float                                              m_PhaseChangeRemainingTime;                               // 0x1CD4(0x0004)
	int                                                r_nPhase;                                                 // 0x1CD8(0x0004) (Net)
	int                                                c_PreviousPhase;                                          // 0x1CDC(0x0004)
	TArray<class UTgAnimNodeSimpleTransitioner*>       m_SimpleTransitionerNodes;                                // 0x1CE0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeStanceTransitioner*>       m_StanceTransitionerNodes;                                // 0x1CF0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeFitToDuration*>            m_AttackAnimFitToDurationNodes;                           // 0x1D00(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFire*>                  m_FireBlendNodes;                                         // 0x1D10(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByCombatWariness*>    m_CombatWarinessBlendNodes;                               // 0x1D20(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByPosture*>               m_PostureBlendNodes;                                      // 0x1D30(0x0010) (NeedCtorLink)
	TArray<class UAnimNodeBlendList*>                  m_HitOrMissBlendNodes;                                    // 0x1D40(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSwitch*>              m_AnimNodeEmoteSwitches;                                  // 0x1D50(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByEmote*>                 m_EmoteBlendNodes;                                        // 0x1D60(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            m_EmoteSequenceNodes;                                     // 0x1D70(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByIntroduction*>      m_AnimNodeBlendByIntroductions;                           // 0x1D80(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByHitReaction*>       m_AnimNodeBlendByHitReactions;                            // 0x1D90(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFireMode*>              m_DeviceModeBlendNodes;                                   // 0x1DA0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByFall*>                  m_FallBlendNodes;                                         // 0x1DB0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByCharge*>                m_ChargeBlendNodes;                                       // 0x1DC0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendList_Staging_Multi*>  m_StagingMultiBlendNodes;                                 // 0x1DD0(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByState*>                 m_StateBlendNodes;                                        // 0x1DE0(0x0010) (NeedCtorLink)
	TArray<class USkelControlBase*>                    m_SkelControlLocks;                                       // 0x1DF0(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_SkelControlLockNames;                                   // 0x1E00(0x0010) (NeedCtorLink)
	class UAnimNodeBlend*                              m_UpperBodyAnimBlendNode;                                 // 0x1E10(0x0008)
	class UAnimNodeSequence*                           m_UpperBodyAnimNodeSequence;                              // 0x1E18(0x0008)
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                                       // 0x1E20(0x0008)
	int                                                m_nYawOffset;                                             // 0x1E28(0x0004) (Const, Transient)
	struct FPostureStack                               m_PostureStack;                                           // 0x1E2C(0x0024) (NeedCtorLink)
	struct FName                                       PelvisBoneName;                                           // 0x1E50(0x0008) (Edit)
	float                                              m_fKnockbackMultiplier;                                   // 0x1E58(0x0004)
	float                                              r_DistanceToPushback;                                     // 0x1E5C(0x0004) (Net)
	float                                              f_RemainingDistanceToPushback;                            // 0x1E60(0x0004)
	struct FVector                                     r_PushbackDirection;                                      // 0x1E64(0x000C) (Net)
	float                                              m_PushbackSpeed;                                          // 0x1E70(0x0004)
	float                                              m_fPushbackMultiplier;                                    // 0x1E74(0x0004)
	class ATgBotFactorySpawnable*                      s_PetBotFactory;                                          // 0x1E78(0x0008) (Transient)
	TArray<class ATgNavigationPointSpawnable*>         s_PetLocationList;                                        // 0x1E80(0x0010) (Transient, NeedCtorLink)
	float                                              m_fTimeBetweenPetSpawns;                                  // 0x1E90(0x0004)
	TArray<struct FName>                               m_DeployPetsSocketNames;                                  // 0x1E94(0x0010) (NeedCtorLink)
	float                                              m_ValidPetSpawnPointDistance;                             // 0x1EA4(0x0004)
	float                                              m_fRBPushStrengthMultiplier;                              // 0x1EA8(0x0004) (Edit)
	struct FVector2D                                   m_fRBPushStrengthRange;                                   // 0x1EAC(0x0008) (Edit)
	struct FRotator                                    m_PreviousNetReceiveRotation;                             // 0x1EB4(0x000C)
	struct FRotator                                    m_TargetNetReceiveRotation;                               // 0x1EC0(0x000C)
	float                                              m_RotationInterpRate;                                     // 0x1ECC(0x0004)
	int                                                m_nNetRotationCount;                                      // 0x1ED0(0x0004)
	int                                                m_nSmoothedRemoteViewPitch;                               // 0x1ED4(0x0004)
	int                                                m_nPreviousReceivedRemoteViewPitch;                       // 0x1ED8(0x0004)
	int                                                m_nTargetRemoteViewPitch;                                 // 0x1EDC(0x0004)
	float                                              m_PitchInterpRate;                                        // 0x1EE0(0x0004)
	int                                                m_nNetViewPitchCount;                                     // 0x1EE4(0x0004)
	float                                              m_fSmoothCorrectionRate;                                  // 0x1EE8(0x0004) (Edit)
	struct FPointer                                    m_pStatsTracker;                                          // 0x1EEC(0x0008) (Native)
	class ATgPawn*                                     r_TeleportTarget;                                         // 0x1EF4(0x0008) (Net)
	int                                                r_nMatResGrpIdOverride;                                   // 0x1EFC(0x0004) (Net)
	class ATgPawn*                                     s_RevengeTarget;                                          // 0x1F00(0x0008)
	class ATgPawn*                                     m_LastDamager;                                            // 0x1F08(0x0008)
	int                                                m_LastDamagerTimeStamp;                                   // 0x1F10(0x0004)
	TArray<struct FPawnDamagerStruct>                  s_Damagers;                                               // 0x1F14(0x0010) (NeedCtorLink)
	int                                                s_nTowerDamageTaken;                                      // 0x1F24(0x0004)
	float                                              m_fJumpLandingTime;                                       // 0x1F28(0x0004)
	class ATgPawn*                                     r_FallingCollideOverridePawn;                             // 0x1F2C(0x0008) (Net)
	float                                              s_fLastJumpStampTime;                                     // 0x1F34(0x0004)
	float                                              s_fJumpStampFrequency;                                    // 0x1F38(0x0004)
	float                                              m_fIntoxicatedStartTime;                                  // 0x1F3C(0x0004)
	float                                              m_fIntoxicatedDuration;                                   // 0x1F40(0x0004)
	float                                              m_fIntoxicatedInterval;                                   // 0x1F44(0x0004)
	int                                                m_iIntoxicatedOrder;                                      // 0x1F48(0x0004) (Const)
	int                                                m_iIntoxicatedNumControlPoints;                           // 0x1F4C(0x0004)
	TArray<float>                                      m_IntoxicationKnots;                                      // 0x1F50(0x0010) (NeedCtorLink)
	TArray<struct FVector2D>                           m_IntoxicationRotatorControl;                             // 0x1F60(0x0010) (NeedCtorLink)
	struct FVector2D                                   m_vIntoxicatedMaxRotator;                                 // 0x1F70(0x0008)
	float                                              m_fIntoxicatedStrafeStartDirection;                       // 0x1F78(0x0004)
	TArray<float>                                      m_IntoxicationStrafeChangeTimes;                          // 0x1F7C(0x0010) (NeedCtorLink)
	struct FVector2D                                   m_vIntoxicatedMinMaxStrafeDuration;                       // 0x1F8C(0x0008)
	class UMaterialInstanceConstant*                   m_IntoxicatedWineMIC;                                     // 0x1F94(0x0008)
	class AActor*                                      r_StunTauntTarget;                                        // 0x1F9C(0x0008) (Net)
	int                                                c_WhiteoutHUDFxId;                                        // 0x1FA4(0x0004)
	class UMaterialInstanceConstant*                   m_WhiteoutHUDFxMIC;                                       // 0x1FA8(0x0008)
	class UPostProcessChain*                           m_FogPostProcess;                                         // 0x1FB0(0x0008)
	int                                                m_FogPostProcessFxId;                                     // 0x1FB8(0x0004)
	class UPostProcessChain*                           m_GenericEmotePostProcess;                                // 0x1FBC(0x0008)
	int                                                m_GenericEmotePostProcessFxId;                            // 0x1FC4(0x0004)
	int                                                m_GenericEmotePostProcessBaseId;                          // 0x1FC8(0x0004)
	class UTgSpecialFx*                                c_TeleportIncomingFx;                                     // 0x1FCC(0x0008) (Transient)
	int                                                s_nTeleportsIncoming;                                     // 0x1FD4(0x0004)
	float                                              s_fMaxRelevancyDistanceSquared;                           // 0x1FD8(0x0004)
	float                                              m_fLastCameraValueTimeStamp;                              // 0x1FDC(0x0004)
	struct FRotator                                    m_CachedBaseAimRotation;                                  // 0x1FE0(0x000C)
	float                                              m_fLastBaseAimRotationTimeStamp;                          // 0x1FEC(0x0004)
	float                                              m_fPushBlockPressure;                                     // 0x1FF0(0x0004)
	float                                              m_fSlowVelSizeSquard;                                     // 0x1FF4(0x0004)
	float                                              m_fPushBlockVelMultiplier;                                // 0x1FF8(0x0004)
	struct FLinearColor                                c_LastRimColor;                                           // 0x1FFC(0x0010)
	class UTgDropShadowDecalComponent*                 c_PlayerCircle;                                           // 0x200C(0x0008) (ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   c_PlayerCircleMIC;                                        // 0x2014(0x0008)
	class UMaterial*                                   c_CircleTemplate;                                         // 0x201C(0x0008)
	class UMaterial*                                   c_CircleTemplateSpectator;                                // 0x2024(0x0008)
	class UTgDropShadowDecalComponent*                 c_PlayerDropShadow;                                       // 0x202C(0x0008) (ExportObject, Component, EditInline)
	class UMaterial*                                   c_PlayerDropShadowTemplate;                               // 0x2034(0x0008)
	class UMaterialInstanceConstant*                   c_PlayerDropShadowMIC;                                    // 0x203C(0x0008)
	float                                              c_fPlayerDropShadowFade;                                  // 0x2044(0x0004) (Transient)
	struct FName                                       c_PlayerDropShadowSocketName;                             // 0x2048(0x0008)
	class ATgAttachPoint*                              c_GroundAttachPoint;                                      // 0x2050(0x0008)
	float                                              m_fLastGroundZ;                                           // 0x2058(0x0004)
	float                                              m_fFaceRotationInterpTime;                                // 0x205C(0x0004)
	float                                              m_fRemainingFaceRotationInterpTime;                       // 0x2060(0x0004)
	int                                                r_nBigTeleportCount;                                      // 0x2064(0x0004) (Net)
	int                                                c_nTickCheckingState;                                     // 0x2068(0x0004)
	class UTgManifestGroup*                            c_AssetManifestGroup;                                     // 0x206C(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UTgSpecialFx*                                c_LevelUpFX;                                              // 0x2074(0x0008)
	int                                                c_nLevelUpFxId;                                           // 0x207C(0x0004)
	int                                                c_nLevelUpFxMaxId;                                        // 0x2080(0x0004)
	class UTgSpecialFx*                                c_JumpStampFx;                                            // 0x2084(0x0008)
	int                                                c_nJumpStampFxId;                                         // 0x208C(0x0004)
	class UTgSpecialFx*                                c_DeathStampFx;                                           // 0x2090(0x0008)
	int                                                c_nDeathStampFxId;                                        // 0x2098(0x0004)
	class UTgSpecialFx*                                c_InStoreFx;                                              // 0x209C(0x0008)
	int                                                c_InStoreFxId;                                            // 0x20A4(0x0004)
	class UTgTiDiState*                                s_CurrentTiDi;                                            // 0x20A8(0x0008)
	float                                              r_fTotalTiDi;                                             // 0x20B0(0x0004) (Net)
	int                                                s_nKillCombo;                                             // 0x20B4(0x0004)
	int                                                s_nKillStreak;                                            // 0x20B8(0x0004)
	struct FPointer                                    m_pAmBot;                                                 // 0x20BC(0x0008) (Const, Native)
	struct FPointer                                    m_pAmSettingsBot;                                         // 0x20C4(0x0008) (Const, Native)
	struct FPointer                                    m_pAmSkin;                                                // 0x20CC(0x0008) (Const, Native)
	int                                                c_StunnedPostureID;                                       // 0x20D4(0x0004)
	int                                                c_PanickedOrFearedPostureID;                              // 0x20D8(0x0004)
	struct FName                                       r_nmDebugShowSocket;                                      // 0x20DC(0x0008) (Net)
	int                                                r_btDebugDisplays;                                        // 0x20E4(0x0004) (Net)
	TArray<class APlayerController*>                   s_Viewers;                                                // 0x20E8(0x0010) (NeedCtorLink)
	class ATgCarriedFlag*                              m_CurrentFlag;                                            // 0x20F8(0x0008) (Transient)
	float                                              m_fLastCTFVolumeTimestamp;                                // 0x2100(0x0004) (Transient)
	TArray<struct FOverlayInfo>                        m_OverlayInfos;                                           // 0x2104(0x0010) (Edit, Component, NeedCtorLink)
	class UMaterialInstanceConstant*                   m_OverlayMaterial;                                        // 0x2114(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_OutlineOverlayMaterial;                                 // 0x211C(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_FadeOverlayMaterial;                                    // 0x2124(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_AthenaTargetOverlayMaterial;                            // 0x212C(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_HitPulseOverlayMaterial;                                // 0x2134(0x0008) (Const)
	class UMaterialInstanceConstant*                   m_ThanatosHarvesterMaterial;                              // 0x213C(0x0008) (Const)
	class UClass*                                      m_SilhouetteOverlayClass;                                 // 0x2144(0x0008) (Const)
	TArray<class UMeshComponent*>                      c_ExtraMeshes;                                            // 0x214C(0x0010) (ExportObject, Component, NeedCtorLink, EditInline)
	TArray<struct FSpawnedSkelMeshEntry>               m_SpawnedSkelMeshMap;                                     // 0x215C(0x0010) (Component, NeedCtorLink)
	TArray<struct FSpawnedAnimNotifyMeshEntry>         m_SpawnedAnimNotifyMeshes;                                // 0x216C(0x0010) (NeedCtorLink)
	TArray<int>                                        m_IgnoredHitPulseIndicies;                                // 0x217C(0x0010) (NeedCtorLink)
	float                                              m_fFinalBlowAdditionalZ;                                  // 0x218C(0x0004) (Edit)
	float                                              m_fFinalBlowMomentumMultiplier;                           // 0x2190(0x0004) (Edit)
	float                                              m_fHitReactionTweenDistancePct;                           // 0x2194(0x0004) (Edit)
	float                                              m_fHitReactionAIPauseTime;                                // 0x2198(0x0004) (Edit)
	float                                              m_fHitReactionBlendOutTime;                               // 0x219C(0x0004) (Edit)
	float                                              m_fHitReactionTweenTime;                                  // 0x21A0(0x0004) (Edit)
	float                                              m_fFadeOutTime;                                           // 0x21A4(0x0004) (Edit)
	float                                              m_fFadeOutSpeed;                                          // 0x21A8(0x0004) (Edit)
	class UTgSpecialFx*                                m_DeathAnimFX;                                            // 0x21AC(0x0008)
	float                                              m_fBasicAttackHitReactionDistance;                        // 0x21B4(0x0004)
	TArray<class UTgSkelCon_HitReaction*>              m_HitReactionSkelControls;                                // 0x21B8(0x0010) (NeedCtorLink)
	float                                              m_fRemainingHitReactionPulseTime;                         // 0x21C8(0x0004)
	float                                              m_fHitReactionPulseTime;                                  // 0x21CC(0x0004) (Edit)
	float                                              m_fDisorientSpinRate;                                     // 0x21D0(0x0004) (Edit)
	float                                              m_fMaxSmoothNetUpdateDist;                                // 0x21D4(0x0004)
	float                                              m_fNoSmoothNetUpdateDist;                                 // 0x21D8(0x0004)
	float                                              m_fSmoothNetUpdateTime;                                   // 0x21DC(0x0004)
	struct FVector                                     m_vMeshTranslationOffset;                                 // 0x21E0(0x000C)
	TArray<class UPrimitiveComponent*>                 m_SmoothableComponents;                                   // 0x21EC(0x0010) (ExportObject, Component, NeedCtorLink, EditInline)
	float                                              m_fInitialHealthPercent;                                  // 0x21FC(0x0004)
	float                                              m_fDamageDealtPercent;                                    // 0x2200(0x0004)
	float                                              m_fDamageTakenPercent;                                    // 0x2204(0x0004)
	TArray<struct FHealingInfo>                        m_RecentHealList;                                         // 0x2208(0x0010) (NeedCtorLink)
	float                                              m_fRecentHealExpireTime;                                  // 0x2218(0x0004) (Const)
	struct FManaHealToHealth                           m_ManaHealToHealthSettings;                               // 0x221C(0x0008)
	int                                                r_nTranscendenceCount;                                    // 0x2224(0x0004) (Net)
	int                                                r_nBanCroftsTalonCount;                                   // 0x2228(0x0004) (Net)
	int                                                r_nBookOfThothCount;                                      // 0x222C(0x0004) (Net)
	int                                                r_nTyphonsFangCount;                                      // 0x2230(0x0004) (Net)
	int                                                m_nCloneExpirationAttacksCount;                           // 0x2234(0x0004)
	float                                              m_fCloneLeashRange;                                       // 0x2238(0x0004)
	float                                              m_fCloneExpirationTime;                                   // 0x223C(0x0004)
	class ATgRepInfo_Player*                           r_CloneParentPRI;                                         // 0x2240(0x0008) (Net)
	struct FFloorPortalTweenInfo                       r_FloorPortalTween;                                       // 0x2248(0x0014) (Net)
	TArray<struct FName>                               c_PostRecallParticleKillExceptions;                       // 0x225C(0x0010) (Transient, NeedCtorLink)
	TArray<class UAudioComponent*>                     c_RecallAudios;                                           // 0x226C(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UAudioComponent*>                     c_ManagedAudios;                                          // 0x227C(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UParticleSystemComponent*>            c_ManagedPSCs;                                            // 0x228C(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UParticleSystemComponent*>            c_LimitedPSCs;                                            // 0x229C(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<struct FAnimNotifyAudioEntry>               c_AudioNotifyData;                                        // 0x22AC(0x0010) (Transient, NeedCtorLink)
	class ATgRepInfo_Factory*                          r_FactoryInfo;                                            // 0x22BC(0x0008) (Net)
	class ATgRepInfo_Factory*                          m_LocalFactoryInfo;                                       // 0x22C4(0x0008)
	class AActor*                                      m_MegaKillInstigator;                                     // 0x22CC(0x0008)
	class UTgDeviceFire*                               m_MegaKillDeviceMode;                                     // 0x22D4(0x0008)
	class UTgEffectGroup*                              m_MegaKillStunProperty;                                   // 0x22DC(0x0008)
	class UTgEffectGroup*                              m_MegaKillDamageImmunity;                                 // 0x22E4(0x0008)
	float                                              m_fMegaKillTweenDelay;                                    // 0x22EC(0x0004)
	struct FVector                                     m_vMegaKillTweenLocation;                                 // 0x22F0(0x000C)
	float                                              m_fMegaKillMinDamage;                                     // 0x22FC(0x0004)
	int                                                m_IntroPostureID;                                         // 0x2300(0x0004)
	float                                              r_fIntroCombatDelay;                                      // 0x2304(0x0004) (Edit, Net)
	float                                              r_fIntroTime;                                             // 0x2308(0x0004) (Net)
	float                                              r_fIntroOffset;                                           // 0x230C(0x0004) (Net)
	float                                              s_fIntroStartTime;                                        // 0x2310(0x0004)
	float                                              m_fIntroProgress;                                         // 0x2314(0x0004)
	struct FName                                       r_ReplicatedState;                                        // 0x2318(0x0008) (Net)
	TArray<class UAnimNodeSequence*>                   m_RespawnNodes;                                           // 0x2320(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByBuffMonsterIntro*>      m_BuffCampIntroNodes;                                     // 0x2330(0x0010) (NeedCtorLink)
	struct FName                                       m_IntialIntroState;                                       // 0x2340(0x0008)
	struct FName                                       m_nmIntroWhiteOutParamName;                               // 0x2348(0x0008)
	float                                              m_fIntroWhiteOutScale;                                    // 0x2350(0x0004)
	float                                              m_fIntroWhiteOutUpTime;                                   // 0x2354(0x0004)
	float                                              m_fIntroWhiteOutDownTime;                                 // 0x2358(0x0004)
	float                                              s_fLiveSpectateRelevancyDist;                             // 0x235C(0x0004) (Const, Config)
	class ATgObjectiveVolume*                          c_ObjectiveVolume;                                        // 0x2360(0x0008)
	int                                                s_nOriginalQueueId;                                       // 0x2368(0x0004)
	float                                              m_fAdditionalAssistDistance;                              // 0x236C(0x0004)
	TArray<int>                                        m_nDisallowedItemIds;                                     // 0x2370(0x0010) (NeedCtorLink)
	float                                              m_fBlinkLockoutLength;                                    // 0x2380(0x0004)
	float                                              m_fBookOfThoth_BaseMana;                                  // 0x2384(0x0004)
	float                                              m_fBookOfThoth_LvlMana;                                   // 0x2388(0x0004)
	class ATgDevice*                                   s_DeviceInterruptingInHand;                               // 0x238C(0x0008)
	struct FExternalCameraOverrides                    r_cameraOverridesDeath;                                   // 0x2394(0x001C) (Net)
	struct FExternalCameraOverrides                    r_cameraOverridesSpectator;                               // 0x23B0(0x001C) (Net)
	float                                              s_fOrbitingRadius;                                        // 0x23CC(0x0004)
	struct FVector                                     s_vOrbitingCenterLoc;                                     // 0x23D0(0x000C)
	TArray<struct FMicList>                            c_micOverrides;                                           // 0x23DC(0x0010) (NeedCtorLink)
	TArray<struct FMicOverridesMap>                    c_micExtraMeshOverrides;                                  // 0x23EC(0x0010) (NeedCtorLink)
	float                                              m_fAttackComboTimeout;                                    // 0x23FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn");
		return ptr;
	}


	void UpdateEndStateBlendNodes(const struct FName& nmNextState);
	void UpdateBeginStateBlendNodes(const struct FName& nmPreviousState);
	void EndState(const struct FName& NextStateName);
	void BeginState(const struct FName& PreviousStateName);
	void AllowPhysicalDisplacement(bool bAllowDisplacementFromHardCC, bool bAllowTeleports, bool bAllowTweens, bool bAllowGrabs);
	bool STATIC_ShouldPawnTriggerCastReactionItems(class UTgDeviceFire* FireMode);
	void Entrap(bool bOn);
	void AnyoneCanCrit(bool bOn);
	void STATIC_SetupOrbitingState(bool bIsOrbiting, float fRadius);
	void ResetExternalCameraOverrides();
	void ResetSpectatorCameraOverrides();
	struct FVector STATIC_GetSpectatorCameraScaledByZoomOffset();
	struct FVector STATIC_GetSpectatorCameraAbsoluteOffset();
	void STATIC_GetSpectatorCameraZoomOverride(float* fZoomOverride, float* fTweenSpeed);
	void SetSpectatorCameraOverrides(float fZoomOverride, const struct FVector& vAbsoluteOffset, const struct FVector& vScaledByZoomOffset);
	void ResetDeathCameraOverrides();
	struct FVector STATIC_GetDeathCameraScaledByZoomOffset();
	struct FVector STATIC_GetDeathCameraAbosoluteOffset();
	void STATIC_GetDeathZoomFactorOverride(float* fZoomOverride, float* fTweenSpeed);
	void SetDeathCameraOverrides(float fZoomOverride, const struct FVector& vAbsoluteOffset, const struct FVector& vScaledByZoomOffset);
	void ToggleActionCamera(bool bOn, bool bResetCameraDefaults);
	float STATIC_GetChargeInitialYaw();
	bool STATIC_ShouldOverrideChargeAccel();
	bool STATIC_ShouldCacheAndResetChargeValues();
	void STATIC_ResetChargeValues(unsigned char ChargeState, float fChargeInitialYaw, const struct FVector& vChargeInitialPosition, float fChargeSpeed, float fChargeRange, bool bChargeIngoreHumanoidBlocking, bool bWantsCharge, class ATgPawn* ChargeTarget);
	void STATIC_CacheChargeValues(unsigned char* ChargeState, float* fChargeInitialYaw, struct FVector* vChargeInitialPosition, float* fChargeSpeed, float* fChargeRange, int* bChargeIngoreHumanoidBlocking, int* bWantsCharge, class ATgPawn** ChargeTarget);
	class UTgCameraModule* GetCameraModule();
	void DisableDebugDisplay(int btDisplayBitfield);
	void EnableDebugDisplay(int btDisplayBitfield);
	bool CheckProjectileTargetableState(class ATgProjectile* Proj);
	void RemoveSpawnedAnimNotifyMesh(class UAnimNotify* AnimNotifyData);
	void AddSpawnedAnimNotifyMesh(class ATgSkeletalMeshActorSpawnable* MeshActor, class UAnimNotify* AnimNotifyData);
	void ExitBlinkLockout();
	void EnterBlinkLockout();
	float GetEffectFormChangeFilterDelay(int nEffectGroupId, float fEffectFormDuration);
	bool ShouldHardCleanse(bool bPet);
	void STATIC_OnAddStacks(class UTgSeqAct_AddStacks* tgSeqAct);
	void STATIC_OnChangeGameMod(class UTgSeqAct_ChangeGameMod* tgSeqAct);
	void STATIC_OnModifyPropValue(class UTgSeqAct_ModifyPropValue* tgSeqAct);
	void STATIC_OnGetPropVal(class UTgSeqAct_GetPropVal* tgSeqAct);
	void STATIC_GameOnPrematchStop();
	void STATIC_GameOnPrematchStart();
	int GetEvolvingItemSkinLevel();
	int GetDefaultDeathStampFxId();
	int GetDefaultJumpStampFxId();
	void FinishedIntroAnim(class UAnimNode* IntroAnimNode);
	void STATIC_ExitIntroPosture(bool bForceAnimTreeOut);
	void STATIC_EnterIntroPosture();
	void STATIC_SetupIntroAnimNodesAndTimers();
	void DoIntroduction(bool bUseInitialIntro);
	bool IsPlayingIntro();
	void BeginWhiteOutScaleUp();
	void STATIC_SetWhiteOutStartTimer();
	void IntroTimer();
	void STATIC_EndWhiteOut();
	void UpdateWhiteOut();
	float GetAssistTime(class ATgPawn* VictimPawn);
	float GetAdditionalAssistDistance();
	bool StopFiring();
	void STATIC_RemoveAttachedBuffCampDevice();
	void SetCustomLightingChannels();
	void SetFactoryInfo(class ATgRepInfo_Factory* FactoryInfo);
	void SetMeshHiddenDueToAbility(bool bMeshHiddenDueToAbility);
	void SetHiddenInDeath(bool bHiddenDueToDeath);
	void STATIC_ProcessChargeNumber(unsigned char nChargeNumber);
	unsigned char STATIC_GetChargeNumber();
	bool CanApplyShield();
	void UpdateTeleportFX();
	void STATIC_RemoveIncomingTeleport();
	void AddIncomingTeleport();
	bool STATIC_InputLockedDueToFiring();
	bool IsInputLocked();
	void OnCameraCutAnimNotify(class UTgAnimNotify_CameraCut* CameraCutNotify);
	void KillCloneTimer();
	bool CanPlayHitReaction();
	void STATIC_SetMeshDepthPriority(TEnumAsByte<ESceneDepthPriorityGroup> NewDepth);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_InterruptInhand(class ATgDevice* InterruptingDevice);
	void PawnOnOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqpSlot);
	void STATIC_OnRightMousePressed();
	void STATIC_OnTargetSpeedModifierReached();
	void TickMaxSpeedModifier(float DeltaSeconds);
	void STATIC_ClientStartMaxSpeedModifierTween(float fTweenToStrength, float fTweenTime);
	void StartMaxSpeedModifierTween(float fTweenToStrength, float fTweenTime);
	void OnRedirectedDamageOriginUpdated(const struct FVector& Origin);
	bool IsInClassSpecificChannel();
	bool IsInClassSpecificMovement();
	bool IsInJumpLanding();
	bool CannotJumpNow();
	void ClientUpdateAttackSpeed(float fAttackSpeed);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostDemoRewind();
	void PreDemoRewind();
	void STATIC_EmptyRecallAudios(bool bDoDetach);
	void STATIC_CleanUpLimitedFX();
	void STATIC_CleanUpManagedFX();
	void ManagedParticleSystemFinished(class UParticleSystemComponent* PSC);
	void STATIC_EndParticleSystem(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	bool PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	bool STATIC_ShouldLimitParticleFX(class UAnimNotify_PlayParticleEffect* AnimNotifyData, class UParticleSystem* Template, class UParticleSystemComponent** OldestPSC);
	bool STATIC_ShouldManageParticleFX(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void ManagedAudioFinished(class UAudioComponent* AC);
	void STATIC_PlaySelfManagedSound(class USoundCue* Cue, class UAnimNodeSequence* OwningNode, float VolumeMultipler, float PitchMultipler);
	bool AnimNotifySound(class USoundCue* Cue, class UAnimNodeSequence* OwningNode, class UTgAnimNotify_Sound* OwningNotify, float VolumeMultipler, float PitchMultipler);
	void AddNotifyAudioEntryByGroup(int CueGroup);
	void AddNotifyAudioEntryByCue(class USoundCue* Cue);
	int STATIC_FindNotifyAudioEntryByGroup(int CueGroup);
	int STATIC_FindNotifyAudioEntryByCue(class USoundCue* Cue);
	void UpdateLocalGlobalEmoteInfo();
	void STATIC_SetGlobalEmoteFilters(int nGlobalEmoteId);
	struct FParticleChannelContainer STATIC_GetGlobalEmoteChannelOverride();
	bool WantsGlobalEmoteChannelOverride();
	void STATIC_OnAuthorityPlayGlobalEmote();
	void STATIC_PawnAnimTest(const struct FName& AnimName, float fRate, bool bLoop);
	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
	bool WantsLoopingEmote(TEnumAsByte<EEmote> Emote);
	void ClientPlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	void PlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	bool STATIC_CanPlayEmote(TEnumAsByte<EEmote> Emote, TEnumAsByte<EEmoteFail>* failType);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetEmoteSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	class USoundCue* STATIC_GetEmoteSoundCue(int BotID, TEnumAsByte<EEmote> Emote, int ExtraInfo);
	int STATIC_GetBotId();
	void STATIC_PostBigTeleport();
	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	void TriggerJump();
	bool STATIC_PreTeleport(class ATeleporter* InTeleporter);
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	void STATIC_OnTeleportToBaseNotify(class AActor* TeleportingActor);
	void TeleportToBaseNotify();
	void TeleportNotify();
	void RemoveFromTeleportNotify(class AActor* RemoveActor);
	void AddToTeleportNotify(class AActor* ToBeNotified);
	void STATIC_ServerChangePhase(int NewPhase);
	void STATIC_ChangePhase(int NewPhase);
	void STATIC_Perf2(bool bEnabled);
	void STATIC_ServerSetPushBlockParam(float fPushBlockPressure, float fSlowVelSizeSquard, float fVelModifier);
	void STATIC_SetPushBlockParam(float fPushBlockPressure, float fSlowVelSizeSquard, float fVelModifier);
	void STATIC_SetPushBlockParamHelper(float fPushBlockPressure, float fSlowVelSizeSquard, float fVelModifier);
	void STATIC_OnPhaseTransitionComplete();
	void OnPhaseChange();
	void OnPhaseEnded(int nPhaseThatEnded);
	void BaseChange();
	bool STATIC_CanPickupDroppedItem();
	bool ShouldSuppressNameplate();
	bool IsValidMeleeTarget(class ATgPawn* ProspectiveMeleeTarget);
	void SaveDeathInfoForZoomCam(class ATgPawn* KillerOwner, class ATgPawn* Killer, int DeviceID, bool bPetKill);
	void UpdateCooldownsOnDevices();
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	bool STATIC_CanFireDeviceWhenInvulnerable(class ATgDevice* Dev);
	bool STATIC_CanFireDeviceInStasis(class ATgDevice* Dev);
	bool IsPet();
	bool Teleport(const struct FVector& vDest, const struct FRotator& rDest, bool bPlayFx, int TeleportEnterState, int TeleportExitState, bool bMaintainControllerPitch);
	bool STATIC_TeleportTraceCheck(const struct FVector& vTestLoc, const struct FVector& vDestLoc);
	void KillPets();
	class ATgPawn* STATIC_GetCurrentOwnerPawn();
	bool WasPlayerSpawned();
	bool IsTargetWithInCone(class AActor* Target);
	void UpdateContextNotifyGroundTargetPreviewer(int TargeterContextId);
	void AddTargetingAidHudInfos(class ATgPlayerController* PC, struct FVector* CamLoc, struct FVector* CamRot);
	void UpdateTargetingAidReticle(TEnumAsByte<ETargetingReticleStyle> reticleStyle, TEnumAsByte<ETargetingHighlightStyle> highlightStyle);
	void UpdateTargetingAidGroundTarget(TEnumAsByte<ETargetingPreviewStyle> targetStyle);
	void UpdateTargetingAidLine(TEnumAsByte<ETargetingLineStyle> lineStyle);
	void UpdateTargetingAid();
	bool IsCinematicMode();
	void STATIC_SelectDeathDevices();
	void TickTargeting(float DeltaSeconds);
	void Tick(float DeltaSeconds);
	void STATIC_DoubleCheckSimulatedProxy();
	void TickFriendlyPush();
	bool ShouldRecharge();
	void STATIC_FPT(float X, float Y, float Z);
	void STATIC_DisplayMessage(const struct FString& sMessage);
	void ModifyPawnPropertiesVolumeChanged();
	void OnRigidBodySpringOverextension(class URB_BodyInstance* BodyInstance);
	void SetUsePhysicsWithAnimation(bool Enable);
	class ATgPawn* STATIC_FindLocalPlayerPawn();
	void BlendPawnAnimtreeToMatchInHandDevice();
	void BlendToAnimTreeDeviceType(float fDeviceType, float BlendTime);
	void STATIC_SetVar(int varId);
	void STATIC_ServerSetVar(int varId);
	void STATIC_OnTeleport(class USeqAct_Teleport* Action);
	void ResetChainedAttack(TEnumAsByte<ETG_EQUIP_POINT> eqpPoint);
	bool DoJump(bool bUpdating);
	void ClientCancelJump();
	void STATIC_ServerCancelJump();
	void StartCrouch(float HeightAdjust);
	void EndCrouch(float HeightAdjust);
	bool IsInForcedConsoleRestrictedPitch();
	float ApplyPitchLimit(float fPitch);
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void GetAdjustedAimNative(class AWeapon* W, const struct FVector& StartFireLoc, struct FRotator* Rot);
	void GetBaseAimRotationNative(class AWeapon* W, bool bIgnoreAutoLock, struct FRotator* Rot);
	struct FVector GetWeaponStartTraceLocation(class ATgDevice* Dev);
	struct FVector STATIC_GetFireLocationOffset(class ATgDevice* Dev);
	void STATIC_HideWeaponSwitchProgressBar();
	void STATIC_DisplayWeaponSwitchProgressBar(float Duration);
	void CheckUseDuration(float* fDuration);
	void STATIC_ClientSetTriggerMessage(class ATgTrigger_Use* newTrigger, int msgId);
	void STATIC_SetTriggerToUse(class ATgTrigger_Use* Trigger, bool bEnable);
	void InterruptAllDevicesWithExceptions(TArray<TEnumAsByte<ETG_EQUIP_POINT>> eEqpExceptionList);
	void InterruptAllDevices();
	bool IsUseInterrupted();
	void InterruptUse();
	void EnableFootControls(int foot, bool bDisable);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool IsEntrapped();
	bool CanBeHardDisplaced();
	bool CanBeVortexed();
	bool CanBePulled(bool bIsActuallyPulling);
	void DrawHUD(class AHUD* H);
	int STATIC_GetStunPropertyIdFromType(TEnumAsByte<EStunType> StunType);
	void STATIC_OnTargetEscapedMegaKill(class ATgPawn* Target);
	void CancelDelayedMegaDeath();
	void STATIC_EndDelayedMegaKill();
	bool STATIC_DoMegaKill();
	bool BeginMegaDeathTween();
	struct FVector STATIC_CalcMegaKillTweenVelocity(const struct FVector& EndLocation, const struct FVector& StartLocation, float TweenTime);
	bool BeginMegaKillTween();
	bool BeginDelayedMegaKill(class AActor* KillInstigator, class UTgDeviceFire* KillingMode, float fStunDelay, TEnumAsByte<EStunType> StunType, float fTweenDelay, TEnumAsByte<ETweenState> TweenType, const struct FVector& TweenLocation, bool bShouldKill, TEnumAsByte<ETG_DEATH_REASON> DeathReason, float fMinDamage);
	void STATIC_OnStasis(class UTgSeqAct_Stasis* StasisAction);
	void CannotUseAutoPortal(bool bOn);
	void DeathPreventedFrom(class APawn* attacker);
	void Immortal(bool bImmortal);
	void Enamored(class ATgPawn* Lover);
	void STATIC_ClientSlide(bool bSliding, const struct FRotator& rSlideDir, TEnumAsByte<EChargeState> eSlideType);
	void Slide(bool bSliding, TEnumAsByte<EChargeState> eSlideType);
	void STATIC_ClientSetGenericEmotePostProcessFx(bool IsActive);
	void SetGenericEmotePostProcessFx(bool IsActive);
	void STATIC_ClientSetFogHUDFx(bool IsActive);
	void SetFogHUDFx(bool IsActive);
	void STATIC_ClientSetWhiteoutHUDFx(bool IsActive);
	void SetWhiteoutHUDFx(bool IsActive);
	void STATIC_ClientIntoxicate(bool bIntoxicated, float Duration, int FxId);
	void Tremble(bool bIntoxicated, float Duration, int FxId);
	void Intoxicate(bool bIntoxicated, float Duration, int FxId);
	void Stasis(bool bStasised);
	void Cripple(bool bCrippled);
	void Disarm(bool bDisarmed);
	void BeadsSilence(bool bSilenced);
	void Silence(bool bSilenced);
	void STATIC_ResetStunnedBehavior(class ATgPlayerController* PC, class ATgAIController* aic);
	void STATIC_ClientSetStun();
	void STATIC_StopFullBodyAnimation(float BlendOutTime);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void OnAnimPlay(class UAnimNodeSequence* SeqNode);
	void STATIC_gibbedBy(class AActor* Other);
	void STATIC_DetachConeComponent(class UDrawConeComponent* ConeComponent);
	class UDrawConeComponent* AttachConeComponent(class UDrawConeComponent* ConeComponent, float fRadius, float fAngle);
	void STATIC_PlayInitialSpawnFX();
	void TriggerKismetPlayerInitialized();
	void OnPawnInitialized();
	void STATIC_OnWaitingForPawnDone();
	void WaitForInventoryThenDoPostPawnSetup();
	void HandleClientPostPawnSetup();
	void PropertySet(int nPropertyId, float fPreviousValue, float fNewValue);
	void AttachDevice();
	void DetachDevice();
	void STATIC_OnFadeOutTimerExpired();
	void STATIC_OnLifeAfterDeathTimerExpired();
	void BeginFadeOut();
	void DropFlag(class AController* C);
	void HoldFlag(class ATgCarriedFlag* NewFlag);
	bool STATIC_InitRagdoll();
	void TurnOff();
	void KilledBy(class APawn* EventInstigator);
	void OutsideWorldBounds();
	void FellOutOfWorld(class UClass* dmgType);
	void STATIC_FlushDebug();
	void STATIC_PlayHit(float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* dmgType, const struct FVector& Momentum, const struct FTraceHitInfo& HitInfo);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool IsDying();
	void STATIC_ResetPawnShadows();
	void ApplyPawnShadows(bool bOn);
	float GetEnergyPercent();
	bool InCombat();
	void Combat(bool bInCombat);
	void STATIC_InCombatTimer();
	void STATIC_ExitCombat();
	void EnterCombat(class ATgDevice* Device, class AActor* aInstigator, class AActor* ATarget, float fLength);
	void BreakVisionRestrictionStealth();
	void STATIC_RemoveVisionRestrictionVolume(class ATgVisionRestrictionVolume* Volume);
	void AddVisionRestrictionVolume(class ATgVisionRestrictionVolume* Volume);
	void STATIC_RemoveVisibilityVolume(class ATgVisibilityVolume* Vol);
	void AddVisibilityVolume(class ATgVisibilityVolume* Vol);
	void AdjustPawnMeshVisibility();
	void AdjustPolymorphVisibilityClient();
	void SetPolymorphVisibilityHera(bool IsPolymorphed);
	void SetPolymorphVisibility(bool IsPolymorphed);
	bool ForceHideDropShadow();
	void ApplyStealthClient();
	bool STATIC_ShouldShowAsStealthed(bool bDetected);
	void ApplyStealthServer(TEnumAsByte<ESTEALTH_TYPE> eStealthed, float fRate);
	bool ForceHideOnMinimap();
	void ReceivedCachedMaxMana();
	void ReceivedCachedMaxHealth();
	void ReceivedPropValues();
	void STATIC_ReplicateDying();
	void STATIC_EnablePlayerStatUIUpdate();
	void ReplicatedEvent(const struct FName& VarName);
	void TgPawnControllerSet();
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	struct FName STATIC_GetDefaultCameraMode(class APlayerController* RequestedBy);
	void LockTargetingDeviceToInHand(bool bEnable);
	void SetTargetingDevice(class ATgDevice* Dev);
	bool SetActiveWeapon(class AWeapon* NewWeapon, bool bForceFastClear);
	void STATIC_SetPawnState(const struct FName& NewState);
	void STATIC_RemoveDeathEffects();
	void STATIC_OnRespawn();
	void STATIC_OnPreRespawn();
	void TimerDestroy();
	void STATIC_CleanupParamsForDying();
	void STATIC_StopAllAnimations();
	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other, bool bAllowHitFromBehind);
	bool PredictChargeHit(const struct FVector& ChargeDir, const struct FVector& ChargeStart, float fChargeRange, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other, bool bAllowHitFromBehind);
	void STATIC_GetHitLocationForProximityTouch(class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal);
	void STATIC_ChargeEnding(bool bIsInterrupted);
	void EndPhysCharge(bool bInterrupted);
	void StartPhysCharge(TEnumAsByte<EChargeState> newChargeType, const struct FRotator& InitialDirection, const struct FVector& InitialLocation, float fChargeSpeed, float fChargeRange, bool bIngoreHumanoidBlocking, int NewMoveState, class ATgPawn* ChargeTarget);
	float STATIC_GetChargeTurnRate();
	bool IsGrabSourceValid(class ATgPawn* Target, bool bAllowTurrets, bool bAllowStealthed);
	bool IsInNonStackableGrab();
	void DecrementCannotBeGrabSource();
	void IncrementCannotBeGrabSource(bool bBreakGrabs);
	void TickGrab(float DeltaSeconds);
	void STATIC_SetMovementPhysics();
	bool CanBeBaseForPawn(class APawn* aPawn);
	bool IsInMovement();
	bool IsGrabSourceInMovement();
	void KnightChargeGrabEnd(bool bInterrupted);
	void XingTianSweepGrabEnd(bool bInterrupted);
	void XingTianSweepGrabStart();
	void KhepriReviveGrabEnd();
	void KhepriGrabEnd(bool bInterrupted);
	void KhepriGrabStart();
	void STATIC_FenrirBiteEnd(bool bInterrupted);
	void TyrGrabEnd(bool bInterrupted);
	void TyrGrabStart(bool bRemoveRoots);
	void AddVelocity(const struct FVector& NewVelocity, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo);
	void BaselessGrabEnd(bool bInterrupted);
	void BaselessGrabStart(bool bRemoveRoots);
	void STATIC_DefaultGrabEnd(bool bInterrupted);
	void STATIC_DefaultGrabStart(bool bRemoveRoots);
	void STATIC_EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	bool STATIC_CanInterpolateToGrabRotation(TEnumAsByte<EGrabState> grabState);
	bool STATIC_CanInterpolateToGrabLocation(TEnumAsByte<EGrabState> grabState);
	bool IsBaselessGrab(TEnumAsByte<EGrabState> grabState);
	bool ShouldGrabBreakStealth(TEnumAsByte<EGrabState> grabState);
	void RemoveFromConnectedGrabChain(class ATgPawn* pawnToRemove);
	void AddToConnectedGrabChain(class ATgPawn* pawnToAdd);
	void UpdateTiDiForGrabs(class ATgPawn* Target);
	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void STATIC_OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void ForceAllGrabTargetsDetach(TEnumAsByte<EGrabState> State);
	void NotifyGrabEndIgnored();
	bool STATIC_ShouldGrabEnd(bool bInterrupted);
	void EndPhysGrab(bool bInterrupted);
	void StartPhysGrab(class ATgPawn* Source, float fTime, TEnumAsByte<EGrabState> grabState, const struct FName& grabSocket, const struct FVector& grabLocOffset, const struct FRotator& grabRotOffset);
	class ATgPawn* STATIC_GetGrabRoot();
	void SetHercSmashGravity(bool bEnable, float fMultipler);
	void EndLevitation(class ATgPawn* pawnInstigator, const struct FVector& TargetLocation, float TweenTime);
	void BeginLevitation(TEnumAsByte<ELevitateType> LevitateType, const struct FVector& TweenOffset, float TweenTime, float fLevitateTime, class ATgPawn* pawnInstigator, bool bUnbreakable);
	float STATIC_CalcFloorPortalMinStartVelocityZ(float FallTime);
	float STATIC_CalcFloorPortalMaxStartVelocityZ(float FinalLocationZ, float FallTime);
	void STATIC_FloorPortalTweenEnd(bool bInterrupted);
	void STATIC_FloorPortalTweenStart();
	bool STATIC_DoesInstigatorAllowFloorPortalActorCollision();
	void STATIC_SinkTweenEnd(bool bInterrupted);
	void MegaKillTweenEnd(bool bInterrupted);
	void LevitateTweenEnd(bool bInterrupted);
	void STATIC_DefaultTweenEnd(bool bInterrupted);
	void STATIC_ClearChainedTweenEvents();
	void STATIC_StartNextChainedTween();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void MinionKnockbackTweenStart(bool bIsMelee);
	void PlayHitReaction(int BitPackedHitReaction);
	void SendHitReaction(bool bIsMelee, unsigned char HitDirection);
	void ArachnePullTweenStart();
	void TweenStartWithCollision(bool bRemoveRoots, bool bNewCollideActors, bool bNewBlockActors, bool bNewIgnoreEncroachers, bool bNewCollideWorld);
	void STATIC_DefaultTweenStart(bool bRemoveRoots);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void EndPhysTween(bool bInterrupted);
	void StartPhysTween(const struct FVector& Target, float fTime, TEnumAsByte<ETweenState> tweenState, class ATgPawn* pawnInstigator, int NewMoveState);
	bool STATIC_GetChainedPhysTweenTargetLocation(TEnumAsByte<ETweenState> eChainedTweenState, class ATgPawn* Target, struct FVector* TargetLocation);
	void AddChainedPhysTweenEvent(class ATgPawn* TgInstigator, TEnumAsByte<ETweenState> eChainedTweenState, float fPhysTweenChainedTime);
	struct FVector GetPhysTweenTargetLocation();
	bool IsDashing();
	bool IsLeaping();
	void STATIC_RemoveAllEffectsOnRevive();
	void STATIC_RemoveAllEffectsOnDeath();
	void STATIC_CleanUpDyingEffects();
	void STATIC_OnSwapToDestroyedMesh();
	void AttachDeathAnimationFX(int SpecialFXId, const struct FName& SocketName);
	bool STATIC_CanDespawn();
	bool STATIC_HasDespawnAnim();
	struct FName GetDespawnAnimName();
	struct FName GetDeathAnimName();
	void PlayDeathAnimation();
	void STATIC_PlayDyingEffects();
	void STATIC_FindNewTargetTimer();
	float STATIC_GetNewTargetTimerLength();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void ClientTriggerGlobalEventClass(class UClass* InEventClass, class AActor* InInstigator, int ActivateIndex);
	void PlayFootStepSound(int FootDown, TEnumAsByte<EFootstepTypes> FootStepType);
	struct FString STATIC_GetDebugName();
	void PostureTransitionEnded(TEnumAsByte<ETG_POSTURE> PostureThatEnded);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	bool STATIC_IgnoreFaceRotationWithInterp();
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fTweenSpeed);
	bool CalcCamera(float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV);
	void EndViewTarget(class APlayerController* PC);
	void BecomeViewTarget(class APlayerController* PC);
	float GetPlayerHealthForRender();
	struct FString GetPlayerTagForRender();
	struct FString GetPlayerNameForRender();
	struct FColor STATIC_GetTargetBoxColor(class ATgPawn* LocalPlayerPawn);
	void OnGroupChange();
	void STATIC_NotifyLocalPlayerTeamReceived();
	void STATIC_NotifyTeamChanged();
	int STATIC_GetColumnBasedOnIndex(int nIndex);
	int STATIC_GetRowBasedOnIndex(int nIndex);
	int STATIC_GetY2CoordBasedOnIndex(int nIndex);
	int STATIC_GetX2CoordBasedOnIndex(int nIndex);
	int STATIC_GetY1CoordBasedOnIndex(int nIndex);
	int STATIC_GetX1CoordBasedOnIndex(int nIndex);
	class UClass* STATIC_GetDeadControlModule();
	class ATgPawn* STATIC_GetLocalPlayerPawn();
	bool LoadPlayerIcons();
	void DrawMultiLineText(class UCanvas* Canvas, const struct FString& Text, int X, int Y, int LineHeight, float XScale, float YScale);
	void ModifyHealthProp(int nDamage);
	void AdjustDamage(class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser, int* InDamage, struct FVector* Momentum);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void OverrideKillBonusLogic(class ATgPawn* VictimPawn, class AController* overrideController);
	class AController* OverrideKillInstigator();
	class AController* STATIC_SetKillInstigator(class AController* InstigatedBy, class UClass* DamageType);
	bool STATIC_CanPreventDeathFrom(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool WillOverrideTakeDamage(class APawn* Victim, int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void DrawVisionRangeDebug(class UCanvas* Canvas);
	struct FString STATIC_GenPEPPusherString();
	void DrawPEPString(class UCanvas* Canvas, const struct FVector& ScreenLoc);
	struct FString CharacterDebugString();
	struct FString LightingDebugString();
	struct FString STATIC_GetAnimNodeString(const struct FString& preString, class UAnimNode* aNode);
	struct FString AnimDebugString();
	void DrawAnimDebug(class UCanvas* Canvas, const struct FVector& ScreenLoc);
	void DrawCategoryDebugs(class UCanvas* Canvas, const struct FVector& ScreenLoc);
	struct FString AIDebugString();
	void DrawAIDebug(class UCanvas* Canvas, const struct FVector& ScreenLoc);
	void STATIC_NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum, class AActor* DamageCauser);
	void SendNotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum);
	void PlayTakeHit(int Damage, class UClass* dmgType);
	void PlayHitReactionMaterialPulse();
	void STATIC_RememberPlayerAttackerExpired();
	void STATIC_StopPlayFiring();
	void ClearFlashLocation(class AWeapon* Who);
	void ClearFlashCount(class AWeapon* Who);
	void STATIC_IncrementFlashCount(class AWeapon* Who, unsigned char FireModeNum);
	void PawnOnBeginEndMission();
	bool CanApplyEffects();
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_PostRecallTimerToKillParticles();
	void STATIC_FixInHandProgressionAnims(int nNewMode, float NewDesiredDuration);
	void STATIC_OnDeviceFormSetStagingMultiAnimIndex(int nEquipSlot, int nChild);
	void STATIC_OnDeviceFormInterruptCharge(int nEquipSlot);
	void STATIC_OnDeviceFormEndCharge(int nEquipSlot, bool bHit);
	void STATIC_OnDeviceFormBeginCharge(int nEquipSlot);
	void STATIC_OnDeviceFormHit(int nEquipSlot, class ATgPawn* TargetPawn);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	bool DeviceOverrideLockedDown(class ATgDevice* Device);
	bool STATIC_DeviceCausesWariness(int nEquipSlot);
	void STATIC_SyncDeviceTimers(class ATgDevice* SourceDevice, class ATgDevice* DestinationDevice);
	void STATIC_PopEquippedDevice(class ATgDevice* newDev, int nEqpSlot);
	void STATIC_PushEquippedDevice(class ATgDevice* newDev, int nEqpSlot);
	void STATIC_SwapEquippedDevices(class ATgDevice* newDev, int nEqpSlot);
	void STATIC_SwapDeviceEquipPoints(int nEqpSlot1, int nEqpSlot2);
	int GetDeviceFormFXIndex(class UTgDeviceForm* form);
	void RestartAllDevices();
	void STATIC_ClientStopFiringAllDevices(bool bClearEquipEffectFlag, bool bResetCooldowns);
	void PushClientStopFire(bool bClearEquipEffectFlag, bool bResetCooldowns);
	void StopFiringAllDevices(bool bClearEquipEffectFlag, bool bResetCooldowns);
	void StopAction(class ATgDevice* Dev);
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void AnimSwapDevice();
	void UIH();
	void UpdateInHand(bool bForceFastClear);
	void STATIC_OnDeviceFormExitedTargetingMode(class UTgDeviceForm* form);
	void STATIC_OnDeviceFormEnteredTargetingMode(class UTgDeviceForm* form);
	void STATIC_EquipPendingDeviceTimer(bool SkipPlayAnim);
	void STATIC_ShowAnimSets();
	void PutInHandDeviceAwayFast(class UTgDeviceForm* form);
	bool STATIC_CanChangeInHandDeviceOrMode();
	void KillAllOwnedPets();
	void Destroyed();
	bool STATIC_PawnScoresOnDeath();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void TakeFallingDamage();
	void STATIC_OnJoinTeam(class UTgSeqAct_JoinTeam* Action);
	void DespawnOnReconnect();
	void DespawnAndHide();
	void Despawn();
	void Suicide();
	void STATIC_SetDeathZoomInfo(class ATgPawn* theKiller, class ATgRepInfo_Player* theKillerPRI, int nHealthPct, int nDeviceId, class ATgRepInfo_Player* OwnerPRI);
	void PreRender(class UCanvas* Canvas);
	bool IsCustomCharacter();
	void MissionTimeUpdate();
	bool PostPawnSetup();
	void CrushedBy(class APawn* OtherPawn);
	void STATIC_ClearSpawnFxTimer();
	void PostBeginPlay();
	void PreBeginPlay();
	void AllManifestsLoaded();
	void ToggleSkelControlLocks(bool bOn);
	void STATIC_CacheSkelControlLocks(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void SpecialFXAttached(class UTgSpecialFx* NewFX, int FxId);
	void STATIC_DebugFireDevice(int eEqPoint);
	void STATIC_OnResetCooldown(class UTgSeqAct_ResetCooldown* inAction);
	void STATIC_OnDespawnBots(class UTgSeqAct_DespawnBots* inAction);
	void STATIC_OnDoDamageToPawn(class UTgSeqAct_DoDamageToPawn* Action);
	void STATIC_OnKillpawns(class UTgSeqAct_Killpawns* Action);
	void ReflectChargeDirection(const struct FVector& HitNormal);
	void BumpLevel(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	void Falling();
	void OnPhysChange(unsigned char NewPhysState);
	void CollisionChanged();
	void STATIC_OnUIAlert(class UTgSeqAct_UIAlert* Action);
	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_OnGetTaskForceNumber(class UTgSeqAct_GetTaskForceNumber* Action);
	void STATIC_OnGetTeamIndex(class UTgSeqAct_GetTeamIndex* Action);
	void CleanupPostTempSpawn();
	void UnPossessed();
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void STATIC_ServerTestPushBack(float Distance);
	void STATIC_TestPushBack(float Distance);
	void UpdateCameraAttachPoint();
	void STATIC_HandleInstigatedTweenEnd(class ATgPawn* pawnTween, TEnumAsByte<ETweenState> eTween, bool bInterrupted);
	void STATIC_HandleInstigatedTweenStart(class ATgPawn* pawnTween, TEnumAsByte<ETweenState> eTween);
	bool ApplyMicOverride(int nMatIndex, class UMeshComponent* meshExtra, int nStackIndexOverride, bool bForceApply);
	void STATIC_RemoveMicOverride(int nMatIndex, class UMaterialInstanceConstant* MIC, class UMeshComponent* meshExtra);
	void AddMicOverride(int nMatIndex, class UMaterialInstanceConstant* MIC, class UMeshComponent* meshExtra);
	void STATIC_RemoveExtraMesh(class UMeshComponent* meshExtra);
	void AddExtraMesh(class UMeshComponent* meshExtra);
	TEnumAsByte<ESpecialItemPurchaseException> STATIC_HasSpecialPurchaseException(int nItemId);
	bool STATIC_InitializeTeleportIncomingFx();
	void AdjustAlphaMaskForOverlayMIC(class UMaterialInstanceConstant* micOverlay, int nMICIndex);
	bool STATIC_ShouldApplyHitPulseMIC(int nElementId);
	void ToggleOverlayVisibility(bool bVisible, bool bDead);
	void STATIC_SetOverlayState(class USkeletalMeshComponent* ParentMesh, TEnumAsByte<EOverlayState> NewState);
	void STATIC_SetForceFullOverlayMesh(bool bEnable);
	bool STATIC_ShouldUseFadeOverlay();
	void AdjustFadeOverlay(float fFadeValue);
	void AdjustHitPulseOverlay(float fBrightness);
	void STATIC_OnStealthOverlayChanged(bool bEnabled);
	void STATIC_SwapOverlayMICs(TEnumAsByte<EOverlayMICType> Type);
	int STATIC_FindOverlayInfo(class USkeletalMeshComponent* ParentMesh);
	void STATIC_ReinitializeOverlays();
	int STATIC_InitializeOverlayMeshComponent(class USkeletalMeshComponent* InMesh, bool bMakePhysAsset);
	bool STATIC_GetGroundAtLocation(const struct FVector& InLocation, bool bExcludeCollisionHeight, struct FVector* GroundLoc);
	bool STATIC_GetGroundLocation(bool bExcludeCollisionHeight, struct FVector* GroundLoc);
	void STATIC_ReduceActiveCooldownForOffhand(TEnumAsByte<ETG_EQUIP_POINT> offhandType, float fValue, bool bPercentage);
	void STATIC_ReduceActiveCooldowns(float fValue, bool bPercentage);
	void STATIC_SpawnModifierOnChanged(int ItemId, int NumStacks);
	void STATIC_CacheHitReactionSkelControls();
	void STATIC_CacheConfigValues();
	void STATIC_PostPawnSetupServer();
	void STATIC_CleanupSkeletalMeshComponent(class UTgSkeletalMeshComponent* MeshComponent, bool bResetAnims);
	void STATIC_OnMeshSwapped();
	void STATIC_SwapToLiveMesh();
	void STATIC_SwapToDestroyedMesh();
	void STATIC_RetouchAllVolumes();
	bool InvObjCastTrackingException(struct FOnDamagedParams* Params);
	void STATIC_OnSilenceOther(class ATgPawn* Other, class UTgEffectGroup* EffectGroup);
	void STATIC_OnKnockupEnd(class AActor* Target);
	void STATIC_OnSpecialKnockback(class AActor* Target, class AActor* BlockingActor);
	bool STATIC_EffectGroupCanBeHardCleared(class UTgEffectGroup* EffectGroup);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_EffectGroupOnStackChange(bool bActive, int nDeltaStacks, class UTgEffectGroup* EffectGroup);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeployableOnProjShutdown(class ATgDeployable* dep, class ATgProjectile* Proj);
	struct FName STATIC_GetDamageTypeOverride(class ATgDevice* Dev, class UTgEffectGroup* EffectGroup);
	class UClass* STATIC_DeviceOnOverrideDamageType(class ATgDevice* Dev, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceOnModifyEffectLifeTime(class ATgDevice* Dev, class UTgEffectGroup* EffectGroup, float* fLifeTime);
	bool STATIC_DeviceIsTargetingModeReady(class ATgDevice* Dev, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_DeviceOverrideManaUseVitals(class ATgDevice* Dev, class ATgPlayerController* PC);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	bool STATIC_DeviceHasEnoughSpecificPowerPool(class ATgDevice* Dev, unsigned char FireModeNum, int nPacingType);
	bool STATIC_DeviceHasEnoughPowerPool(class ATgDevice* Dev, unsigned char FireModeNum);
	void STATIC_DeviceAdjustPowerScaling(class ATgDevice* Dev, int nScalingType, struct FImpactInfo* Impact, float* fPhysicalPower, float* fMagicPower);
	bool STATIC_DeviceOnCanDeviceCriticalStrike(class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceAdjustHeal(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_DeviceOnProjShutdown(class ATgDevice* Dev, class ATgProjectile* Proj);
	void STATIC_DeviceCalcConditionalDamageTakenPerc(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamageTakenPerc);
	void STATIC_DeviceAdjustCrit(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void STATIC_DeviceOnHealed(struct FOnHealedParams* Params);
	void STATIC_DeviceOnDodged(struct FOnDodgedParams* Params);
	void STATIC_DeviceOnAbsorbHit(struct FOnAbsorbHitParams* Params);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_DeviceOnHitSpecial(class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnBeforeHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnPostHit(class ATgDevice* Dev);
	void STATIC_DeviceOnStopCooldown(class ATgDevice* Dev);
	void STATIC_DeviceOnStartCooldown(class ATgDevice* Dev, float fCooldownTime);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnFire(class ATgDevice* Dev);
	void STATIC_DeviceOnAboutToFire(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void STATIC_PawnOnReviveForms();
	void STATIC_PawnRoundReset();
	void STATIC_PawnOnSetLevel(int nLevel, bool bIsLower);
	void STATIC_PawnOnSwapSetup();
	void STATIC_PawnOnSpecialCleanup();
	void STATIC_PawnOnSpecialReset();
	void STATIC_PawnOnDeliverHits(TArray<struct FImpactInfo>* PendingHits);
	bool STATIC_PawnCanDisplayImmuneMessage();
	bool STATIC_PawnOnDidBreakableGrabHit();
	bool STATIC_PawnOnDidBreakableTweenHit(bool IsConsideredKnockup);
	void STATIC_PawnOnLifestealing(class ATgPawn* Victim, class UTgEffectGroup* EffectGroup, float* lifestealAmount);
	void STATIC_PawnOnLifesteal(class ATgPawn* attacker, class UTgEffectGroup* EffectGroup, float* lifestealAmount);
	void STATIC_PawnOnObjectiveSteal(struct FScoreKillData* Data);
	void STATIC_PawnOnModifyEffectLifeTime(class UTgEffectGroup* eg, float* fLifeTime);
	void STATIC_PawnOnTaskforceAdd(class ATgRepInfo_TaskForce* tf);
	void STATIC_PawnOnTaskforceRemove(class ATgRepInfo_TaskForce* tf);
	void STATIC_PawnOnReduceActiveCooldowns(float fValue, bool bPercentage);
	void STATIC_PawnOnDodged(struct FOnDodgedParams* Params);
	void STATIC_PawnOnAbsorbHit(struct FOnAbsorbHitParams* Params);
	void STATIC_PawnOnCurrency(class AActor* Source, unsigned char RewardType, int* nCurrency);
	void STATIC_PawnOnXp(class AActor* Source, unsigned char RewardType, int* nXp);
	void STATIC_PawnOnVortexTouchedOnce(class ATgPawn* InstigatorPawn);
	void STATIC_PawnOnRemovedVortex(class ATgPawn* HitPawn);
	void STATIC_PawnOnAppliedVortex(class ATgPawn* HitPawn);
	void STATIC_PawnOnExitVortex(class ATgPawn* InstigatorPawn);
	void STATIC_PawnOnEnterVortex(class ATgPawn* InstigatorPawn);
	void STATIC_PawnOnSlowed(struct FImpactInfo* Impact);
	void STATIC_PawnOnHardCCed(const struct FImpactInfo& Impact, class UTgEffectGroup* eg);
	void STATIC_PawnOnCCed(const struct FImpactInfo& Impact, class UTgEffectGroup* eg);
	void STATIC_PawnOnEffectGroupSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_PawnOnSpellShieldProc();
	void STATIC_PawnOnGodCombatEvent();
	void STATIC_PawnOnCombatEvent();
	void STATIC_PawnOnExitCombat();
	void STATIC_PawnOnEnterCombat();
	void STATIC_PawnOnRevive();
	void STATIC_PawnOnDied(class AController* pKilller);
	void STATIC_PawnOnAssisted(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnAdjustHeal(class ATgPawn* InstigatorPawn, int nPropertyId, int nSimplifiedPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_PawnOnHealed(struct FOnHealedParams* Params);
	float STATIC_PawnOnConditionalDamageTakenPerc();
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_PawnOnAllyDamaged(class ATgPawn* ally, struct FOnDamagedParams* Params);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_SetSpawnEnergy();
	void STATIC_SetSpawnMana();
	void STATIC_SetSpawnHealth();
	void STATIC_OnAttackDamagePropertyChange();
	void STATIC_OnOwnerGroundSpeedChange();
	void STATIC_OnUtilityPowerChange();
	float STATIC_GetManaCostModifier();
	float STATIC_GetBasicAttackDamage();
	float STATIC_GetUIGroundSpeed();
	float STATIC_GetStrafePercent();
	float STATIC_GetBackpedalPercent();
	float STATIC_GetForwardPercent();
	float STATIC_GetMinimapWardVisionPercent();
	bool STATIC_GetMinimapRequireLOS();
	float STATIC_GetDamageDealtPercBasicAttack();
	float STATIC_GetDamageDealtPerc();
	float STATIC_GetFlatDamageReduction();
	float STATIC_GetDamageTakenPercInhand();
	float STATIC_GetDamageTakenPercCrit();
	float STATIC_GetDamageTakenFlatCrit();
	float STATIC_GetDamageTakenPercMag();
	float STATIC_GetDamageTakenPercPhys();
	float STATIC_GetDamageTakenPerc();
	float STATIC_GetHealingDealtPerc();
	float STATIC_GetHealingTakenPerc();
	float STATIC_GetVisionRange();
	float STATIC_GetAttackSpeed();
	float STATIC_GetMaxShieldHealth();
	float STATIC_GetMaxHealthWithoutPercentBuff();
	float STATIC_GetMaxHealth();
	float STATIC_GetMaxEnergy();
	float STATIC_GetMaxManaWithoutPercentBuff();
	float STATIC_GetMaxMana();
	float STATIC_GetShieldHealth();
	float STATIC_GetHealth();
	float STATIC_GetSmoothEnergy();
	float STATIC_GetEnergy();
	float STATIC_GetMana();
	float STATIC_GetEnergyRegen();
	float STATIC_GetManaRegen();
	float STATIC_GetHealthRegen();
	float STATIC_GetXPPer5();
	float STATIC_GetXPPer5Gain();
	float STATIC_GetGoldPer5();
	float STATIC_GetGoldPer5Gain();
	float STATIC_GetGoldGain();
	float STATIC_GetXPGain();
	float STATIC_GetReviveReduction();
	float STATIC_GetCooldownExtension();
	float STATIC_GetCooldownReduction();
	float STATIC_GetPercReduction(int nPropIndex);
	float STATIC_GetFlatReduction(int nPropIndex);
	float STATIC_GetPercPenetration(int nProtectionType, class AActor* Target);
	float STATIC_GetFlatPenetration(int nProtectionType, class AActor* Target);
	void STATIC_GetConditionalPenetration(class UTgEffectGroup* eg, int nProtectionType, class AActor* Target, float* fFlatPen, float* fPercPen);
	float STATIC_GetProtection(int nPropIndex);
	float STATIC_GetSpellVamp();
	float STATIC_GetPhysAbilityLifeSteal();
	float STATIC_GetLifeSteal();
	float STATIC_GetCriticalDamage();
	float STATIC_GetCriticalStrike();
	float STATIC_GetMagicalProtection();
	float STATIC_GetPhysicalProtection();
	float STATIC_GetHealingPowerItem();
	float STATIC_GetUtilityPowerItem();
	float STATIC_GetMagicalPowerCustom(const struct FImpactInfo& Impact, float PowerScaling);
	float STATIC_GetPhysicalPowerCustom(const struct FImpactInfo& Impact, float PowerScaling);
	float STATIC_GetMagicalPowerItem(const struct FImpactInfo& Impact, float PowerScaling);
	float STATIC_GetPhysicalPowerItem(const struct FImpactInfo& Impact, float PowerScaling);
	float STATIC_GetHealingPowerBot();
	float STATIC_GetUtilityPowerBot();
	float STATIC_GetMagicalPowerBot();
	float STATIC_GetPhysicalPowerBot();
	float STATIC_GetUIBonusAttackDamage();
	float STATIC_GetHealingPower();
	float STATIC_GetUtilityPower();
	float STATIC_GetMagicalPower(const struct FImpactInfo& Impact);
	float STATIC_GetPhysicalPower(const struct FImpactInfo& Impact);
	bool STATIC_HasDeathPostureAnimation();
	class ATgDevice* STATIC_GetEquippedDevice(int nDeviceId);
	void STATIC_ServerSetSpecialFloat1(float fValue);
	bool STATIC_ServerUpdateLockedTarget(class AActor* Locked);
	bool STATIC_DoServerDetonate();
	class ATgPawn* STATIC_GetLocalTgPawn();
	float STATIC_GetMaxPowerPoolValue(int nPacingType);
	float STATIC_GetCurrentPowerPoolValue(int nPacingType);
	void STATIC_ConsumePowerPool(class ATgDevice* Dev, int nPacingType, float fAmount);
	bool STATIC_ShouldAllowOffhandFireLock();
	bool IsInFireLock();
	float STATIC_GetAirControl();
	void UpdatePRIAssetRefs();
	void STATIC_OnSetPlayerLevel(class UTgSeqAct_SetPlayerLevel* Action);
	struct FVector STATIC_GetLocationOfFeet(bool bAllowGroundTrace, const struct FVector& LocationSubstitute);
	float NativeGetCollisionRadius();
	float NativeGetCollisionHeight();
	void STATIC_OnPostureChange();
	void STATIC_OnProjectileExploded(class ATgProjectile* ExplodedProjectile, class AActor* HitActor, struct FVector* vHitLocation, struct FVector* vHitNormal);
	void STATIC_RemoveSpawnFadeOutFx();
	void STATIC_OnLevelUp(int nLevel);
	void STATIC_ClearEquippedDevice();
	void STATIC_OnPetSpawned(class ATgPawn* Pet);
	struct FVector STATIC_GetTargetCenter();
	void STATIC_CheckUiVolumeTriggers();
	bool PopPosture(int PostureID);
	int PushPosture(TEnumAsByte<ETG_POSTURE> Posture);
	void OnRefireTimeout();
	void OnAttackComboTimeout();
	void ToggleUpgradeableRelics();
	class UClass* STATIC_CreatePawnSpecificProcessor();
	bool UsesSinglePawnProcessor();
	float STATIC_GetSoulRipHeightOffset();
	class UTgSkeletalMeshComponent* STATIC_GetSoulRipMesh();
	void STATIC_ShutdownTiDi();
	void TransmitTiDiClient();
	void TransmitTiDiServer();
	void ApplyTiDi();
	bool STATIC_ShouldUpdateTiDi();
	class UTgTiDiState* STATIC_GetCurrentTiDi();
	void STATIC_InitializeTiDi();
	bool IsInGodCombat();
	bool IsInCombat();
	bool IsInSelfInstigatedCharge();
	bool IsInSlideState();
	bool STATIC_GetSpecialTargetAI(class ATgPawn** NewTarget);
	void STATIC_DeactivatePac(class UTgSkeletalMeshComponent* meshPac);
	void ActivatePac(class UTgSkeletalMeshComponent* meshPac);
	void STATIC_DeactivateMeshComponent(class UTgSkeletalMeshComponent* MeshComp, bool bFreezeAnimTree);
	void ActivateMeshComponent(class UTgSkeletalMeshComponent* MeshComp);
	void STATIC_DeactivateSpawnedMesh(int nMeshId, bool bPAC, bool bFreezeAnimTree);
	void ActivateSpawnedPAC(int nMeshId, const struct FName& nmBone);
	void ActivateSpawnedMesh(int nMeshId, const struct FName& nmSocket, const struct FName& nmFullBody, bool bUseSocketLoc, bool bUseSocketRot, bool bIgnoreOwnerHiddens, bool bIgnoreOwnerRotation, bool bResetOnActivate);
	int STATIC_FindSpawnedMeshEntry(int nMeshId);
	void STATIC_DestroySpawnedMeshMap();
	void STATIC_CreateSpawnedMeshEntry(int nMeshId, bool bPAC);
	void AddItemStacks(class UTgSeqAct_AddStacks* tgSeqAct);
	class UTexture2D* STATIC_GetDefaultPortrait();
	int STATIC_GetOwnedMeshSkin(int eOMST, int nMeshId);
	void STATIC_SpawnGenericReturnProjectileWithRandomDirection(const struct FVector& SourceLocation, const struct FVector& TargetLocation, class ATgDevice* SourceDevice, class AActor* projTarget);
	void STATIC_SpawnGenericReturnProjectile(const struct FVector& SourceLocation, const struct FVector& TargetLocation, const struct FRotator& StartRotation, class ATgDevice* SourceDevice, class AActor* projTarget);
	void STATIC_ForceSetRelativeLocation(const struct FVector& NewRelativeLocation);
	void STATIC_SetJustTeleported(bool bInJustTeleported);
	void STATIC_CustomRedirectDamageHandler(const struct FImpactInfo& redirectImpact, float redirectDamage, const struct FImpactInfo& sourceImpact, class ATgPawn* sourcePawn, class UTgEffectGroup* sourceEG);
	void STATIC_PlaySeasonalDyingEffects();
	void STATIC_FixRelativeRotation();
	void STATIC_RemoveOverlappingWallInfo(class ATgDeploy_Wall* DeployWall);
	void AddOverlappingWallInfo(class ATgDeploy_Wall* DeployWall, const struct FVector& PushingVector);
	int STATIC_GetCustomParticleSystemFilter();
	void STATIC_ServerSetSkinLevel(unsigned char nSkinLevel);
	void STATIC_EndSkinLevelUp();
	void STATIC_PlaySkinLevelUpFx();
	void STATIC_OnSkinLevelChanged();
	void LevelUpSkin(unsigned char NewSkinLevel);
	bool UsesSkinLeveling();
	void STATIC_FillChargeDeviceArray(TArray<class ATgDevice_Charge*>* ChargeList);
	void STATIC_RemoveIgnoreBlockingFlags(unsigned char NewFlags);
	void AddIgnoreBlockingFlags(unsigned char NewFlags);
	bool STATIC_FindBestLocationAtRadiusOffset(const struct FVector& originLocation, const struct FVector& originForward, const struct FVector& Extent, float Radius, int maxAttempts, bool bVerifyGroundLoc, struct FVector* finalLocation, struct FVector* finalForward);
	bool STATIC_FindBestEndGrabLocation(const struct FVector& Extent, class AActor* TestActor, struct FVector* finalLocation, struct FRotator* finalRotation);
	bool IsInOffensiveTween();
	bool IsTweenBanish(TEnumAsByte<ETweenState> tweenState);
	bool IsTweenKnockUp(TEnumAsByte<ETweenState> tweenState);
	bool IsTweenBreakable(TEnumAsByte<ETweenState> tweenState);
	bool IsPerformingOffensiveGrab();
	bool IsInOffensiveGrab();
	bool IsGrabBreakable(TEnumAsByte<EGrabState> tweenState);
	void STATIC_ResetSkelControls(class USkeletalMeshComponent* SkelComp);
	void STATIC_CalcSocketWorldGrabLocationRotation(class ATgPawn* Source, const struct FName& SocketName, const struct FVector& relLoc, const struct FRotator& RelRot, struct FVector* WorldLoc, struct FRotator* WorldRot);
	void STATIC_CalcWorldGrabLocationRotation(class ATgPawn* Source, const struct FVector& relLoc, const struct FRotator& RelRot, struct FVector* WorldLoc, struct FRotator* WorldRot);
	struct FRotator TweenRelRotation(float fDeltaSeconds, const struct FRotator& currRel, const struct FRotator& targetRel);
	class AActor* STATIC_FindMadnessTarget(float fRadius);
	class AActor* STATIC_FindCharmTarget(float fRadius);
	bool IsStructure();
	bool IsObjective();
	bool IsGodDecoy();
	bool IsGod();
	float AdjustRespawnTime(float InRespawnTime);
	void STATIC_PostRewindUpdateComponents();
	void STATIC_ForceUpdateComponents(bool bCollisionUpdate, bool bTransformOnly);
	void UpdateSpectatorStatUI();
	void UpdatePlayerStatUI();
	void STATIC_PlayCustomAnimation(int nAnimResId, bool bFullBody, float fTime);
	void STATIC_GetCurrentUsedResourceList(TArray<struct FString> List);
	void LoadGenericEmotePostProcess();
	void LoadFogPostProcess();
	void LoadWhiteoutHUDFxMIC(int FxId);
	struct FVector2D IntoxicationRotatorOffset(float OffsetFromWorldTime);
	float IntoxicationStrafeOffset(float OffsetFromWorldTime);
	void LoadIntoxicationMIC(int FxId);
	bool STATIC_IgnoreThreatsFromDamage();
	bool IsNonCombat();
	bool STATIC_CanMove();
	void STATIC_PlayUpperBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, bool bLooping);
	float STATIC_PlayFullBodyLoopingAnimWithTransition(const struct FName& TransitionAnimName, const struct FName& LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime);
	bool STATIC_PlayFullBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, bool bBlendOutIfVelocityIsGreaterThanZero, bool bHideInHandDevice);
	bool IsFriendlyWithLocalPawn();
	class ATgPawn_Courier* STATIC_GetAvailableCourier();
	bool STATIC_HasAvailableCourier();
	void STATIC_CourierPhaseChanged(TEnumAsByte<ECourierPetPhase> Phase);
	void STATIC_CourierDied();
	void STATIC_CourierDropOff();
	void STATIC_ForceUpdateEquippedDevices();
	void STATIC_RegainEnergyPool(float fDelta);
	void STATIC_RegainManaPool(float fDelta);
	void STATIC_RegainPools(float fDelta);
	struct FVector STATIC_GetSeekingTargetLocation();
	void STATIC_SyncMana();
	float STATIC_GetManaPercent();
	float STATIC_GetHealthPercent();
	void STATIC_SetMeshComponentVectorValue(class UMeshComponent* theMesh, const struct FName& ScalarParam, struct FLinearColor* ColorValue);
	void STATIC_SetMeshComponentScalarValue(class UMeshComponent* theMesh, const struct FName& ScalarParam, float ScalarValue);
	void STATIC_SetMeshVectorValue(const struct FName& ScalarParam, struct FLinearColor* ColorValue);
	void STATIC_SetMeshScalarValue(const struct FName& ScalarParam, float ScalarValue);
	bool MoveCloseTo(const struct FVector& vDesiredLocation);
	void KillProjectiles();
	void KillDeployables(bool bAll);
	int STATIC_DrawMatString(class UCanvas* CanvasToUse, float StartX, float StartY, float XScale, float YScale, const struct FString& NameString, class UFont* NameFont, class UMaterialInstanceConstant* FontMIC);
	void STATIC_SwapAttachedDeviceMaterials(class UMaterialInstanceConstant* NewMaterial, bool bIgnoreParams);
	void STATIC_SwapSkinMaterials(TArray<struct FFx_Material> MaterialList, bool bIgnoreParams, bool bIsFriendly);
	void STATIC_SetSkin(class UTgSpecialFx* NewSpecialFx, bool bIgnoreParams, bool bForceSetSkin);
	bool TouchingAnyVisionRestrictionVolume();
	bool IsVisibleThroughRestrictionVolumesBy(class ATgPawn* Other);
	int STATIC_FindVisionRestrictionVolume(class ATgVisionRestrictionVolume* Volume);
	int STATIC_NumVisionRestrictionVolumesTouching();
	class ATgVisionRestrictionVolume* STATIC_GetATouchingVisionRestrictionVolume();
	void UpdateVisibilityFx();
	class ATgVisibilityVolume* STATIC_GetATouchingVisibilityVolume();
	bool IsInSameVisibilityVolume(class ATgPawn* Other);
	int STATIC_FindVisibilityVolume(class ATgVisibilityVolume* VisVolume);
	int STATIC_NumVisibilityVolumesTouching();
	float STATIC_GetVisibilityVolumeRange();
	void STATIC_RemoveDetectedFx();
	void STATIC_PlayDetectedFx();
	float STATIC_GetDetectionRange();
	bool IsDetector();
	bool IsHardStealthed();
	bool IsStealthed(class ATgRepInfo_Player* Viewer);
	class ATgDevice* STATIC_GetDeviceById(int nDeviceId);
	class ATgDevice* STATIC_GetDeviceByInstanceId(int nDeviceInstanceId);
	struct FString STATIC_GetDeviceNameByID(int DeviceID);
	void STATIC_OnPawnDied();
	void ApplyAnyPushback(float DeltaTime);
	bool STATIC_Pushback(const struct FVector& Distance);
	void STATIC_PlaySpawnFx();
	void STATIC_PrepareIntro();
	void STATIC_PlayBasicAttackAbsorbFx(int nCategoryCode);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_PlayCurrencyFx(class ATgRepInfo_Player* sourcePRI, int nCurrency, int nMsgId);
	float STATIC_GetTerminalVelocity();
	float STATIC_GetDropShadowFadeAmount();
	void UpdateDropShadow();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void STATIC_ForceRecalculateMaterial();
	bool STATIC_CanBeAffectedByVortices();
	bool STATIC_OverrideDistanceFadeRange();
	void STATIC_CalcStealthFadeValue(float fDeltaTime);
	void STATIC_CalcDistanceFadeValue(float fDeltaTime);
	void STATIC_CalcVolumeFadeValue(float fDeltaTime);
	bool IsHittableToSpecialAI();
	bool IsHittableToAI();
	bool STATIC_IsInvisible();
	bool STATIC_ShouldInHandDeviceBeHiddenThisTick();
	bool STATIC_ShouldPawnMeshBeHiddenThisTick();
	class UFont* STATIC_GetFont(int nResId);
	class UMaterialInstanceConstant* STATIC_GetMIC(int nResId);
	void STATIC_PlaySoundCue(int nSoundCueId);
	void STATIC_SetPhase(int nNewPhase);
	void UpdateHUDScores();
	void WardPlaced();
	void TrackDeath();
	void TrackKill(class ATgPawn* Killer);
	void UpdateEnemyAssists(class ATgPawn* Assister);
	void UpdateDamagers(class ATgPawn* Damager);
	void TrackDamageMitigated(class ATgPawn* theInstigator, int nAmount);
	void TrackDamageTaken(class ATgPawn* theInstigator, int nDamage, int nDamageType);
	void TrackSelfKill(int nDeviceModeID);
	void TrackTeamKill(int nDeviceModeID);
	void TrackSelfDamage(int nDeviceModeID, int nDamage);
	void TrackTeamDamage(int nDeviceModeID, int nDamage);
	void TrackReleaseTime(int nDeviceModeID, float fReleaseTime);
	void TrackHit(int nDeviceModeID, float fDistance, bool bHitPlayer);
	void STATIC_RemoveTrackFired(int nDeviceModeID);
	void TrackCompleteKillInfo(int nKillerCharacterID, int nKillerDeviceModeID, int nVictimCharacterID, int nVictimDeviceModeID, const struct FVector& KillerLocation, const struct FVector& VictimLocation, const struct FVector& PetLocation, bool bPetKill);
	void TrackFired(int nDeviceModeID);
	void TrackBotHealing(int nDeviceModeID, float fDamage, float fMissingHealth, int nMaxHealth);
	void TrackSelfHealing(float fHealing, float fMissingHealth, int nMaxHealth);
	void TrackHealing(int nDeviceModeID, float fDamage, float fMissingHealth, int nMaxHealth);
	void TrackKilledBot(int nDeviceModeID);
	void TrackFromPlayerDeath(int nDeviceModeID);
	void TrackKilledPlayer(int nDeviceModeID);
	void TrackDamagedBot(class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage, int nDamageType, bool bIsGod);
	void TrackDamagedPlayer(class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage, int nDamageType, bool bInHand);
	void UpdateStatsTracker();
	void STATIC_EndStats();
	void BeginStats();
	void STATIC_StatsCleanup();
	void ValidateStatsTracker();
	class APawn* STATIC_FindBestKiller(class AController* Killer);
	bool IsShooterTargetValid(class ATgPawn* PawnTarget, class ATgDevice* Dev);
	class ATgPawn* STATIC_FindPlayerPawn(const struct FString& fsName);
	class ATgRepInfo_Player* STATIC_GetPRI();
	void STATIC_RemoveAllAnimationSets();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetEquipPointByType(int nDeviceType);
	unsigned char STATIC_GetTaskForceNumber();
	void SetTaskForceNumber(int nTaskForce);
	float STATIC_CheckTargetDistance(class AActor* TargetActor);
	void AdjustMeshTranslation();
	void KillOwnedBots();
	void KillPet();
	void STATIC_SetPet(class ATgPawn* PetPawn);
	struct FString STATIC_GetResourceFromGAssembly(int ResId);
	void STATIC_ReplaceMeshComponent(int nNewMeshId, class UMeshComponent* DestComponent);
	int STATIC_GetSkinnedSpecialFxId(int nSpecialFxId);
	int STATIC_GetSkinnedMeshId(int nMeshId);
	class UMeshComponent* STATIC_CreateMeshComponent(int nMeshId);
	class UTgSpecialFx* STATIC_GetSpecialFx(int nSpecialFxId);
	void STATIC_SetDeviceVisibility(bool bVisible);
	void STATIC_SetMeshVisibility(bool bVisible);
	bool STATIC_CanSeeActor(class AActor* Other);
	void STATIC_PlayDeathStampFx(class ATgPawn* KilledPawn);
	void STATIC_DeathStamp();
	void STATIC_ServerHandleDeathStamp(class ATgPawn_Character* VictimCharacter);
	void JumpStamp();
	void STATIC_ServerHandleJump();
	bool IsJumpDisabled();
	bool IsPhysicalLadderInFrontOfPawn(bool bTraceFromTopOfCylinder);
	float STATIC_GetGravityZ();
	void AddRemoveAnimSetList(TArray<class UAnimSet*> AnimSetList, bool bAdd);
	void STATIC_PlayGlobalEmoteFx();
	bool IsEmoteMuted();
	void STATIC_CancelEmote(bool bVerifyNoRelevantEmotes, class UTgAnimNodeEmoteSequence* Exclude);
	void STATIC_PlaySoundEmote();
	void STATIC_PlayAnimEmote();
	bool TermRagdoll();
	void LogPawnAnim();
	bool IsPointInsideCollisionCylinder(const struct FVector& Point, float AddHeight, float AddRadius);
	void STATIC_DrawClientDebug();
	bool bIsEditor();
	void STATIC_ReapplyLoadoutEffects();
	void STATIC_ReapplyLevelEffectGroups(int nPrevLevel, int nCurrentLevel, bool bPreserveParams);
	bool STATIC_ShouldAllowSkillUp(bool bIsAutoSkillUp);
	void STATIC_FlashRadialSweep(int nDeviceInstanceId, int nFireModeNum, int nYaw, float fDuration);
	void STATIC_FlashReflect(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc);
	void STATIC_FlashInterruptCharge(int nDeviceInstanceId);
	void STATIC_FlashEndCharge(int nDeviceInstanceId, bool bHitTarget);
	void STATIC_FlashBeginCharge(int nDeviceInstanceId);
	void STATIC_FlashGuanYuV2UltSwing();
	void STATIC_FlashGuanYuV2Dismount();
	void STATIC_FlashFreyaLevitateEnd();
	void STATIC_FlashLevelupFx();
	void STATIC_FlashBasicAttackAbsorb(int nCategoryCode);
	void STATIC_FlashTeleportFx(int nTeleportState, const struct FVector& vLocation);
	void STATIC_FlashChangeMesh();
	void STATIC_FlashDestruct(int nDeviceInstanceId, const struct FVector& vLocation);
	void STATIC_FlashHitReaction();
	void STATIC_FlashResyncClient();
	void STATIC_FlashModeEquipDone(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashEventUpdate();
	void STATIC_FlashResetChainAttack(int nDeviceInstanceId);
	void STATIC_FlashSuccessfulHit(int nDeviceInstanceId, int nFireModeNum, class AActor* Target);
	void STATIC_FlashInterrupt(int nDeviceInstanceId);
	void STATIC_FlashBlockDone(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashBlockFx(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashBlock(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashCooldownDone(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashCooldown(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashStartFireNoSim(int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target);
	void STATIC_FlashStartFire(int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target);
	void STATIC_FlashStopFire(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashArcing(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc, const struct FVector& vOldLoc, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit);
	void STATIC_FlashFireNoSim(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit, float RefireTime);
	void STATIC_FlashFire(int nDeviceInstanceId, int nFireModeNum, const struct FVector& vNewLoc, int nEquipSlot, int nSocketIndex, bool bsuccesfulhit, float RefireTime);
	void STATIC_FlashPlayEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	void STATIC_FlashPlayOffhandFx(int nDeviceInstanceId, const struct FVector& vNewLoc, const struct FVector& vNewDirection, int nSocketIndex);
	void STATIC_FlashBuildUp(int nDeviceInstanceId, int nFireModeNum, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void STATIC_FlashFireMode(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashResetReplication();
	struct FVector NativeCanvasProject(class UCanvas* CanvasToUse, const struct FVector& vLocation);
	int STATIC_DrawNameText(class UCanvas* CanvasToUse, float StartX, float StartY, const struct FString& NameString, class UFont* NameFont, const struct FColor& NameColor, float Scale);
	int STATIC_DrawScaledString(class UCanvas* CanvasToUse, float StartX, float StartY, const struct FString& NameString, class UFont* NameFont, const struct FColor& NameColor, float Scale);
	void STATIC_RemoveAllCrowdControl();
	void STATIC_CrowdControlBreak();
	bool IsCCedOrDead();
	bool IsCrowdControlImmune();
	bool STATIC_ShowImmunityHighlight();
	float STATIC_GetAttackSlow();
	float STATIC_GetBasicAttackGroundSpeedPct();
	float STATIC_GetGroundSpeed(bool bIgnoreSlowDiminishing);
	float STATIC_GetSlowDiminishing();
	void STATIC_ResetProperties();
	void STATIC_SetPropCurrentValue(int nPropIndex, float nNewValue);
	float STATIC_GetPropDisplayValue(int nPropIndex);
	float STATIC_GetPropCurrentValue(int nPropId);
	void STATIC_SetProperty(int nPropIndex, float fNewValue);
	struct FTgPropertyInstance STATIC_GetPropertyCopy(int nPropIndex);
	void AddProperty(int nPropId, float fBase, float fRaw, float FMin, float FMax);
	void InitializeDefaultProps();
	bool ApplyPawnSetup();
	void STATIC_DoBlend(const struct FName& BlendName, float BlendTarget, float BlendTime, class USkeletalMeshComponent* SkelMesh);
	void STATIC_DeviceFormChanged(bool bForceReload);
	class UTgDeviceForm* STATIC_CreateDeviceForm(const struct FEquipDeviceInfo& Info);
	class ATgDevice* STATIC_GetInHandDevice();
	bool IsDisplayedOffhand(class ATgDevice* Dev);
	class ATgDevice* STATIC_GetDisplayedDeviceByEqPoint(TEnumAsByte<ETG_EQUIP_POINT> eEqp);
	class ATgDevice* STATIC_GetDeviceByEqPoint(int eEqPoint);
	void UpdateClientDevices(bool bForce);
	class ATgDevice* STATIC_GetDeviceFiring();
	bool AreAnyDevicesFiring();
	class ATgDevice* STATIC_GetOffhandDeviceLockingFiring(class ATgDevice* CurrentDevice);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void BeginEquipOffhandCooldown();
	struct FVector STATIC_OverrideLookAt();
	bool WantsOverrideLookAt();
	void STATIC_SetAcceptsTargeting(bool bTargetable);
	void STATIC_SetTargetActor(class AActor* Target);
	class ATgPawn* STATIC_GetTargetPawn();
	class AActor* STATIC_GetTargetActor();
};


// Class TgGame.TgPawn_Biped
// 0x0130 (0x2530 - 0x2400)
class ATgPawn_Biped : public ATgPawn
{
public:
	struct FName                                       m_nmLeftFootBone;                                         // 0x2400(0x0008) (Edit)
	struct FName                                       m_nmRightFootBone;                                        // 0x2408(0x0008) (Edit)
	struct FName                                       m_nmLeftFootControlName;                                  // 0x2410(0x0008) (Edit)
	struct FName                                       m_nmRightFootControlName;                                 // 0x2418(0x0008) (Edit)
	float                                              m_fOldLocationZ;                                          // 0x2420(0x0004)
	unsigned long                                      m_bEnableRightFootPlacement : 1;                          // 0x2424(0x0004)
	unsigned long                                      m_bEnableLeftFootPlacement : 1;                           // 0x2424(0x0004)
	unsigned long                                      m_bMayDisableFootIKFromAnimNodes : 1;                     // 0x2424(0x0004)
	unsigned long                                      m_bInitializedFootIKCachedNodeList : 1;                   // 0x2424(0x0004)
	unsigned long                                      m_bApplyLeftHandWeaponIK : 1;                             // 0x2424(0x0004)
	unsigned long                                      m_bSetHandIKStrengthFromAnimNodes : 1;                    // 0x2424(0x0004)
	unsigned long                                      m_bInitializedHandIKCachedNodeList : 1;                   // 0x2424(0x0004)
	unsigned long                                      c_bPlayingRefire : 1;                                     // 0x2424(0x0004)
	unsigned long                                      c_bRefireIsUpperBody : 1;                                 // 0x2424(0x0004)
	float                                              m_fZSmoothingRate;                                        // 0x2428(0x0004) (Const)
	float                                              m_fMaxFootPlacementDistSquared;                           // 0x242C(0x0004)
	class USkelControlFootPlacement*                   m_LeftLegControl;                                         // 0x2430(0x0008)
	class USkelControlFootPlacement*                   m_RightLegControl;                                        // 0x2438(0x0008)
	TArray<struct FName>                               m_FootIKZeroStrengthAnimNodeNameList;                     // 0x2440(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_FootIKZeroStrengthCachedNodeList;                       // 0x2450(0x0010) (NeedCtorLink)
	struct FVector                                     m_vPreviousRightFootPosition;                             // 0x2460(0x000C)
	struct FVector                                     m_vPreviousLeftFootPosition;                              // 0x246C(0x000C)
	float                                              m_fCachedRightTracedFloor;                                // 0x2478(0x0004)
	float                                              m_fCachedLeftTracedFloor;                                 // 0x247C(0x0004)
	float                                              m_fCachedRightFloorNormalZ;                               // 0x2480(0x0004)
	float                                              m_fCachedLeftFloorNormalZ;                                // 0x2484(0x0004)
	int                                                m_nCachedLeftFootBoneIndex;                               // 0x2488(0x0004)
	int                                                m_nCachedRightFootBoneIndex;                              // 0x248C(0x0004)
	struct FName                                       m_SkelControl_LeftHandName;                               // 0x2490(0x0008)
	class USkelControlLimb*                            m_SkelControl_LeftHand;                                   // 0x2498(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_LeftHandRotate;                             // 0x24A0(0x0008)
	struct FName                                       m_SkelControl_RightHandName;                              // 0x24A8(0x0008)
	class USkelControlLimb*                            m_SkelControl_RightHand;                                  // 0x24B0(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_RightHandRotate;                            // 0x24B8(0x0008)
	class USkelControlSingleBone*                      m_SkelControl_RightToLeftPropSwitch;                      // 0x24C0(0x0008)
	TArray<struct FName>                               m_HandIKFullStrengthAnimNodeNameList;                     // 0x24C8(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_HandIKZeroStrengthAnimNodeNameList;                     // 0x24D8(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_HandIKFullStengthCachedNodeList;                        // 0x24E8(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_HandIKZeroStrengthCachedNodeList;                       // 0x24F8(0x0010) (NeedCtorLink)
	class UMaterialInstanceConstant*                   m_FadeMaterialControllerBody;                             // 0x2508(0x0008)
	struct FName                                       c_RefireBeginBlendAnimationName;                          // 0x2510(0x0008)
	struct FName                                       c_RefireEndBlendAnimationName;                            // 0x2518(0x0008)
	class UAnimSet*                                    c_RefireAnimSet;                                          // 0x2520(0x0008)
	float                                              c_fRefireDuration;                                        // 0x2528(0x0004)
	float                                              c_fRefireEndDuration;                                     // 0x252C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Biped");
		return ptr;
	}


	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool STATIC_CanTrackATarget();
	void STATIC_SetAimTarget(float X, float Y, float Z);
	void EnableFootControls(int foot, bool bDisable);
	void zpivot(float F);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void PostBeginPlay();
	void STATIC_EndRefireTimer();
	void STATIC_EndRefire();
	void BeginRefire();
	bool STATIC_InitializeFootIKZeroStrengthAnimNodes(class USkeletalMeshComponent* SkelComp);
	bool STATIC_InitializeLeftHandIKAnimNodes(class USkeletalMeshComponent* SkelComp);
};


// Class TgGame.TgPawn_Character
// 0x0088 (0x25B8 - 0x2530)
class ATgPawn_Character : public ATgPawn_Biped
{
public:
	unsigned long                                      c_bUpdatePlayerStatUI : 1;                                // 0x2530(0x0004)
	unsigned long                                      m_bUpdatePlayerStatFromGoldChange : 1;                    // 0x2530(0x0004) (Const)
	unsigned long                                      m_bCachedTeleportResult : 1;                              // 0x2530(0x0004) (Transient)
	unsigned long                                      s_bRepossessOnPawnSwap : 1;                               // 0x2530(0x0004)
	unsigned long                                      m_bSuppressItemPurchaseAlert : 1;                         // 0x2530(0x0004)
	float                                              c_AttackDurationPausePercentage;                          // 0x2534(0x0004) (Const)
	TArray<struct FPERSISTENT_BUFF_STRUCT>             m_PersistentBuffs;                                        // 0x2538(0x0010) (NeedCtorLink)
	TArray<struct FTG_HUD_INFO>                        c_HudInfos;                                               // 0x2548(0x0010) (NeedCtorLink)
	float                                              m_fLastCapturePointReclaimedTime;                         // 0x2558(0x0004) (Transient)
	float                                              m_fMinReclaimPointTime;                                   // 0x255C(0x0004)
	float                                              m_fLastHealthLowMessageTime;                              // 0x2560(0x0004) (Transient)
	float                                              m_fMinHealthLowMessageTime;                               // 0x2564(0x0004)
	float                                              s_fLastTimeInCombat;                                      // 0x2568(0x0004)
	float                                              m_minWardEmoteTime;                                       // 0x256C(0x0004)
	float                                              m_lastWardEmoteTime;                                      // 0x2570(0x0004)
	float                                              m_fMinItemEmoteTime;                                      // 0x2574(0x0004)
	float                                              m_fLastItemEmoteTime;                                     // 0x2578(0x0004)
	float                                              m_vCachedTeleportTimestamp;                               // 0x257C(0x0004) (Transient)
	struct FVector                                     m_vCachedTeleportDestination;                             // 0x2580(0x000C) (Transient)
	class UTgSpecialFx*                                m_SpecialFountainFX;                                      // 0x258C(0x0008)
	int                                                m_nSpecialFountainFXId;                                   // 0x2594(0x0004)
	struct FVector                                     m_vLastValidGroundLocation;                               // 0x2598(0x000C)
	float                                              m_fMaxDistanceFromGround;                                 // 0x25A4(0x0004)
	struct FDEATH_CAM_ZOOM                             r_DeathCamZoom;                                           // 0x25A8(0x000C) (Net)
	float                                              r_fWardDetectionRange;                                    // 0x25B4(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Character");
		return ptr;
	}


	void STATIC_GetCameraZoomOverride(float* fZoom, float* fTweenSpeed);
	bool AnimNotifySound(class USoundCue* Cue, class UAnimNodeSequence* OwningNode, class UTgAnimNotify_Sound* OwningNotify, float VolumeMultipler, float PitchMultipler);
	void PlayEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	void STATIC_OnRespawn();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_ResetAnimPlayRate();
	void STATIC_ResumeAnimationsAfterHit();
	void STATIC_OnMeleeHitAnimationPause(int nEquipSlot);
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void InterruptRecallFromDamage();
	void InterruptRecall();
	bool ShouldInterruptRecall(bool bDebugLog, TEnumAsByte<ETG_EQUIP_POINT> Slot);
	void Tick(float DeltaSeconds);
	void STATIC_EnablePlayerStatUIUpdate();
	void ReplicatedEvent(const struct FName& VarName);
	void ServerTeleportToLastValidGroundPosition();
	void ClientUpdateAttackSpeed(float fAttackSpeed);
	void ReceivedPropValues();
	bool PostPawnSetup();
	void OnPlayerControllerDisconnect();
	void STATIC_CharacterPawnControllerSet();
	void STATIC_ResetKillCombo();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_PlaySpawnFx();
	void STATIC_PrepareIntro();
	void PostBeginPlay();
	void STATIC_ForceCrouch();
	void STATIC_PlaySeasonalDyingEffects();
	void NotifyTeamOnKillComboReset();
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveString(struct FString* sResult);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_SetWardDetection(bool bCanDetectWards, float fWardDetectionRangeOverride);
	float STATIC_GetDetectionRange();
	bool IsDetector();
	void AddBehaviorScore(TEnumAsByte<ETrackedBehaviorType> eTBT, int nScore);
	void UpdateSpecialFountainFX();
	void AddTargetingAidHudInfos(class ATgPlayerController* PC, struct FVector* CamLoc, struct FVector* CamRot);
	struct FVector STATIC_GetPassivePetSpawnOffset(class ATgPawn* pSpawnedPet);
	void STATIC_DespawnPassivePet();
	void STATIC_SpawnPassivePet();
	void STATIC_InitSpawnedPet(class ATgPawn* Pet);
	int STATIC_GetPassiveRank();
	class UTgDeviceFire* STATIC_GetPassiveFireMode();
	class ATgDevice* STATIC_GetPassiveDevice();
	bool IsPassiveTrained();
	void STATIC_GetConditionalPenetration(class UTgEffectGroup* eg, int nProtectionType, class AActor* Target, float* fFlatPen, float* fPercPen);
	void STATIC_OnSilenceOther(class ATgPawn* Target, class UTgEffectGroup* EffectGroup);
	void STATIC_OnKnockupEnd(class AActor* Target);
	void STATIC_OnSpecialKnockback(class AActor* Target, class AActor* BlockingActor);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_EffectGroupOnStackChange(bool bActive, int nDeltaStacks, class UTgEffectGroup* EffectGroup);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceOnProjShutdown(class ATgDevice* Dev, class ATgProjectile* Proj);
	void STATIC_DeviceCalcConditionalDamageTakenPerc(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamageTakenPerc);
	void STATIC_DeviceAdjustPowerScaling(class ATgDevice* Dev, int nScalingType, struct FImpactInfo* Impact, float* fPhysicalPower, float* fMagicPower);
	void STATIC_DeviceAdjustHeal(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_DeviceAdjustCrit(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void STATIC_DeviceOnHealed(struct FOnHealedParams* Params);
	void STATIC_DeviceOnDodged(struct FOnDodgedParams* Params);
	void STATIC_DeviceOnAbsorbHit(struct FOnAbsorbHitParams* Params);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_DeviceOnHitSpecial(class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnBeforeHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnStopCooldown(class ATgDevice* Dev);
	void STATIC_DeviceOnStartCooldown(class ATgDevice* Dev, float CooldownTime);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnFire(class ATgDevice* Dev);
	void STATIC_DeviceOnAboutToFire(class ATgDevice* Dev);
	void STATIC_PawnOnLifestealing(class ATgPawn* Victim, class UTgEffectGroup* EffectGroup, float* lifestealAmount);
	void STATIC_PawnOnLifesteal(class ATgPawn* attacker, class UTgEffectGroup* EffectGroup, float* lifestealAmount);
	void STATIC_TestOutOfCombatDuration();
	void STATIC_PawnOnCombatEvent();
	void STATIC_PawnOnExitCombat();
	void STATIC_PawnOnEnterCombat();
	void STATIC_PawnOnRevive();
	void STATIC_PawnAdjustHeal(class ATgPawn* InstigatorPawn, int nPropertyId, int nSimplifiedPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_PawnOnHealed(struct FOnHealedParams* Params);
	void STATIC_PawnOnAssisted(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnDodged(struct FOnDodgedParams* Params);
	void STATIC_PawnOnAbsorbHit(struct FOnAbsorbHitParams* Params);
	void STATIC_PawnOnAllyDamaged(class ATgPawn* ally, struct FOnDamagedParams* Params);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	bool STATIC_CacheTeleportDestination(bool bteleporting, const struct FVector& Destination);
	bool STATIC_GetTeleportDestination(struct FVector* Destination);
	void STATIC_OnPawnDied();
	bool ApplyMonsterRewardEffects(class UTgInventoryObject* pItem, bool bRemove);
	bool ApplyItemEffects(class UTgInventoryObject* pItem, bool bRemove);
	void STATIC_ReapplyLoadoutEffects();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void LoadDisconnectedPlayerState();
	bool ApplyPawnSetup();
};


// Class TgGame.TgPawn_Jumong
// 0x0008 (0x25C0 - 0x25B8)
class ATgPawn_Jumong : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_DamageMultiplierMarkComponent;                          // 0x25B8(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Jumong");
		return ptr;
	}


	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
};


// Class TgGame.TgPawn_MeshSwapper
// 0x002C (0x25E4 - 0x25B8)
class ATgPawn_MeshSwapper : public ATgPawn_Character
{
public:
	TArray<struct FStanceInfo>                         m_Stances;                                                // 0x25B8(0x0010) (NeedCtorLink)
	TArray<struct FCachedStanceObject>                 c_StanceCache;                                            // 0x25C8(0x0010) (NeedCtorLink)
	int                                                r_nTargetMesh;                                            // 0x25D8(0x0004) (Net)
	int                                                r_nCurrentStance;                                         // 0x25DC(0x0004) (Net)
	int                                                c_nCurrentSwappedMesh;                                    // 0x25E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_MeshSwapper");
		return ptr;
	}


	class ATgDevice* GetStanceDeviceByID(int nDeviceId);
	void StopFiringAllDevices(bool bClearEquipEffectFlag, bool bResetCooldowns);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_FindAdjustedMeshLocation(const struct FVector& Extent, struct FVector* FouncLocation);
	void STATIC_SwapDevices(int nMeshId);
	void STATIC_SwapToMesh(int nMeshId);
	void STATIC_SwitchStance(int nStanceIndex);
};


// Class TgGame.TgPawn_Racer
// 0x0154 (0x270C - 0x25B8)
class ATgPawn_Racer : public ATgPawn_Character
{
public:
	int                                                s_nIceWallEffectCount;                                    // 0x25B8(0x0004)
	unsigned long                                      c_bApplyIceWallHUDFx : 1;                                 // 0x25BC(0x0004)
	unsigned long                                      c_bApplyCurseHUDFx : 1;                                   // 0x25BC(0x0004)
	unsigned long                                      r_IsDriftButtonPressed : 1;                               // 0x25BC(0x0004) (Net)
	unsigned long                                      r_NitrousActive : 1;                                      // 0x25BC(0x0004) (Net)
	unsigned long                                      r_TravelingWrongWay : 1;                                  // 0x25BC(0x0004) (Net)
	unsigned long                                      r_ShowSpeedLines : 1;                                     // 0x25BC(0x0004) (Net)
	float                                              c_fIceWallHUDFadePercent;                                 // 0x25C0(0x0004)
	float                                              c_fIceWallHUDToggleTime;                                  // 0x25C4(0x0004)
	float                                              m_fIceWallHUDTransitionDuration;                          // 0x25C8(0x0004) (Const)
	int                                                c_IceWallHUDFxId;                                         // 0x25CC(0x0004) (Const)
	class UMaterialInstanceConstant*                   m_IceWallHUDFxMIC;                                        // 0x25D0(0x0008)
	int                                                s_nCurseEffectCount;                                      // 0x25D8(0x0004)
	float                                              c_fCurseHUDFadePercent;                                   // 0x25DC(0x0004)
	float                                              c_fCurseHUDToggleTime;                                    // 0x25E0(0x0004)
	float                                              m_fCurseHUDTransitionDuration;                            // 0x25E4(0x0004) (Const)
	int                                                c_CurseHUDFxId;                                           // 0x25E8(0x0004) (Const)
	class UMaterialInstanceConstant*                   m_CurseHUDFxMIC;                                          // 0x25EC(0x0008)
	float                                              m_Mass;                                                   // 0x25F4(0x0004)
	struct FVector                                     m_Momentum;                                               // 0x25F8(0x000C)
	struct FRacerAnimInstanceData                      r_AnimState;                                              // 0x2604(0x0008) (Net)
	float                                              m_WallCollisionTimer;                                     // 0x260C(0x0004)
	float                                              m_ActorCollisionTimer;                                    // 0x2610(0x0004)
	TEnumAsByte<ERacerGear>                            r_Gear;                                                   // 0x2614(0x0001) (Net)
	TEnumAsByte<ERacerDriftState>                      r_DriftState;                                             // 0x2615(0x0001) (Net)
	TEnumAsByte<ERacerFinishState>                     r_FinishedState;                                          // 0x2616(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x2617(0x0001) MISSED OFFSET
	float                                              m_FwdAccelRate;                                           // 0x2618(0x0004) (Net)
	float                                              m_ReverseAccelRate;                                       // 0x261C(0x0004) (Net)
	float                                              m_BrakeAccelRate;                                         // 0x2620(0x0004) (Net)
	float                                              m_DragAccelRate;                                          // 0x2624(0x0004) (Net)
	float                                              m_PostBoostAccelRate;                                     // 0x2628(0x0004)
	float                                              m_PushForceAccelRate;                                     // 0x262C(0x0004)
	float                                              m_NormalTurnRate;                                         // 0x2630(0x0004)
	float                                              m_TightTurnRate;                                          // 0x2634(0x0004)
	float                                              m_DriftTurnRate;                                          // 0x2638(0x0004)
	float                                              m_TightTurnTime;                                          // 0x263C(0x0004)
	float                                              m_TurnTimer;                                              // 0x2640(0x0004)
	float                                              m_DriftFacingRate;                                        // 0x2644(0x0004)
	float                                              m_BrakeAccumulator;                                       // 0x2648(0x0004)
	float                                              m_TurnFacingAngleOffsets[0x3];                            // 0x264C(0x0004)
	float                                              m_MinDistanceForPushForce;                                // 0x2658(0x0004)
	float                                              m_DriftMinSpeedPercent;                                   // 0x265C(0x0004) (Net)
	int                                                r_BoostCount;                                             // 0x2660(0x0004) (Net)
	float                                              m_BoostAccelModifier;                                     // 0x2664(0x0004) (Net)
	int                                                r_LapsCompleted;                                          // 0x2668(0x0004) (Net)
	int                                                m_HighestLapsCompleted;                                   // 0x266C(0x0004)
	int                                                r_CurrentPlace;                                           // 0x2670(0x0004) (Net)
	float                                              m_LapDistance;                                            // 0x2674(0x0004)
	float                                              m_TotalRaceDistance;                                      // 0x2678(0x0004)
	float                                              m_DistanceBehindFirst;                                    // 0x267C(0x0004)
	float                                              m_fSpeedComeBackRange1;                                   // 0x2680(0x0004) (Const)
	float                                              m_fSpeedComeBackRange2;                                   // 0x2684(0x0004) (Const)
	int                                                m_NumRacersAhead;                                         // 0x2688(0x0004)
	class ATgRacingCheckpoint*                         s_CurrentCheckpoint;                                      // 0x268C(0x0008) (Transient)
	float                                              m_LapTime;                                                // 0x2694(0x0004)
	int                                                m_RubberbandingStackCount;                                // 0x2698(0x0004)
	class UAudioComponent*                             m_EngineAudioComponent;                                   // 0x269C(0x0008) (ExportObject, Component, EditInline)
	class UAudioComponent*                             m_BrakeAudioComponent;                                    // 0x26A4(0x0008) (ExportObject, Component, EditInline)
	class UAudioComponent*                             m_SquealAudioComponent;                                   // 0x26AC(0x0008) (ExportObject, Component, EditInline)
	float                                              m_EngineRPM;                                              // 0x26B4(0x0004)
	struct FRacerSoundData                             m_EngineAccelCue;                                         // 0x26B8(0x0010)
	TArray<class ATgDevice*>                           s_PickupDevices;                                          // 0x26C8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByRacerAction*>           m_ActionAnimNodes;                                        // 0x26D8(0x0010) (NeedCtorLink)
	TArray<class UTgSkelCon_Spring*>                   m_SpringSkelControls;                                     // 0x26E8(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlendByIntroduction*>      m_IntroductionNodes;                                      // 0x26F8(0x0010) (NeedCtorLink)
	float                                              m_HUDCutOffDistance;                                      // 0x2708(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Racer");
		return ptr;
	}


	void ClientPlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	void PlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	void DrawHUD(class AHUD* H);
	void STATIC_ClientSetCurseHUDFx(bool IsActive);
	void SetCurseHUDFx(bool AddCount);
	void STATIC_ClientSetIceWallHUDFx(bool IsActive);
	void SetIceWallHUDFx(bool AddCount);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void OnPlayerControllerDisconnect();
	void VictoryLapExpired();
	void CrossedFinishLine();
	void STATIC_HandleLapCompletedClient(int LapIndex, float LapTime);
	void HandleLapCompleted(int LapIndex);
	void STATIC_HandleRaceStartClient();
	void STATIC_HandleRaceStart();
	void STATIC_PlayRacerIntroductionAnimation();
	void STATIC_HandleCountdownStart();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DebugDump();
	bool DoJump(bool bUpdating);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fTweenSpeed);
	bool IsInTightRegularTurn();
	void Tick(float DeltaSeconds);
	void UpdateEngineSounds(float DeltaTime);
	struct FRotator STATIC_ComputeDrivingRotation(const struct FRotator& PrevRotation, float DeltaTime);
	void UpdateLapTime(float DeltaSeconds);
	void UpdateBoostCount();
	void UpdateDriftState(float DeltaTime);
	void UpdateSpeedLineFx();
	void ToggleTailpipeFx(bool IsOn);
	void ToggleDriftFx(bool IsOn);
	void TryActivateDrift();
	void ToggleDriftButton(bool IsOn);
	void PostBeginPlay();
	void ClientRestart();
	void TgPawnControllerSet();
	void STATIC_CharacterPawnControllerSet();
	void STATIC_SetupCameraAndControlModules();
	void STATIC_OnRightMousePressed();
	void ReplicatedEvent(const struct FName& VarName);
	void LoadCurseHUDFxMIC();
	void LoadIceWallHUDFxMIC();
	void BeginStats();
	void UpdateFloatGameStat(TEnumAsByte<ERacerFloatGameStatsIndices> Index, float val);
	void UpdateIntGameStat(TEnumAsByte<ERacerIntGameStatsIndices> Index, int val);
	void STATIC_IncrementIntGameStat(TEnumAsByte<ERacerIntGameStatsIndices> Index);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PawnOnSlowed(struct FImpactInfo* Impact);
	void STATIC_PawnOnCCed(const struct FImpactInfo& Impact, class UTgEffectGroup* eg);
	void STATIC_HandleHit(struct FImpactInfo* Impact);
	bool TryGivePickup(int nItemId);
	void AddTargetingAidHudInfos(class ATgPlayerController* PC, struct FVector* CamLoc, struct FVector* CamRot);
	void UpdateTargetingAidReticle(TEnumAsByte<ETargetingReticleStyle> reticleStyle, TEnumAsByte<ETargetingHighlightStyle> highlightStyle);
	void UpdateTargetingAid();
	void UpdateRubberBanding(int StackCount);
	float STATIC_GetSlowDiminishing();
	void AnimateWheels();
	TEnumAsByte<ERacerActionAnimNames> STATIC_QueryAnimation();
	void TriggerAnimation(TEnumAsByte<ERacerActionAnimNames> ActioName);
	void STATIC_InitializeEngineAudio();
	void InitializeDefaultProps();
	void UpdateWallPenalty(float DeltaTime);
	void ApplyWallPenalty();
	void STATIC_HandleWallCollision(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
};


// Class TgGame.TgPawn_Guardian
// 0x00A4 (0x25D4 - 0x2530)
class ATgPawn_Guardian : public ATgPawn_Biped
{
public:
	float                                              s_fLastDamageTime;                                        // 0x2530(0x0004)
	float                                              s_fDamageNotificationDelay;                               // 0x2534(0x0004)
	class UTgMarkComponent*                            s_DamageScaler;                                           // 0x2538(0x0008) (ExportObject, Component, EditInline)
	int                                                m_RestPostureID;                                          // 0x2540(0x0004)
	int                                                m_ThronePostureID;                                        // 0x2544(0x0004)
	int                                                s_nCurrentLevel;                                          // 0x2548(0x0004)
	int                                                r_nCurrentLevel;                                          // 0x254C(0x0004) (Net)
	unsigned long                                      s_bWillHeal : 1;                                          // 0x2550(0x0004)
	unsigned long                                      r_bFactoryModified : 1;                                   // 0x2550(0x0004) (Net)
	unsigned long                                      r_bHasLeftThrone : 1;                                     // 0x2550(0x0004) (Net)
	unsigned long                                      m_IsInTransition : 1;                                     // 0x2550(0x0004)
	unsigned long                                      m_bDeathCameraIntialized : 1;                             // 0x2550(0x0004)
	unsigned long                                      m_bUseSocketForDeathCam : 1;                              // 0x2550(0x0004)
	int                                                m_EnragedPostureId;                                       // 0x2554(0x0004)
	int                                                r_nConsecutiveHitCount;                                   // 0x2558(0x0004) (Net)
	struct FVector                                     r_vSpawnLoc;                                              // 0x255C(0x000C) (Net)
	struct FVector                                     r_vSpawnDir;                                              // 0x2568(0x000C) (Net)
	TEnumAsByte<EThroneState>                          r_ThroneState;                                            // 0x2574(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2575(0x0003) MISSED OFFSET
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x2578(0x0008) (ExportObject, Component, EditInline)
	struct FVector                                     m_vCameraLocation;                                        // 0x2580(0x000C)
	struct FRotator                                    m_rCameraRotation;                                        // 0x258C(0x000C)
	float                                              m_fDeathCamTweenSpeed;                                    // 0x2598(0x0004)
	struct FVector                                     m_vDeathCamTweenDir;                                      // 0x259C(0x000C)
	struct FRotator                                    m_rTargetDeathCamRotation;                                // 0x25A8(0x000C)
	float                                              m_fQueuedTotalDeathCamRotationTime;                       // 0x25B4(0x0004)
	struct FRotator                                    m_rQueuedTargetRotation;                                  // 0x25B8(0x000C)
	float                                              m_fRemainingDeathCamRotationTime;                         // 0x25C4(0x0004)
	float                                              m_fTotalDeathCamRotationTime;                             // 0x25C8(0x0004)
	float                                              m_fDuelHealthMod;                                         // 0x25CC(0x0004) (Const)
	float                                              m_fDuelDamageMod;                                         // 0x25D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Guardian");
		return ptr;
	}


	void UpdatePosture();
	void STATIC_FindGoodViewPoint(struct FVector* Loc, struct FRotator* Rot);
	void STATIC_StartDeathCamRotation();
	void OnCameraCutAnimNotify(class UTgAnimNotify_CameraCut* CameraCutNotify);
	void CompletedTransition();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void STATIC_GetOffThroneEnd();
	void GetOffThroneStart();
	void Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	void SetInitialState();
	bool IsIdle();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void ReplicatedEvent(const struct FName& VarName);
	void Update1v1Props();
	int STATIC_GetConsecutiveHitCount();
	int STATIC_GetCurrentHealthLevel();
	void STATIC_RegainPools(float fDelta);
	bool STATIC_CanMove();
	void STATIC_PostPawnSetupServer();
	void UpdateLevel();
	void TriggerResetHeal();
	void STATIC_PawnOnExitCombat();
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_CheckLastTarget();
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_SetTargetActor(class AActor* Target);
	void STATIC_SendDeathAlert();
	void STATIC_SendAttackAlert();
};


// Class TgGame.TgPawn_Guardian_EgyptClash
// 0x0000 (0x25D4 - 0x25D4)
class ATgPawn_Guardian_EgyptClash : public ATgPawn_Guardian
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Guardian_EgyptClash");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
};


// Class TgGame.TgPawn_Minotaur
// 0x0000 (0x25D4 - 0x25D4)
class ATgPawn_Minotaur : public ATgPawn_Guardian
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Minotaur");
		return ptr;
	}

};


// Class TgGame.TgPawn_Manticore
// 0x0000 (0x2530 - 0x2530)
class ATgPawn_Manticore : public ATgPawn_Biped
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Manticore");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void UpdateLevel();
};


// Class TgGame.TgPawn_Minion
// 0x005C (0x258C - 0x2530)
class ATgPawn_Minion : public ATgPawn_Biped
{
public:
	float                                              s_fSpeedMultiplierToCatchUpToSquad;                       // 0x2530(0x0004)
	class ATgPawn_Character*                           s_PlayerAttacker;                                         // 0x2534(0x0008)
	struct FFireMinionIds                              m_FireMinionIds;                                          // 0x253C(0x0050) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Minion");
		return ptr;
	}


	void PlayDeathAnimation();
	void ToggleAggroAlert(bool bOn);
	void ReplicatedEvent(const struct FName& VarName);
	void TargetActorUpdated();
	void STATIC_RememberPlayerAttackerExpired();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Despawn();
	bool STATIC_CanDespawn();
	void STATIC_SetTargetActor(class AActor* Target);
	void STATIC_PostPawnSetupServer();
	void STATIC_SetInitialLevel();
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
};


// Class TgGame.TgPawn_CH06_SummonSword
// 0x0014 (0x25A0 - 0x258C)
class ATgPawn_CH06_SummonSword : public ATgPawn_Minion
{
public:
	unsigned long                                      m_bDistanceScalingWasInitialized : 1;                     // 0x258C(0x0004)
	float                                              m_fMinDistance;                                           // 0x2590(0x0004)
	float                                              m_fMaxDistance;                                           // 0x2594(0x0004)
	float                                              m_fMinMultiplier;                                         // 0x2598(0x0004)
	float                                              m_fMaxMultiplier;                                         // 0x259C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH06_SummonSword");
		return ptr;
	}


	void STATIC_OnPawnDied();
	void STATIC_InitializeDistanceScaling();
	float STATIC_CalcDistanceMultiplier();
	float STATIC_GetMagicalPowerBot();
	float STATIC_GetPhysicalPowerBot();
};


// Class TgGame.TgPawn_Chicken_PVE
// 0x0008 (0x2594 - 0x258C)
class ATgPawn_Chicken_PVE : public ATgPawn_Minion
{
public:
	unsigned long                                      r_bUnhatched : 1;                                         // 0x258C(0x0004) (Net)
	int                                                c_nHatchedPostureId;                                      // 0x2590(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Chicken_PVE");
		return ptr;
	}


	void Tick(float DeltaSeconds);
};


// Class TgGame.TgPawn_LanePusher
// 0x0010 (0x259C - 0x258C)
class ATgPawn_LanePusher : public ATgPawn_Minion
{
public:
	float                                              s_fTimeSinceLastPing;                                     // 0x258C(0x0004)
	TEnumAsByte<EDestroyedAnimStages>                  c_eDestroyedAnimStage;                                    // 0x2590(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2591(0x0003) MISSED OFFSET
	class UTgSpecialFx*                                c_BeamFX;                                                 // 0x2594(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_LanePusher");
		return ptr;
	}


	void ReceivedPropValues();
	void Tick(float DeltaSeconds);
	void ModifyHealthProp(int nDamage);
	void STATIC_OnPawnDied();
	void STATIC_SetInitialLevel();
	void STATIC_SendPing();
};


// Class TgGame.TgPawn_Juggernaut
// 0x0094 (0x2630 - 0x259C)
class ATgPawn_Juggernaut : public ATgPawn_LanePusher
{
public:
	struct FVector                                     m_vArcherNestOffset;                                      // 0x259C(0x000C)
	struct FVector                                     m_vArcherFiringOffsets[0x2];                              // 0x25A8(0x000C)
	TArray<class UAnimNodeBlend*>                      c_ActiveArcherBlendNodes;                                 // 0x25C0(0x0010) (NeedCtorLink)
	struct FName                                       c_ActiveArcherBlendName;                                  // 0x25D0(0x0008)
	TEnumAsByte<EJuggernautActiveArcher>               r_eActiveArcher;                                          // 0x25D8(0x0001) (Net)
	TEnumAsByte<EJuggernautActiveArcher>               c_eLocalActiveArcher;                                     // 0x25D9(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x25DA(0x0002) MISSED OFFSET
	float                                              c_fActiveArcherBlendTime;                                 // 0x25DC(0x0004)
	TArray<struct FMinionSpawnInfo>                    m_MinionSpawnProfiles;                                    // 0x25E0(0x0010) (NeedCtorLink)
	int                                                r_nActiveMinionSpawnProfile;                              // 0x25F0(0x0004) (Net)
	class AActor*                                      r_SpawnedMinions[0x2];                                    // 0x25F4(0x0008) (Net)
	class USkelControlBase*                            c_MinionSkelControls[0x2];                                // 0x2604(0x0008)
	struct FName                                       c_MinionSkelControlNames[0x2];                            // 0x2614(0x0008)
	int                                                m_nMinionBotId;                                           // 0x2624(0x0004) (Const)
	int                                                m_nMinionSkinId[0x2];                                     // 0x2628(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Juggernaut");
		return ptr;
	}


	void ScaleOutMinions();
	void UpdateActiveArcher(TEnumAsByte<EJuggernautActiveArcher> NewArcher);
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	struct FName GetDeathAnimName();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_PostPawnSetupServer();
	void STATIC_SpawnMinions();
};


// Class TgGame.TgPawn_SiegeMinion
// 0x0000 (0x258C - 0x258C)
class ATgPawn_SiegeMinion : public ATgPawn_Minion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeMinion");
		return ptr;
	}

};


// Class TgGame.TgPawn_WiseCleric
// 0x0001 (0x258D - 0x258C)
class ATgPawn_WiseCleric : public ATgPawn_SiegeMinion
{
public:
	TEnumAsByte<EDestroyAnimStages>                    c_eDestroyAnimStage;                                      // 0x258C(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_WiseCleric");
		return ptr;
	}


	void STATIC_PostPawnSetupServer();
	void ReceivedPropValues();
	void ModifyHealthProp(int nDamage);
	void Despawn();
};


// Class TgGame.TgPawn_Monster
// 0x0040 (0x2570 - 0x2530)
class ATgPawn_Monster : public ATgPawn_Biped
{
public:
	float                                              m_fSecondsBeforeRest;                                     // 0x2530(0x0004)
	int                                                m_RestPostureID;                                          // 0x2534(0x0004)
	int                                                m_FussyPostureID;                                         // 0x2538(0x0004)
	int                                                s_nApplyOnDeathItemId;                                    // 0x253C(0x0004)
	unsigned long                                      m_bResetHealthOnEvade : 1;                                // 0x2540(0x0004)
	unsigned long                                      m_bLookAtAggressor : 1;                                   // 0x2540(0x0004)
	unsigned long                                      r_bAggressorInLeashVolume : 1;                            // 0x2540(0x0004) (Net)
	unsigned long                                      m_bLeashCanEvadeDamage : 1;                               // 0x2540(0x0004)
	unsigned long                                      s_bAttackAggressorOnSight : 1;                            // 0x2540(0x0004)
	unsigned long                                      m_bTrackObjectiveSteal : 1;                               // 0x2540(0x0004)
	unsigned long                                      m_bWantsDeathFX : 1;                                      // 0x2540(0x0004)
	class AActor*                                      s_BestAggressor;                                          // 0x2544(0x0008)
	TArray<int>                                        s_nAttackOnSightIgnoredCategoryCodes;                     // 0x254C(0x0010) (NeedCtorLink)
	int                                                m_nTaskforceDamage[0x2];                                  // 0x255C(0x0004)
	int                                                m_nBuffDeployableOverride;                                // 0x2564(0x0004)
	struct FName                                       r_nmDeathAnimOverride;                                    // 0x2568(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Monster");
		return ptr;
	}


	void NotifyTouchers();
	void SetCustomLightingChannels();
	bool STATIC_StartIdleInRestPosture(const struct FName& PrevStateName);
	void STATIC_RemoveHealthRegenBuff();
	void ApplyHealthRegenBuff();
	void STATIC_EnterRestPosture();
	void UpdateAgressorInLeashVolume(bool bInVolume);
	void SetInitialState();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void Intoxicate(bool bIntoxicated, float Duration, int FxId);
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	bool IsFussy();
	bool IsEvading();
	bool IsIdle();
	struct FName GetDeathAnimName();
	void ReplicatedEvent(const struct FName& VarName);
	int STATIC_GetBuffDeployableId();
	void AttackOnSightLogic(class ATgPawn* Target, class ATgAIController_BehaviorMapNpc* leashController);
	void STATIC_InitObjectiveTracking();
	bool STATIC_HasDeathPostureAnimation();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void TrackDamageTaken(class ATgPawn* theInstigator, int nDamage, int nDamageType);
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	bool STATIC_CheckForAggressorInLeashVolume();
	bool STATIC_IgnoreThreatsFromDamage();
	bool IsNonCombat();
	void STATIC_SetTargetActor(class AActor* Target);
	void STATIC_PostPawnSetupServer();
	void STATIC_SetInitialLevel();
	void STATIC_PlayDeathFXFor(class AController* Killer);
	bool WantsDeathFX();
	void ApplyDeathItem(class AController* Killer);
};


// Class TgGame.TgPawn_Centaur
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_Centaur : public ATgPawn_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Centaur");
		return ptr;
	}

};


// Class TgGame.TgPawn_CH08_CenterObjective
// 0x0008 (0x2578 - 0x2570)
class ATgPawn_CH08_CenterObjective : public ATgPawn_Monster
{
public:
	int                                                m_nScalingItemId;                                         // 0x2570(0x0004)
	unsigned long                                      m_bHasAppliedScalingItem : 1;                             // 0x2574(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH08_CenterObjective");
		return ptr;
	}


	bool PostPawnSetup();
	void ApplyRoundScalingItem();
	void ApplyDeathItem(class AController* Killer);
};


// Class TgGame.TgPawn_Cyclops
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_Cyclops : public ATgPawn_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Cyclops");
		return ptr;
	}


	int STATIC_GetBuffDeployableId();
	void ApplyDeathItem(class AController* Killer);
};


// Class TgGame.TgPawn_Apep
// 0x0024 (0x2594 - 0x2570)
class ATgPawn_Apep : public ATgPawn_Cyclops
{
public:
	class UTgSpecialFx*                                c_Offhand01Beam;                                          // 0x2570(0x0008)
	unsigned long                                      r_Offhand01BeamActive : 1;                                // 0x2578(0x0004) (Net)
	unsigned long                                      r_bOffhand02Firing : 1;                                   // 0x2578(0x0004) (Net)
	struct FVector                                     r_Offhand01BeamLocation;                                  // 0x257C(0x000C) (Net)
	struct FVector                                     r_vOffhand2Aim;                                           // 0x2588(0x000C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Apep");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void PlayStrikeAnim(const struct FVector& EndTrace);
	void ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_OverrideLookAt();
	bool WantsOverrideLookAt();
	void STATIC_PostPawnSetupServer();
	void ApplyDeathItem(class AController* Killer);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void ToggleOffhand01Beam(bool IsOn);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
};


// Class TgGame.TgPawn_Scorpion
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_Scorpion : public ATgPawn_Cyclops
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Scorpion");
		return ptr;
	}

};


// Class TgGame.TgPawn_DuoLane_S8
// 0x003C (0x25AC - 0x2570)
class ATgPawn_DuoLane_S8 : public ATgPawn_Scorpion
{
public:
	int                                                m_nDownedPostureId;                                       // 0x2570(0x0004)
	float                                              m_fDownedTimer;                                           // 0x2574(0x0004)
	unsigned long                                      m_bHasBeenDowned : 1;                                     // 0x2578(0x0004)
	unsigned long                                      r_bIsDowned : 1;                                          // 0x2578(0x0004) (Net)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x2578(0x0004)
	struct FName                                       m_nmDownedTimerComplete;                                  // 0x257C(0x0008) (Const)
	struct FName                                       m_nmDownedState;                                          // 0x2584(0x0008) (Const)
	struct FName                                       m_nmPostDownedState;                                      // 0x258C(0x0008) (Const)
	int                                                m_nScaleMod;                                              // 0x2594(0x0004) (Const)
	float                                              r_fHealthOnRecoverPercent;                                // 0x2598(0x0004) (Const, Net, Config)
	int                                                r_nHitsToKill;                                            // 0x259C(0x0004) (Net, Config)
	int                                                r_nHitsRemaining;                                         // 0x25A0(0x0004) (Net)
	class ATgDevice_AuraToggle*                        m_devPassive;                                             // 0x25A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_DuoLane_S8");
		return ptr;
	}


	void STATIC_RecoverHealth();
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_RemoveHealthRegenBuff();
	void ApplyHealthRegenBuff();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_TakeDownedHit(int nHitCount);
	void STATIC_CalculateHitsToKill();
	void STATIC_PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	float STATIC_GetMaxHealth();
	float STATIC_GetHealth();
	void UpdateClientDevices(bool bForce);
	void STATIC_CacheConfigValues();
	void STATIC_PostPawnSetupServer();
	void STATIC_DownedTimerInterrupted(class AController* contInterrupter, const struct FVector& HitLocation, class UClass* DamageType);
	void STATIC_DownedTimerComplete();
};


// Class TgGame.TgPawn_Cyclops_Dom2016a
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_Cyclops_Dom2016a : public ATgPawn_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Cyclops_Dom2016a");
		return ptr;
	}


	void ApplyDeathItem(class AController* Killer);
};


// Class TgGame.TgPawn_Elemental
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_Elemental : public ATgPawn_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Elemental");
		return ptr;
	}


	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
};


// Class TgGame.TgPawn_PortalDemon
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_PortalDemon : public ATgPawn_Elemental
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_PortalDemon");
		return ptr;
	}

};


// Class TgGame.TgPawn_Betray
// 0x0008 (0x2578 - 0x2570)
class ATgPawn_Betray : public ATgPawn_PortalDemon
{
public:
	class UTgSpecialFx*                                c_BeamFX;                                                 // 0x2570(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Betray");
		return ptr;
	}

};


// Class TgGame.TgPawn_EliteMOB_CH06
// 0x0004 (0x2574 - 0x2570)
class ATgPawn_EliteMOB_CH06 : public ATgPawn_Monster
{
public:
	unsigned long                                      m_bUnpausesAfterIntro : 1;                                // 0x2570(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_EliteMOB_CH06");
		return ptr;
	}


	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_SetTargetActor(class AActor* Target);
};


// Class TgGame.TgPawn_CH06_Trapper
// 0x0014 (0x2588 - 0x2574)
class ATgPawn_CH06_Trapper : public ATgPawn_EliteMOB_CH06
{
public:
	class UTgSpecialFx*                                c_PullBeamFx;                                             // 0x2574(0x0008) (Transient)
	class UTgSkeletalMeshComponent*                    c_PullMissMeshComponent;                                  // 0x257C(0x0008) (ExportObject, Transient, Component, EditInline)
	unsigned long                                      m_bCancelPull : 1;                                        // 0x2584(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH06_Trapper");
		return ptr;
	}


	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	void STATIC_PlayPullRetrieve();
	void KillPullBeam();
	void SetPullBeamTarget(class AActor* Target);
	void STATIC_PlayDyingEffects();
	void DetachDev3Mesh();
	void AttachDev3Mesh();
	bool PostPawnSetup();
	void STATIC_InitializePullBeamFx();
	void STATIC_ResetDev3MeshComponent();
	bool STATIC_InitializeDev3MeshComponent();
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_FireGiant
// 0x0014 (0x2584 - 0x2570)
class ATgPawn_FireGiant : public ATgPawn_Monster
{
public:
	unsigned long                                      m_IsInTransition : 1;                                     // 0x2570(0x0004)
	float                                              m_fInitialTransitionTime;                                 // 0x2574(0x0004)
	float                                              m_fRegularTransitionTime;                                 // 0x2578(0x0004)
	class UParticleSystemComponent*                    m_FlamingBoulderPSC;                                      // 0x257C(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_FireGiant");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SetCustomLightingChannels();
	void Tick(float fDeltaTime);
	void CompletedTransition();
	void STATIC_PlayInitialSpawnFX();
	void PostBeginPlay();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_CanMove();
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void ApplyDeathItem(class AController* Killer);
	void STATIC_SendDeathAlert(int TaskForce);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_FireGiant_GC2015a
// 0x0028 (0x25AC - 0x2584)
class ATgPawn_FireGiant_GC2015a : public ATgPawn_FireGiant
{
public:
	float                                              fSpawnFromChestIntroTime;                                 // 0x2584(0x0004)
	float                                              fChestTriggeredTime;                                      // 0x2588(0x0004)
	unsigned long                                      bChestTriggered : 1;                                      // 0x258C(0x0004)
	int                                                nChestIntroMeshAssembyForAnimSetsId;                      // 0x2590(0x0004)
	TArray<class UAnimSet*>                            FromChestAnimSets;                                        // 0x2594(0x0010) (NeedCtorLink)
	struct FPointer                                    ChestIntroMeshAssembyForAnimSets;                         // 0x25A4(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_FireGiant_GC2015a");
		return ptr;
	}


	bool STATIC_StartIdleInRestPosture(const struct FName& PrevStateName);
	void AttemptToTriggerChest();
	void STATIC_SetChestOpened();
	void DoIntroduction(bool bUseInitialIntro);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SwapToLiveMesh();
};


// Class TgGame.TgPawn_SiegeBoss
// 0x0014 (0x25C0 - 0x25AC)
class ATgPawn_SiegeBoss : public ATgPawn_FireGiant_GC2015a
{
public:
	TArray<class ATgPawn*>                             s_Attackers;                                              // 0x25AC(0x0010) (NeedCtorLink)
	int                                                s_nBackupDeployableId;                                    // 0x25BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SiegeBoss");
		return ptr;
	}


	bool STATIC_GiveDevice(int nItemId, class ATgInventoryManager* TargetInv);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void ApplyDeathItem(class AController* Killer);
};


// Class TgGame.TgPawn_FireGiant_S5
// 0x0010 (0x2594 - 0x2584)
class ATgPawn_FireGiant_S5 : public ATgPawn_FireGiant
{
public:
	int                                                m_nMaxFuryShots;                                          // 0x2584(0x0004)
	float                                              m_fIntroTime;                                             // 0x2588(0x0004)
	int                                                r_nPreviousOnFuryFX;                                      // 0x258C(0x0004) (Net)
	int                                                r_nPreviousOffFuryFX;                                     // 0x2590(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_FireGiant_S5");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void TurnOnDistanceFade();
	void CleanUpRagnarokFuryVars();
	void ClearRagnarokFuryFX();
	void TurnOffIndividualRagnarokFuryFX();
	void TurnOnAllRagnarokFuryFX();
	void TurnOnIndividualRagnarokFuryFX();
	bool STATIC_CheckForAggressorInLeashVolume();
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_FireGiant_CHRR
// 0x0000 (0x2594 - 0x2594)
class ATgPawn_FireGiant_CHRR : public ATgPawn_FireGiant_S5
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_FireGiant_CHRR");
		return ptr;
	}

};


// Class TgGame.TgPawn_Fury
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_Fury : public ATgPawn_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Fury");
		return ptr;
	}


	int STATIC_GetBuffDeployableId();
	void ApplyDeathItem(class AController* Killer);
};


// Class TgGame.TgPawn_GoldFury
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_GoldFury : public ATgPawn_Fury
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_GoldFury");
		return ptr;
	}


	void SetCustomLightingChannels();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void ApplyDeathItem(class AController* Killer);
	void STATIC_SendDeathAlert(int TaskForce);
};


// Class TgGame.TgPawn_GoldFury_GC2015a
// 0x0040 (0x25B0 - 0x2570)
class ATgPawn_GoldFury_GC2015a : public ATgPawn_GoldFury
{
public:
	float                                              fSpawnFromInitialIntroTime;                               // 0x2570(0x0004)
	unsigned long                                      bInitialIntroSetLoaded : 1;                               // 0x2574(0x0004)
	unsigned long                                      bSpectatorInitialIntroSetLoaded : 1;                      // 0x2574(0x0004)
	int                                                nInitialIntroMeshAssembyForAnimSetsId;                    // 0x2578(0x0004)
	TArray<class UAnimSet*>                            InitialIntroAnimSets;                                     // 0x257C(0x0010) (NeedCtorLink)
	struct FPointer                                    InitialIntroMeshAssembyForAnimSets;                       // 0x258C(0x0008) (Native)
	int                                                nSpectatorInitialIntroMeshAssembyForAnimSetsId;           // 0x2594(0x0004)
	TArray<class UAnimSet*>                            SpectatorInitialIntroAnimSets;                            // 0x2598(0x0010) (NeedCtorLink)
	struct FPointer                                    SpectatorInitialIntroMeshAssembyForAnimSets;              // 0x25A8(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_GoldFury_GC2015a");
		return ptr;
	}


	bool STATIC_StartIdleInRestPosture(const struct FName& PrevStateName);
	void DoIntroduction(bool bUseInitialIntro);
	void STATIC_SwapToLiveMesh();
};


// Class TgGame.TgPawn_JoustBoss
// 0x0004 (0x2574 - 0x2570)
class ATgPawn_JoustBoss : public ATgPawn_GoldFury
{
public:
	int                                                s_nStructureDebuffItemId;                                 // 0x2570(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_JoustBoss");
		return ptr;
	}


	void ApplyDeathItemToStructures(class AController* Killer);
	void ApplyDeathItem(class AController* Killer);
};


// Class TgGame.TgPawn_JuggernautJungle
// 0x0004 (0x2574 - 0x2570)
class ATgPawn_JuggernautJungle : public ATgPawn_GoldFury
{
public:
	unsigned long                                      m_bMeshSwapped : 1;                                       // 0x2570(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_JuggernautJungle");
		return ptr;
	}


	void STATIC_OnSwapToDestroyedMesh();
	void PlayDeathAnimation();
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void STATIC_SendDeathAlert(int TaskForce);
};


// Class TgGame.TgPawn_MOB_Adv
// 0x0004 (0x2574 - 0x2570)
class ATgPawn_MOB_Adv : public ATgPawn_Monster
{
public:
	unsigned long                                      m_bUnpausesAfterIntro : 1;                                // 0x2570(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_MOB_Adv");
		return ptr;
	}


	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_SetTargetActor(class AActor* Target);
};


// Class TgGame.TgPawn_Boar_Adv
// 0x0020 (0x2594 - 0x2574)
class ATgPawn_Boar_Adv : public ATgPawn_MOB_Adv
{
public:
	TArray<class ATgPawn*>                             s_ModTriggerDamagers;                                     // 0x2574(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             s_ModTriggerDamaged;                                      // 0x2584(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Boar_Adv");
		return ptr;
	}


	bool STATIC_IgnoreFaceRotationWithInterp();
	void Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	void BumpLevel(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnPawnDied();
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
};


// Class TgGame.TgPawn_CH05_Draugr
// 0x000C (0x25A0 - 0x2594)
class ATgPawn_CH05_Draugr : public ATgPawn_Boar_Adv
{
public:
	class ATgDevice*                                   m_SeaweedManager;                                         // 0x2594(0x0008)
	unsigned long                                      r_bIsOnBoat : 1;                                          // 0x259C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH05_Draugr");
		return ptr;
	}


	void SetCustomLightingChannels();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PawnAdjustHeal(class ATgPawn* InstigatorPawn, int nPropertyId, int nSimplifiedPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_PawnOnHealed(struct FOnHealedParams* Params);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_CH05_Draugr_Nightmare
// 0x0018 (0x25B8 - 0x25A0)
class ATgPawn_CH05_Draugr_Nightmare : public ATgPawn_CH05_Draugr
{
public:
	class ATgDevice*                                   m_NightmareSeaweedManager;                                // 0x25A0(0x0008)
	TArray<class ATgPawn*>                             m_AppliedDoomedPawns;                                     // 0x25A8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH05_Draugr_Nightmare");
		return ptr;
	}


	void STATIC_ForwardNightmareDebuff(class AActor* TargetActor);
	void STATIC_PawnAdjustHeal(class ATgPawn* InstigatorPawn, int nPropertyId, int nSimplifiedPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_PawnOnHealed(struct FOnHealedParams* Params);
};


// Class TgGame.TgPawn_Surtr_Adv
// 0x0000 (0x2594 - 0x2594)
class ATgPawn_Surtr_Adv : public ATgPawn_Boar_Adv
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Surtr_Adv");
		return ptr;
	}


	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgPawn_CH05_DieOnTouch
// 0x0000 (0x2574 - 0x2574)
class ATgPawn_CH05_DieOnTouch : public ATgPawn_MOB_Adv
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH05_DieOnTouch");
		return ptr;
	}


	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_CH05_FrostMob
// 0x0004 (0x2578 - 0x2574)
class ATgPawn_CH05_FrostMob : public ATgPawn_MOB_Adv
{
public:
	unsigned long                                      r_bFrozen : 1;                                            // 0x2574(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH05_FrostMob");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void HandleFreezeState();
	void STATIC_SpawnModifierOnChanged(int ItemId, int NumStacks);
};


// Class TgGame.TgPawn_CH05_FrostEliteMob
// 0x0000 (0x2578 - 0x2578)
class ATgPawn_CH05_FrostEliteMob : public ATgPawn_CH05_FrostMob
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH05_FrostEliteMob");
		return ptr;
	}

};


// Class TgGame.TgPawn_EliteMOB_Adv
// 0x0000 (0x2574 - 0x2574)
class ATgPawn_EliteMOB_Adv : public ATgPawn_MOB_Adv
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_EliteMOB_Adv");
		return ptr;
	}

};


// Class TgGame.TgPawn_CH06_OrderTitan
// 0x0044 (0x25B8 - 0x2574)
class ATgPawn_CH06_OrderTitan : public ATgPawn_EliteMOB_Adv
{
public:
	class UTgMarkComponent*                            m_DivineLightMarks;                                       // 0x2574(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgDeviceFire*>                       m_DivineLightDetonationModes;                             // 0x257C(0x0010) (AlwaysInit, NeedCtorLink)
	class UTgEffectGroup*                              m_DivineLightSlowEffectGroup;                             // 0x258C(0x0008)
	class UTgEffect*                                   m_DivineLightSlowEffect;                                  // 0x2594(0x0008)
	class UTgEffectGroup*                              m_DivineLightBlindEffectGroup;                            // 0x259C(0x0008)
	class UTgEffect*                                   m_DivineLightBlindEffect;                                 // 0x25A4(0x0008)
	float                                              m_DivineLightPercentageProgress;                          // 0x25AC(0x0004)
	class UMaterialInstanceConstant*                   m_DivineLightGlowingMIC;                                  // 0x25B0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH06_OrderTitan");
		return ptr;
	}


	void STATIC_ResetWeaponDuringDivineLight();
	void Tick(float DeltaSeconds);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool PostPawnSetup();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_EliteMOB_Adv_RelevantIntro
// 0x0000 (0x2574 - 0x2574)
class ATgPawn_EliteMOB_Adv_RelevantIntro : public ATgPawn_EliteMOB_Adv
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_EliteMOB_Adv_RelevantIntro");
		return ptr;
	}


	void STATIC_SwapToLiveMesh();
};


// Class TgGame.TgPawn_Hydra_Adv
// 0x0038 (0x25AC - 0x2574)
class ATgPawn_Hydra_Adv : public ATgPawn_MOB_Adv
{
public:
	unsigned long                                      r_bIsActive : 1;                                          // 0x2574(0x0004) (Net)
	unsigned long                                      r_bIsPreDeath : 1;                                        // 0x2574(0x0004) (Net)
	struct FVector                                     r_vPreDeathLookAt;                                        // 0x2578(0x000C) (Net)
	int                                                r_nHitsRemaining;                                         // 0x2584(0x0004) (Net)
	int                                                m_nPreDeathHits;                                          // 0x2588(0x0004)
	float                                              m_fPreDeathTimer;                                         // 0x258C(0x0004)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x2590(0x0008) (ExportObject, Component, EditInline)
	class ATgDeployable*                               s_PreDeathDep;                                            // 0x2598(0x0008)
	class UTgStaticMeshComponent*                      m_PreDeathCollisionComp;                                  // 0x25A0(0x0008) (ExportObject, Component, EditInline)
	int                                                r_nReactionAnim;                                          // 0x25A8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Hydra_Adv");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void STATIC_OnAdventure_TweenForward(class UTgSeqAct_Adventure_TweenForward* Seq);
	void AdjustPreDeathCollision();
	void UpdatePassiveEffects();
	void STATIC_ResetDeath();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void UpdateProjectileOffsets();
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_PlayFullBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, bool bBlendOutIfVelocityIsGreaterThanZero, bool bHideInHandDevice);
	void STATIC_PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void UpdatePreDeathCollision();
	struct FVector STATIC_OverrideLookAt();
	bool WantsOverrideLookAt();
	void STATIC_PostPawnSetupServer();
	bool IsNonCombat();
};


// Class TgGame.TgPawn_Lion_Adv
// 0x002C (0x25A0 - 0x2574)
class ATgPawn_Lion_Adv : public ATgPawn_MOB_Adv
{
public:
	class UTgEffectGroup*                              s_GrabTargetCCImmunity;                                   // 0x2574(0x0008)
	int                                                s_nRestPostureId;                                         // 0x257C(0x0004)
	float                                              s_fTriggerTime;                                           // 0x2580(0x0004)
	float                                              s_fStartTime;                                             // 0x2584(0x0004)
	unsigned long                                      r_bEating : 1;                                            // 0x2588(0x0004) (Net)
	unsigned long                                      r_bIsSleeping : 1;                                        // 0x2588(0x0004) (Net)
	unsigned long                                      r_bIsRoaring : 1;                                         // 0x2588(0x0004) (Net)
	class UTgCameraShake*                              m_LionCamShake;                                           // 0x258C(0x0008)
	class ATgCollisionProxy_ConeKnockback*             s_RoarKnockback;                                          // 0x2594(0x0008)
	float                                              r_fRoarRadius;                                            // 0x259C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Lion_Adv");
		return ptr;
	}


	void EnterCombat(class ATgDevice* Device, class AActor* aInstigator, class AActor* ATarget, float fLength);
	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void STATIC_OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void UpdateSleepingState();
	void UpdateEatingState();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_StopRoar();
	void STATIC_StartRoar();
	void STATIC_OnPawnDied();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_Meat_Adv
// 0x0000 (0x2574 - 0x2574)
class ATgPawn_Meat_Adv : public ATgPawn_MOB_Adv
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Meat_Adv");
		return ptr;
	}


	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
};


// Class TgGame.TgPawn_MOB_Adv_Neutral_ZMasked
// 0x0000 (0x2574 - 0x2574)
class ATgPawn_MOB_Adv_Neutral_ZMasked : public ATgPawn_MOB_Adv
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_MOB_Adv_Neutral_ZMasked");
		return ptr;
	}

};


// Class TgGame.TgPawn_Pillar_Adv
// 0x0008 (0x257C - 0x2574)
class ATgPawn_Pillar_Adv : public ATgPawn_MOB_Adv
{
public:
	unsigned long                                      r_bIsActive : 1;                                          // 0x2574(0x0004) (Net)
	int                                                c_nCachedPhysicality;                                     // 0x2578(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Pillar_Adv");
		return ptr;
	}


	void STATIC_ForcePhysicalityUpdate();
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void OnPawnInitialized();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_OverrideDistanceFadeRange();
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
};


// Class TgGame.TgPawn_Rogue_Adv
// 0x0008 (0x257C - 0x2574)
class ATgPawn_Rogue_Adv : public ATgPawn_MOB_Adv
{
public:
	class ATgPawn*                                     r_LinkedTarget;                                           // 0x2574(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Rogue_Adv");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void Tick(float DeltaSeconds);
	void BreakLinkIfNecessary();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_EndLink();
	void STATIC_StartLink(class ATgPawn* LinkTarget);
	void STATIC_RemoveLockEffectsFromTarget(class ATgPawn* Target);
	void ApplyLockEffectsToTarget(class ATgPawn* Target);
	void STATIC_PawnOnAssisted(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnHardCCed(const struct FImpactInfo& Impact, class UTgEffectGroup* eg);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_OnPawnDied();
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
};


// Class TgGame.TgPawn_Undead_Adv
// 0x0004 (0x2578 - 0x2574)
class ATgPawn_Undead_Adv : public ATgPawn_MOB_Adv
{
public:
	int                                                m_nNumToSpawn;                                            // 0x2574(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Undead_Adv");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_SpawnOffspring();
};


// Class TgGame.TgPawn_Nidhoggr
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_Nidhoggr : public ATgPawn_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Nidhoggr");
		return ptr;
	}


	void ApplyDeathItem(class AController* Killer);
};


// Class TgGame.TgPawn_Skeleton_PVE
// 0x000C (0x257C - 0x2570)
class ATgPawn_Skeleton_PVE : public ATgPawn_Monster
{
public:
	class ATgPawn_AhPuch*                              m_AhPuchPawn;                                             // 0x2570(0x0008) (Const)
	int                                                m_nCorpseDepId;                                           // 0x2578(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Skeleton_PVE");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_InitializeAhPuchRef();
	void STATIC_PostPawnSetupServer();
	void STATIC_SpawnCorpse();
};


// Class TgGame.TgPawn_SoloObjective
// 0x0034 (0x25A4 - 0x2570)
class ATgPawn_SoloObjective : public ATgPawn_Monster
{
public:
	int                                                m_nMaxTaskForces;                                         // 0x2570(0x0004) (Const)
	float                                              s_fTotalDamage;                                           // 0x2574(0x0004)
	TArray<float>                                      s_fTFDamage;                                              // 0x2578(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fSimRepTFPercents;                                      // 0x2588(0x0010) (NeedCtorLink)
	unsigned long                                      r_bCurrentlyTracking : 1;                                 // 0x2598(0x0004) (Net)
	unsigned long                                      r_bTriggerDeathAnim : 1;                                  // 0x2598(0x0004) (Net)
	TEnumAsByte<ESoloObjectiveHitDirection>            r_SoloObjectiveHitDirection;                              // 0x259C(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x259D(0x0003) MISSED OFFSET
	int                                                r_nIncomingAttackCount;                                   // 0x25A0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SoloObjective");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PlayDamageAnim(int Dir);
	void STATIC_OnToggle(class USeqAct_Toggle* inAction);
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Tick(float DeltaTime);
	int STATIC_GetTotemMaterialIndex(int nTaskForceNumber);
	TEnumAsByte<ESoloObjectiveHitDirection> STATIC_GetHitDirection(const struct FVector& HitLocation, const struct FVector& Momentum);
	void TriggerRespawnAnim();
	void TriggerDeathAnim();
	void TriggerSoloObjectiveComplete(int nCaptureTaskForce, class AActor* Killer);
	void UpdateReplicatedTFPercents();
	void ApplySoloObjectiveRewards(int nTeamTaskforce, class AActor* Killer);
};


// Class TgGame.TgPawn_CH13_CenterObjective
// 0x000C (0x25B0 - 0x25A4)
class ATgPawn_CH13_CenterObjective : public ATgPawn_SoloObjective
{
public:
	float                                              r_fTFPercents[0x3];                                       // 0x25A4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH13_CenterObjective");
		return ptr;
	}


	void TriggerSoloObjectiveComplete(int nCaptureTaskForce, class AActor* Killer);
	int STATIC_GetTotemMaterialIndex(int nTaskForceNumber);
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateReplicatedTFPercents();
	void ApplyDeathItem(class AController* Killer);
	void ApplySoloObjectiveDeathItem(class AActor* Killer);
	void STATIC_SetInitialLevel();
};


// Class TgGame.TgPawn_Totem_Conquest_S6
// 0x0008 (0x25AC - 0x25A4)
class ATgPawn_Totem_Conquest_S6 : public ATgPawn_SoloObjective
{
public:
	float                                              r_fTFPercents[0x2];                                       // 0x25A4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Totem_Conquest_S6");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	int STATIC_GetTotemMaterialIndex(int nTaskForceNumber);
	void UpdateReplicatedTFPercents();
};


// Class TgGame.TgPawn_Totem_PEP
// 0x0020 (0x25C4 - 0x25A4)
class ATgPawn_Totem_PEP : public ATgPawn_SoloObjective
{
public:
	float                                              r_fTFPercents[0x4];                                       // 0x25A4(0x0004) (Net)
	TArray<class ATgPawn*>                             s_GuardianList;                                           // 0x25B4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Totem_PEP");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void Destroyed();
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_PostPawnSetupServer();
	void ApplySoloObjectiveRewards(int nTeamTaskforce, class AActor* Killer);
	void TriggerSoloObjectiveComplete(int nCaptureTaskForce, class AActor* Killer);
	void UpdateReplicatedTFPercents();
};


// Class TgGame.TgPawn_Totem_JungleShrine_Conquest_S7
// 0x0058 (0x25C8 - 0x2570)
class ATgPawn_Totem_JungleShrine_Conquest_S7 : public ATgPawn_Monster
{
public:
	int                                                m_nChaliceMeshId;                                         // 0x2570(0x0004) (Const)
	int                                                m_nMaxChalices;                                           // 0x2574(0x0004) (Const)
	int                                                m_nChaliceGoldThreshold;                                  // 0x2578(0x0004) (Const)
	int                                                m_nTotemTaskForce;                                        // 0x257C(0x0004) (Const)
	int                                                m_fFadeDistance;                                          // 0x2580(0x0004) (Const)
	struct FName                                       m_nmConsecutiveHitTimer;                                  // 0x2584(0x0008) (Const)
	TArray<struct FChaliceInfo>                        c_chalices;                                               // 0x258C(0x0010) (Component, NeedCtorLink)
	class UTgSkeletalMeshComponent*                    c_totemMesh;                                              // 0x259C(0x0008) (ExportObject, Component, EditInline)
	int                                                r_nCurrentGoldCount;                                      // 0x25A4(0x0004) (Net)
	int                                                r_nActiveChalices;                                        // 0x25A8(0x0004) (Net)
	int                                                r_nPlayEnemyHitFX;                                        // 0x25AC(0x0004) (Net)
	int                                                c_nClientActiveChalices;                                  // 0x25B0(0x0004)
	int                                                s_nConsecutiveHits;                                       // 0x25B4(0x0004)
	float                                              m_fConsecutiveHitTime;                                    // 0x25B8(0x0004)
	int                                                m_nConsecutiveHitsNeeded;                                 // 0x25BC(0x0004)
	class ATgPlayerController*                         c_localPlayerController;                                  // 0x25C0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Totem_JungleShrine_Conquest_S7");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void SetFactoryInfo(class ATgRepInfo_Factory* FactoryInfo);
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	float STATIC_GetMaxShieldHealth();
	float STATIC_GetShieldHealth();
	void STATIC_OnAddGoldToJungleShrine(class UTgSeqAct_AddGoldToJungleShrine* inAction);
	void STATIC_ConsecutiveHitTimer();
	void STATIC_ConsumeChalice(int NumChalices);
	void ActivateChalice();
	void STATIC_CreateChaliceMeshes(TArray<struct FVector> locations);
	void AddGoldToShrine(int nNumGold);
	void STATIC_CacheShrineFactoryInfo();
};


// Class TgGame.TgPawn_SplineCart
// 0x0050 (0x2580 - 0x2530)
class ATgPawn_SplineCart : public ATgPawn_Biped
{
public:
	float                                              s_fSpeedMultiplierToCatchUpToSquad;                       // 0x2530(0x0004)
	class ATgSplineActor*                              r_StartSpline;                                            // 0x2534(0x0008) (Const, Net)
	struct FServerSplineSync                           r_ServerSync;                                             // 0x253C(0x0010) (Const, Net)
	unsigned long                                      m_bMoving : 1;                                            // 0x254C(0x0004) (Const)
	unsigned long                                      c_bServerSync : 1;                                        // 0x254C(0x0004)
	unsigned long                                      m_bResetTargetOnSetSpline : 1;                            // 0x254C(0x0004) (Const)
	unsigned long                                      m_bDoNotScaleCollisionBoxWithDatabase : 1;                // 0x254C(0x0004) (Const)
	unsigned long                                      c_bApplySplinePitchToMesh : 1;                            // 0x254C(0x0004) (Const)
	unsigned long                                      m_bFullStopWhenNoDesiredSpeed : 1;                        // 0x254C(0x0004) (Const)
	unsigned long                                      s_bStopBackpeddlingAtCheckpoints : 1;                     // 0x254C(0x0004) (Const)
	unsigned long                                      m_bAllowBackpeddling : 1;                                 // 0x254C(0x0004)
	unsigned long                                      r_bAsleep : 1;                                            // 0x254C(0x0004) (Net)
	class ATgSplineActor*                              m_Spline;                                                 // 0x2550(0x0008)
	class UStaticMeshComponent*                        m_CollisionBox;                                           // 0x2558(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fSplineDist;                                            // 0x2560(0x0004)
	float                                              c_fSplineDistCorrection;                                  // 0x2564(0x0004)
	float                                              c_fClientSideMovementFudgeFactor;                         // 0x2568(0x0004)
	float                                              c_fClientCorrectionTolerance;                             // 0x256C(0x0004)
	float                                              c_fClientCorrectionRate;                                  // 0x2570(0x0004)
	float                                              m_fGroundSpeedScaleLastTick;                              // 0x2574(0x0004)
	float                                              r_fTrackGroundSpeed;                                      // 0x2578(0x0004) (Net)
	float                                              m_fAcceleration;                                          // 0x257C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SplineCart");
		return ptr;
	}


	float STATIC_GetDistanceToEndOfSpline();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_SetMovementPhysics();
	void PropertySet(int nPropertyId, float fPreviousValue, float fNewValue);
	void ClientUpdateMoving();
	void PlayDeathAnimation();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_CalcDistanceFadeValue(float fDeltaTime);
	void STATIC_SnapToServerSync();
	void STATIC_ReceiveServerSync();
	void UpdateServerSync();
	void UpdateMoving();
	void STATIC_SetSpline(class ATgSplineActor* NewSpline, bool bSnapToStart);
	void STATIC_SendPing();
	void STATIC_PostPawnSetupServer();
	void STATIC_SetInitialLevel();
};


// Class TgGame.TgPawn_Adv_Cart
// 0x0030 (0x25B0 - 0x2580)
class ATgPawn_Adv_Cart : public ATgPawn_SplineCart
{
public:
	TEnumAsByte<EAdvCartTowerState>                    m_eTowerHealthState;                                      // 0x2580(0x0001)
	TEnumAsByte<EAdvCartFoxState>                      m_eFoxState;                                              // 0x2581(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x2582(0x0002) MISSED OFFSET
	unsigned long                                      m_bInIntroduction : 1;                                    // 0x2584(0x0004)
	unsigned long                                      r_bInTowerTransition : 1;                                 // 0x2584(0x0004) (Net)
	unsigned long                                      r_bInOutroDelay : 1;                                      // 0x2584(0x0004) (Net)
	unsigned long                                      r_bInOutroExitDelay : 1;                                  // 0x2584(0x0004) (Net)
	unsigned long                                      r_bIsStalling : 1;                                        // 0x2584(0x0004) (Net)
	class ATgPawn_CH06_FoxTower*                       r_CurrentTower;                                           // 0x2588(0x0008) (Net)
	float                                              m_fIntroDelayTime;                                        // 0x2590(0x0004)
	float                                              m_fOutroDelayTime;                                        // 0x2594(0x0004)
	float                                              m_fOutroExitDelayTime;                                    // 0x2598(0x0004)
	float                                              m_fStallTime;                                             // 0x259C(0x0004)
	TArray<class UTgAnimNodeBlendByCH06Fox*>           m_FoxBlendList;                                           // 0x25A0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Adv_Cart");
		return ptr;
	}


	bool ShouldSuppressNameplate();
	void ExitFoxTower();
	void DelayForTowerExit();
	void EndTowerTransition();
	void EndStall();
	void EnterFoxTower(class ATgPawn_CH06_FoxTower* foxTower);
	void UpdateFoxTowerHealthState();
	void STATIC_SetStoppedVulnerable();
	void STATIC_SetStoppedImmune();
	void STATIC_SetMoving();
	void STATIC_EndOutroExitDelay();
	void STATIC_EndOutroDelay();
	void STATIC_EndIntroDelay();
	struct FVector GetWeaponStartTraceLocation(class ATgDevice* Dev);
	void PlayDeathAnimation();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void IntroTimer();
	void STATIC_PlayInitialSpawnFX();
	void PostBeginPlay();
	void UpdateFoxState();
	void Tick(float DeltaSeconds);
	bool CanApplyEffects();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgPawn_Familiar
// 0x0064 (0x2464 - 0x2400)
class ATgPawn_Familiar : public ATgPawn
{
public:
	float                                              m_fOwnerPhysPowerBotPercent;                              // 0x2400(0x0004)
	float                                              m_fOwnerPhysPowerItemPercent;                             // 0x2404(0x0004)
	float                                              m_fOwnerMagicalPowerBotPercent;                           // 0x2408(0x0004)
	float                                              m_fOwnerMagicalPowerItemPercent;                          // 0x240C(0x0004)
	float                                              m_fOwnerUltilityPowerItemPercent;                         // 0x2410(0x0004)
	float                                              m_fOwnerFlatPenetrationPercent;                           // 0x2414(0x0004)
	float                                              m_fOwnerPercPenetrationPercent;                           // 0x2418(0x0004)
	float                                              m_fOwnerAttackSpeedPercent;                               // 0x241C(0x0004)
	float                                              m_fOwnerPhysicalProtectionPercent;                        // 0x2420(0x0004)
	float                                              m_fOwnerMagicalProtectionPercent;                         // 0x2424(0x0004)
	float                                              m_fOwnerHealthProtectionPercent;                          // 0x2428(0x0004)
	unsigned long                                      m_bInheritOwnerStats : 1;                                 // 0x242C(0x0004)
	unsigned long                                      m_bAffectedByBumbas : 1;                                  // 0x242C(0x0004)
	unsigned long                                      s_bLastPositionAdjustmentRotationValid : 1;               // 0x242C(0x0004)
	unsigned long                                      s_bPetPositionUsesVelocity : 1;                           // 0x242C(0x0004)
	TEnumAsByte<EPetPhase>                             s_PetPhase;                                               // 0x2430(0x0001)
	TEnumAsByte<EPetPosition>                          s_PetPosition;                                            // 0x2431(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x2432(0x0002) MISSED OFFSET
	struct FRotator                                    s_LastPositionAdjustmentRotation;                         // 0x2434(0x000C)
	struct FVector                                     s_InterpolatedPetPosition;                                // 0x2440(0x000C)
	struct FVector                                     s_InterpolatedPetOwnerPosition;                           // 0x244C(0x000C)
	float                                              s_fPetPositionDistanceMultiplier;                         // 0x2458(0x0004)
	float                                              s_fOwnerVelocityTime;                                     // 0x245C(0x0004)
	float                                              s_fSmoothedMaxSpeed;                                      // 0x2460(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Familiar");
		return ptr;
	}


	void UpdatePetPhase(TEnumAsByte<EPetPhase> NewPhase, const struct FName& SourceName);
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_PostPawnSetupServer();
	float STATIC_GetMagicalProtection();
	float STATIC_GetPhysicalProtection();
	float STATIC_GetAttackSpeed();
	float STATIC_GetPercPenetration(int nProtectionType, class AActor* Target);
	float STATIC_GetFlatPenetration(int nProtectionType, class AActor* Target);
	float STATIC_GetUtilityPowerItem();
	float STATIC_GetMagicalPowerItem(const struct FImpactInfo& Impact, float PowerScaling);
	float STATIC_GetMagicalPowerBot();
	float STATIC_GetPhysicalPowerItem(const struct FImpactInfo& Impact, float PowerScaling);
	float STATIC_GetPhysicalPowerBot();
	class ATgPawn* STATIC_GetOwnerFromController();
};


// Class TgGame.TgPawn_Familiar_LongTerm
// 0x002C (0x2490 - 0x2464)
class ATgPawn_Familiar_LongTerm : public ATgPawn_Familiar
{
public:
	struct FString                                     PetSoundSuffix;                                           // 0x2464(0x0010) (NeedCtorLink)
	float                                              m_fOwnerGroundSpeedPercent;                               // 0x2474(0x0004)
	float                                              m_fLastInheritedGroundSpeed;                              // 0x2478(0x0004)
	unsigned long                                      m_bBoostTexturesForLocalOwner : 1;                        // 0x247C(0x0004)
	TArray<struct FTG_HUD_INFO>                        c_HudInfos;                                               // 0x2480(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Familiar_LongTerm");
		return ptr;
	}


	void STATIC_PlaySpawnFx();
	void STATIC_PrepareIntro();
	void UpdatePetPhase(TEnumAsByte<EPetPhase> NewPhase, const struct FName& SourceName);
	void STATIC_TeleportToOwner();
	void STATIC_OnOwnerAddPercentVitals(float pctHealth);
	void STATIC_OnOwnerGivenPercentVitals(float pctHealth);
	void STATIC_OnOwnerGivenFullVitals();
	void STATIC_OnOwnerPostTeleport();
	void STATIC_OnOwnerJumped();
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	bool STATIC_OwnerPlayedSound(class USoundCue* Cue);
	void UpdateGroundSpeed();
	void STATIC_OnOwnerGroundSpeedChange();
};


// Class TgGame.TgPawn_Courier
// 0x002C (0x24BC - 0x2490)
class ATgPawn_Courier : public ATgPawn_Familiar_LongTerm
{
public:
	struct FCourierPhaseState                          r_CourierPhaseState;                                      // 0x2490(0x000C) (Net)
	TEnumAsByte<ECourierPetPhase>                      m_DefaultCourierPhase;                                    // 0x249C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x249D(0x0003) MISSED OFFSET
	struct FCourierPhaseState                          c_CourierPhaseState;                                      // 0x24A0(0x000C)
	unsigned long                                      c_bClientShowPackage : 1;                                 // 0x24AC(0x0004)
	unsigned long                                      s_CanOnlyBeUsedByOwner : 1;                               // 0x24AC(0x0004)
	float                                              c_fPackageBoneScale;                                      // 0x24B0(0x0004)
	class USkelControlSingleBone*                      c_PackageSkelControl;                                     // 0x24B4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Courier");
		return ptr;
	}


	bool CanApplyEffects();
	void ReturnToDefaultPhase();
	void AnimHidePackage();
	void AnimShowPackage();
	void STATIC_ClientPhaseChanged();
	void UpdatePhaseEnergy();
	void SetCourierPhase(TEnumAsByte<ECourierPetPhase> Phase);
	void AtStore();
	void ArrivedAtStore();
	void TickClientVisuals(float DeltaSeconds);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void PostBeginPlay();
	bool IsAvailable(class ATgPawn* Customer);
	void STATIC_SetCustomer(class ATgPawn* Customer);
	bool BeginTransaction(class ATgPawn* Customer, TEnumAsByte<EPendingTransactionType> Type);
	void STATIC_DropOff();
	void TransactionCancelled();
	void TransactionComplete();
	void STATIC_PostPawnSetupServer();
	void UpdateGroundSpeed();
	void STATIC_SetSpawnEnergy();
	void STATIC_OnPawnDied();
};


// Class TgGame.TgPawn_Courier_FollowOwner
// 0x0039 (0x24F5 - 0x24BC)
class ATgPawn_Courier_FollowOwner : public ATgPawn_Courier
{
public:
	float                                              m_fLeashRange;                                            // 0x24BC(0x0004) (Const)
	float                                              m_fBaseOwnerGroundSpeedPercent;                           // 0x24C0(0x0004) (Const)
	float                                              m_fCatchupInterpSpeed;                                    // 0x24C4(0x0004) (Const)
	float                                              m_fFromRestMovementDelay;                                 // 0x24C8(0x0004) (Const)
	float                                              m_fRotationsPerSecond;                                    // 0x24CC(0x0004) (Const)
	float                                              m_fMovementMinMultiplier;                                 // 0x24D0(0x0004) (Const)
	float                                              m_fMovementMaxMultiplier;                                 // 0x24D4(0x0004) (Const)
	float                                              m_fMovementAcceleration;                                  // 0x24D8(0x0004) (Const)
	float                                              m_fMinMovementDistanceSq;                                 // 0x24DC(0x0004) (Const)
	float                                              m_fZOscillation;                                          // 0x24E0(0x0004) (Const)
	int                                                m_nTeleportFxId;                                          // 0x24E4(0x0004) (Const)
	unsigned long                                      m_bMaintainFixedHeight : 1;                               // 0x24E8(0x0004) (Const)
	unsigned long                                      r_bHidden : 1;                                            // 0x24E8(0x0004) (Const, Net)
	float                                              s_fDefaultZHeight;                                        // 0x24EC(0x0004) (Const)
	float                                              s_fCurrentSpeedMultiplier;                                // 0x24F0(0x0004)
	TEnumAsByte<EPetPosition>                          s_PetPositionOverride;                                    // 0x24F4(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Courier_FollowOwner");
		return ptr;
	}


	void STATIC_OwnerJumpedTimer();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	struct FVector STATIC_GetDesiredRelativePosition();
	void STATIC_CatchUpToOwner(float fDistance, float fDeltaSeconds);
	void STATIC_TeleportToOwner();
	void STATIC_OnOwnerPostTeleport();
	void STATIC_OnOwnerJumped();
	bool IsNonCombat();
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_NeNeKappa
// 0x0000 (0x2464 - 0x2464)
class ATgPawn_NeNeKappa : public ATgPawn_Familiar
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_NeNeKappa");
		return ptr;
	}


	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_Terracotta
// 0x0004 (0x2468 - 0x2464)
class ATgPawn_Terracotta : public ATgPawn_Familiar
{
public:
	unsigned long                                      r_bDiarrhea : 1;                                          // 0x2464(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Terracotta");
		return ptr;
	}


	void PlayDeathAnimation();
	struct FName GetDeathAnimName();
	void STATIC_PlayExplosiveDiarrhea();
	void STATIC_ExplosiveDiarrhea();
	void ReplicatedEvent(const struct FName& VarName);
	void DeviceOnStopFire(class ATgDevice* Dev, bool bWasInterrupted);
};


// Class TgGame.TgPawn_Fountain
// 0x0000 (0x2400 - 0x2400)
class ATgPawn_Fountain : public ATgPawn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Fountain");
		return ptr;
	}


	bool IsNonCombat();
};


// Class TgGame.TgPawn_Structure
// 0x0008 (0x2408 - 0x2400)
class ATgPawn_Structure : public ATgPawn
{
public:
	float                                              s_fLastDamageTime;                                        // 0x2400(0x0004)
	float                                              s_fDamageNotificationDelay;                               // 0x2404(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Structure");
		return ptr;
	}


	void STATIC_SetMovementPhysics();
	void PostDemoRewind();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_SendDeathAlert();
	void STATIC_SendAttackAlert();
	bool STATIC_CanMove();
};


// Class TgGame.TgPawn_Adv_Chest
// 0x0009 (0x2411 - 0x2408)
class ATgPawn_Adv_Chest : public ATgPawn_Structure
{
public:
	unsigned long                                      r_bIsActive : 1;                                          // 0x2408(0x0004) (Net)
	unsigned long                                      r_bIsOpen : 1;                                            // 0x2408(0x0004) (Net)
	int                                                c_nCachedPhysicality;                                     // 0x240C(0x0004)
	TEnumAsByte<EChestType>                            m_eChestType;                                             // 0x2410(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Adv_Chest");
		return ptr;
	}


	void Tick(float DeltaTime);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_ForcePhysicalityUpdate();
	void OnPawnInitialized();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_HandleChestOpen(int nTaskForce);
};


// Class TgGame.TgPawn_CH06_FoxTower
// 0x0004 (0x240C - 0x2408)
class ATgPawn_CH06_FoxTower : public ATgPawn_Structure
{
public:
	unsigned long                                      r_bIsFakingDeath : 1;                                     // 0x2408(0x0004) (Net)
	unsigned long                                      r_bIsTowerActive : 1;                                     // 0x2408(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH06_FoxTower");
		return ptr;
	}


	bool ShouldSuppressNameplate();
	void DeathPreventedFrom(class APawn* attacker);
};


// Class TgGame.TgPawn_CH06_HealingShrine
// 0x002C (0x2434 - 0x2408)
class ATgPawn_CH06_HealingShrine : public ATgPawn_Structure
{
public:
	class UTexture2D*                                  m_TextureNormal;                                          // 0x2408(0x0008)
	int                                                m_nPotionDeployableId;                                    // 0x2410(0x0004) (Edit)
	float                                              m_fRespawnTime;                                           // 0x2414(0x0004) (Edit)
	float                                              m_fSpawnOffset;                                           // 0x2418(0x0004) (Edit)
	class ATgDeployable*                               m_Potion1;                                                // 0x241C(0x0008)
	class ATgDeployable*                               m_Potion2;                                                // 0x2424(0x0008)
	class ATgDeployable*                               m_Potion3;                                                // 0x242C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH06_HealingShrine");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void TryToSpawnHealthPotion();
	class ATgDeployable* STATIC_SpawnHealthPotion(int nSpawnSlot);
};


// Class TgGame.TgPawn_Inhibitor
// 0x0000 (0x2408 - 0x2408)
class ATgPawn_Inhibitor : public ATgPawn_Structure
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Inhibitor");
		return ptr;
	}


	void STATIC_PlaySpawnFx();
	void STATIC_SendDeathAlert();
	void STATIC_SendAttackAlert();
};


// Class TgGame.TgPawn_Nexus
// 0x0000 (0x2408 - 0x2408)
class ATgPawn_Nexus : public ATgPawn_Structure
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Nexus");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_SendDeathAlert();
	void STATIC_SendAttackAlert();
};


// Class TgGame.TgPawn_TowerBase
// 0x005C (0x2464 - 0x2408)
class ATgPawn_TowerBase : public ATgPawn_Structure
{
public:
	class UTgSpecialFx*                                c_BeamFX;                                                 // 0x2408(0x0008) (Transient)
	class UTgMarkComponent*                            s_DamageScaler;                                           // 0x2410(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nNumGuardianLevels;                                     // 0x2418(0x0004)
	unsigned long                                      r_bLocked : 1;                                            // 0x241C(0x0004) (Net)
	unsigned long                                      m_bShouldBeFaded : 1;                                     // 0x241C(0x0004) (Transient)
	unsigned long                                      r_bAllowBackdoorFX : 1;                                   // 0x241C(0x0004) (Net)
	unsigned long                                      r_bBackdoorActive : 1;                                    // 0x241C(0x0004) (Net)
	float                                              m_fTransparentFadeSpeed;                                  // 0x2420(0x0004)
	float                                              m_fMaxFadeTransparency;                                   // 0x2424(0x0004)
	float                                              m_fFadeDistance2D;                                        // 0x2428(0x0004)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x242C(0x0008)
	float                                              m_fBackdoorRange;                                         // 0x2434(0x0004)
	TArray<class AActor*>                              s_NearbyMinions;                                          // 0x2438(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_NearbyGods;                                             // 0x2448(0x0010) (NeedCtorLink)
	int                                                r_nConsecutiveHitCount;                                   // 0x2458(0x0004) (Net)
	class USoundCue*                                   c_ProtCue;                                                // 0x245C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_TowerBase");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool PostPawnSetup();
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void CollisionProxyOnUnTouch(class AActor* Other);
	void CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void InitializeCollisionProxy();
	void STATIC_ForceBackdoorFXOn();
	void ToggleBackdoorFX(bool bToggleOn);
	int STATIC_GetConsecutiveHitCount();
	void STATIC_RemoveImmunity();
	void STATIC_SetImmune();
	void STATIC_SendDeathInputLightingEffects();
	void STATIC_PostPawnSetupServer();
	void STATIC_SetTransparencyFaded(bool bShouldBeFaded);
	void STATIC_CalcDistanceFadeValue(float fDeltaTime);
	bool STATIC_InitializeTeleportIncomingFx();
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_SendTargetedAlert(class ATgPawn* Target);
	void STATIC_SetTargetActor(class AActor* Target);
	void UpdateGuardian();
};


// Class TgGame.TgPawn_Phoenix
// 0x001C (0x2480 - 0x2464)
class ATgPawn_Phoenix : public ATgPawn_TowerBase
{
public:
	float                                              m_fRespawnHealthPct;                                      // 0x2464(0x0004)
	unsigned long                                      s_bIsRespawnedPhoenix : 1;                                // 0x2468(0x0004)
	float                                              m_fRespawnRechargeLimit;                                  // 0x246C(0x0004) (Const)
	TArray<struct FNavMeshBorderEdges>                 BorderEdges;                                              // 0x2470(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Phoenix");
		return ptr;
	}


	bool ShouldRecharge();
	void SetCustomLightingChannels();
	void STATIC_PlayInitialSpawnFX();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	int STATIC_GetRespawnHealthLimit();
	void STATIC_SetSpawnHealth();
	void STATIC_PostPawnSetupServer();
	void STATIC_SendTargetedAlert(class ATgPawn* Target);
	void STATIC_SendRespawnAlert();
	void STATIC_SendDeathAlert();
	void STATIC_SendAttackAlert();
	void STATIC_QueryBorderEdges();
};


// Class TgGame.TgPawn_Djinni
// 0x0040 (0x24C0 - 0x2480)
class ATgPawn_Djinni : public ATgPawn_Phoenix
{
public:
	float                                              m_fScalingTime;                                           // 0x2480(0x0004)
	TArray<struct FScalingProp>                        m_ScalingProperties;                                      // 0x2484(0x0010) (NeedCtorLink)
	class USoundCue*                                   m_EnemyAgroVoxSound;                                      // 0x2494(0x0008)
	class USoundCue*                                   m_FriendlyAgroVoxSound;                                   // 0x249C(0x0008)
	float                                              m_fLastAgroTimestamp;                                     // 0x24A4(0x0004) (Transient)
	class USoundCue*                                   m_IdleVoxSound;                                           // 0x24A8(0x0008)
	class USoundCue*                                   m_EnemyKilledVoxSound;                                    // 0x24B0(0x0008)
	int                                                m_AttackEscalationThreshold;                              // 0x24B8(0x0004)
	float                                              m_AttackEscalationDamageBonus;                            // 0x24BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Djinni");
		return ptr;
	}


	bool CanApplyEffects();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_PlayIdleSound();
	void PostBeginPlay();
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_PostPawnSetupServer();
	void STATIC_SendTargetedAlert(class ATgPawn* Target);
	void STATIC_SendDeathAlert();
	void STATIC_SendAttackAlert();
	void STATIC_ScaleProperties();
};


// Class TgGame.TgPawn_Phoenix_ClashV3
// 0x0008 (0x2488 - 0x2480)
class ATgPawn_Phoenix_ClashV3 : public ATgPawn_Phoenix
{
public:
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x2480(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Phoenix_ClashV3");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
};


// Class TgGame.TgPawn_Phoenix_PVE
// 0x0000 (0x2480 - 0x2480)
class ATgPawn_Phoenix_PVE : public ATgPawn_Phoenix
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Phoenix_PVE");
		return ptr;
	}


	bool ShouldRecharge();
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
};


// Class TgGame.TgPawn_Phoenix_TowerPadOwner
// 0x0008 (0x2488 - 0x2480)
class ATgPawn_Phoenix_TowerPadOwner : public ATgPawn_Phoenix
{
public:
	class ATgStaticMeshActor_TowerPad*                 r_TowerPadMesh;                                           // 0x2480(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Phoenix_TowerPadOwner");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void RegisterTowerPadMesh(class ATgStaticMeshActor_TowerPad* NewMesh);
	void STATIC_SetTargetActor(class AActor* Target);
};


// Class TgGame.TgPawn_Tower
// 0x0070 (0x24D4 - 0x2464)
class ATgPawn_Tower : public ATgPawn_TowerBase
{
public:
	float                                              m_TimeSinceDeath;                                         // 0x2464(0x0004)
	TArray<class UMaterialInstanceConstant*>           m_DestroyedMICs;                                          // 0x2468(0x0010) (NeedCtorLink)
	float                                              m_fFadeOutStartTime;                                      // 0x2478(0x0004)
	float                                              m_fFadeOutEndTime;                                        // 0x247C(0x0004)
	float                                              m_fDamageAngleOffset;                                     // 0x2480(0x0004) (Const)
	struct FVector                                     r_vInitialRotation;                                       // 0x2484(0x000C) (Net)
	unsigned long                                      m_bUseDestruction : 1;                                    // 0x2490(0x0004)
	unsigned char                                      r_nTowerSideHealth[0x4];                                  // 0x2494(0x0001) (Net)
	unsigned char                                      c_nLocalTowerSideHealth[0x4];                             // 0x2498(0x0001)
	unsigned char                                      c_bTowerSideDestroyedLocally[0x4];                        // 0x249C(0x0001)
	unsigned char                                      m_nStartSideHealth;                                       // 0x24A0(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x24A1(0x0003) MISSED OFFSET
	class USkelControlBase*                            c_TowerSideSkelControls[0x4];                             // 0x24A4(0x0008)
	int                                                m_nTowerSideMeshIds[0x4];                                 // 0x24C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower");
		return ptr;
	}


	void SetCustomLightingChannels();
	void PostDemoRewind();
	struct FVector STATIC_GetFireLocationOffset(class ATgDevice* Dev);
	void STATIC_OnSwapToDestroyedMesh();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_CheckSideDestructionSkelControls(int ForceSideIndexHidden);
	void STATIC_PlaySideDestructionAnim(int SideIndex);
	void UpdateTowerSideHealth();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	bool PostPawnSetup();
	void PostBeginPlay();
	float NormalizeDamageAngle(float fAngle);
	void BroadcastDiedToGame();
	void STATIC_SwapToBrokenMesh();
	void STATIC_SendTargetedAlert(class ATgPawn* Target);
	void STATIC_SendDeathAlert();
	void STATIC_SendAttackAlert();
};


// Class TgGame.TgPawn_Tower_ArenaBase
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_ArenaBase : public ATgPawn_Tower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_ArenaBase");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_PointCapture
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_PointCapture : public ATgPawn_Tower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_PointCapture");
		return ptr;
	}


	bool CanApplyEffects();
	void STATIC_SendTargetedAlert(class ATgPawn* Target);
};


// Class TgGame.TgPawn_Tower_PVE
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_PVE : public ATgPawn_Tower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_PVE");
		return ptr;
	}


	void STATIC_SendDeathAlert();
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
};


// Class TgGame.TgPawn_Tower_ClashV2_EasterEgg
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_ClashV2_EasterEgg : public ATgPawn_Tower_PVE
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_ClashV2_EasterEgg");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_ImmunePVE
// 0x000C (0x24E0 - 0x24D4)
class ATgPawn_Tower_ImmunePVE : public ATgPawn_Tower_PVE
{
public:
	class UTgSpecialFx*                                c_ImmuneFx;                                               // 0x24D4(0x0008)
	unsigned long                                      r_GodModeActivated : 1;                                   // 0x24DC(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_ImmunePVE");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetTowerImmuneFx(bool bTurnOn);
};


// Class TgGame.TgPawn_Tower_Obelisk
// 0x0038 (0x250C - 0x24D4)
class ATgPawn_Tower_Obelisk : public ATgPawn_Tower_PVE
{
public:
	TArray<class ATgPawn*>                             m_BuffedAllies;                                           // 0x24D4(0x0010) (NeedCtorLink)
	struct FTowerBeamInfo                              c_BeamTargetInfo;                                         // 0x24E4(0x0010)
	int                                                m_nTowerBeamFxId;                                         // 0x24F4(0x0004)
	struct FVector                                     m_vSpineOffset;                                           // 0x24F8(0x000C)
	class ATgPawn*                                     r_TargetPawn;                                             // 0x2504(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_Obelisk");
		return ptr;
	}


	void CreateBeamInfo(class ATgPawn* Target);
	void DeactivateBeam();
	void STATIC_RemoveAllEffectsOnDeath();
	void UpdateBeamToTarget(const struct FTowerBeamInfo& Info, float DeltaTime);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	class UTgSpecialFx* STATIC_GetBeamFx();
	void STATIC_CalcLinkedTargetLocation(class ATgPawn* TargetPawn, struct FVector* LinkLocation);
	void DeviceOnFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_Tower_TP_PVE
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_TP_PVE : public ATgPawn_Tower_PVE
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_TP_PVE");
		return ptr;
	}


	void AddIncomingTeleport();
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_Tower_TowerPadOwner
// 0x0008 (0x24DC - 0x24D4)
class ATgPawn_Tower_TowerPadOwner : public ATgPawn_Tower
{
public:
	class ATgStaticMeshActor_TowerPad*                 r_TowerPadMesh;                                           // 0x24D4(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_TowerPadOwner");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void RegisterTowerPadMesh(class ATgStaticMeshActor_TowerPad* NewMesh);
	void STATIC_SetTargetActor(class AActor* Target);
};


// Class TgGame.TgPawn_Tower_OlympusS5
// 0x0000 (0x24DC - 0x24DC)
class ATgPawn_Tower_OlympusS5 : public ATgPawn_Tower_TowerPadOwner
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_OlympusS5");
		return ptr;
	}


	struct FVector STATIC_GetFireLocationOffset(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_DialogueInterface
// 0x0000 (0x0060 - 0x0060)
class UTgPawn_DialogueInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_DialogueInterface");
		return ptr;
	}


	class ATgDevice_Dialogue* STATIC_GetDialogueDevice();
};


// Class TgGame.TgPawnSingletonProcessor
// 0x0000 (0x0060 - 0x0060)
class UTgPawnSingletonProcessor : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawnSingletonProcessor");
		return ptr;
	}


	void UnregisterPawn(class ATgPawn* PawnRep);
	bool STATIC_HasFinalizedRepresentation();
	void STATIC_FinalizeRepresentation();
	void STATIC_RegisterPawn(class ATgPawn* PawnRep);
	bool STATIC_RepresentsPawn(class ATgPawn* PawnRep);
};


// Class TgGame.TgPlayerController_Racer
// 0x0001 (0x154D - 0x154C)
class ATgPlayerController_Racer : public ATgPlayerController
{
public:
	unsigned char                                      m_ReverseViewHeld;                                        // 0x154C(0x0001) (Input)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerController_Racer");
		return ptr;
	}


	void STATIC_DriftButtonToggled(bool IsOn);
	void STATIC_StunTypeChanged();
	void ClientSurrender(bool bSurrender);
	void ClientPlayVGS(int nId, int usedVPSetting);
	void ClientPlayLocalEmote(TEnumAsByte<EEmote> Emote);
	void ClientPlayEmote(TEnumAsByte<EEmote> Emote);
};


// Class TgGame.TgSpectatorController
// 0x02BC (0x1808 - 0x154C)
class ATgSpectatorController : public ATgPlayerController
{
public:
	TEnumAsByte<ESpectatorCameraMode>                  m_CameraMode;                                             // 0x154C(0x0001) (Transient)
	TEnumAsByte<ESpectatorCameraCycle>                 m_CurrentCycle;                                           // 0x154D(0x0001) (Transient)
	TEnumAsByte<ESpectatorCameraCycle>                 m_PendingCycle;                                           // 0x154E(0x0001) (Transient)
	TEnumAsByte<ESpecFlightMode>                       m_eHelicopterFlight;                                      // 0x154F(0x0001) (Transient)
	TEnumAsByte<ESpectatorMode>                        m_CurrentSpectatorMode;                                   // 0x1550(0x0001) (Transient)
	TEnumAsByte<EZoomState>                            m_CurrentZoomState;                                       // 0x1551(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x1552(0x0002) MISSED OFFSET
	class ATgSpectatorTempCam*                         m_BookmarkCamera;                                         // 0x1554(0x0008) (Transient)
	struct FSpectatorBookmark                          m_Bookmarks[0xA];                                         // 0x155C(0x0030) (Transient)
	float                                              m_fDefaultTweenTime;                                      // 0x173C(0x0004)
	unsigned long                                      m_bOutlineCharacters : 1;                                 // 0x1740(0x0004) (Transient)
	unsigned long                                      m_bIsMapSquashed : 1;                                     // 0x1740(0x0004) (Transient)
	unsigned long                                      m_bDeferZoomStateReset : 1;                               // 0x1740(0x0004)
	unsigned long                                      m_bIgnoreCullDistanceVolumes : 1;                         // 0x1740(0x0004) (Edit, Config)
	unsigned long                                      m_bPlayerMappingComplete : 1;                             // 0x1740(0x0004) (Transient)
	unsigned long                                      m_bFlippedSides : 1;                                      // 0x1740(0x0004) (Transient)
	unsigned long                                      bIgnoreConsoleLock : 1;                                   // 0x1740(0x0004) (Transient)
	unsigned long                                      m_bSpectatorHideOverlayMesh : 1;                          // 0x1740(0x0004)
	float                                              m_fNameplateFadeMinDist;                                  // 0x1744(0x0004) (Edit)
	float                                              m_fNameplateFadeMaxDist;                                  // 0x1748(0x0004) (Edit)
	float                                              m_fNameplateFadeMaxAmount;                                // 0x174C(0x0004) (Edit)
	float                                              m_fNameplateScaleMinDist;                                 // 0x1750(0x0004) (Edit)
	float                                              m_fNameplateScaleMaxDist;                                 // 0x1754(0x0004) (Edit)
	float                                              m_fNameplateScaleMaxAmount;                               // 0x1758(0x0004) (Edit)
	float                                              m_fInterpolateCameraDistance;                             // 0x175C(0x0004) (Edit)
	float                                              m_fZoomInputCachedWorldTime;                              // 0x1760(0x0004)
	float                                              m_fTargetZoomDest;                                        // 0x1764(0x0004)
	struct FBroadcastChannel                           m_BroadcastChannels[0x4];                                 // 0x1768(0x0008)
	struct FVector                                     c_vMouseClickDeprojectionExtent;                          // 0x1788(0x000C) (Config)
	float                                              m_fOverviewCenterpointOffset;                             // 0x1794(0x0004) (Edit, Config)
	float                                              m_fMouseCursorVisibleTime;                                // 0x1798(0x0004) (Edit, Config)
	float                                              m_fRemainingCursorVisibleTime;                            // 0x179C(0x0004) (Transient)
	struct FVector                                     m_vWorldScreenCenterLocation;                             // 0x17A0(0x000C) (Transient)
	struct FVector                                     m_vWorldScreenCenterDirection;                            // 0x17AC(0x000C) (Transient)
	class ATgPawn*                                     m_PlayerPanelPawn;                                        // 0x17B8(0x0008) (Transient)
	int                                                PlayerMapping[0xA];                                       // 0x17C0(0x0004) (Transient)
	float                                              m_fFollowTopDownBlendTime;                                // 0x17E8(0x0004) (Edit)
	float                                              m_fFollowThirdPersonBlendTime;                            // 0x17EC(0x0004) (Edit)
	int                                                CurrentViewTargetIdx;                                     // 0x17F0(0x0004) (Transient)
	int                                                IntendedViewTargetIdx;                                    // 0x17F4(0x0004) (Transient)
	int                                                m_nSelectedPawnId;                                        // 0x17F8(0x0004)
	float                                              m_fViewTargetDeathSwapTime;                               // 0x17FC(0x0004) (Const)
	class ATgPawn*                                     s_pawnLiveSpectateViewTarget;                             // 0x1800(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorController");
		return ptr;
	}


	void ClearSpectatorViewTarget();
	void PlayerMappingUpdated();
	void ToggleConsoleLock();
	void TogglePawnOverlay();
	void STATIC_SetIntendedPanel();
	void STATIC_ShowPreviousInfoPanel();
	void STATIC_ShowNextInfoPanel();
	void ToggleStatPanel();
	void STATIC_ShowPreviousStatPanel();
	void STATIC_ShowNextStatPanel();
	void SetIntendedTarget();
	void STATIC_OnCancel();
	void STATIC_OnSelection();
	void STATIC_SelectTeamStat();
	void STATIC_TeamStatBack();
	void STATIC_GoToNextIntendedTarget();
	void STATIC_GoToPrevIntendedTarget();
	void STATIC_SetCameraTargetByPawnId(int pawnId);
	void STATIC_GoToPrevViewTarget();
	void STATIC_GoToNextViewTarget();
	int STATIC_GetViewTargetIndex();
	void PreRender(class UCanvas* Canvas);
	void STATIC_CacheScreenCenter(class UCanvas* Canvas);
	void STATIC_SpectatorSelectPlayer(int pawnId);
	void SpectatePlayerIndex(int nPlayerIndex, bool bSelectOnly);
	void UpdateBroadcastChannels();
	void STATIC_ChangeZoomState(TEnumAsByte<EZoomState> NewZoomState);
	void STATIC_SpectateZoomOut(bool bEnabled);
	void STATIC_SpectateZoomIn(bool bEnabled);
	void STATIC_GetActorListFrom2DCoordinate(const struct FVector2D& Coordinate, TArray<class AActor*>* ActorList);
	class APawn* STATIC_GetPawnFrom2DCoordinate(const struct FVector2D& Coordinate);
	class APawn* STATIC_GetPawnFromScreenCenter();
	void STATIC_SpectateSetTarget();
	void STATIC_FlipOverviewSides();
	void STATIC_SpecTest();
	void STATIC_SquashMap();
	float GetFOVAngle();
	void STATIC_SetOutlineCharacters(bool bNewOutlineCharacters);
	void ToggleOutlineCharacters();
	struct FString STATIC_StripClanTag(const struct FString& PlayerName);
	void STATIC_DecreaseCameraSpeed();
	void STATIC_IncreaseCameraSpeeed();
	void STATIC_CameraSpeed(float NewSpeed);
	void STATIC_GotoCinematicCam(const struct FString& sCamName);
	void ToggleHelicopterMode();
	void STATIC_SpecSetFlightMode(TEnumAsByte<ESpecFlightMode> sfm);
	void STATIC_RecallSpectatorBookmark(int nNum);
	void STATIC_SetSpectatorBookmark(int nNum);
	struct FViewTargetTransitionParams STATIC_GetSnapBlendParams();
	struct FViewTargetTransitionParams STATIC_GetDefaultBlendParams();
	struct FViewTargetTransitionParams GetBlendParams(class AActor* Target);
	void STATIC_SwitchToPlayer(const struct FString& PlayerName);
	void STATIC_SpecViewPlayer(bool bAltView, const struct FString& PlayerName);
	void STATIC_SpecViewAction();
	TEnumAsByte<ESpectatorCameraMode> STATIC_GetDefaultModeFor(class AActor* Target);
	TArray<class AActor*> STATIC_GetActionList();
	TArray<class AActor*> STATIC_GetOutermostTowerList();
	TArray<class AActor*> STATIC_GetPlayerList();
	TArray<class AActor*> STATIC_GetViewTargetListForMode(TEnumAsByte<ESpectatorCameraCycle> cycle);
	void STATIC_CycleNext(bool bSkipIfPresent, bool bReverse);
	void STATIC_SnapViewToLocation(const struct FVector& WorldLocation, bool bUseFocalPoint);
	void STATIC_SetPendingOnDirectorMode();
	bool STATIC_PingMap(const struct FVector& WorldLocation, TEnumAsByte<EPING_TYPE> Type, TArray<class AReplicationInfo*>* worldActorRepInfo);
	void STATIC_SnapViewToHoverTarget(bool bUseAltView);
	void ToggleRigidFreeCam();
	void LockedViewCam(bool bEnabled);
	bool STATIC_InterceptFlashInput(const struct FName& ButtonName, TEnumAsByte<EInputEvent> Event);
	void STATIC_OnRightMouseReleased();
	void STATIC_OnRightMousePressed();
	void STATIC_OnLeftMousePressed();
	void STATIC_ClearPendingSpecCycle();
	void STATIC_SetPendingSpecCycle(TEnumAsByte<ESpectatorCameraCycle> Mode);
	void STATIC_ClientSetReadyState(bool bReadyToPlay);
	void STATIC_SetSpectatorCameraMode(TEnumAsByte<ESpectatorCameraMode> Mode, bool bCameraTween);
	void STATIC_SetNewSpectatorMode(TEnumAsByte<ESpectatorMode> NewMode);
	bool STATIC_ShouldFlyFromInput();
	void ServerSetLiveSpectateViewTarget(class AActor* VT);
	void SpectatorSetViewTarget(class AActor* VT, const struct FViewTargetTransitionParams& TransitionParams);
	void STATIC_SwitchCamera(const struct FString& sCamera);
	void STATIC_ClientForwardToSpectatingMatch();
	void STATIC_ForwardToSpectatingMatch();
	void STATIC_EndIntro();
	void STATIC_SetupIntro();
	void ThrottleWorldAddCheck();
	void UnthrottleWorldAddCheck();
	void ViewTargetDeathSwapTimer();
	float STATIC_GetDistanceFromViewTargetSquared2D(struct FVector* vLoc);
	bool IsLiveSpectate();
	void SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
	void STATIC_SetNetTarget(const struct FQWord& qwId, int nTaskForce);
	class UClass* STATIC_GetHudClass(class UClass* pNewHudType);
};


// Class TgGame.TgDemoRecSpectator
// 0x0088 (0x1890 - 0x1808)
class ATgDemoRecSpectator : public ATgSpectatorController
{
public:
	TArray<struct FSpectatorCommand>                   PendingCommands;                                          // 0x1808(0x0010) (NeedCtorLink)
	int                                                m_TimeIndex;                                              // 0x1818(0x0004) (Transient)
	TArray<struct FDilationData>                       m_TimeDilations;                                          // 0x181C(0x0010) (Transient, NeedCtorLink)
	struct FPointer                                    m_pTgCallbackDevice;                                      // 0x182C(0x0008) (Native)
	int                                                m_1xTimeIndex;                                            // 0x1834(0x0004) (Transient)
	unsigned long                                      m_bIsPaused : 1;                                          // 0x1838(0x0004) (Transient)
	unsigned long                                      m_bInStasis : 1;                                          // 0x1838(0x0004) (Transient)
	unsigned long                                      m_bSpectatorMaster : 1;                                   // 0x1838(0x0004) (Transient)
	unsigned long                                      m_bSyncWithMasterEnabled : 1;                             // 0x1838(0x0004) (Transient)
	unsigned long                                      m_bIsSyncingWithMaster : 1;                               // 0x1838(0x0004) (Transient)
	unsigned long                                      m_bAutoSlomo : 1;                                         // 0x1838(0x0004) (Transient)
	unsigned long                                      m_bReceiveCamSync : 1;                                    // 0x1838(0x0004) (Transient, Config)
	int                                                m_nLastReceivedMasterFrame;                               // 0x183C(0x0004) (Transient)
	float                                              m_fLastReceivedMasterTimeDilation;                        // 0x1840(0x0004) (Transient)
	float                                              m_fLastReceievedRealTimeStamp;                            // 0x1844(0x0004) (Transient)
	int                                                m_nSyncFrameThreshold;                                    // 0x1848(0x0004) (Const, Config)
	int                                                m_nSyncFrameCheckThreshold;                               // 0x184C(0x0004) (Const, Config)
	int                                                m_nSyncAheadFrameThreshold;                               // 0x1850(0x0004) (Const, Config)
	int                                                m_nLastTimerValue;                                        // 0x1854(0x0004) (Transient)
	class ATgSpectatorDirector*                        m_SpectatorDirector;                                      // 0x1858(0x0008)
	class ATgCollisionProxy_SpectatorActionListener*   m_ActionListener;                                         // 0x1860(0x0008) (Transient)
	float                                              m_fActionListenerRadius;                                  // 0x1868(0x0004) (Transient, Config)
	float                                              m_fActionListenerHeight;                                  // 0x186C(0x0004) (Transient, Config)
	int                                                m_nCurrentActionListenerRating;                           // 0x1870(0x0004) (Transient)
	int                                                m_nActionListenerRatingThreshold;                         // 0x1874(0x0004) (Transient, Config)
	float                                              m_fRemainingAutoSlomoTime;                                // 0x1878(0x0004)
	float                                              m_fAutoSlomoExpirationTime;                               // 0x187C(0x0004) (Transient, Config)
	int                                                m_nAutoSlomoSpeedIndex;                                   // 0x1880(0x0004) (Transient, Config)
	int                                                m_nAutoSlomoNearbyPlayersNum;                             // 0x1884(0x0004) (Transient, Config)
	float                                              m_fAutoSlomoFrequency;                                    // 0x1888(0x0004) (Transient, Config)
	float                                              m_fRemainingAutoSlomoTimeoutTime;                         // 0x188C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDemoRecSpectator");
		return ptr;
	}


	void PlayerMappingUpdated();
	void STATIC_SetSpectatorCameraMode(TEnumAsByte<ESpectatorCameraMode> Mode, bool bCameraTween);
	void SetIntendedTarget();
	void STATIC_ReceiveCamSyncTarget(int pawnId, int SourcePlayerId);
	void STATIC_SendCamSyncTarget();
	void SpectatorReceivedViewTarget(class AActor* VT);
	void SpectatorSetViewTarget(class AActor* VT, const struct FViewTargetTransitionParams& TransitionParams);
	void STATIC_EnableCamSync(bool bEnabled);
	void TriggerAutoSlomo(float SlomoTime);
	void STATIC_OnActionListenerStartFire(class ATgPawn* FiringPawn, int nEquipSlot);
	void STATIC_EnableAutoSlomo(bool bEnabled);
	void SetAutoSlomo(bool bEnabled);
	void STATIC_SpecViewPlayer(bool bAltView, const struct FString& PlayerName);
	bool STATIC_PingMap(const struct FVector& WorldLocation, TEnumAsByte<EPING_TYPE> Type, TArray<class AReplicationInfo*>* worldActorRepInfo);
	void STATIC_SetNewSpectatorMode(TEnumAsByte<ESpectatorMode> NewMode);
	void FindNextClosestAssistedViewTarget();
	void FindNearbyAssistedViewTarget();
	void STATIC_DirectorModeToggle();
	void PostDemoRewind();
	void STATIC_CheckSpectatorMasterSlave();
	void ToggleHeightRestriction();
	void ToggleWorldCollision();
	void ToggleSync();
	void STATIC_EnableSync(bool bEnabled);
	bool IsSyncedWithMaster(int Threshold);
	int STATIC_GetSyncTargetFrame();
	void STATIC_SetSyncTargetFrame(int FrameNum, float TimeDilation);
	void STATIC_RewindGraphs();
	void STATIC_PauseEx();
	bool STATIC_SetSpectatorMasterSlave();
	bool STATIC_CanFastForward();
	void STATIC_GoToFrame(float fPercent);
	void STATIC_SpecRewindPoint(int nPoint, bool bUseOnlyMajorIntervals);
	void STATIC_Rewind(int JumpAmount, int FrameNum, bool bUseOnlyMajorIntervals);
	void UpdateSpectatorUI();
	void STATIC_DilateTime(float Amount, bool bForceReset);
	void STATIC_Pause();
	void STATIC_Slomo(float NewTimeDilation);
	void PostBeginPlay();
	void ReceivedPlayer();
	void SpectateAutoSlomo(bool bShow);
	int STATIC_GetSpectateTaskForce();
	void SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
	void STATIC_StartAutoCombatLog();
	void ToggleThirdPersonView();
	void STATIC_CreateManualRewindPoint();
	class UClass* STATIC_GetHudClass(class UClass* pNewHudType);
	void UnregisterEngineCallbacks();
	void STATIC_RegisterEngineCallbacks();
	void UpdateCameraModeUI();
	bool UpdateSyncingUI();
	void UpdateTimeDilation();
	void STATIC_RequestSync();
	void STATIC_OnSynced();
};


// Class TgGame.TgDemoRecSpectator_Debug
// 0x0010 (0x18A0 - 0x1890)
class ATgDemoRecSpectator_Debug : public ATgDemoRecSpectator
{
public:
	class UPlayer*                                     m_OriginalPlayer;                                         // 0x1890(0x0008)
	class APlayerController*                           m_OriginalPlayerController;                               // 0x1898(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDemoRecSpectator_Debug");
		return ptr;
	}

};


// Class TgGame.TgPlayerInput
// 0x0084 (0x03C4 - 0x0340)
class UTgPlayerInput : public UPComPlayerInput
{
public:
	class ATgPlayerController*                         c_TgPC;                                                   // 0x0340(0x0008)
	unsigned long                                      c_bASKeyBlock : 1;                                        // 0x0348(0x0004)
	unsigned long                                      c_bASKeyCapture : 1;                                      // 0x0348(0x0004)
	unsigned long                                      c_bASSpecKeyCapture : 1;                                  // 0x0348(0x0004)
	unsigned long                                      c_bMiniMapPinging : 1;                                    // 0x0348(0x0004)
	unsigned long                                      c_bAutoRun : 1;                                           // 0x0348(0x0004)
	unsigned long                                      bUseLinearPitch : 1;                                      // 0x0348(0x0004)
	TArray<struct FName>                               CaptureModifierKeys;                                      // 0x034C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	float                                              fLookAttractorAmount;                                     // 0x035C(0x0004) (Transient)
	float                                              fLookAttractorTarget;                                     // 0x0360(0x0004) (Config)
	float                                              fLookAttractorSpeed;                                      // 0x0364(0x0004) (Config)
	float                                              fLastTurn;                                                // 0x0368(0x0004) (Transient)
	float                                              fLookAccelAmount;                                         // 0x036C(0x0004) (Transient)
	float                                              fLookAccelTarget;                                         // 0x0370(0x0004) (Config)
	float                                              fLookAccelExponent;                                       // 0x0374(0x0004) (Config)
	float                                              fLookAccelSpeed;                                          // 0x0378(0x0004) (Config)
	float                                              fLinearPitchMult;                                         // 0x037C(0x0004)
	float                                              nKBMVersion;                                              // 0x0380(0x0004) (Config)
	TArray<struct FKeyBind>                            KeyboardBindings;                                         // 0x0384(0x0010) (Config, NeedCtorLink)
	struct FScriptDelegate                             __OnRawInputKey__Delegate;                                // 0x0394(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0394(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnInputAxis__Delegate;                                  // 0x03A4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x03A4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnInputChar__Delegate;                                  // 0x03B4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData02[0x4];                                       // 0x03B4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerInput");
		return ptr;
	}


	void SetLinearPitch(bool bEnable, float fMult);
	void UnbindCommand(const struct FString& Command, int nAlternate);
	void UnbindCommandAll(const struct FString& Command);
	void SetBindExtended(const struct FString& ExtendedBinding, const struct FString& Command, bool bStoreToServer);
	void SetAimAcceleration(float fLookAccel);
	void SetLookSensitivity(float fSensitivity, float fSensitivityY);
	void SetMouseInput(bool bInvert, bool bSmooth, float fSensitivity);
	void STATIC_CancelAutoRun();
	void STATIC_StartAutoRun();
	void ToggleAutoRun();
	void STATIC_PreProcessInput(float DeltaTime);
	void PlayerInput(float DeltaTime);
	TEnumAsByte<EDoubleClickDir> CheckForDoubleClickMove(float DeltaTime);
	void Duck();
	bool InputChar(int ControllerId, const struct FString& Unicode);
	void STATIC_HandleAimAssist(float fDeltaTime);
	void STATIC_PreProcessJoystickInput(float fDeltaTime);
	struct FKeyBind STATIC_GenerateKeybindFromButton(const struct FString& ButtonName);
	void STATIC_SetKeyCaptureModifier(const struct FName& ButtonName, bool bPressed);
	void STATIC_SetKeyCaptureState(bool bSpectator, bool bCaptureKey);
	void STATIC_SetKeyBlockState(bool bBlock);
	void ResetKeysToDefault(const struct FString& PresetName, bool isForceSetKey);
	void ReadMouseSettings();
	void ReadBindings();
	void InitKeyBindingsMap();
	bool STATIC_CanRebindKeys();
	bool OnInputChar(int ControllerId, const struct FString& Unicode);
	bool OnInputAxis(int ControllerId, const struct FName& Key, float Delta, float DeltaTime);
	bool OnRawInputKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> Event, float AmountDepressed);
};


// Class TgGame.TgPlayerInput_Racer
// 0x0010 (0x03D4 - 0x03C4)
class UTgPlayerInput_Racer : public UTgPlayerInput
{
public:
	TArray<struct FRacerKeyBind>                       m_RacerKeybindings;                                       // 0x03C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerInput_Racer");
		return ptr;
	}


	void SetupRacingBindings();
	void InitKeyBindingsMap();
	bool STATIC_CanRebindKeys();
};


// Class TgGame.TgSpectatorInput
// 0x0008 (0x03CC - 0x03C4)
class UTgSpectatorInput : public UTgPlayerInput
{
public:
	float                                              SpectatorSensitivity;                                     // 0x03C4(0x0004) (Config)
	float                                              RawTriggerUp;                                             // 0x03C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorInput");
		return ptr;
	}


	void PlayerInput(float DeltaTime);
	void AdjustMouseSensitivity(float FOVScale);
	TArray<struct FKeyBind> STATIC_GetDefaultSpectatorBindings();
	void STATIC_CheckIdleBreak();
};


// Class TgGame.TgSkeletalMeshActor_FireGiantIntro_GC2015a
// 0x0020 (0x032C - 0x030C)
class ATgSkeletalMeshActor_FireGiantIntro_GC2015a : public ATgSkeletalMeshActor
{
public:
	class USkeletalMesh*                               SpectatorSkeletalMesh;                                    // 0x030C(0x0008) (Edit)
	class USkeletalMesh*                               DefaultSkeletalMesh;                                      // 0x0314(0x0008) (Transient)
	TArray<class UTgAnimBlendByFireGiantChest*>        FireGiantChestNodes;                                      // 0x031C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_FireGiantIntro_GC2015a");
		return ptr;
	}


	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_SetOpened(bool bForce);
	void STATIC_OpenChest(float fOffset);
	void STATIC_ForceClosed();
	void PostBeginPlay();
};


// Class TgGame.TgSkeletalMeshActor_Loader
// 0x00A8 (0x03B4 - 0x030C)
class ATgSkeletalMeshActor_Loader : public ATgSkeletalMeshActor
{
public:
	class UTgMenuMeshInfo*                             m_PendingMeshInfo;                                        // 0x030C(0x0008) (Transient)
	class UTgMenuMeshInfo*                             m_CurrentMeshInfo;                                        // 0x0314(0x0008) (Transient)
	class UTgManifestGroup*                            c_AssetManifestGroup;                                     // 0x031C(0x0008) (ExportObject, NeedCtorLink, EditInline)
	struct FPointer                                    m_PendingBot;                                             // 0x0324(0x0008) (Native)
	struct FPointer                                    m_PendingSkin;                                            // 0x032C(0x0008) (Native)
	TEnumAsByte<ELobbyAnimPose>                        m_PendingPose;                                            // 0x0334(0x0001) (Transient)
	TEnumAsByte<ELobbyAnimPose>                        m_CurrentPose;                                            // 0x0335(0x0001) (Transient)
	unsigned char                                      m_nMeshActiveState;                                       // 0x0336(0x0001)
	TEnumAsByte<EAsyncLoadPriority>                    m_eDefaultLoadPriority;                                   // 0x0337(0x0001)
	TEnumAsByte<ELobbyMeshType>                        m_LobbyMeshType;                                          // 0x0338(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0339(0x0003) MISSED OFFSET
	struct FPointer                                    m_CurrentBot;                                             // 0x033C(0x0008) (Native)
	struct FPointer                                    m_CurrentSkin;                                            // 0x0344(0x0008) (Native)
	unsigned long                                      m_bWaitingForTextures : 1;                                // 0x034C(0x0004) (Transient)
	unsigned long                                      m_bIsAsyncLoading : 1;                                    // 0x034C(0x0004) (Transient)
	unsigned long                                      m_bIsLoadSuspended : 1;                                   // 0x034C(0x0004) (Transient)
	unsigned long                                      m_bAllowOverlays : 1;                                     // 0x034C(0x0004) (Edit)
	unsigned long                                      m_bAllowSkinLevel : 1;                                    // 0x034C(0x0004) (Edit)
	unsigned long                                      m_bOverrideLightingChannels : 1;                          // 0x034C(0x0004) (Edit)
	int                                                m_nAsyncLoadDelayTicksDefault;                            // 0x0350(0x0004)
	int                                                m_nAsyncLoadDelayTicks;                                   // 0x0354(0x0004) (Transient)
	TArray<class UMeshComponent*>                      m_ChildMeshes;                                            // 0x0358(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	class ULightEnvironmentComponent*                  m_AlternateLightEnvironmentTemplate;                      // 0x0368(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class ULightEnvironmentComponent*>          m_AlternateLightEnvironments;                             // 0x0370(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	class UMaterialInterface*                          m_OverlayMaterial;                                        // 0x0380(0x0008)
	int                                                m_nSkinLevel;                                             // 0x0388(0x0004) (Edit)
	struct FLightingChannelContainer                   m_LightingChannels;                                       // 0x038C(0x0004) (Edit, Const)
	TArray<class UTgAnimBlendByEmote*>                 m_EmoteBlendNodes;                                        // 0x0390(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgAnimNodeEmoteSequence*>            m_EmoteSequenceNodes;                                     // 0x03A0(0x0010) (Transient, NeedCtorLink)
	float                                              m_fAudioMult;                                             // 0x03B0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Loader");
		return ptr;
	}


	bool PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void PlayChildAnim(class UTgSkeletalMeshComponent* notifySource, const struct FName& AnimSeqName);
	void EndTransition();
	void BeginTransition(bool bPlayFx);
	void NotifyUIEndTransition();
	bool UnsuspendPendingLoads();
	bool STATIC_SuspendPendingLoads();
	void UpdateComponentTickGroup();
	void STATIC_CancelEmote(bool bVerifyNoRelevantEmotes, class UTgAnimNodeEmoteSequence* Exclude);
	float PlayEmote(int nVgsId);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void STATIC_ForceRecalculateMaterial();
	void STATIC_CleanupForAssetSwap(bool bReset);
	void STATIC_SwapAssets(class UTgMenuMeshInfo* MeshInfo);
	void SetActive(bool bActive);
	void AllManifestsLoaded();
	void STATIC_ResetAnims();
};


// Class TgGame.TgSkeletalMeshActor_FlagStand
// 0x0020 (0x03D4 - 0x03B4)
class ATgSkeletalMeshActor_FlagStand : public ATgSkeletalMeshActor_Loader
{
public:
	struct FString                                     m_FlagContentDataClassName;                               // 0x03B4(0x0010) (NeedCtorLink)
	class UTgFlagContentData*                          m_FlagContentData;                                        // 0x03C4(0x0008) (Transient)
	int                                                m_nGameTaskForce;                                         // 0x03CC(0x0004) (Edit)
	int                                                m_nTeamIndex;                                             // 0x03D0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_FlagStand");
		return ptr;
	}


	void PostBeginPlay();
	void PreBeginPlay();
	void STATIC_ChangeTaskForceFlag(int nTaskForce, int nTeamIndex);
};


// Class TgGame.TgSkeletalMeshActor_LobbyBase
// 0x001C (0x03D0 - 0x03B4)
class ATgSkeletalMeshActor_LobbyBase : public ATgSkeletalMeshActor_Loader
{
public:
	unsigned long                                      m_bPlayTransitionOutro : 1;                               // 0x03B4(0x0004) (Transient)
	struct FString                                     m_TransitionActorClassName;                               // 0x03B8(0x0010) (NeedCtorLink)
	class ATgMenuTransitionActor*                      m_TransitionActor;                                        // 0x03C8(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_LobbyBase");
		return ptr;
	}


	void Destroyed();
	void EndTransition();
	void BeginTransition(bool bPlayFx);
	void PostBeginPlay();
	void PreBeginPlay();
};


// Class TgGame.TgSkeletalMeshActor_Lobby
// 0x0044 (0x0414 - 0x03D0)
class ATgSkeletalMeshActor_Lobby : public ATgSkeletalMeshActor_LobbyBase
{
public:
	class ATgSkeletalMeshActor_FlagStand*              m_FlagStandActor;                                         // 0x03D0(0x0008) (Edit)
	class ATgSkeletalMeshActor_Pedestal*               m_PedestalActor;                                          // 0x03D8(0x0008) (Edit)
	unsigned long                                      m_bCanBeRotated : 1;                                      // 0x03E0(0x0004) (Edit)
	unsigned long                                      m_bWallEnable : 1;                                        // 0x03E0(0x0004) (Edit)
	unsigned long                                      m_bForceActiveForVideo : 1;                               // 0x03E0(0x0004) (Edit)
	float                                              m_fRotationAmount;                                        // 0x03E4(0x0004) (Transient)
	float                                              m_fDesiredRotationAmount;                                 // 0x03E8(0x0004) (Transient)
	struct FRotator                                    m_rOriginalRotation;                                      // 0x03EC(0x000C) (Transient)
	struct FVector                                     m_WallOffset;                                             // 0x03F8(0x000C) (Edit)
	struct FVector                                     m_WallNormal;                                             // 0x0404(0x000C) (Edit)
	int                                                m_nDefaultSkinId;                                         // 0x0410(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Lobby");
		return ptr;
	}


	void STATIC_OnSetLobbyMeshSkin(class UTgSeqAct_SetLobbyMeshSkin* tgSeqAct);
	void EndTransition();
	void PreBeginPlay();
	bool UnsuspendPendingLoads();
	bool STATIC_SuspendPendingLoads();
	void STATIC_SetSkin(int nSkinId);
	void STATIC_SetSkinFromMessage(int nMsgId);
	bool IsSocketBelowLobbyWall(const struct FName& SocketName);
	void STATIC_RotateModel(float fValue, bool bSnap);
	void SetActive(bool bActive);
};


// Class TgGame.TgSkeletalMeshActor_ProgressTracker
// 0x0000 (0x0414 - 0x0414)
class ATgSkeletalMeshActor_ProgressTracker : public ATgSkeletalMeshActor_Lobby
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_ProgressTracker");
		return ptr;
	}


	void UpdateProgress(float fVal);
	void SetActive(bool bActive);
};


// Class TgGame.TgSkeletalMeshActor_Pedestal
// 0x0038 (0x0408 - 0x03D0)
class ATgSkeletalMeshActor_Pedestal : public ATgSkeletalMeshActor_LobbyBase
{
public:
	struct FPointer                                    m_DefaultBot;                                             // 0x03D0(0x0008) (Native, Transient)
	TArray<class AActor*>                              m_DefaultPedestalActors;                                  // 0x03D8(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bUsingDefaultPedestal : 1;                              // 0x03E8(0x0004) (Transient)
	unsigned long                                      c_bHovered : 1;                                           // 0x03E8(0x0004)
	unsigned long                                      c_bSelected : 1;                                          // 0x03E8(0x0004)
	struct FRacerPedestalFlags                         m_RacerPedestalFlags;                                     // 0x03EC(0x0014)
	class UTgPedestalProcessor*                        m_PedestalProcessor;                                      // 0x0400(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Pedestal");
		return ptr;
	}


	void EndTransition();
	void STATIC_SwitchToDefaultPedestal(TEnumAsByte<ELobbyAnimPose> animPose);
};


// Class TgGame.TgSkeletalMeshActor_Ownable
// 0x0028 (0x0334 - 0x030C)
class ATgSkeletalMeshActor_Ownable : public ATgSkeletalMeshActor
{
public:
	struct FPointer                                    VfTable_ITgOwnedPlaceableMesh;                            // 0x030C(0x0008) (Const, Native, NoExport)
	int                                                m_nMeshAsmId;                                             // 0x0314(0x0004) (Edit)
	TEnumAsByte<EOwnedMeshSkinType>                    m_eSkinType;                                              // 0x0318(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0319(0x0003) MISSED OFFSET
	class ATgTeamPlayerStart*                          m_StartPoint;                                             // 0x031C(0x0008) (Edit)
	class ATgBotFactory*                               m_Factory;                                                // 0x0324(0x0008) (Edit)
	int                                                m_nTaskForce;                                             // 0x032C(0x0004) (Edit)
	unsigned long                                      c_bInitialized : 1;                                       // 0x0330(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Ownable");
		return ptr;
	}


	void InitializeOwnableMesh();
	bool IsLinkedToTaskForce(int nTaskForce);
	int STATIC_GetDefaultMeshId();
	void STATIC_SetNewMeshAssembly(int nMshAsm);
	void STATIC_SetActorOwner(class ATgPawn* tgOwner);
	TEnumAsByte<EOwnedMeshSkinType> STATIC_GetSkinType();
};


// Class TgGame.TgSkeletalMeshActor_Leash
// 0x0030 (0x034C - 0x031C)
class ATgSkeletalMeshActor_Leash : public ATgSkeletalMeshActorSpawnable
{
public:
	class USkeletalMeshComponent*                      m_StartMesh;                                              // 0x031C(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       m_StartBoneName;                                          // 0x0324(0x0008)
	class USkeletalMeshComponent*                      m_EndMesh;                                                // 0x032C(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       m_EndBoneName;                                            // 0x0334(0x0008)
	class USkelControlSingleBone*                      m_StartControl;                                           // 0x033C(0x0008)
	class USkelControlSingleBone*                      m_EndControl;                                             // 0x0344(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Leash");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshComponent
// 0x0060 (0x0824 - 0x07C4)
class UTgSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterfaceLite;                             // 0x07C4(0x0008) (Const, Native, NoExport)
	unsigned long                                      c_bFxApplied : 1;                                         // 0x07CC(0x0004)
	unsigned long                                      c_bIsFemale : 1;                                          // 0x07CC(0x0004)
	unsigned long                                      c_bSkeletonFrozen : 1;                                    // 0x07CC(0x0004) (Transient)
	TArray<class UTgSpecialFx*>                        c_FxList;                                                 // 0x07D0(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_DatabaseFxList;                                         // 0x07E0(0x0010) (NeedCtorLink)
	int                                                m_nAssemblyId;                                            // 0x07F0(0x0004)
	struct FVector                                     FPCTranslation;                                           // 0x07F4(0x000C)
	struct FRotator                                    FPCRotation;                                              // 0x0800(0x000C)
	struct FVector                                     FPCScale;                                                 // 0x080C(0x000C)
	int                                                c_AudioGroupId;                                           // 0x0818(0x0004)
	int                                                c_nForceUpdateAttachmentsInTick;                          // 0x081C(0x0004)
	int                                                c_nOldForcedLodLevel;                                     // 0x0820(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshComponent");
		return ptr;
	}


	void ApplyTiDi(float fTotalTiDi);
	void STATIC_SetForceUpdateAttachmentsInTick(bool bSet);
	class UAnimTree* STATIC_GetAnimTree();
	void UpdateMaterialResourceGroups(int nMaterialResGrpId, bool bLocalPlayerOwned, bool bSetAsDefaults);
	void STATIC_FreezeSkeleton(bool bFreeze);
	void STATIC_OnMeshSetHidden(bool bHidden);
	void STATIC_RecalculateFx();
	void ActivateWhileAliveFx();
	void ActivateOnWhenDeployedFx();
	float STATIC_GetCurrentDeployPercentage();
	void SwapMaterial(class UMaterialInterface* MI, bool bNoParamReaping);
	class UMaterialInterface* STATIC_GetDefaultMaterial(int nIndex);
	void STATIC_SetDefaultSkin(int nIndex);
	void STATIC_FxActivateIndependant(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot, bool bUseSocketOverride, float fScale);
	void STATIC_FxSpawnSound(const struct FName& nmGroup, int nMode, const struct FVector& SoundLocation, int nSocketIndex, int nEquipSlot);
	void STATIC_FxSpawnEmitter(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot);
	void STATIC_FxSpawnTracer(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, int nSocketIndex, int nEquipSlot);
	void STATIC_FxDeactivateAll(int nEquipSlot);
	void STATIC_FxDeactivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* STATIC_FxActivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy);
	class UObject* STATIC_FxGet(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	void STATIC_FxRemove(class UObject* Fx);
	void STATIC_FxAdd(class UObject* Fx);
	void STATIC_EndRagdoll();
	void STATIC_InitRagdoll();
};


// Class TgGame.TgStaticMeshActor
// 0x0000 (0x0274 - 0x0274)
class ATgStaticMeshActor : public AStaticMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor");
		return ptr;
	}

};


// Class TgGame.TgStaticMeshActor_CardMIC
// 0x0014 (0x0288 - 0x0274)
class ATgStaticMeshActor_CardMIC : public ATgStaticMeshActor
{
public:
	int                                                m_nMaterialResourceId;                                    // 0x0274(0x0004) (Edit)
	struct FString                                     m_sDefaultChangeCardName;                                 // 0x0278(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_CardMIC");
		return ptr;
	}


	void PreBeginPlay();
	void STATIC_ChangeCardMIC(int nMaterialResourceId);
};


// Class TgGame.TgStaticMeshActor_GodMIC
// 0x0008 (0x027C - 0x0274)
class ATgStaticMeshActor_GodMIC : public ATgStaticMeshActor
{
public:
	int                                                m_nGameTaskForce;                                         // 0x0274(0x0004) (Edit)
	int                                                m_nTeamIndex;                                             // 0x0278(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_GodMIC");
		return ptr;
	}


	void PreBeginPlay();
	void STATIC_ChangeGodMIC(int nTaskForce, int nTeamIndex);
};


// Class TgGame.TgStaticMeshActor_Ownable
// 0x0038 (0x02AC - 0x0274)
class ATgStaticMeshActor_Ownable : public ATgStaticMeshActor
{
public:
	struct FPointer                                    VfTable_ITgOwnedPlaceableMesh;                            // 0x0274(0x0008) (Const, Native, NoExport)
	int                                                m_nMeshAsmId;                                             // 0x027C(0x0004) (Edit)
	TEnumAsByte<EOwnedMeshSkinType>                    m_eSkinType;                                              // 0x0280(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0281(0x0003) MISSED OFFSET
	class ATgTeamPlayerStart*                          m_StartPoint;                                             // 0x0284(0x0008) (Edit)
	int                                                m_nTaskForce;                                             // 0x028C(0x0004) (Edit)
	class ATgBotFactory*                               m_Factory;                                                // 0x0290(0x0008) (Edit)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x0298(0x0008) (Edit, Const, ExportObject, EditConst, Component, EditInline)
	unsigned long                                      c_bInitialized : 1;                                       // 0x02A0(0x0004)
	int                                                s_nMeshAsmIdOverride;                                     // 0x02A4(0x0004) (Const, Config)
	int                                                r_nMeshAsmIdOverride;                                     // 0x02A8(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_Ownable");
		return ptr;
	}


	void InitializeOwnableMesh();
	void ReplicatedEvent(const struct FName& VarName);
	bool IsLinkedToTaskForce(int nTaskForce);
	int STATIC_GetDefaultMeshId();
	void STATIC_SetNewMeshAssembly(int nMshAsm);
	void STATIC_SetActorOwner(class ATgPawn* tgOwner);
	TEnumAsByte<EOwnedMeshSkinType> STATIC_GetSkinType();
};


// Class TgGame.TgStaticMeshActor_PantheonMIC
// 0x0088 (0x02FC - 0x0274)
class ATgStaticMeshActor_PantheonMIC : public ATgStaticMeshActor
{
public:
	class UMaterialInstanceConstant*                   MICOverrides[0x10];                                       // 0x0274(0x0008) (Edit)
	int                                                m_nGameTaskForce;                                         // 0x02F4(0x0004) (Edit)
	int                                                m_nTeamIndex;                                             // 0x02F8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_PantheonMIC");
		return ptr;
	}


	void PreBeginPlay();
	void STATIC_ChangePantheonMIC(int nTaskForce, int nTeamIndex);
};


// Class TgGame.TgStaticMeshActor_TowerPad
// 0x000C (0x0280 - 0x0274)
class ATgStaticMeshActor_TowerPad : public ATgStaticMeshActor
{
public:
	unsigned long                                      r_bOwnerAlive : 1;                                        // 0x0274(0x0004) (Net)
	class ATgPawn*                                     m_BaseOwner;                                              // 0x0278(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActor_TowerPad");
		return ptr;
	}


	void ClearWarningGlow();
	void UpdateWarningGlow(class AActor* TargetedActor);
	void STATIC_SetTowerOwner(class ATgPawn* tgOwner);
};


// Class TgGame.TgStaticMeshActorTargeting
// 0x0000 (0x0274 - 0x0274)
class ATgStaticMeshActorTargeting : public AStaticMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshActorTargeting");
		return ptr;
	}

};


// Class TgGame.TgStaticMeshComponent
// 0x0030 (0x0340 - 0x0310)
class UTgStaticMeshComponent : public UStaticMeshComponent
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterfaceLite;                             // 0x0310(0x0008) (Const, Native, NoExport)
	unsigned long                                      c_bFxApplied : 1;                                         // 0x0318(0x0004)
	TArray<class UTgSpecialFx*>                        c_FxList;                                                 // 0x031C(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_DatabaseFxList;                                         // 0x032C(0x0010) (NeedCtorLink)
	int                                                m_nAssemblyId;                                            // 0x033C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgStaticMeshComponent");
		return ptr;
	}


	void ApplyTiDi(float fTotalTiDi);
	void STATIC_RecalculateFx();
	void STATIC_OnMeshSetHidden(bool bHidden);
	class UMaterialInterface* STATIC_GetDefaultMaterial(int nIndex);
	void STATIC_SetDefaultSkin(int nIndex);
	void SwapMaterial(class UMaterialInterface* MI, bool bNoParamReaping);
	void UpdateMaterialResourceGroups(int nMaterialResGrpId, bool bLocalPlayerOwned, bool bSetAsDefaults);
	void STATIC_FxActivateIndependant(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot, bool bUseSocketOverride, float fScale);
	void STATIC_FxSpawnSound(const struct FName& nmGroup, int nMode, const struct FVector& SoundLocation, int nSocketIndex, int nEquipSlot);
	void STATIC_FxSpawnEmitter(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, const struct FVector& HitNormal, int nSocketIndex, int nEquipSlot);
	void STATIC_FxSpawnTracer(const struct FName& nmGroup, int nMode, const struct FVector& HitLocation, int nSocketIndex, int nEquipSlot);
	void STATIC_FxDeactivateAll(int nEquipSlot);
	void STATIC_FxDeactivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot);
	class UObject* STATIC_FxActivateGroup(const struct FName& nmGroup, int nMode, int nSocketIndex, int nEquipSlot, bool bIgnoreRelevancy);
	class UObject* STATIC_FxGet(const struct FName& nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot);
	void STATIC_FxRemove(class UObject* Fx);
	void STATIC_FxAdd(class UObject* Fx);
};


// Class TgGame.TgAIBehaviorObject
// 0x0004 (0x0064 - 0x0060)
class UTgAIBehaviorObject : public UObject
{
public:
	int                                                NodeToken;                                                // 0x0060(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorObject");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComment
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorComment : public UTgAIBehaviorObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComment");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorNode
// 0x0030 (0x0094 - 0x0064)
class UTgAIBehaviorNode : public UTgAIBehaviorObject
{
public:
	class UTgAIBehaviorNode*                           Parent;                                                   // 0x0064(0x0008) (DuplicateTransient)
	float                                              InvTickFrequency;                                         // 0x006C(0x0004)
	struct FString                                     TitleName;                                                // 0x0070(0x0010) (NeedCtorLink)
	struct FString                                     FriendlyName;                                             // 0x0080(0x0010) (Edit, AlwaysInit, NeedCtorLink)
	unsigned long                                      bShownInMenu : 1;                                         // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorNode");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction : public UTgAIBehaviorNode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PlayVGS
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_PlayVGS : public UTgAIBehaviorAction
{
public:
	int                                                VgsId;                                                    // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PlayVGS");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite
// 0x0024 (0x00B8 - 0x0094)
class UTgAIBehaviorComposite : public UTgAIBehaviorNode
{
public:
	TArray<class UTgAIBehaviorNode*>                   Children;                                                 // 0x0094(0x0010) (EditFixedSize, AlwaysInit, NeedCtorLink, EditInline)
	TArray<int>                                        ChildrenIndices;                                          // 0x00A4(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	unsigned long                                      bCompleteOnAll : 1;                                       // 0x00B4(0x0004) (Edit, Const, EditConst)
	unsigned long                                      bFailsOnAll : 1;                                          // 0x00B4(0x0004) (Edit, Const, EditConst)
	unsigned long                                      bRetryFailedChild : 1;                                    // 0x00B4(0x0004) (Edit, Const, EditConst)
	unsigned long                                      bFixedChildrenSize : 1;                                   // 0x00B4(0x0004) (Const, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Gated
// 0x0000 (0x00B8 - 0x00B8)
class UTgAIBehaviorComposite_Gated : public UTgAIBehaviorComposite
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Gated");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Random
// 0x0018 (0x00D0 - 0x00B8)
class UTgAIBehaviorComposite_Random : public UTgAIBehaviorComposite
{
public:
	TArray<float>                                      ChildWeights;                                             // 0x00B8(0x0010) (Edit, EditFixedSize, NeedCtorLink, EditInline)
	float                                              ChildFreezeTime;                                          // 0x00C8(0x0004) (Edit)
	unsigned long                                      bRandomizeOnComplete : 1;                                 // 0x00CC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Random");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Sequence
// 0x0004 (0x00BC - 0x00B8)
class UTgAIBehaviorComposite_Sequence : public UTgAIBehaviorComposite
{
public:
	unsigned long                                      bStopOnRunningChild : 1;                                  // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Sequence");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_Parallel
// 0x0000 (0x00BC - 0x00BC)
class UTgAIBehaviorComposite_Parallel : public UTgAIBehaviorComposite_Sequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_Parallel");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SequenceScripted
// 0x0004 (0x00BC - 0x00B8)
class UTgAIBehaviorComposite_SequenceScripted : public UTgAIBehaviorComposite
{
public:
	unsigned long                                      bFreezeOnLast : 1;                                        // 0x00B8(0x0004) (Edit)
	unsigned long                                      bIsLooping : 1;                                           // 0x00B8(0x0004) (Edit)
	unsigned long                                      bFirstChildIsResetTest : 1;                               // 0x00B8(0x0004) (Edit)
	unsigned long                                      bResetSequenceOnFailure : 1;                              // 0x00B8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SequenceScripted");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SubTree
// 0x0008 (0x00C0 - 0x00B8)
class UTgAIBehaviorComposite_SubTree : public UTgAIBehaviorComposite
{
public:
	class UTgAIBehaviorTree*                           ChildTree;                                                // 0x00B8(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SubTree");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorCondition : public UTgAIBehaviorNode
{
public:
	TEnumAsByte<EBehaviorComparison>                   ComparisonOperator;                                       // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetHasEffectCategory
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetHasEffectCategory : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0098(0x0004) (Edit)
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)
	int                                                EffectGroupId;                                            // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetHasEffectCategory");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasEffectCategory
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_HasEffectCategory : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x0098(0x0004) (Edit)
	int                                                EffectGroupId;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasEffectCategory");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_PawnState
// 0x0008 (0x009D - 0x0095)
class UTgAIBehaviorCondition_PawnState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bCheckInheritedState : 1;                                 // 0x0098(0x0004) (Edit)
	TEnumAsByte<EPawnStateName>                        ePawnState;                                               // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_PawnState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor : public UTgAIBehaviorNode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorTree
// 0x0018 (0x00AC - 0x0094)
class UTgAIBehaviorTree : public UTgAIBehaviorNode
{
public:
	class UTgAIBehaviorComposite*                      ChildNode;                                                // 0x0094(0x0008)
	TArray<class UTgAIBehaviorSensor*>                 SensorNodes;                                              // 0x009C(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorTree");
		return ptr;
	}

};


// Class TgGame.TgAIController
// 0x012C (0x05EC - 0x04C0)
class ATgAIController : public AGameAIController
{
public:
	class ATgPawn*                                     m_pOwner;                                                 // 0x04C0(0x0008) (Transient)
	struct FVector                                     m_vSpawnLocation;                                         // 0x04C8(0x000C) (Transient)
	struct FRotator                                    m_rSpawnDirection;                                        // 0x04D4(0x000C) (Transient)
	class ATgBotFactory*                               m_pFactory;                                               // 0x04E0(0x0008) (Transient)
	int                                                m_nFactorySpawnGroup;                                     // 0x04E8(0x0004) (Transient)
	struct FPointer                                    m_pBot;                                                   // 0x04EC(0x0008) (Const, Native, Transient)
	struct FPointer                                    m_pSettings;                                              // 0x04F4(0x0008) (Const, Native, Transient)
	struct FPointer                                    m_pSkin;                                                  // 0x04FC(0x0008) (Const, Native, Transient)
	int                                                m_iAssignedLane;                                          // 0x0504(0x0004) (Transient)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0508(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.m_SeePawnCache
	float                                              LastSeePawnCacheTime;                                     // 0x0550(0x0004) (Transient)
	float                                              SeePawnClearTime;                                         // 0x0554(0x0004) (Transient)
	class ATgPawn*                                     m_pLastAttacker;                                          // 0x0558(0x0008) (Transient)
	class AController*                                 m_pLastKiller;                                            // 0x0560(0x0008) (Transient)
	class UTgAISquad*                                  m_Squad;                                                  // 0x0568(0x0008) (Transient)
	float                                              m_fAILevelUpSecs;                                         // 0x0570(0x0004)
	unsigned long                                      s_bBotFactoryDrivenLevelUp : 1;                           // 0x0574(0x0004)
	unsigned long                                      bUsesObstacleAvoidance : 1;                               // 0x0574(0x0004)
	unsigned long                                      bIsPaused : 1;                                            // 0x0574(0x0004) (Transient)
	TEnumAsByte<EPhysics>                              WalkingPhysics;                                           // 0x0578(0x0001)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0579(0x0003) MISSED OFFSET
	float                                              VisionDistance;                                           // 0x057C(0x0004)
	class UTgAIObstacleAvoidance*                      ObstacleAvoidance;                                        // 0x0580(0x0008) (Transient)
	float                                              ObstacleAvoidanceGridPointSize;                           // 0x0588(0x0004)
	float                                              ObstacleAvoidanceGridExtents;                             // 0x058C(0x0004)
	struct FVector                                     SpreadLocation;                                           // 0x0590(0x000C) (Transient)
	class ATgRepInfo_Player*                           CachedPRI;                                                // 0x059C(0x0008) (Transient)
	unsigned char                                      UnknownData02[0x48];                                      // 0x05A4(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.DeviceTargetingCache

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController");
		return ptr;
	}


	void STATIC_NotifyWeaponFired(class AWeapon* W, unsigned char FireMode);
	void NotifyDamagedTarget(class ATgPawn* TargetPawn);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void STATIC_OnEnterCombat();
	void STATIC_OnExitCombat();
	void STATIC_NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum);
	void NotifyKilledBy(class AController* Killer);
	void STATIC_SetActionlessPause(bool bOn);
	void STATIC_OnToggleImmuneGodMode(class UTgSeqAct_ToggleImmuneGodMode* inAction);
	void STATIC_OnSetTaskforce(class UTgSeqAct_SetTaskforce* Action);
	void STATIC_OnTriggerBots(class UTgSeqAct_TriggerBots* Action);
	void PawnDied(class APawn* P);
	void Suicide();
	void DespawnAndHide();
	void Despawn();
	void Destroyed();
	void CleanupPRI();
	void STATIC_InitPlayerReplicationInfo();
	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void PostBeginPlay();
	bool STATIC_CanSpreadOut();
	void STATIC_ClearSpreadLocation();
	void STATIC_SetSpreadLocation(struct FVector* SpreadLoc);
	void STATIC_Evade();
	void STATIC_SquadEvade();
	void STATIC_SquadTargetChanged();
	void UpdateTargetingList(TArray<struct FImpactInfo> ImpactList, unsigned char EquipSlot);
	float STATIC_GetMaxDeviceRange();
	bool LineCheckPassThrough(const struct FVector& vLocation, class AActor* pTarget, const struct FVector& vTarget);
	bool LineCheckEx(const struct FVector& vLocation, class AActor* pTarget, const struct FVector& vTarget);
	bool STATIC_LineCheck(const struct FVector& vLocation, class AActor* pTarget);
	bool LineCheckVisibility(class AActor* pTarget, class AActor* pSource);
	bool LineCheckMovement(class AActor* pTarget, class AActor* pSource);
	void SetTaskForceNumber(int nTaskForce);
	int STATIC_GetTaskForceNumber();
	void AddThreat(class ATgPawn* attacker, float fAmount);
	bool IsDeviceReady(TEnumAsByte<ETG_EQUIP_POINT> DeviceSlot);
	bool AtLocation(const struct FVector& vLocation);
};


// Class TgGame.TgAIController_Behavior
// 0x02B0 (0x089C - 0x05EC)
class ATgAIController_Behavior : public ATgAIController
{
public:
	TArray<struct FDeferredNode>                       DeferredNodes;                                            // 0x05EC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                BlackboardType;                                           // 0x05FC(0x0004) (Transient)
	struct FName                                       BehaviorTreeAsName;                                       // 0x0600(0x0008)
	struct FPointer                                    SensorTree;                                               // 0x0608(0x0008) (Native, Transient)
	struct FPointer                                    SensorDynamicMemory;                                      // 0x0610(0x0008) (Native, Transient)
	struct FPointer                                    SensorStaticMemory;                                       // 0x0618(0x0008) (Native, Transient)
	struct FPointer                                    WorkerTree;                                               // 0x0620(0x0008) (Native, Transient)
	struct FPointer                                    WorkerTreeCachedStatus;                                   // 0x0628(0x0008) (Native, Transient)
	struct FPointer                                    WorkerDynamicMemory;                                      // 0x0630(0x0008) (Native, Transient)
	struct FPointer                                    WorkerStaticMemory;                                       // 0x0638(0x0008) (Native, Transient)
	int                                                SensorNodeCount;                                          // 0x0640(0x0004) (Transient)
	int                                                WorkerNodeCount;                                          // 0x0644(0x0004) (Transient)
	float                                              LastUpdateTime;                                           // 0x0648(0x0004) (Transient)
	TArray<struct FBehaviorStateData>                  CachedNodeData;                                           // 0x064C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	float                                              m_fCooldownModifier;                                      // 0x065C(0x0004)
	float                                              m_fLeadAccuracy;                                          // 0x0660(0x0004)
	float                                              m_fGoldGainModifier;                                      // 0x0664(0x0004)
	float                                              m_fXpGainModifier;                                        // 0x0668(0x0004)
	class UTgAILocalPositionSolver*                    LocalRepulsorSolver;                                      // 0x066C(0x0008) (Transient)
	class UClass*                                      LocalRepulsorSolverClass;                                 // 0x0674(0x0008)
	struct FNavigationQueueEntry                       CurrentNavigation;                                        // 0x067C(0x0040) (Transient)
	float                                              NavigationSearchModifier;                                 // 0x06BC(0x0004) (Transient)
	float                                              NavigationSearchModifier_Max;                             // 0x06C0(0x0004)
	float                                              NavigationSearchModifier_Min;                             // 0x06C4(0x0004)
	float                                              ReachabilityCacheTime;                                    // 0x06C8(0x0004)
	struct FFollowLaneState                            FollowLaneForwardState;                                   // 0x06CC(0x0008)
	struct FFollowLaneState                            FollowLaneReverseState;                                   // 0x06D4(0x0008)
	unsigned long                                      bIsAlive : 1;                                             // 0x06DC(0x0004) (Transient)
	unsigned long                                      bIsRotationLocked : 1;                                    // 0x06DC(0x0004) (Transient)
	unsigned long                                      bIsStunned : 1;                                           // 0x06DC(0x0004) (Transient)
	unsigned long                                      bCanUpdateAIWhileStunned : 1;                             // 0x06DC(0x0004) (Const)
	unsigned long                                      bInHostileAbility : 1;                                    // 0x06DC(0x0004) (Transient)
	unsigned long                                      bIsSafeToRecall : 1;                                      // 0x06DC(0x0004) (Transient)
	unsigned long                                      bInEnemyTowerRadius : 1;                                  // 0x06DC(0x0004) (Transient)
	unsigned long                                      bInFriendlyTowerRadius : 1;                               // 0x06DC(0x0004) (Transient)
	unsigned long                                      bInEnemyMinotaurRadius : 1;                               // 0x06DC(0x0004) (Transient)
	unsigned long                                      bInFriendlyMinotaurRadius : 1;                            // 0x06DC(0x0004) (Transient)
	unsigned long                                      bIsTargetOfEnemyTowerOrMinotaur : 1;                      // 0x06DC(0x0004) (Transient)
	unsigned long                                      bCombatTargetInEnemyTowerRadius : 1;                      // 0x06DC(0x0004) (Transient)
	unsigned long                                      bCombatTargetInFriendlyTowerRadius : 1;                   // 0x06DC(0x0004) (Transient)
	unsigned long                                      bCombatTargetInEnemyMinotaurRadius : 1;                   // 0x06DC(0x0004) (Transient)
	unsigned long                                      bCombatTargetInFriendlyMinotaurRadius : 1;                // 0x06DC(0x0004) (Transient)
	unsigned long                                      bCombatTargetIsTargetOfFriendlyTowerOrMinotaur : 1;       // 0x06DC(0x0004) (Transient)
	unsigned long                                      bIsAtCachedRallyPoint : 1;                                // 0x06DC(0x0004) (Transient)
	unsigned long                                      bBtDebugSpawnPaused : 1;                                  // 0x06DC(0x0004)
	unsigned long                                      bBtDebugPaused : 1;                                       // 0x06DC(0x0004) (Transient)
	unsigned long                                      bBtDebugStep : 1;                                         // 0x06DC(0x0004) (Transient)
	unsigned long                                      bBtDebugClientOverlay : 1;                                // 0x06DC(0x0004) (Transient)
	float                                              NextFearDirectionTime;                                    // 0x06E0(0x0004) (Transient)
	struct FVector                                     NextFearDirection;                                        // 0x06E4(0x000C) (Transient)
	float                                              PawnCollisionHeight;                                      // 0x06F0(0x0004) (Transient)
	float                                              PawnCollisionRadius;                                      // 0x06F4(0x0004) (Transient)
	float                                              LastDamageTakenTime;                                      // 0x06F8(0x0004) (Transient)
	struct FVector                                     LastDamageTakenPosition;                                  // 0x06FC(0x000C) (Transient)
	float                                              DeviceRanges[0x1F];                                       // 0x0708(0x0004) (Transient)
	class AActor*                                      CombatTarget;                                             // 0x0784(0x0008) (Transient)
	class ATgPawn*                                     CombatTargetAsPawn;                                       // 0x078C(0x0008) (Transient)
	int                                                EnemyMinionsInEnemyTowerRadius;                           // 0x0794(0x0004) (Transient)
	int                                                FriendlyMinionsInEnemyTowerRadius;                        // 0x0798(0x0004) (Transient)
	int                                                EnemyMinionsInFriendlyTowerRadius;                        // 0x079C(0x0004) (Transient)
	int                                                FriendlyMinionsInFriendlyTowerRadius;                     // 0x07A0(0x0004) (Transient)
	int                                                EnemyGodsInEnemyTowerRadius;                              // 0x07A4(0x0004) (Transient)
	int                                                FriendlyGodsInEnemyTowerRadius;                           // 0x07A8(0x0004) (Transient)
	int                                                EnemyGodsInFriendlyTowerRadius;                           // 0x07AC(0x0004) (Transient)
	int                                                FriendlyGodsInFriendlyTowerRadius;                        // 0x07B0(0x0004) (Transient)
	float                                              HealthOfNearestEnemyTower;                                // 0x07B4(0x0004) (Transient)
	float                                              HealthOfNearestFriendlyTower;                             // 0x07B8(0x0004) (Transient)
	int                                                EnemyMinionsInEnemyMinotaurRadius;                        // 0x07BC(0x0004) (Transient)
	int                                                FriendlyMinionsInEnemyMinotaurRadius;                     // 0x07C0(0x0004) (Transient)
	int                                                EnemyMinionsInFriendlyMinotaurRadius;                     // 0x07C4(0x0004) (Transient)
	int                                                FriendlyMinionsInFriendlyMinotaurRadius;                  // 0x07C8(0x0004) (Transient)
	int                                                EnemyGodsInEnemyMinotaurRadius;                           // 0x07CC(0x0004) (Transient)
	int                                                FriendlyGodsInEnemyMinotaurRadius;                        // 0x07D0(0x0004) (Transient)
	int                                                EnemyGodsInFriendlyMinotaurRadius;                        // 0x07D4(0x0004) (Transient)
	int                                                FriendlyGodsInFriendlyMinotaurRadius;                     // 0x07D8(0x0004) (Transient)
	float                                              HealthOfEnemyMinotaur;                                    // 0x07DC(0x0004) (Transient)
	float                                              HealthOfFriendlyMinotaur;                                 // 0x07E0(0x0004) (Transient)
	class ATgPawn*                                     CachedEnemyMinotaur;                                      // 0x07E4(0x0008) (Transient)
	class ATgPawn*                                     CachedAllyMinotaur;                                       // 0x07EC(0x0008) (Transient)
	class AActor*                                      LaneMoveTarget;                                           // 0x07F4(0x0008) (Transient)
	TArray<class AActor*>                              VisibleActorsToAvoid;                                     // 0x07FC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class AActor*>                              ActorsToAvoidWithoutChecks;                               // 0x080C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgPawn*>                             CachedTowers;                                             // 0x081C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgPawn_Character*>                   CachedGods;                                               // 0x082C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class AController*>                         EnemyControllersInSightRadius;                            // 0x083C(0x0010) (Transient, NeedCtorLink)
	TArray<class AController*>                         FriendlyControllersInSightRadius;                         // 0x084C(0x0010) (Transient, NeedCtorLink)
	TEnumAsByte<EBotDifficultyLevel>                   Difficulty;                                               // 0x085C(0x0001) (Transient)
	TEnumAsByte<EUseDeviceAimType>                     LastUseDeviceAimType;                                     // 0x085D(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x085E(0x0002) MISSED OFFSET
	TArray<struct FIncomingDamageEntry>                IncomingDamage;                                           // 0x0860(0x0010) (Transient, NeedCtorLink)
	class ATgAIVolume*                                 CachedRallyVolume;                                        // 0x0870(0x0008) (Transient)
	int                                                RandomRallyPointIndex;                                    // 0x0878(0x0004) (Transient)
	struct FVector                                     StrafeDir;                                                // 0x087C(0x000C) (Transient)
	float                                              LastStrafeDirUpdate;                                      // 0x0888(0x0004) (Transient)
	TArray<class ATgBotFactory*>                       CachedJungleCamps;                                        // 0x088C(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_Behavior");
		return ptr;
	}


	void STATIC_GameHasEnded(class AActor* EndGameFocus, bool bIsWinner);
	void PawnDied(class APawn* P);
	struct FRotator STATIC_GetAdjustedAimFor(class AWeapon* Weap, const struct FVector& StartFireLoc);
	float STATIC_GetLeadAccuracy();
	float STATIC_GetCooldownModifier();
	float STATIC_GetAngleToTarget();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	bool CancelFiring();
	bool FireDevice(TEnumAsByte<ETG_EQUIP_POINT> DeviceSlot, TEnumAsByte<EUseDeviceAimType> aimType);
	void STATIC_NotifyTakeHit(class AController* InstigatedBy, const struct FVector& HitLocation, int Damage, class UClass* DamageType, const struct FVector& Momentum);
	void Stun(bool bStun, TEnumAsByte<EStunType> eType);
	void UpdateDeviceRanges();
	void STATIC_StopNavigation();
	void STATIC_ClearNavigation();
	void AddLocationToNavigationQueue(int NodeToken, const struct FVector& TargetLocation, bool bLookAtTarget, bool bMustHaveLOS, float DistanceTolerance);
	void AddActorToNavigationQueue(int NodeToken, class AActor* TargetActor, bool bLookAtTarget, bool bMustHaveLOS, float DistanceTolerance, bool bStopNavOnReachedDestination);
	bool STATIC_HasVisibilityToPoint(struct FVector* TestPoint);
	void ResetBlackboard();
	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void Destroyed();
	void PostBeginPlay();
	void PreBeginPlay();
	void LoadBehaviorTree(const struct FName& TreeName);
	void STATIC_ResetBehaviorTree();
	void STATIC_CleanupBehaviorTree();
	void STATIC_SpawnDebuggerWindow();
	void STATIC_Debug_Reset();
	void STATIC_Debug_Resume();
	void STATIC_Debug_Step();
	void STATIC_Debug_Pause();
	void UpdatePawnDebug();
};


// Class TgGame.TgAIController_BehaviorGod
// 0x001C (0x08B8 - 0x089C)
class ATgAIController_BehaviorGod : public ATgAIController_Behavior
{
public:
	float                                              WaitForSpawnSecs;                                         // 0x089C(0x0004)
	int                                                PlayerID;                                                 // 0x08A0(0x0004) (Transient)
	unsigned long                                      bCanPurchaseItems : 1;                                    // 0x08A4(0x0004) (Transient)
	unsigned long                                      bCanPurchaseSkills : 1;                                   // 0x08A4(0x0004) (Transient)
	float                                              CurrentGoldRemainder;                                     // 0x08A8(0x0004) (Transient)
	int                                                CurrentGold;                                              // 0x08AC(0x0004) (Transient)
	float                                              CurrentXPRemainder;                                       // 0x08B0(0x0004) (Transient)
	int                                                CurrentXP;                                                // 0x08B4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorGod");
		return ptr;
	}


	void STATIC_SetupIntro();
	void STATIC_ResetPlayer();
	void CopyPropertiesTo(class AController* C);
	void PawnDied(class APawn* P);
	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void Revive();
	void STATIC_InitPlayerReplicationInfo();
	void STATIC_SetStartingProperties();
	void STATIC_SetBotPlayerId();
	float STATIC_StartReviveTimer();
	void STATIC_PurchaseSkills();
	int STATIC_GetSkillPointsAvailable();
	bool STATIC_HaveBasicSkillsBeenActivated();
	bool STATIC_CanAllocateSkillPoint(int DeviceID, class ATgDevice* aDevice);
	bool STATIC_PurchaseItemWrapper(int nItemId, int nItemCount);
	void STATIC_PurchaseItems();
};


// Class TgGame.TgAIController_BehaviorGod_Leashed
// 0x0030 (0x08E8 - 0x08B8)
class ATgAIController_BehaviorGod_Leashed : public ATgAIController_BehaviorGod
{
public:
	TArray<struct FThreatEntry>                        ThreatList;                                               // 0x08B8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	unsigned long                                      bThreatListDecays : 1;                                    // 0x08C8(0x0004) (Transient)
	unsigned long                                      bOutsideLeash : 1;                                        // 0x08C8(0x0004) (Transient)
	unsigned long                                      bHadCombatTarget : 1;                                     // 0x08C8(0x0004) (Transient)
	float                                              LeashDistance;                                            // 0x08CC(0x0004) (Transient)
	class AVolume*                                     LeashVolume;                                              // 0x08D0(0x0008) (Transient)
	TArray<class ATgPawn*>                             LeashActors;                                              // 0x08D8(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorGod_Leashed");
		return ptr;
	}


	void NotifyKilledBy(class AController* Killer);
	void STATIC_SquadTargetChanged();
	void STATIC_SquadEvade();
	void STATIC_Evade();
	bool STATIC_CanSpreadOut();
	void STATIC_ClearThreatList();
	void AddThreat(class ATgPawn* attacker, float ThreatLevel);
};


// Class TgGame.TgAIController_BehaviorGodDisconnected
// 0x0004 (0x08BC - 0x08B8)
class ATgAIController_BehaviorGodDisconnected : public ATgAIController_BehaviorGod
{
public:
	unsigned long                                      bInitialController : 1;                                   // 0x08B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorGodDisconnected");
		return ptr;
	}


	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void STATIC_InitPlayerReplicationInfo();
};


// Class TgGame.TgAIController_BehaviorGodTransfer
// 0x0000 (0x08B8 - 0x08B8)
class ATgAIController_BehaviorGodTransfer : public ATgAIController_BehaviorGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorGodTransfer");
		return ptr;
	}


	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void STATIC_InitPlayerReplicationInfo();
};


// Class TgGame.TgAIController_BehaviorLaneNpc
// 0x000C (0x08A8 - 0x089C)
class ATgAIController_BehaviorLaneNpc : public ATgAIController_Behavior
{
public:
	class AActor*                                      GoalTarget;                                               // 0x089C(0x0008) (Transient)
	unsigned long                                      bDespawnOnLoseCombatTarget : 1;                           // 0x08A4(0x0004) (Transient)
	unsigned long                                      bIsBehindSquad : 1;                                       // 0x08A4(0x0004) (Transient)
	unsigned long                                      bTooFarFromLane : 1;                                      // 0x08A4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorLaneNpc");
		return ptr;
	}


	bool STATIC_CanSpreadOut();
};


// Class TgGame.TgAIController_BehaviorMapNpc
// 0x0030 (0x08CC - 0x089C)
class ATgAIController_BehaviorMapNpc : public ATgAIController_Behavior
{
public:
	TArray<struct FThreatEntry>                        ThreatList;                                               // 0x089C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	unsigned long                                      bThreatListDecays : 1;                                    // 0x08AC(0x0004) (Transient)
	unsigned long                                      bOutsideLeash : 1;                                        // 0x08AC(0x0004) (Transient)
	unsigned long                                      bHadCombatTarget : 1;                                     // 0x08AC(0x0004) (Transient)
	float                                              LeashDistance;                                            // 0x08B0(0x0004) (Transient)
	class AVolume*                                     LeashVolume;                                              // 0x08B4(0x0008) (Transient)
	TArray<class ATgPawn*>                             LeashActors;                                              // 0x08BC(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorMapNpc");
		return ptr;
	}


	void NotifyKilledBy(class AController* Killer);
	void STATIC_SquadTargetChanged();
	void STATIC_SquadEvade();
	void STATIC_Evade();
	bool STATIC_CanSpreadOut();
	void STATIC_ClearThreatList();
	void AddThreat(class ATgPawn* attacker, float ThreatLevel);
};


// Class TgGame.TgAIController_BehaviorPet
// 0x0000 (0x089C - 0x089C)
class ATgAIController_BehaviorPet : public ATgAIController_Behavior
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorPet");
		return ptr;
	}

};


// Class TgGame.TgAIController_BehaviorPet_LongTerm
// 0x0000 (0x089C - 0x089C)
class ATgAIController_BehaviorPet_LongTerm : public ATgAIController_BehaviorPet
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_BehaviorPet_LongTerm");
		return ptr;
	}

};


// Class TgGame.TgAIController_Behavior_PVEMinion
// 0x0000 (0x089C - 0x089C)
class ATgAIController_Behavior_PVEMinion : public ATgAIController_BehaviorPet_LongTerm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIController_Behavior_PVEMinion");
		return ptr;
	}

};


// Class TgGame.TgAIInfluenceMap
// 0x0038 (0x0098 - 0x0060)
class UTgAIInfluenceMap : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<int>                                        Influences;                                               // 0x0068(0x0010) (Transient, NeedCtorLink)
	struct FPointer                                    FalloffTable;                                             // 0x0078(0x0008) (Native, Transient)
	class UHavokNavMeshGrid*                           InfluenceGrid;                                            // 0x0080(0x0008) (Const, Native, Transient)
	float                                              TickFrequency;                                            // 0x0088(0x0004)
	float                                              InvTickFrequency;                                         // 0x008C(0x0004) (Transient)
	float                                              Decay;                                                    // 0x0090(0x0004)
	float                                              Momentum;                                                 // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIInfluenceMap");
		return ptr;
	}


	void STATIC_RegisterInfluence(const struct FVector& StartPosition, int PackedInfluence, bool Additive, float Radius);
	void Init();
};


// Class TgGame.TgAIInfluenceMapRenderingComponent
// 0x0010 (0x0260 - 0x0250)
class UTgAIInfluenceMapRenderingComponent : public UHavokNavigationRenderingComponent
{
public:
	class UTgAIInfluenceMap*                           InfluenceMap;                                             // 0x0250(0x0008) (Transient)
	class UTexture2DDynamic*                           InfluenceMapTexture;                                      // 0x0258(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIInfluenceMapRenderingComponent");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver
// 0x0040 (0x00A0 - 0x0060)
class UTgAILocalPositionSolver : public UObject
{
public:
	struct FPointer                                    VfTable_IInterface_ActorPathConstraints;                  // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<struct FDefaultRepulsorData>                DefaultWeights;                                           // 0x0068(0x0010) (NeedCtorLink)
	class ATgAIController_Behavior*                    OuterController;                                          // 0x0078(0x0008) (Transient)
	float                                              LastQueryTime;                                            // 0x0080(0x0004) (Transient)
	struct FVector                                     LastQueryPoint;                                           // 0x0084(0x000C) (Transient)
	struct FVector                                     LastSolvePoint;                                           // 0x0090(0x000C) (Transient)
	unsigned long                                      bSolveDistanceThreshold : 1;                              // 0x009C(0x0004)
	unsigned long                                      bSolveWeights : 1;                                        // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver");
		return ptr;
	}


	void STATIC_SolveConstraints(const struct FVector& InitialPosition, float MaxDistance, struct FVector* OutDesiredPosition);
};


// Class TgGame.TgAIObstacleAvoidance
// 0x0050 (0x00B0 - 0x0060)
class UTgAIObstacleAvoidance : public UObject
{
public:
	struct FPointer                                    ObstacleGrid;                                             // 0x0060(0x0008) (Native, Transient)
	struct FObstacleQueryCache                         CachedAvoidance;                                          // 0x0068(0x002C) (Transient, NeedCtorLink)
	TArray<class ABlockingVolume*>                     CachedBlockers;                                           // 0x0094(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	class ATgAIController_Behavior*                    OuterController;                                          // 0x00A4(0x0008) (Transient)
	unsigned long                                      bRenderingIsDirty : 1;                                    // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIObstacleAvoidance");
		return ptr;
	}


	void STATIC_TestObstacleAvoidance(int TestType);
	void Reset();
	void Init(float GridPointSize, float GridExtents);
	TEnumAsByte<EObstacleAvoidanceStatus> STATIC_GetNextMoveLocation(struct FVector* TargetPoint, struct FVector* IntermediatePoint, float* ArrivalDistance);
	bool FindPath(TArray<class AActor*>* ActorsToAvoid, TArray<class AActor*>* ActorsToAvoidWithoutChecks, struct FVector* TargetPoint, struct FVector* UpdatedTargetPoint);
};


// Class TgGame.TgAIObstacleAvoidanceRenderingComponent
// 0x0008 (0x0254 - 0x024C)
class UTgAIObstacleAvoidanceRenderingComponent : public UPrimitiveComponent
{
public:
	class UTgAIObstacleAvoidance*                      ObstacleAvoidance;                                        // 0x024C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIObstacleAvoidanceRenderingComponent");
		return ptr;
	}

};


// Class TgGame.TgAISquad
// 0x0078 (0x00D8 - 0x0060)
class UTgAISquad : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	unsigned long                                      s_bOpen : 1;                                              // 0x0068(0x0004)
	unsigned long                                      s_bShouldSpread : 1;                                      // 0x0068(0x0004)
	unsigned long                                      s_bHadMembers : 1;                                        // 0x0068(0x0004)
	unsigned long                                      s_bDiedWhileOpen : 1;                                     // 0x0068(0x0004)
	TArray<class ATgAIController*>                     s_MemberList;                                             // 0x006C(0x0010) (NeedCtorLink)
	class ATgBotFactory*                               s_Factory;                                                // 0x007C(0x0008)
	class AActor*                                      s_CurrentTarget;                                          // 0x0084(0x0008)
	TArray<class AActor*>                              s_TargetList;                                             // 0x008C(0x0010) (NeedCtorLink)
	class AController*                                 s_LastKiller;                                             // 0x009C(0x0008)
	float                                              s_fNextSpreadTime;                                        // 0x00A4(0x0004)
	TArray<class ATgAIController*>                     s_PendingAddMemberList;                                   // 0x00A8(0x0010) (NeedCtorLink)
	TArray<struct FSquadPendingRemove>                 s_PendingRemoveMemberList;                                // 0x00B8(0x0010) (NeedCtorLink)
	struct FPointer                                    AddPendingMemberSyncObject;                               // 0x00C8(0x0008)
	struct FPointer                                    RemovePendingMemberSyncObject;                            // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad");
		return ptr;
	}


	void OnSquadCreated();
	void NotifyEvade();
	void NotifyTargetChanged();
	void STATIC_Evade();
	void STATIC_SuggestEvade();
	void UpdateTargetList(float DeltaTime);
	void STATIC_DropTarget(class AActor* TargetToDrop);
	void STATIC_SuggestDropTarget(class AActor* TargetToDrop, class ATgAIController* requester);
	class ATgPawn* STATIC_GetTargetPawn();
	class AActor* STATIC_GetTarget();
	void SetTarget(class AActor* NewTarget);
	void STATIC_SuggestTarget(class AActor* NewTarget, class ATgAIController* requester);
	struct FBox STATIC_GetSquadBounds();
	void STATIC_SpreadSquad();
	void STATIC_ProcessPendingRemoves();
	void STATIC_ProcessPendingAdds();
	void STATIC_QueuePendingMemberRemove(class ATgAIController* aic, bool bDied);
	void STATIC_QueuePendingMemberAdd(class ATgAIController* aic);
	void STATIC_SquadDied();
	bool MergeWith(class UTgAISquad* squad);
	void MemberKilledBy(class AController* Killer);
	void RemoveMember(class ATgAIController* aic, bool bDied);
	void AddMember(class ATgAIController* aic);
	bool IsOpen();
	void STATIC_CloseSquad();
	void STATIC_OpenSquad();
	void STATIC_InitializeSquad();
};


// Class TgGame.TgAISquad_Minion
// 0x0008 (0x00E0 - 0x00D8)
class UTgAISquad_Minion : public UTgAISquad
{
public:
	float                                              s_fNextClusterTime;                                       // 0x00D8(0x0004)
	float                                              s_fNextMergeTime;                                         // 0x00DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad_Minion");
		return ptr;
	}


	void STATIC_CheckForMerge();
	void STATIC_ClusterSquad();
};


// Class TgGame.TgAISquad_Monster
// 0x0000 (0x00D8 - 0x00D8)
class UTgAISquad_Monster : public UTgAISquad
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad_Monster");
		return ptr;
	}


	void STATIC_DropTarget(class AActor* TargetToDrop);
};


// Class TgGame.TgAISquad_MonsterBehaviorTree
// 0x0014 (0x00EC - 0x00D8)
class UTgAISquad_MonsterBehaviorTree : public UTgAISquad
{
public:
	struct FName                                       BehaviorTreeAsName;                                       // 0x00D8(0x0008)
	class ATgAIController_BehaviorMapNpc*              Controller;                                               // 0x00E0(0x0008) (Transient)
	unsigned long                                      m_bAllowFriendlyTargets : 1;                              // 0x00E8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAISquad_MonsterBehaviorTree");
		return ptr;
	}


	void UnpauseSquadController();
	void OnSquadCreated();
	class ATgPawn* STATIC_GetTargetPawn();
	class AActor* STATIC_GetTarget();
	void STATIC_Evade();
	void STATIC_SquadDied();
	void UpdateTargetList(float DeltaTime);
	void STATIC_DropTarget(class AActor* TargetToDrop);
	void STATIC_SuggestDropTarget(class AActor* TargetToDrop, class ATgAIController* requester);
	void SetTarget(class AActor* NewTarget);
	void STATIC_SuggestTarget(class AActor* NewTarget, class ATgAIController* requester);
	class ATgAIController_BehaviorMapNpc* STATIC_SpawnController();
};


// Class TgGame.TgMinionGoal
// 0x0014 (0x036C - 0x0358)
class ATgMinionGoal : public ANavigationPoint
{
public:
	int                                                m_nLaneNum;                                               // 0x0358(0x0004) (Edit)
	int                                                m_nTaskForce;                                             // 0x035C(0x0004) (Edit)
	class ATgActionPoint*                              m_EndPoint;                                               // 0x0360(0x0008) (Edit)
	unsigned long                                      m_bUseForFinalDestination : 1;                            // 0x0368(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMinionGoal");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgCameraModifier_EmoteZoom
// 0x0038 (0x00B8 - 0x0080)
class UTgCameraModifier_EmoteZoom : public UCameraModifier
{
public:
	class UTgAnimMetaData_LobbyCameraModifier*         ActiveMetaData;                                           // 0x0080(0x0008)
	struct FVector                                     vTranslationOffset;                                       // 0x0088(0x000C)
	struct FRotator                                    rRotationOffset;                                          // 0x0094(0x000C)
	struct FVector                                     vTargetTranslationOffset;                                 // 0x00A0(0x000C)
	struct FRotator                                    rTargetRotationOffset;                                    // 0x00AC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModifier_EmoteZoom");
		return ptr;
	}


	bool STATIC_ModifyCamera(class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV);
	void DisableModifier(bool bImmediate);
	void AddCameraModifierAsEvent(class ACamera* Cam);
	void EnableModifierAsEvent();
	void STATIC_SetActiveMetaData(class UTgAnimMetaData_LobbyCameraModifier* MetaData);
};


// Class TgGame.TgCameraModifier_LobbyCameraTransition
// 0x0018 (0x0098 - 0x0080)
class UTgCameraModifier_LobbyCameraTransition : public UCameraModifier
{
public:
	class ATgLobbyCamera*                              SourceCamera;                                             // 0x0080(0x0008)
	class ATgLobbyCamera*                              DestinationCamera;                                        // 0x0088(0x0008)
	TEnumAsByte<ECameraTransType>                      TransitionType;                                           // 0x0090(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0091(0x0003) MISSED OFFSET
	float                                              fSlideDistance;                                           // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModifier_LobbyCameraTransition");
		return ptr;
	}


	bool STATIC_RemoveCameraModifier(class ACamera* Camera);
	bool AddCameraModifier(class ACamera* Camera);
	void DisableModifier(bool bImmediate);
	void RemoveCameraModifierAsEvent(class ACamera* Cam);
	void AddCameraModifierAsEvent(class ACamera* Cam);
	void STATIC_StreamDestinationTextures();
	bool STATIC_ChangeDestination(class ATgLobbyCamera* NewDestination);
	bool STATIC_ModifyCamera(class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV);
};


// Class TgGame.TgCameraModifier_LobbyFade
// 0x0000 (0x0080 - 0x0080)
class UTgCameraModifier_LobbyFade : public UCameraModifier
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModifier_LobbyFade");
		return ptr;
	}


	bool STATIC_ModifyCamera(class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV);
};


// Class TgGame.TgCameraModule
// 0x0008 (0x0068 - 0x0060)
class UTgCameraModule : public UObject
{
public:
	class ATgPlayerCamera*                             PlayerCamera;                                             // 0x0060(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule");
		return ptr;
	}


	void ZoomClamp();
	void ZoomOut();
	void ZoomIn();
	void BecomeViewTarget(class ATgPlayerController* PC);
	void STATIC_ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void Init();
};


// Class TgGame.TgCameraModule_Free
// 0x0014 (0x007C - 0x0068)
class UTgCameraModule_Free : public UTgCameraModule
{
public:
	float                                              CamAltitude;                                              // 0x0068(0x0004)
	float                                              DesiredCamAltitude;                                       // 0x006C(0x0004)
	float                                              MaxCamAltitude;                                           // 0x0070(0x0004)
	float                                              MinCamAltitude;                                           // 0x0074(0x0004)
	float                                              CamZoomIncrement;                                         // 0x0078(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Free");
		return ptr;
	}


	void ZoomOut();
	void ZoomIn();
	void BecomeViewTarget(class ATgPlayerController* PC);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
	void STATIC_ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
};


// Class TgGame.TgCameraModule_GroundTarget
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_GroundTarget : public UTgCameraModule_Free
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_GroundTarget");
		return ptr;
	}


	void ZoomOut();
	void ZoomIn();
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
};


// Class TgGame.TgCameraModule_Server
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Server : public UTgCameraModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Server");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Spectator
// 0x0034 (0x009C - 0x0068)
class UTgCameraModule_Spectator : public UTgCameraModule
{
public:
	int                                                WorldViewPitch;                                           // 0x0068(0x0004) (Edit)
	struct FTPOV                                       OldViewpoint;                                             // 0x006C(0x0024) (Transient)
	float                                              RemainingBlendTime;                                       // 0x0090(0x0004) (Transient)
	float                                              TotalBlendTime;                                           // 0x0094(0x0004) (Transient)
	unsigned long                                      bCollideWorld : 1;                                        // 0x0098(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Spectator");
		return ptr;
	}


	void BlendCameraToLocation(const struct FVector& NewLocation, float BlendTime, bool bUseFocalPoint);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void STATIC_DecreaseCameraSpeed();
	void STATIC_IncreaseCameraSpeeed();
	void ZoomOut();
	void ZoomIn();
	float GetFOVAngle();
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_SpectatorOverview
// 0x00B4 (0x0150 - 0x009C)
class UTgCameraModule_SpectatorOverview : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                        // 0x009C(0x000C) (Edit)
	float                                              FOV;                                                      // 0x00A8(0x0004) (Edit, Config)
	float                                              TargetZoomedFOV;                                          // 0x00AC(0x0004)
	float                                              ZoomIncrement;                                            // 0x00B0(0x0004) (Edit, Config)
	float                                              MinZoom;                                                  // 0x00B4(0x0004) (Edit, Config)
	float                                              MaxZoom;                                                  // 0x00B8(0x0004) (Edit, Config)
	float                                              ZoomInterpTime;                                           // 0x00BC(0x0004) (Edit, Config)
	struct FVector                                     CurrentSpringLocation;                                    // 0x00C0(0x000C)
	float                                              PawnTargetSpringDamping;                                  // 0x00CC(0x0004) (Edit, Config)
	float                                              FreeCamSpringDamping;                                     // 0x00D0(0x0004) (Edit, Config)
	float                                              IgnoreSpringDistance;                                     // 0x00D4(0x0004) (Edit, Config)
	TArray<struct FCameraPitchInfo>                    CameraPitchData;                                          // 0x00D8(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bFlippedSides : 1;                                        // 0x00E8(0x0004) (Edit)
	unsigned long                                      bJustBecameActive : 1;                                    // 0x00E8(0x0004)
	unsigned long                                      bAutoZoomEnabled : 1;                                     // 0x00E8(0x0004) (Edit, Config)
	unsigned long                                      m_bActiveInExpertMode : 1;                                // 0x00E8(0x0004)
	float                                              OverviewCameraInfluenceDist;                              // 0x00EC(0x0004) (Edit)
	TArray<class ATgOverviewCameraActor*>              OverviewCameras;                                          // 0x00F0(0x0010) (NeedCtorLink)
	TArray<class ATgPawn_TowerBase*>                   TransparentTowerList;                                     // 0x0100(0x0010) (NeedCtorLink)
	struct FVector                                     ObstacleTransparentExtent;                                // 0x0110(0x000C) (Edit)
	float                                              fMinAutoZoomFOVAngle;                                     // 0x011C(0x0004) (Edit, Config)
	float                                              fMaxAutoZoomFOVAngle;                                     // 0x0120(0x0004) (Edit, Config)
	float                                              fMinAutoZoomDistance;                                     // 0x0124(0x0004) (Edit, Config)
	float                                              fMaxAutoZoomDistance;                                     // 0x0128(0x0004) (Edit, Config)
	float                                              fAutoZoomDetectionRadius;                                 // 0x012C(0x0004) (Edit, Config)
	float                                              fAutoZoomInSpeed;                                         // 0x0130(0x0004) (Edit, Config)
	float                                              fAutoZoomOutSpeed;                                        // 0x0134(0x0004) (Edit, Config)
	float                                              fAutoZoomInLockOutTime;                                   // 0x0138(0x0004) (Edit, Config)
	float                                              fAutoZoomOutLockOutTime;                                  // 0x013C(0x0004) (Edit, Config)
	float                                              m_RemainingAutoZoomInLockOutTime;                         // 0x0140(0x0004) (Transient)
	float                                              m_RemainingAutoZoomOutLockOutTime;                        // 0x0144(0x0004) (Transient)
	float                                              m_fInputZoomAxis;                                         // 0x0148(0x0004) (Transient)
	float                                              m_fZoomAxisScale;                                         // 0x014C(0x0004) (Edit, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorOverview");
		return ptr;
	}


	void STATIC_SetFlipSides(bool bFlipped);
	float GetFOVAngle();
	void ZoomOut();
	void ZoomIn();
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void STATIC_ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
	void STATIC_OverridePawnTargetLocation(class ATgPawn* TgP, struct FVector* TargetLocation);
	void BlendCameraToLocation(const struct FVector& NewLocation, float BlendTime, bool bUseFocalPoint);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void STATIC_ClearObstacleTransparency();
	void STATIC_CheckObstacleTransparency();
	bool UpdateAutoZoom(float DeltaTime);
	struct FRotator STATIC_GetWorldViewRotation();
};


// Class TgGame.TgCameraModule_ThirdPerson
// 0x0040 (0x00A8 - 0x0068)
class UTgCameraModule_ThirdPerson : public UTgCameraModule
{
public:
	struct FVector                                     CameraOffset;                                             // 0x0068(0x000C)
	float                                              fZoomFactorInterp;                                        // 0x0074(0x0004)
	float                                              fZoomFactor;                                              // 0x0078(0x0004)
	float                                              fZoomStep;                                                // 0x007C(0x0004)
	float                                              fZoomInterpSpeed;                                         // 0x0080(0x0004)
	float                                              fZoomMax;                                                 // 0x0084(0x0004)
	float                                              fZoomMin;                                                 // 0x0088(0x0004)
	unsigned long                                      bPlaceInLineOfSight : 1;                                  // 0x008C(0x0004)
	struct FVector                                     vCachedCameraAttachPoint;                                 // 0x0090(0x000C)
	struct FVector                                     vFloorPortalProgressiveAdjust;                            // 0x009C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_ThirdPerson");
		return ptr;
	}


	struct FVector STATIC_GetCustomCameraOffsetModification(class ATgPawn* PawnTarget);
	void STATIC_HandleFloorPortalTween(class ATgPawn* PawnOwner, float DeltaTime, struct FVector* vCamOrigin);
	void STATIC_HandleLocalGrabState(class ATgPawn* PawnOwner, class AActor* Target, struct FTViewTarget* OutVT);
	void ZoomClamp();
	void ZoomOut();
	void ZoomIn();
	void AdjustFloorPortalCamOrigin(class ATgPawn* P, float DeltaTime, struct FVector* Offset);
	void BecomeViewTarget(class ATgPlayerController* PC);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamAttachPoint(class AActor* ViewTarget);
	struct FVector STATIC_GetCamLocationOffset(const struct FRotator& PawnRot, class AActor* ViewTarget);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_Action
// 0x01B0 (0x0258 - 0x00A8)
class UTgCameraModule_Action : public UTgCameraModule_ThirdPerson
{
public:
	struct FVector                                     m_vCameraAttachPointOffset;                               // 0x00A8(0x000C)
	struct FVector                                     m_vCameraAttachPointOffsetDefault;                        // 0x00B4(0x000C)
	class UTgCameraShake*                              m_CameraShake;                                            // 0x00C0(0x0008)
	struct FVector                                     m_vPreTickCameraLocation;                                 // 0x00C8(0x000C) (Transient)
	struct FVector                                     m_vPreTickAttachPoint;                                    // 0x00D4(0x000C) (Transient)
	unsigned long                                      m_bSteadyCam : 1;                                         // 0x00E0(0x0004) (Transient)
	unsigned long                                      m_bOverrideTargetRot : 1;                                 // 0x00E0(0x0004) (Transient)
	unsigned long                                      m_bClampAttachPoint : 1;                                  // 0x00E0(0x0004) (Transient)
	unsigned long                                      m_bInterpToRotation : 1;                                  // 0x00E0(0x0004) (Transient)
	unsigned long                                      m_bZooming : 1;                                           // 0x00E0(0x0004)
	unsigned long                                      m_bOverrideCameraAttachPoint : 1;                         // 0x00E0(0x0004)
	unsigned long                                      m_bOverrideRotation : 1;                                  // 0x00E0(0x0004)
	unsigned long                                      m_bKeepHighestZ : 1;                                      // 0x00E0(0x0004)
	unsigned long                                      m_bConstantZ : 1;                                         // 0x00E0(0x0004)
	unsigned long                                      m_bUsePawnVelocity : 1;                                   // 0x00E0(0x0004)
	unsigned long                                      m_bReverseCameraMovements : 1;                            // 0x00E0(0x0004)
	float                                              m_fSteadyCamDuration;                                     // 0x00E4(0x0004) (Transient)
	float                                              m_fSteadyCamStartTime;                                    // 0x00E8(0x0004) (Transient)
	struct FRotator                                    m_rSteadyCamOffset;                                       // 0x00EC(0x000C) (Transient)
	struct FRotator                                    m_rTargetOverrideRot;                                     // 0x00F8(0x000C) (Transient)
	struct FVector                                     m_vAttachPointPivot;                                      // 0x0104(0x000C) (Transient)
	float                                              m_fMoveBounds;                                            // 0x0110(0x0004) (Transient)
	float                                              m_fRotModifier;                                           // 0x0114(0x0004) (Transient)
	float                                              m_fTickMoveLimit;                                         // 0x0118(0x0004) (Transient)
	struct FVector                                     m_vPreviousAttachPoint;                                   // 0x011C(0x000C) (Transient)
	float                                              m_fInterpToRotationStartTime;                             // 0x0128(0x0004) (Transient)
	float                                              m_fInterpToRotationDuration;                              // 0x012C(0x0004) (Transient)
	struct FRotator                                    m_rInterpToRotationTargetRot;                             // 0x0130(0x000C) (Transient)
	struct FCameraZoomState                            m_CurrentZoomState;                                       // 0x013C(0x000C)
	TArray<struct FCameraZoomState>                    m_QueuedZoomStates;                                       // 0x0148(0x0010) (NeedCtorLink)
	float                                              m_fTranslationStartTime;                                  // 0x0158(0x0004)
	float                                              m_fLastTranslationTime;                                   // 0x015C(0x0004)
	struct FVector                                     m_TotalAbsoluteTranslationVector;                         // 0x0160(0x000C)
	struct FVector                                     m_TotalRelativeTranslationVector;                         // 0x016C(0x000C)
	struct FVector                                     m_StartingAbsoluteTranslationVector;                      // 0x0178(0x000C)
	struct FVector                                     m_StartingRelativeTranslationVector;                      // 0x0184(0x000C)
	struct FCameraTranslationState                     m_CurrentTranslationState;                                // 0x0190(0x0020)
	TArray<struct FCameraTranslationState>             m_QueuedTranslationStates;                                // 0x01B0(0x0010) (NeedCtorLink)
	struct FCameraShakeState                           m_CurrentShakeState;                                      // 0x01C0(0x003C)
	TArray<struct FCameraShakeState>                   m_QueuedShakeStates;                                      // 0x01FC(0x0010) (NeedCtorLink)
	struct FVector                                     m_vCameraAttachPointOverride;                             // 0x020C(0x000C)
	struct FRotator                                    m_rRotationOverride;                                      // 0x0218(0x000C)
	float                                              m_fViewTargetInterpDuration;                              // 0x0224(0x0004)
	float                                              m_fViewTargetStartingTime;                                // 0x0228(0x0004)
	class AActor*                                      m_PreviousViewTarget;                                     // 0x022C(0x0008)
	float                                              m_fCurrentHighestZ;                                       // 0x0234(0x0004)
	float                                              m_fCachedZ;                                               // 0x0238(0x0004)
	float                                              m_fCamSpeed;                                              // 0x023C(0x0004)
	float                                              m_fCamSpeedLimit;                                         // 0x0240(0x0004)
	float                                              m_fCamAccel;                                              // 0x0244(0x0004)
	float                                              m_fPawnVelocityMod;                                       // 0x0248(0x0004)
	float                                              fZoomMinDefault;                                          // 0x024C(0x0004)
	float                                              fZoomMaxDefault;                                          // 0x0250(0x0004)
	float                                              fZoomFactorDefault;                                       // 0x0254(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Action");
		return ptr;
	}


	void Init();
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void LockCameraInput(bool bLock);
	void EndReverseCameraState();
	void StartReverseCameraState(float fDuration);
	void EndPawnVelocityState();
	void StartPawnVelocityState(float fPawnVelocityMod, float fDuration);
	void ResetCamSpeed();
	void SetCamSpeed(float fCamSpeed, float fCamAccel, float fCamMaxSpeed);
	void SetConstantZ(bool bConstantZ);
	void SetKeepHighestZ(bool bKeepHighestZ);
	void ResetCameraDefaults();
	void QueueResetCamera(float fResetTime);
	void ResetCamera(float fResetTime);
	void EndViewTargetWithInterp();
	void SetViewTargetWithInterp(float fDuration, class AActor* NewViewTarget);
	class AActor* GetViewTarget();
	void SetViewTarget(class AActor* NewViewTarget);
	void EndRotationOverride();
	void StartRotationOverride(const struct FRotator& rRotationOverride, float fDuration);
	void EndCameraAttachPointOverride();
	void StartCameraAttachPointOverride(float fDuration, const struct FVector& vCameraAttachPointOverride, bool bLockCameraInput);
	void EndInterpToRotationState();
	void StartInterpToRotationState(float fDuration, const struct FRotator& rTargetRot);
	void EndSteadyCamState();
	void StartSteadyCamState(float fDuration, const struct FRotator& rOffset, bool bClampAttachPoint, const struct FVector& vAttachPointPivot, float fMoveBounds, float fRotModifier, float fTickMoveLimit, bool bOverrideTargetRot, const struct FRotator& rTargetOverrideRot);
	struct FVector GetCameraAttachPointOffset();
	void ResetCameraAttachPointOffset();
	void SetCameraAttachPointOffset(const struct FVector& vOffset, bool bSetAsDefault);
	void STATIC_EndCameraShake();
	void STATIC_StartCameraShake();
	void STATIC_EndShakeState();
	void SetShakeState(float fTimeTillStart, const struct FVector& Epicenter, float fDuration, float fShakeScale, const struct FROscillator& RotOscillation);
	void QueueShakeState(float fTimeTillStart, const struct FVector& Epicenter, float fDuration, float fShakeScale, const struct FROscillator& RotOscillation);
	void STATIC_EndTranslationState();
	void SetTranslationState(const struct FVector& AbsoluteTranslationVector, const struct FVector& RelativeTranslationVector, float fDuration, bool bLockAbsoluteTranslationAfter);
	void QueueTranslationState(const struct FVector& AbsoluteTranslationVector, const struct FVector& RelativeTranslationVector, float fDuration, bool bLockAbsoluteTranslationAfter);
	void SetZoomValues(float fNewZoomMin, float fNewZoomMax, float fNewZoomFactor, bool bSetAsDefaults);
	void ZoomDT(float DeltaTime);
	void ZoomOut();
	void ZoomIn();
	void STATIC_EndZoomState();
	void SetZoomState(float fZoomTarget, float fDuration, bool bLockZoomAfter);
	void QueueZoomState(float fZoomTarget, float fDuration, bool bLockZoomAfter);
	struct FVector STATIC_GetCamAttachPoint(class AActor* ViewTarget);
	struct FVector STATIC_GetCamAttachPointDT(class AActor* ViewTarget, float DeltaTime);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_SpectatorAction
// 0x0000 (0x0258 - 0x0258)
class UTgCameraModule_SpectatorAction : public UTgCameraModule_Action
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorAction");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_SpectatorThirdPerson
// 0x002C (0x00D4 - 0x00A8)
class UTgCameraModule_SpectatorThirdPerson : public UTgCameraModule_ThirdPerson
{
public:
	struct FTPOV                                       OldViewpoint;                                             // 0x00A8(0x0024) (Transient)
	float                                              RemainingBlendTime;                                       // 0x00CC(0x0004) (Transient)
	float                                              TotalBlendTime;                                           // 0x00D0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorThirdPerson");
		return ptr;
	}


	struct FVector STATIC_GetCustomCameraOffsetModification(class ATgPawn* PawnTarget);
	void BlendToTarget(float BlendTime);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	bool STATIC_GetNearestGod(class ATgPawn* FromGod, float MaxDistance, class ATgPawn** NearestGod);
};


// Class TgGame.TgLobbyCamera
// 0x004C (0x044C - 0x0400)
class ATgLobbyCamera : public ACameraActor
{
public:
	class ATgSkeletalMeshActor_Lobby*                  m_ViewTarget;                                             // 0x0400(0x0008) (Edit)
	TArray<class ATgSkeletalMeshActor_Lobby*>          m_FriendlyTargets;                                        // 0x0408(0x0010) (Edit, NeedCtorLink)
	TArray<class ATgSkeletalMeshActor_Lobby*>          m_EnemyTargets;                                           // 0x0418(0x0010) (Edit, NeedCtorLink)
	class ATgStaticMeshActor_CardMIC*                  m_CardTarget;                                             // 0x0428(0x0008) (Edit)
	class ATgSkeletalMeshActor_Lobby*                  m_PreloadTarget;                                          // 0x0430(0x0008) (Edit)
	struct FVector                                     m_RenderCenterPointOffset;                                // 0x0438(0x000C) (Edit)
	unsigned long                                      m_bActive : 1;                                            // 0x0444(0x0004) (Transient)
	unsigned long                                      m_bInit : 1;                                              // 0x0444(0x0004) (Transient)
	int                                                m_nPosition;                                              // 0x0448(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLobbyCamera");
		return ptr;
	}


	void Tick(float DeltaTime);
	void SetPosition(int nPosition);
	void TriggerKismetActivationEvent(bool bActive, int nPosition);
	void STATIC_ClearEnemyTargets();
	void STATIC_ClearFriendlyTargets();
	void SetActive(bool bActive);
};


// Class TgGame.TgLobbyCamera_DynamicFocus
// 0x0038 (0x0484 - 0x044C)
class ATgLobbyCamera_DynamicFocus : public ATgLobbyCamera
{
public:
	TArray<struct FLobbyFocusData>                     m_LobbyFocusPoints;                                       // 0x044C(0x0010) (Edit, NeedCtorLink)
	float                                              m_fTransitionTime;                                        // 0x045C(0x0004) (Edit)
	int                                                m_nTargetIndex;                                           // 0x0460(0x0004)
	unsigned long                                      m_bAtTarget : 1;                                          // 0x0464(0x0004)
	struct FVector                                     m_vStartingLoc;                                           // 0x0468(0x000C)
	struct FRotator                                    m_rStartingRot;                                           // 0x0474(0x000C)
	float                                              m_fRemainingBlendTime;                                    // 0x0480(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLobbyCamera_DynamicFocus");
		return ptr;
	}


	void Tick(float DeltaTime);
	void STATIC_OnLobbyFocusChanged(class UTgSeqAct_LobbyFocusChanged* inAction);
	void SetActive(bool bActive);
};


// Class TgGame.TgLobbyCamera_ProgressTracker
// 0x0010 (0x045C - 0x044C)
class ATgLobbyCamera_ProgressTracker : public ATgLobbyCamera
{
public:
	TArray<class ASkeletalMeshActor*>                  m_ProgressActors;                                         // 0x044C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLobbyCamera_ProgressTracker");
		return ptr;
	}


	void SetActive(bool bActive);
};


// Class TgGame.TgLobbyCamera_ResetTargets
// 0x0000 (0x044C - 0x044C)
class ATgLobbyCamera_ResetTargets : public ATgLobbyCamera
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLobbyCamera_ResetTargets");
		return ptr;
	}


	void SetActive(bool bActive);
};


// Class TgGame.TgLobbyCaptureActor
// 0x0008 (0x0278 - 0x0270)
class ATgLobbyCaptureActor : public ASceneCapture2DActor
{
public:
	class ATgSkeletalMeshActor_Lobby*                  m_ViewTarget;                                             // 0x0270(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLobbyCaptureActor");
		return ptr;
	}

};


// Class TgGame.TgOverviewCameraActor
// 0x0004 (0x0404 - 0x0400)
class ATgOverviewCameraActor : public ACameraActor
{
public:
	unsigned long                                      m_bFlipped : 1;                                           // 0x0400(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgOverviewCameraActor");
		return ptr;
	}

};


// Class TgGame.TgPlayerCamera
// 0x0068 (0x064C - 0x05E4)
class ATgPlayerCamera : public ACamera
{
public:
	class ATgPlayerController*                         PlayerOwner;                                              // 0x05E4(0x0008)
	class UTgCameraModule*                             CurrentCameraMod;                                         // 0x05EC(0x0008) (Edit, EditInline)
	class UClass*                                      DefaultCameraModuleClass;                                 // 0x05F4(0x0008)
	TArray<class UTgCameraModule*>                     CameraModuleList;                                         // 0x05FC(0x0010) (NeedCtorLink)
	struct FRotator                                    CamAngle;                                                 // 0x060C(0x000C)
	float                                              m_fDefaultFOVPC;                                          // 0x0618(0x0004)
	float                                              m_fDefaultFOVConsole;                                     // 0x061C(0x0004)
	unsigned long                                      bTweening : 1;                                            // 0x0620(0x0004)
	unsigned long                                      m_bSupportFadingEnvironment : 1;                          // 0x0620(0x0004) (Const)
	unsigned long                                      m_bFadingFadingEnvironmentActive : 1;                     // 0x0620(0x0004) (Transient)
	float                                              fTweenStart;                                              // 0x0624(0x0004)
	float                                              fTweenDuration;                                           // 0x0628(0x0004)
	class UTgCameraModule*                             LastCameraMod;                                            // 0x062C(0x0008)
	float                                              m_fCollisionTraceExtent;                                  // 0x0634(0x0004)
	float                                              m_fFadingHeight;                                          // 0x0638(0x0004) (Const)
	class UCameraAnim*                                 m_CustomAnim;                                             // 0x063C(0x0008)
	class UCameraAnimInst*                             m_CustomAnimInstance;                                     // 0x0644(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerCamera");
		return ptr;
	}


	void STATIC_StopCustomAnim(bool bImmediate);
	void STATIC_PlayCustomAnim(class UCameraAnim* CustomAnim, float fRate, float fScale, float fBlendInTime, float fBlendOutTime, bool bLoop, bool bRandomStartTime, float fDuration, bool bSingleInstance);
	float STATIC_GetFadingEnvironmentHeight();
	void STATIC_ProcessFadingEnvironment(float DeltaTime);
	void STATIC_PostUpdateCamera(float DeltaTime);
	void FillCameraCache(struct FTPOV* NewPOV);
	void UpdateCamera(float DeltaTime);
	void ZoomClamp();
	void ZoomOut();
	void ZoomIn();
	void STATIC_ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
	void UpdateViewTarget(float DeltaTime, struct FTViewTarget* OutVT);
	class UTgCameraModule* CreateCamera(class UClass* CameraClass);
	class UTgCameraModule* SwitchCameras(class UClass* CameraClass, float fTweenTime);
	void STATIC_SetFOV(float NewFOV);
	void InitializeFor(class APlayerController* PC);
	void PostBeginPlay();
	void STATIC_SetDefaultFOV(float ForceFOV);
	void STATIC_CheckPenetration(const struct FVector& CheckLocation, float CheckRadius);
	void STATIC_CameraTrace(const struct FVector& End, const struct FVector& Start, class AActor* Target, bool bZeroExtent, bool bWorldOnly, struct FVector* HitLocation, struct FVector* HitNormal);
};


// Class TgGame.TgSpectatorCamera
// 0x0030 (0x067C - 0x064C)
class ATgSpectatorCamera : public ATgPlayerCamera
{
public:
	struct FViewTargetTransitionParams                 m_DefaultBlendParams;                                     // 0x064C(0x0010)
	struct FViewTargetTransitionParams                 m_SnapBlendParams;                                        // 0x065C(0x0010)
	class UCameraAnim*                                 m_CinematicAnim;                                          // 0x066C(0x0008)
	class UCameraAnimInst*                             m_AnimInstance;                                           // 0x0674(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorCamera");
		return ptr;
	}


	void STATIC_EndCinematicAnim();
	void STATIC_StartCinematicAnim();
	void DoUpdateCamera(float DeltaTime);
};


// Class TgGame.TgBlockingVolume
// 0x0000 (0x02A0 - 0x02A0)
class ATgBlockingVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBlockingVolume");
		return ptr;
	}

};


// Class TgGame.TgBlockingVolume_TargetableEntity
// 0x0000 (0x02A0 - 0x02A0)
class ATgBlockingVolume_TargetableEntity : public ATgBlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBlockingVolume_TargetableEntity");
		return ptr;
	}

};


// Class TgGame.TgBossBlockDynamicVolume
// 0x0000 (0x02A4 - 0x02A4)
class ATgBossBlockDynamicVolume : public ADynamicBlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBossBlockDynamicVolume");
		return ptr;
	}

};


// Class TgGame.TgBossBlockVolume
// 0x0000 (0x02A0 - 0x02A0)
class ATgBossBlockVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBossBlockVolume");
		return ptr;
	}

};


// Class TgGame.TgBotEncounterVolume
// 0x0014 (0x02B0 - 0x029C)
class ATgBotEncounterVolume : public AVolume
{
public:
	TArray<class ATgBotFactory*>                       m_Factories;                                              // 0x029C(0x0010) (Edit, Const, NeedCtorLink)
	int                                                m_nPlayers;                                               // 0x02AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotEncounterVolume");
		return ptr;
	}


	void CheckTouching();
	void PostBeginPlay();
};


// Class TgGame.TgCameraVolume
// 0x0008 (0x02A4 - 0x029C)
class ATgCameraVolume : public AVolume
{
public:
	class ACameraActor*                                AssociatedCamera;                                         // 0x029C(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraVolume");
		return ptr;
	}

};


// Class TgGame.TgDeviceVolume
// 0x006C (0x0308 - 0x029C)
class ATgDeviceVolume : public AVolume
{
public:
	unsigned long                                      bPainCausing : 1;                                         // 0x029C(0x0004) (Edit)
	unsigned long                                      BACKUP_bPainCausing : 1;                                  // 0x029C(0x0004)
	unsigned long                                      s_bDeviceActive : 1;                                      // 0x029C(0x0004)
	class AInfo*                                       PainTimer;                                                // 0x02A0(0x0008)
	int                                                nDefaultMapInfoIndex;                                     // 0x02A8(0x0004) (Edit)
	class AController*                                 DamageInstigator;                                         // 0x02AC(0x0008)
	class ATgActorFactory*                             DamageFactory;                                            // 0x02B4(0x0008) (Edit)
	int                                                m_nMapObjectId;                                           // 0x02BC(0x0004) (Edit, EditConst)
	int                                                s_nDeviceId;                                              // 0x02C0(0x0004) (Edit)
	class UTgDeviceFire*                               s_DeviceFireMode;                                         // 0x02C4(0x0008)
	int                                                s_nTeamNumber;                                            // 0x02CC(0x0004)
	unsigned char                                      s_nTaskForce;                                             // 0x02D0(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02D1(0x0003) MISSED OFFSET
	struct FVector                                     s_vImpactNormal;                                          // 0x02D4(0x000C) (Edit)
	struct FVector                                     s_vImpactRayDir;                                          // 0x02E0(0x000C) (Edit)
	int                                                s_nUniqueDevVolId;                                        // 0x02EC(0x0004) (Transient)
	TArray<struct FVolumeMapInfo>                      m_MapInfos;                                               // 0x02F0(0x0010) (Edit, NeedCtorLink)
	class ATgRepInfo_DeviceVolume*                     m_DVRI;                                                   // 0x0300(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume");
		return ptr;
	}


	void ApplyHit(class AActor* Target);
	void STATIC_OnSetDamageInstigator(class USeqAct_SetDamageInstigator* Action);
	void CausePainTo(class AActor* Other);
	bool STATIC_CanCausePainTo(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TimerPop(class ATgDeviceVolumeInfo* T);
	void UpdateVolumeRepInfo();
	void STATIC_OnChangeCollision(class USeqAct_ChangeCollision* Action);
	void OnMapInfoIndexChange(int nIndex);
	void STATIC_OnToggle(class USeqAct_Toggle* inAction);
	void Reset();
	void PostBeginPlay();
	void PreBeginPlay();
	bool IsFountainVolume();
	bool STATIC_SetupDevice();
};


// Class TgGame.TgDeviceVolume_BattleEncounterRound
// 0x0000 (0x0308 - 0x0308)
class ATgDeviceVolume_BattleEncounterRound : public ATgDeviceVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume_BattleEncounterRound");
		return ptr;
	}


	void ApplyHitSpecial(class AActor* Target);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnToggle(class USeqAct_Toggle* inAction);
};


// Class TgGame.TgDeviceVolume_Pulse
// 0x0025 (0x02C1 - 0x029C)
class ATgDeviceVolume_Pulse : public AVolume
{
public:
	class AController*                                 DamageInstigator;                                         // 0x029C(0x0008)
	class ATgActorFactory*                             DamageFactory;                                            // 0x02A4(0x0008) (Edit)
	int                                                m_nMapObjectId;                                           // 0x02AC(0x0004) (Edit, EditConst)
	int                                                s_nDeviceId;                                              // 0x02B0(0x0004) (Edit)
	class UTgDeviceFire*                               m_FireMode;                                               // 0x02B4(0x0008)
	int                                                s_nTeamNumber;                                            // 0x02BC(0x0004)
	unsigned char                                      s_nTaskForce;                                             // 0x02C0(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume_Pulse");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_FindTouchingActorsFromScript();
	void Fire();
	void TurnOff();
	void TurnOn();
	void STATIC_OnToggle(class USeqAct_Toggle* inAction);
	void STATIC_OnSetDamageInstigator(class USeqAct_SetDamageInstigator* Action);
	void PostBeginPlay();
	bool STATIC_SetupDevice();
};


// Class TgGame.TgDeviceVolume_TimedStack
// 0x0078 (0x0314 - 0x029C)
class ATgDeviceVolume_TimedStack : public AVolume
{
public:
	TArray<struct FDVTSTouchedPawn>                    s_ManagedTouchingList;                                    // 0x029C(0x0010) (NeedCtorLink)
	class AInfo*                                       PainTimer;                                                // 0x02AC(0x0008)
	class AController*                                 DamageInstigator;                                         // 0x02B4(0x0008)
	class ATgActorFactory*                             DamageFactory;                                            // 0x02BC(0x0008) (Edit)
	int                                                m_nMapObjectId;                                           // 0x02C4(0x0004) (Edit, EditConst)
	int                                                s_nDeviceId;                                              // 0x02C8(0x0004) (Edit)
	class UTgDeviceFire*                               s_DeviceFireMode;                                         // 0x02CC(0x0008)
	unsigned long                                      s_bDeviceActive : 1;                                      // 0x02D4(0x0004) (Edit)
	int                                                s_nTeamNumber;                                            // 0x02D8(0x0004)
	unsigned char                                      s_nTaskForce;                                             // 0x02DC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02DD(0x0003) MISSED OFFSET
	struct FVector                                     s_vImpactNormal;                                          // 0x02E0(0x000C) (Edit)
	struct FVector                                     s_vImpactRayDir;                                          // 0x02EC(0x000C) (Edit)
	float                                              s_fStackRate;                                             // 0x02F8(0x0004) (Edit)
	int                                                s_nMaxStacks;                                             // 0x02FC(0x0004) (Edit)
	float                                              s_fDecayRate;                                             // 0x0300(0x0004) (Edit)
	int                                                s_nInverseEffectCategory;                                 // 0x0304(0x0004) (Edit)
	float                                              s_fInverseStackRate;                                      // 0x0308(0x0004) (Edit)
	int                                                s_nMaxInverseStacks;                                      // 0x030C(0x0004) (Edit)
	float                                              s_fInverseDecayRate;                                      // 0x0310(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume_TimedStack");
		return ptr;
	}


	bool ManageTouching(int nIndex, float fDeltaTime);
	void Tick(float DeltaTime);
	void ApplyHit(class AActor* Target, int nPrevStack, int nCurrentStack);
	void STATIC_OnSetDamageInstigator(class USeqAct_SetDamageInstigator* Action);
	bool STATIC_CanStackOn(class AActor* Other);
	void UnTouchFrom(class AActor* Other);
	bool STATIC_HasInverseCategory(class ATgPawn* OtherPawn);
	void TouchTo(class AActor* Other);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnToggle(class USeqAct_Toggle* inAction);
	void PostBeginPlay();
	bool STATIC_SetupDevice();
};


// Class TgGame.TgDynamicBlockingVolume_TargetableEntity
// 0x0000 (0x02A4 - 0x02A4)
class ATgDynamicBlockingVolume_TargetableEntity : public ADynamicBlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDynamicBlockingVolume_TargetableEntity");
		return ptr;
	}

};


// Class TgGame.TgDynamicBlockingVolume_WorldGeometry
// 0x0000 (0x02A4 - 0x02A4)
class ATgDynamicBlockingVolume_WorldGeometry : public ADynamicBlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDynamicBlockingVolume_WorldGeometry");
		return ptr;
	}

};


// Class TgGame.TgEndOfWorldVolume
// 0x0000 (0x02A0 - 0x02A0)
class ATgEndOfWorldVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEndOfWorldVolume");
		return ptr;
	}

};


// Class TgGame.TgHeightFog
// 0x0008 (0x0268 - 0x0260)
class ATgHeightFog : public AInfo
{
public:
	class UHeightFogComponent*                         FogComponent;                                             // 0x0260(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHeightFog");
		return ptr;
	}

};


// Class TgGame.TgHelpAlertVolume
// 0x0014 (0x02B0 - 0x029C)
class ATgHelpAlertVolume : public AVolume
{
public:
	int                                                TaskForceNumber;                                          // 0x029C(0x0004) (Edit)
	TArray<int>                                        GameTipIdList;                                            // 0x02A0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHelpAlertVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_RemoveGameTips(class ATgPlayerController* aPC);
	void AddGameTips(class ATgPlayerController* aPC);
};


// Class TgGame.TgItemShopVolume
// 0x0000 (0x029C - 0x029C)
class ATgItemShopVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgItemShopVolume");
		return ptr;
	}


	void SetPurchaseFlag(class AActor* Other, bool bCanPurchase);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgMissionListVolume
// 0x0014 (0x02B0 - 0x029C)
class ATgMissionListVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                           // 0x029C(0x0004) (Edit, EditConst)
	int                                                s_nQueueTableId;                                          // 0x02A0(0x0004) (Edit)
	int                                                s_nQueueTableMsgId;                                       // 0x02A4(0x0004) (Edit)
	class ATeleporter*                                 m_Teleporter;                                             // 0x02A8(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMissionListVolume");
		return ptr;
	}

};


// Class TgGame.TgModifyPawnPropertiesVolume
// 0x0020 (0x02BC - 0x029C)
class ATgModifyPawnPropertiesVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                           // 0x029C(0x0004) (Edit, EditConst)
	unsigned long                                      m_bDisableJump : 1;                                       // 0x02A0(0x0004) (Edit)
	unsigned long                                      m_bDisableBlockActors : 1;                                // 0x02A0(0x0004) (Edit)
	unsigned long                                      m_bDisableHanging : 1;                                    // 0x02A0(0x0004) (Edit)
	unsigned long                                      m_bDisableAllDevices : 1;                                 // 0x02A0(0x0004) (Edit)
	unsigned long                                      m_bTriggerUseEvent : 1;                                   // 0x02A0(0x0004) (Edit)
	unsigned long                                      m_bOneWayMovement : 1;                                    // 0x02A0(0x0004) (Edit)
	struct FRotator                                    m_vOnewWay;                                               // 0x02A4(0x000C)
	class UArrowComponent*                             m_DirArrow;                                               // 0x02B0(0x0008) (ExportObject, Component, EditInline)
	int                                                s_nLootTableId;                                           // 0x02B8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgModifyPawnPropertiesVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
	void Used(class AActor* Other);
	void LoadObjectConfig();
};


// Class TgGame.TgObjectiveVolume
// 0x0004 (0x02A0 - 0x029C)
class ATgObjectiveVolume : public AVolume
{
public:
	int                                                m_nCurrentObjectiveCount;                                 // 0x029C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjectiveVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ObjectiveRefresh(class ATgPawn* PlayerPawn, bool bExcludeSelf);
	void STATIC_ObjectiveDied(class ATgPawn* ObjectivePawn);
	void STATIC_OnObjectiveSpawned(class ATgPawn* ObjectivePawn);
	void STATIC_ClearCurrentObjective();
	void STATIC_SetCurrentObjective(class AActor* Other);
	bool IsObjective(class AActor* Other);
};


// Class TgGame.TgObjectiveVolume_BotList
// 0x0014 (0x02B4 - 0x02A0)
class ATgObjectiveVolume_BotList : public ATgObjectiveVolume
{
public:
	TArray<int>                                        m_nValidObjectives;                                       // 0x02A0(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      r_bDisabled : 1;                                          // 0x02B0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgObjectiveVolume_BotList");
		return ptr;
	}


	bool IsObjective(class AActor* Other);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgPlayerBlockingVolume
// 0x0000 (0x02A0 - 0x02A0)
class ATgPlayerBlockingVolume : public ABlockingVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerBlockingVolume");
		return ptr;
	}

};


// Class TgGame.TgPlayerBlockingVolume_TaskforceFriendly
// 0x0010 (0x02B0 - 0x02A0)
class ATgPlayerBlockingVolume_TaskforceFriendly : public ATgPlayerBlockingVolume
{
public:
	TArray<int>                                        m_FriendlyTaskforces;                                     // 0x02A0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerBlockingVolume_TaskforceFriendly");
		return ptr;
	}

};


// Class TgGame.TgPlayerCountVolume
// 0x0020 (0x02BC - 0x029C)
class ATgPlayerCountVolume : public AVolume
{
public:
	int                                                PlayerCountTarget;                                        // 0x029C(0x0004) (Edit)
	int                                                TaskForceNumber;                                          // 0x02A0(0x0004) (Edit)
	int                                                MessageId;                                                // 0x02A4(0x0004) (Edit)
	TArray<class APawn*>                               Players;                                                  // 0x02A8(0x0010) (NeedCtorLink)
	unsigned long                                      Enabled : 1;                                              // 0x02B8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerCountVolume");
		return ptr;
	}


	int GetCount();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Update(class ATgPawn* Other);
};


// Class TgGame.TgPostProcessVolume
// 0x0024 (0x0450 - 0x042C)
class ATgPostProcessVolume : public APostProcessVolume
{
public:
	class UMaterialInterface*                          m_Material;                                               // 0x042C(0x0008) (Edit)
	TEnumAsByte<ESceneDepthPriorityGroup>              m_SceneDPG;                                               // 0x0434(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0435(0x0003) MISSED OFFSET
	class UMaterialInstanceConstant*                   m_MaterialMIC;                                            // 0x0438(0x0008)
	float                                              m_FadeInTime;                                             // 0x0440(0x0004) (Edit)
	float                                              m_FadeOutTime;                                            // 0x0444(0x0004) (Edit)
	struct FName                                       m_FadeScalarParameterName;                                // 0x0448(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPostProcessVolume");
		return ptr;
	}


	void PostBeginPlay();
};


// Class TgGame.TgSafeRadius
// 0x003C (0x029C - 0x0260)
class ATgSafeRadius : public AActor
{
public:
	unsigned long                                      s_bIsActive : 1;                                          // 0x0260(0x0004)
	float                                              s_fRadius;                                                // 0x0264(0x0004) (Edit)
	TArray<int>                                        m_TaskForces;                                             // 0x0268(0x0010) (Edit, NeedCtorLink)
	TArray<class ATgPawn*>                             s_AppliedList;                                            // 0x0278(0x0010) (NeedCtorLink)
	TArray<class UTgEffectGroup*>                      s_EffectGroups;                                           // 0x0288(0x0010) (NeedCtorLink)
	int                                                m_nItemId;                                                // 0x0298(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSafeRadius");
		return ptr;
	}


	void STATIC_RemoveFromAllApplied();
	void STATIC_RemoveFrom(class ATgPawn* HitPawn);
	void ApplyTo(class ATgPawn* HitPawn);
	void Tick(float DeltaTime);
	void PostBeginPlay();
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void LoadEffectGroups();
};


// Class TgGame.TgTeleportPlayerVolume
// 0x000C (0x02A8 - 0x029C)
class ATgTeleportPlayerVolume : public AVolume
{
public:
	TEnumAsByte<ETgTeleportVolumeType>                 TeleportLocation;                                         // 0x029C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x029D(0x0003) MISSED OFFSET
	int                                                nMessageId;                                               // 0x02A0(0x0004) (Edit)
	unsigned long                                      bTeleportBots : 1;                                        // 0x02A4(0x0004) (Edit)
	unsigned long                                      bTeleportPlayers : 1;                                     // 0x02A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTeleportPlayerVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgVisibilityVolume
// 0x0004 (0x02A0 - 0x029C)
class ATgVisibilityVolume : public AVolume
{
public:
	float                                              m_fVisibilityRange;                                       // 0x029C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVisibilityVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgVisionRestrictionVolume
// 0x0010 (0x02AC - 0x029C)
class ATgVisionRestrictionVolume : public AVolume
{
public:
	unsigned long                                      m_bBlockViewingIn : 1;                                    // 0x029C(0x0004) (Edit)
	unsigned long                                      m_bBlockViewingOut : 1;                                   // 0x029C(0x0004) (Edit)
	float                                              m_fReapplyTime;                                           // 0x02A0(0x0004) (Edit)
	class ATgVolumeInfo_VisRes*                        s_RetouchTimer;                                           // 0x02A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVisionRestrictionVolume");
		return ptr;
	}


	void TimerPop(class ATgVolumeInfo_VisRes* V);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
};


// Class TgGame.TgVolume
// 0x0000 (0x029C - 0x029C)
class ATgVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolume");
		return ptr;
	}

};


// Class TgGame.TgVolume_GroundPlacementBlocker
// 0x000C (0x02A8 - 0x029C)
class ATgVolume_GroundPlacementBlocker : public ATgVolume
{
public:
	unsigned long                                      r_bIsBlockingGroundPlacement : 1;                         // 0x029C(0x0004) (Edit)
	class ATgRepInfo_GPBVolume*                        m_VRI;                                                    // 0x02A0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolume_GroundPlacementBlocker");
		return ptr;
	}


	bool IsBlockingGroundPlacement();
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void PostBeginPlay();
};


// Class TgGame.TgVolume_Vortex
// 0x003C (0x02D8 - 0x029C)
class ATgVolume_Vortex : public ATgVolume
{
public:
	struct FVector                                     m_vDirection;                                             // 0x029C(0x000C) (Edit)
	unsigned long                                      m_bRadiallyIn : 1;                                        // 0x02A8(0x0004) (Edit)
	unsigned long                                      m_bStayOn : 1;                                            // 0x02A8(0x0004) (Edit)
	unsigned long                                      m_bOverrideFirstTouch : 1;                                // 0x02A8(0x0004)
	float                                              m_fIntensity;                                             // 0x02AC(0x0004) (Edit)
	float                                              m_fWarmupTime;                                            // 0x02B0(0x0004) (Edit)
	float                                              m_fPersistDuration;                                       // 0x02B4(0x0004) (Edit)
	float                                              m_fRampdownTime;                                          // 0x02B8(0x0004) (Edit)
	float                                              m_fMovementPercMaintained;                                // 0x02BC(0x0004) (Edit)
	class ATgRepInfo_VortexVolume*                     m_VVRI;                                                   // 0x02C0(0x0008)
	TArray<class ATgPawn*>                             m_TouchedPawns;                                           // 0x02C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolume_Vortex");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void Tick(float DeltaSeconds);
	void STATIC_OnUpdateVortexVolume(class UTgSeqAct_UpdateVortexVolume* UpdateAction);
	void UpdateState();
	void PostBeginPlay();
	void ApplyEffectsToPawn(class ATgPawn* TgP, float fDeltaTime);
};


// Class TgGame.TgVolume_TimedKill
// 0x0048 (0x02E4 - 0x029C)
class ATgVolume_TimedKill : public AVolume
{
public:
	float                                              m_fKillAfterTime;                                         // 0x029C(0x0004) (Edit)
	float                                              m_fKillStunTime;                                          // 0x02A0(0x0004) (Edit)
	float                                              m_nDeathMeshId;                                           // 0x02A4(0x0004) (Edit)
	int                                                m_nWarningDeviceId;                                       // 0x02A8(0x0004) (Edit)
	TEnumAsByte<ETG_DEATH_REASON>                      m_eDeathReason;                                           // 0x02AC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02AD(0x0003) MISSED OFFSET
	unsigned long                                      m_bUsesDeathCamZoom : 1;                                  // 0x02B0(0x0004) (Edit)
	unsigned long                                      s_bDeviceActive : 1;                                      // 0x02B0(0x0004)
	unsigned long                                      bPainCausing : 1;                                         // 0x02B0(0x0004)
	float                                              m_fDeathCamZoom;                                          // 0x02B4(0x0004) (Edit)
	float                                              m_fDeathCamZoomTween;                                     // 0x02B8(0x0004) (Edit)
	class ATgActorFactory*                             DamageFactory;                                            // 0x02BC(0x0008) (Edit)
	TArray<struct FTimedKillTrackedPawn>               s_TrackedPawns;                                           // 0x02C4(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               s_DeviceFireMode;                                         // 0x02D4(0x0008)
	class ATgRepInfo_VolumeTimedKill*                  TKRI;                                                     // 0x02DC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolume_TimedKill");
		return ptr;
	}


	void Tick(float DeltaTime);
	void STATIC_CleanTrackedList();
	void UntrackPawn(class ATgPawn* TouchedPawn);
	void TrackNewPawn(class ATgPawn* TouchedPawn);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnToggle(class USeqAct_Toggle* inAction);
	void PostBeginPlay();
	bool STATIC_SetupDevice();
};


// Class TgGame.TgArenaManager
// 0x006C (0x02CC - 0x0260)
class ATgArenaManager : public AActor
{
public:
	int                                                m_nArenaId;                                               // 0x0260(0x0004) (Edit)
	TArray<struct FArenaTeamSpawns>                    s_ArenaSpawnPoints;                                       // 0x0264(0x0010) (Edit, NeedCtorLink)
	TArray<struct FArenaFactories>                     s_ArenaFactories;                                         // 0x0274(0x0010) (Edit, NeedCtorLink)
	TArray<struct FArenaEffects>                       s_ArenaEffects;                                           // 0x0284(0x0010) (Edit, NeedCtorLink)
	TArray<struct FSpectatorTargets>                   s_SpectatorPoints;                                        // 0x0294(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<EArenaRoundState>                      s_eCurrentRoundState;                                     // 0x02A4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02A5(0x0003) MISSED OFFSET
	TArray<struct FArenaTFMap>                         s_ActiveTaskForces;                                       // 0x02A8(0x0010) (NeedCtorLink)
	TArray<struct FArenaTFMap>                         s_ActiveFactoryTFs;                                       // 0x02B8(0x0010) (NeedCtorLink)
	int                                                s_nCurrentEncounter;                                      // 0x02C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgArenaManager");
		return ptr;
	}


	void PostBeginPlay();
	void UnpauseBots();
	void STATIC_ResetFactoryVariables();
	int STATIC_GetTFFromTeam(int nTeamNum);
	bool STATIC_CurrentlyOwns(class AController* C);
	float STATIC_GetRespawnTime(class AController* C);
	void BotDied(class ATgAIController* tgAIC);
	void STATIC_PlayerDied(class ATgPlayerController* TgPC);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	void STATIC_CheckRoundState();
	TEnumAsByte<EArenaRoundState> STATIC_GetArenaRoundState();
	void STATIC_ClearRound();
	void STATIC_CalculateScore(bool bEndRound);
	void STATIC_EndRound();
	void STATIC_StartRound();
	void STATIC_StartSetup();
	void STATIC_PrepRound(TArray<struct FArenaTFMap> tfMap, int nEncounter);
};


// Class TgGame.TgBehaviorTracker
// 0x0078 (0x02D8 - 0x0260)
class ATgBehaviorTracker : public AActor
{
public:
	int                                                s_nBehaviorLimits[0x8];                                   // 0x0260(0x0004)
	int                                                s_nConsoleBehaviorLimits[0x8];                            // 0x0280(0x0004)
	int                                                s_nActionThresholds[0x2];                                 // 0x02A0(0x0004)
	struct FBehaviorCategoryMap                        s_BehaviorMap[0x3];                                       // 0x02A8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBehaviorTracker");
		return ptr;
	}


	void LogVals();
	int STATIC_GetBehaviorLimit(TEnumAsByte<ETrackedBehaviorType> eTBT, bool bConsole);
};


// Class TgGame.TgCapturePoint
// 0x0060 (0x02C0 - 0x0260)
class ATgCapturePoint : public AActor
{
public:
	class ATgRepInfo_CapturePoint*                     r_RepInfo;                                                // 0x0260(0x0008) (Net)
	TArray<class ATgPawn_Character*>                   m_NearByPlayers;                                          // 0x0268(0x0010) (NeedCtorLink)
	class UPrimitiveComponent*                         m_Collision;                                              // 0x0278(0x0008) (Edit, ExportObject, Component, EditInline)
	float                                              m_fBaseTransitionSpeed;                                   // 0x0280(0x0004) (Edit, Const)
	float                                              m_fBaseTransitionAmount;                                  // 0x0284(0x0004) (Edit, Const)
	float                                              m_fTransitionSpeedBuff;                                   // 0x0288(0x0004) (Edit, Const)
	unsigned long                                      m_bAllowSpeedBuff : 1;                                    // 0x028C(0x0004) (Edit, Const)
	float                                              m_fCurrentTransitionSpeed;                                // 0x0290(0x0004) (Transient)
	class UTgSeqEvent_ControlPointOwnershipChange*     c_OwnershipChangedKismetNode;                             // 0x0294(0x0008) (Transient)
	int                                                m_CapturePointIndex;                                      // 0x029C(0x0004) (Edit, Const)
	class ATgGame_Mission*                             s_GameInfo;                                               // 0x02A0(0x0008) (Transient)
	int                                                m_nTF1Count;                                              // 0x02A8(0x0004) (Transient)
	int                                                m_nTF2Count;                                              // 0x02AC(0x0004) (Transient)
	class USpriteComponent*                            m_WorldIconSprite;                                        // 0x02B0(0x0008) (Edit, ExportObject, Component, EditInline)
	int                                                m_nCapturedMessageId;                                     // 0x02B8(0x0004) (Edit, Const)
	int                                                m_nLostMessageId;                                         // 0x02BC(0x0004) (Edit, Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCapturePoint");
		return ptr;
	}


	void STATIC_OnGetTaskForceNumber(class UTgSeqAct_GetTaskForceNumber* Action);
	void UpdateLockEffects();
	void STATIC_OnLockCapturePoint(class UTgSeqAct_LockCapturePoint* inAction);
	void STATIC_OnSetCapturePointOwner(class UTgSeqAct_SetCapturePointOwner* inAction);
	void STATIC_OnSetCapturePointPct(class UTgSeqAct_SetCapturePointPct* inAction);
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void STATIC_OnTaskForceControlChanged(int NewTaskForce);
	int GetCapturePointIndex();
	void OnPointReclaimed();
	void OnPointCaptureOwnershipChanged(int NewTaskForceOwner, int PreviousTaskForceOwner);
	void NearbyPawnsUpdated();
	float STATIC_ComputeTransitionSpeed(int TF1Count, int TF2Count);
	void STATIC_RemoveNearbyPlayer(class ATgPawn_Character* aPawn);
	void AddNearbyPlayer(class ATgPawn_Character* aPawn);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PreBeginPlay();
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void AlertPointChanged();
};


// Class TgGame.TgCapturePoint_2019
// 0x0030 (0x02F0 - 0x02C0)
class ATgCapturePoint_2019 : public ATgCapturePoint
{
public:
	float                                              m_fBaseDecaySpeed;                                        // 0x02C0(0x0004) (Edit, Const)
	float                                              m_fBaseDecayAmount;                                       // 0x02C4(0x0004) (Edit, Const)
	unsigned long                                      m_bAllowOwnerDecay : 1;                                   // 0x02C8(0x0004) (Edit, Const)
	unsigned long                                      m_bAllowMultiteamChallenge : 1;                           // 0x02C8(0x0004) (Edit, Const)
	unsigned long                                      m_bCurrentlyDecaying : 1;                                 // 0x02C8(0x0004) (Transient)
	unsigned long                                      m_bTestingEnvironment : 1;                                // 0x02C8(0x0004) (Edit)
	TArray<struct FCapturePointTouchingData>           m_CurrentTeamTouchData;                                   // 0x02CC(0x0010) (Transient, NeedCtorLink)
	int                                                m_nOwningTeam;                                            // 0x02DC(0x0004) (Transient)
	int                                                m_nCapturingTeam;                                         // 0x02E0(0x0004) (Transient)
	int                                                m_nNeutralTeam;                                           // 0x02E4(0x0004) (Transient)
	float                                              m_fCurrentTransitionAmount;                               // 0x02E8(0x0004) (Transient)
	int                                                m_nTestingTeamCount;                                      // 0x02EC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCapturePoint_2019");
		return ptr;
	}


	void NearbyPawnsUpdated();
	float STATIC_ComputeTransitionSpeed(int TF1Count, int TF2Count);
	void GenerateTeamTouchData();
};


// Class TgGame.TgCapturePoint_OwnedEffect
// 0x0000 (0x02C0 - 0x02C0)
class ATgCapturePoint_OwnedEffect : public ATgCapturePoint
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCapturePoint_OwnedEffect");
		return ptr;
	}

};


// Class TgGame.TgCapturePoint_WithBot
// 0x003C (0x02FC - 0x02C0)
class ATgCapturePoint_WithBot : public ATgCapturePoint
{
public:
	float                                              m_fTransitionSpeedGuardModifier;                          // 0x02C0(0x0004) (Edit, Const)
	class ATgBotFactory_PointCapture*                  s_BotSpawners[0x2];                                       // 0x02C4(0x0008) (Edit)
	class ATgBotFactory_PointCapture*                  s_NeutralBotSpawner;                                      // 0x02D4(0x0008) (Edit)
	class ATgBotFactory_PointCapture*                  m_CurrentBotSpawners[0x2];                                // 0x02DC(0x0008) (Transient)
	float                                              s_fReplenishBotTime;                                      // 0x02EC(0x0004) (Edit, Const)
	float                                              s_fFriendlyReplenishBuffPct;                              // 0x02F0(0x0004) (Edit)
	float                                              s_fRemainingReplenishBotTime;                             // 0x02F4(0x0004) (Transient)
	float                                              m_fLastEnemyKillVoxTimestamp;                             // 0x02F8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCapturePoint_WithBot");
		return ptr;
	}


	void STATIC_OnNearbyEnemyPlayerDied(class ATgPawn* DeadPawn);
	void STATIC_DestroyBotsFromOldTaskForce();
	void SpawnBotsForCurrentTaskForce();
	void OnBotDied(int DeadBotTaskForce);
	void OnPointCaptureOwnershipChanged(int NewTaskForceOwner, int PreviousTaskForceOwner);
	void NearbyPawnsUpdated();
	float STATIC_ComputeTransitionSpeed(int PlayerCount, int opposingGuards);
	void PostBeginPlay();
	void STATIC_SpawnNeutralBot();
};


// Class TgGame.TgCustomBlockingTypeInterface
// 0x0000 (0x0060 - 0x0060)
class UTgCustomBlockingTypeInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCustomBlockingTypeInterface");
		return ptr;
	}


	TEnumAsByte<ETG_CUSTOM_BLOCKING_TYPE> STATIC_GetCustomBlockingType();
};


// Class TgGame.TgGame
// 0x00E8 (0x05A4 - 0x04BC)
class ATgGame : public AFrameworkGame
{
public:
	class UClass*                                      m_ContentPackageReference;                                // 0x04BC(0x0008)
	TEnumAsByte<EGAME_WIN_STATE>                       m_GameWinState;                                           // 0x04C4(0x0001)
	TEnumAsByte<ETG_GAME_TYPE>                         m_GameType;                                               // 0x04C5(0x0001)
	TEnumAsByte<ETG_GAME_SEASONAL>                     m_GameSeason;                                             // 0x04C6(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x04C7(0x0001) MISSED OFFSET
	float                                              m_fSpawnProtectionTime;                                   // 0x04C8(0x0004)
	float                                              m_fMaxRepawnTime;                                         // 0x04CC(0x0004)
	float                                              m_fUnpauseCountdownRemaining;                             // 0x04D0(0x0004)
	float                                              m_fPauseSpamProtection;                                   // 0x04D4(0x0004)
	float                                              m_fMaxCooldownOverride;                                   // 0x04D8(0x0004)
	float                                              m_fMinCooldownOverride;                                   // 0x04DC(0x0004)
	float                                              m_fStartingCooldownOverride;                              // 0x04E0(0x0004)
	unsigned long                                      m_bIsMaxCooldownOverriden : 1;                            // 0x04E4(0x0004)
	unsigned long                                      m_bIsMinCooldownOverriden : 1;                            // 0x04E4(0x0004)
	unsigned long                                      m_bIsStartingCooldownOverriden : 1;                       // 0x04E4(0x0004)
	unsigned long                                      m_bInfiniteEnergy : 1;                                    // 0x04E4(0x0004)
	unsigned long                                      s_bGameInitialized : 1;                                   // 0x04E4(0x0004)
	unsigned long                                      s_bGameEndMissionProcessed : 1;                           // 0x04E4(0x0004)
	unsigned long                                      s_bMissionSealed : 1;                                     // 0x04E4(0x0004)
	unsigned long                                      m_bRewardCalculated : 1;                                  // 0x04E4(0x0004)
	unsigned long                                      m_bStatsCanTie : 1;                                       // 0x04E4(0x0004)
	unsigned long                                      m_bStatsIsSymmetric : 1;                                  // 0x04E4(0x0004)
	unsigned long                                      m_bUnpauseQueued : 1;                                     // 0x04E4(0x0004)
	unsigned long                                      m_bIsTutorialGametype : 1;                                // 0x04E4(0x0004)
	unsigned long                                      m_bIsPracticeGametype : 1;                                // 0x04E4(0x0004)
	unsigned long                                      m_bHasMatchBots : 1;                                      // 0x04E4(0x0004)
	unsigned long                                      s_bEACMatchStartSent : 1;                                 // 0x04E4(0x0004)
	int                                                s_nBotPlayerCount;                                        // 0x04E8(0x0004)
	float                                              m_fBotSpawnHealthModifier;                                // 0x04EC(0x0004)
	class ATgBehaviorTracker*                          s_BehaviorTracker;                                        // 0x04F0(0x0008)
	int                                                s_nNextActorInstanceId;                                   // 0x04F8(0x0004)
	int                                                s_nNextProjectileInstanceId;                              // 0x04FC(0x0004)
	class AActor*                                      s_GameEndFocus;                                           // 0x0500(0x0008)
	int                                                m_nDefaultBotId;                                          // 0x0508(0x0004) (Config)
	TArray<class ATgAIVolume*>                         s_AIVolumes;                                              // 0x050C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        s_Taskforce1AIVolumesIndices;                             // 0x051C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        s_Taskforce2AIVolumesIndices;                             // 0x052C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class ATgActorFactory*>                     s_ActorFactories;                                         // 0x053C(0x0010) (NeedCtorLink)
	TArray<int>                                        m_ClientLogins;                                           // 0x054C(0x0010) (AlwaysInit, NeedCtorLink)
	class APlayerReplicationInfo*                      m_AttemptedPauser;                                        // 0x055C(0x0008)
	class ATgGameConfig*                               s_GameConfig;                                             // 0x0564(0x0008)
	class UTgInventory_BuildCache*                     s_BuildCache;                                             // 0x056C(0x0008)
	TArray<struct FTgPlayerWardSkins>                  m_PlayerWardSkins;                                        // 0x0574(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FTgPlayerGlobalEmoteSkins>           m_PlayerGlobalEmoteSkins;                                 // 0x0584(0x0010) (AlwaysInit, NeedCtorLink)
	struct FScriptDelegate                             __CanUnpauseTgGame__Delegate;                             // 0x0594(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0594(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame");
		return ptr;
	}


	void InitBehaviorTracker();
	void UpdateConfiguration(class ATgGameConfig* GameConf);
	bool WantsGameConfigOverride(class ATgGameConfig* GameConf);
	class UClass* STATIC_SpecialInventoryClass();
	bool STATIC_HasSpecialInventory();
	bool IsPracticeGametype();
	bool IsTutorialGametype();
	void KickIdler(class APlayerController* PC);
	void ClearPauseAfterCountdown();
	void ClearPause();
	bool SetPause(class APlayerController* PC, const struct FScriptDelegate& CanUnpauseDelegate);
	bool CanUnpauseTgGame();
	bool STATIC_PreventDeath(class APawn* KilledPawn, class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation);
	bool CanSpectate(class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget);
	void PostCommitMapChange();
	void PostLogin(class APlayerController* NewPlayer);
	bool FindInactivePRI(class APlayerController* PC);
	void AddInactivePRI(class APlayerReplicationInfo* PRI, class APlayerController* PC);
	void STATIC_StartMatch();
	void NativeStartMatch();
	bool ChangeTeam(class AController* Other, int Num, bool bNewTeam);
	float STATIC_RatePlayerStart(class APlayerStart* P, unsigned char Team, class AController* Player);
	float RatePlayerStartPoint(class APlayerStart* P, class AController* Player);
	class ANavigationPoint* STATIC_FindPlayerGroupStart(class AController* Player, int groupNumber, unsigned char InTeam, const struct FString& IncomingName);
	class ANavigationPoint* FindPlayerStart(class AController* Player, unsigned char InTeam, const struct FString& IncomingName);
	class ANavigationPoint* GetReviveLocation(class AController* Player, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ANavigationPoint* FindPlayerStartPoint(class AController* Player, const struct FString& SpawnTagName);
	void STATIC_SetPlayerDefaults(class APawn* PlayerPawn);
	void AddDefaultInventory(class APawn* PlayerPawn);
	void STATIC_RestartPlayer(class AController* aPlayer);
	void AllPlayersEndGame(class AActor* EndGameFocus);
	class APawn* STATIC_SpawnDefaultPawnFor(class AController* NewPlayer, class ANavigationPoint* StartSpot);
	void STATIC_StartBots();
	void InitGame(const struct FString& Options, struct FString* ErrorMessage);
	void Reset();
	int GetNextProjectileInstanceId();
	int GetNextActorInstanceId();
	void STATIC_InitGameReplicationInfo();
	void PostBeginPlay();
	void PreBeginPlay();
	void STATIC_ReceiveClientGameEvent(class ATgPlayerController* TgPC, TEnumAsByte<EClientGameEvent> eCGE, int nVal1, int nVal2, float fVal1);
	bool WantsBehaviorTracking();
	float ModeSpecificCurrencyReward(class ATgPlayerController* TgPC);
	void STATIC_CalcCurrencyRewards(class ATgPlayerController* TgPC);
	bool IsCH04();
	bool IsRA2015();
	bool IsTraining();
	int STATIC_GetGameEndingScore();
	int STATIC_GetStartingScore();
	void STATIC_SendPauseNotification(class APlayerController* PC);
	void STATIC_EndUnpauseCountdown();
	void BeginUnpauseCountdown(float fSeconds);
	bool AllowPausing(class APlayerController* PC);
	void STATIC_ResetStats();
	void NotifyPostCommitMapChange();
	struct FString STATIC_GetGameVersion();
	bool IsCombatPause(class APlayerController* pPc);
	void STATIC_ControllerRespawned(class AController* C);
	float STATIC_GetRespawnTime(class AController* C);
	void BotDied(class ATgAIController* aic);
	void STATIC_PlayerDied(class ATgPlayerController* PC);
	bool STATIC_SpawnDefaultBotPlayers(bool bStartPaused, TArray<struct FTgAIBotPlayersToSpawn>* BotPlayersToSpawn);
	bool STATIC_SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	void STATIC_EnsureBotPrecache(int nBotId, int nSkinId);
	class ATgPawn* STATIC_SpawnTemplatePlayer(class ATgPlayerController* pTgPC, int nProfileId, int nSkinId);
	class ATgPawn* STATIC_SpawnBotPawn(class ATgAIController* pTgAI, const struct FVector& vLocation, const struct FRotator& rRotation, bool bIgnoreCollision, class ATgPawn* pOwnerPawn, float fDeploySecs);
	class ATgPawn* STATIC_SpawnBotById(int nBotId, int nSkinId, const struct FVector& vLocation, const struct FRotator& rRotation, class ATgBotFactory* pFactory, bool bIgnoreCollision, class ATgPawn* pOwnerPawn, class UTgDeviceFire* DeviceFire, float fDeployAnimLength, const struct FName& ControllerClassName, const struct FName& BehaviorTreeName);
	bool STATIC_FinishEndMission();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	int STATIC_GetTaskForcePlacement(int nTaskForceNum);
	int STATIC_GetWinningTaskforce();
	class ATgPawn* STATIC_SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	class ANavigationPoint* TgFindPlayerStart(class AController* pPlayer, const struct FString& fsIncomingName);
	void STATIC_InitGameRepInfo();
	void LoadGameOverrides();
	void LoadGameConfig();
};


// Class TgGame.TgCharacterPerformance
// 0x0088 (0x062C - 0x05A4)
class ATgCharacterPerformance : public ATgGame
{
public:
	class UPComPerformanceCaptureBase*                 BasePerformanceCapture;                                   // 0x05A4(0x0008) (Transient)
	TEnumAsByte<EPComPerformanceCaptureState>          CurrentCaptureState;                                      // 0x05AC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x05AD(0x0003) MISSED OFFSET
	struct FString                                     CharacterInput;                                           // 0x05B0(0x0010) (NeedCtorLink)
	struct FString                                     SkinInput;                                                // 0x05C0(0x0010) (NeedCtorLink)
	int                                                CurrentCharacterIndex;                                    // 0x05D0(0x0004)
	int                                                CurrentSkinIndex;                                         // 0x05D4(0x0004)
	int                                                CurrentSkinLevelUpIndex;                                  // 0x05D8(0x0004)
	int                                                MaxSkinLevelUp;                                           // 0x05DC(0x0004)
	unsigned long                                      bIsLevelSkinExist : 1;                                    // 0x05E0(0x0004)
	TArray<class ATgSkeletalMeshActor_Loader*>         CharacterPlacements;                                      // 0x05E4(0x0010) (Transient, NeedCtorLink)
	TArray<struct FString>                             CharactersToTest;                                         // 0x05F4(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        AllSkinIDs;                                               // 0x0604(0x0010) (NeedCtorLink)
	TArray<struct FPComPerformanceCaptureStatsPerSkin> StatsPerSkin;                                             // 0x0614(0x0010) (Transient, NeedCtorLink)
	class UTgManifestGroup*                            ManifestGroup;                                            // 0x0624(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCharacterPerformance");
		return ptr;
	}


	void STATIC_EnsureBotPrecache(int nBotId, int nSkinId);
	void DoNextAction();
	void STATIC_SpawnCharacters();
	void MoveCameraToNode();
	void STATIC_CollectCharacterPlacementsAndSkins();
	void PostBeginPlay();
};


// Class TgGame.TgGame_City
// 0x0000 (0x05A4 - 0x05A4)
class ATgGame_City : public ATgGame
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_City");
		return ptr;
	}


	class APawn* STATIC_SpawnDefaultPawnFor(class AController* NewPlayer, class ANavigationPoint* StartSpot);
};


// Class TgGame.TgGame_Mission
// 0x019C (0x0740 - 0x05A4)
class ATgGame_Mission : public ATgGame
{
public:
	unsigned long                                      m_bSpawnInTaskForceArea : 1;                              // 0x05A4(0x0004)
	unsigned long                                      s_bPreGuardianPhasePulsed : 1;                            // 0x05A4(0x0004)
	unsigned long                                      s_bGuardianPhasePulsed : 1;                               // 0x05A4(0x0004)
	unsigned long                                      m_bCurrencySpooling : 1;                                  // 0x05A4(0x0004)
	unsigned long                                      m_bXPSpooling : 1;                                        // 0x05A4(0x0004)
	unsigned long                                      m_bSplitKillerXP : 1;                                     // 0x05A4(0x0004)
	unsigned long                                      s_bWasSurrendered : 1;                                    // 0x05A4(0x0004)
	unsigned long                                      m_bSurrenderAvailable : 1;                                // 0x05A4(0x0004)
	unsigned long                                      s_bEarlySurrenderWash : 1;                                // 0x05A4(0x0004)
	unsigned long                                      m_bFirstBloodAwarded : 1;                                 // 0x05A4(0x0004)
	unsigned long                                      m_bAllowAutoUpgrades : 1;                                 // 0x05A4(0x0004)
	unsigned long                                      m_bFountainHealingIsOn : 1;                               // 0x05A4(0x0004)
	unsigned long                                      m_bFountainDamageIsOn : 1;                                // 0x05A4(0x0004)
	unsigned long                                      m_bDoNotSpawnMinionWave : 1;                              // 0x05A4(0x0004)
	unsigned long                                      m_bDoNotSpawnJungleCamps : 1;                             // 0x05A4(0x0004)
	unsigned long                                      m_bDoNotSpawnFireGiant : 1;                               // 0x05A4(0x0004)
	unsigned long                                      m_bDoNotSpawnGoldFury : 1;                                // 0x05A4(0x0004)
	TEnumAsByte<EGameTimerState>                       m_eTimerState;                                            // 0x05A8(0x0001)
	TEnumAsByte<EGameTimerState>                       m_eTimerStatePaused;                                      // 0x05A9(0x0001)
	TEnumAsByte<EPauseMode>                            m_ePauseMode;                                             // 0x05AA(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x05AB(0x0001) MISSED OFFSET
	float                                              m_fMissionTime;                                           // 0x05AC(0x0004)
	float                                              m_fPausedAtTime;                                          // 0x05B0(0x0004)
	float                                              m_fGameMissionTime;                                       // 0x05B4(0x0004)
	float                                              s_MissionTimeAccumulator;                                 // 0x05B8(0x0004)
	TArray<class UPlayer*>                             s_ReadyPlayers;                                           // 0x05BC(0x0010) (NeedCtorLink)
	float                                              s_fGameSetupTime;                                         // 0x05CC(0x0004)
	float                                              m_fMapLength;                                             // 0x05D0(0x0004)
	float                                              m_fTickCurrencyFreq;                                      // 0x05D4(0x0004)
	float                                              m_fCurrencyToGivePerTick;                                 // 0x05D8(0x0004)
	float                                              m_fXpToGivePerTick;                                       // 0x05DC(0x0004)
	int                                                m_nStartingCurrency;                                      // 0x05E0(0x0004)
	int                                                m_nStartingLevel;                                         // 0x05E4(0x0004)
	int                                                s_nNumLowestXPSpool;                                      // 0x05E8(0x0004)
	int                                                s_fCatchupXPSpool;                                        // 0x05EC(0x0004)
	int                                                s_fCatchupXPSpoolStartTime;                               // 0x05F0(0x0004)
	int                                                m_nWinPlayerXp;                                           // 0x05F4(0x0004)
	int                                                m_nLosePlayerXp;                                          // 0x05F8(0x0004)
	int                                                m_nGoldCapMin;                                            // 0x05FC(0x0004)
	int                                                m_nGoldCapMax;                                            // 0x0600(0x0004)
	int                                                m_nXPCapMax;                                              // 0x0604(0x0004)
	float                                              m_fGodXpCoefficient;                                      // 0x0608(0x0004)
	float                                              m_fGodXpCoefficientRanked;                                // 0x060C(0x0004)
	float                                              m_fGodXpWinBonusCoefficient;                              // 0x0610(0x0004)
	float                                              m_fBaseTokens;                                            // 0x0614(0x0004)
	class UClass*                                      m_MinimapManagerClass;                                    // 0x0618(0x0008)
	struct FSurrenderData                              s_SurrenderData[0x2];                                     // 0x0620(0x0024) (NeedCtorLink)
	struct FSurrenderTimings                           s_SurrenderTimes;                                         // 0x0668(0x0018)
	struct FPauseVoteData                              s_PauseData[0x2];                                         // 0x0680(0x0024) (NeedCtorLink)
	float                                              m_fPauseDuration;                                         // 0x06C8(0x0004)
	float                                              m_fPauseStart;                                            // 0x06CC(0x0004)
	float                                              m_fPauseMessageSendTime;                                  // 0x06D0(0x0004)
	float                                              m_fMinPauseMessageTime;                                   // 0x06D4(0x0004) (Const)
	int                                                m_XPRadius;                                               // 0x06D8(0x0004)
	float                                              m_MinionKillerBonus;                                      // 0x06DC(0x0004)
	float                                              m_BasePlayerGoldReward;                                   // 0x06E0(0x0004)
	float                                              m_fFirstBloodGoldReward;                                  // 0x06E4(0x0004)
	float                                              m_fBasePlayerAssistGoldRewardMultipler;                   // 0x06E8(0x0004)
	float                                              m_fBasePlayerAssistXpRewardMultipler;                     // 0x06EC(0x0004)
	float                                              m_fBaseNPCAssistGoldRewardMultipler;                      // 0x06F0(0x0004)
	float                                              m_fBaseNPCAssistXpRewardMultipler;                        // 0x06F4(0x0004)
	int                                                m_nGoldFuryTeamGoldPerMin;                                // 0x06F8(0x0004)
	int                                                m_nGoldFuryTeamGoldMax;                                   // 0x06FC(0x0004)
	int                                                m_nGoldFuryTeamXPPerMin;                                  // 0x0700(0x0004)
	int                                                m_nGoldFuryTeamXPMax;                                     // 0x0704(0x0004)
	int                                                m_nMaxInvItems;                                           // 0x0708(0x0004)
	int                                                m_nLockedDevices;                                         // 0x070C(0x0004)
	TArray<class ATgMinionGoal*>                       m_MinionGoals;                                            // 0x0710(0x0010) (Transient, NeedCtorLink)
	TArray<class ATgActor_DeathFog*>                   m_DeathFogs;                                              // 0x0720(0x0010) (Transient, NeedCtorLink)
	TArray<class ATgDeployableFactory_PlayerDeath*>    m_PlayerDeathFactories;                                   // 0x0730(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Mission");
		return ptr;
	}


	void ProcessVotePause(class ATgPlayerController* PC, bool bDidPause);
	void BaseClearPause();
	void ClearPause();
	bool BaseSetPause(class APlayerController* PC, const struct FScriptDelegate& CanUnpauseDelegate);
	bool SetPause(class APlayerController* PC, const struct FScriptDelegate& CanUnpauseDelegate);
	void SetXpSpooling(bool bSpooling);
	void SetCurrencySpooling(bool bSpooling);
	TEnumAsByte<EGameTimerState> GetMissionTimerStatus();
	float GetMissionTime();
	float STATIC_GetSetupTime();
	float STATIC_GetPlayerConnectTime();
	void SendMissionTimerNotify(TEnumAsByte<EMissionTimerState> eState, float fRemainingSecs);
	void MissionTimeIncrement(float fInc);
	void MissionTimerModify(bool bPause, int nNewTime);
	float MatchDuration();
	float ElapsedTime();
	bool MissionTimerActive();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void EnableMovementOnAllPlayers();
	void AllPlayersReady();
	void MissionTimer();
	void MissionTimerPause();
	void MissionTimerStop();
	void MissionTimerStart();
	void SetMissionTime(float fTime);
	void KeepClientsInSync();
	bool STATIC_StartGameTimer();
	void TgTimer(struct FString* sTimerCommand);
	void QuickEndGame(int nWinnerTF);
	bool CheckScore(class APlayerReplicationInfo* Scorer);
	void UpdateLockedPointStatus();
	void OnPointCaptureOwnershipChanged(class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner);
	void AddObjectiveScore(class APlayerReplicationInfo* Scorer, int Score);
	void STATIC_StartMatch();
	void PostLogin(class APlayerController* NewPlayer);
	void STATIC_CreateMinimapManagers(class UClass* managerClass);
	void SendMissionTimerEvent(int nEventId, int nWinningTaskForce);
	void PostBeginPlay();
	class ATgPawn* STATIC_FindMeshOwnerFor(int nTaskForce);
	void STATIC_SetMeshOwners();
	bool IsCombatPause(class APlayerController* pPc);
	void NativeUpdateTimerState();
	bool STATIC_SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	bool STATIC_GetScoreKillData(class AController* Killer, class AController* Other, struct FScoreKillData* Data);
	void STATIC_ScoreKillAchievements(struct FScoreKillData* Data);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	void STATIC_ScoreKillCommon(struct FScoreKillData* Data);
	void STATIC_ScoreKill(class AController* Killer, class AController* Other);
	float STATIC_GetMinIntroWait();
	void STATIC_CapturePointReclaimed(class ATgPawn_Character* PC);
	void STATIC_CapturedPoint(class ATgPawn_Character* PC);
	void UnpauseFromVote();
	void STATIC_PauseComplete(int nTaskForce);
	void STATIC_PauseCompleteTimer2();
	void STATIC_PauseCompletetimer1();
	void STATIC_RemovePauseVote(int nPlayerId, int nTaskForce);
	void STATIC_PlayerVotePause(int nPlayerId);
	bool AllowPausing(class APlayerController* PC);
	void STATIC_EndGameBySurrender(int SurrenderingTaskForce);
	void STATIC_SurrenderComplete(int nTaskForce);
	void STATIC_SurrenderCompleteTimer2();
	void STATIC_SurrenderCompleteTimer1();
	void STATIC_RemoveSurrenderVote(int nPlayerId, int nTaskForce);
	void STATIC_PlayerSurrender(int nPlayerId, bool bSurrender);
	bool STATIC_SurrenderAvailable(int nTaskForce);
	void STATIC_SetBaseSurrenderTime(float fSurrenderTime);
	bool Is1v1();
	void AllPlayersRecall();
	void AllPlayersFullVitals();
	void AllPlayersRevive();
	void AllPlayersRoundReset();
	void MarkAsReady(class UPlayer* P);
	float MissionTimeElapsed();
	float MissionTimeRemaining();
	void UpdateMissionTimerEventWinVar();
	void STATIC_PauseMinionSpawns(const struct FName& Command);
	class ATgPawn* STATIC_SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	void STATIC_SpoolXp();
	void STATIC_SpoolCurrency();
	void LoadGameOverrides();
	void LoadGameConfig();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
};


// Class TgGame.TgGame_Battle
// 0x00A0 (0x07E0 - 0x0740)
class ATgGame_Battle : public ATgGame_Mission
{
public:
	TArray<int>                                        m_StartingItems;                                          // 0x0740(0x0010) (NeedCtorLink)
	int                                                m_StartingSkills[0x4];                                    // 0x0750(0x0004)
	TArray<int>                                        m_nGlobalStartingItems;                                   // 0x0760(0x0010) (NeedCtorLink)
	float                                              m_MultiLaneXpBonus;                                       // 0x0770(0x0004)
	float                                              m_FireGiantRewardDuration;                                // 0x0774(0x0004)
	unsigned long                                      m_bRespawnInhibitors : 1;                                 // 0x0778(0x0004)
	unsigned long                                      m_bEnableCrowdEvents : 1;                                 // 0x0778(0x0004)
	unsigned long                                      m_bRestrictStoreInteractions : 1;                         // 0x0778(0x0004)
	unsigned long                                      m_bGaveLowestXpBonusThisKill : 1;                         // 0x0778(0x0004)
	unsigned long                                      m_bSuppressMinionAlert : 1;                               // 0x0778(0x0004)
	float                                              m_fLowestXpTimeThreshold;                                 // 0x077C(0x0004)
	float                                              m_fLowestXpBonusMultiplier;                               // 0x0780(0x0004)
	TArray<struct FTgAIBotPlayersToSpawn>              m_MercsToSpawn;                                           // 0x0784(0x0010) (NeedCtorLink)
	TArray<struct FGAMEMODE_PLAYER_MODS>               s_GameModeModList;                                        // 0x0794(0x0010) (NeedCtorLink)
	TEnumAsByte<ETrainingQuest>                        m_eCurrentQuestType;                                      // 0x07A4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x07A5(0x0003) MISSED OFFSET
	int                                                m_nCurrentQuestID;                                        // 0x07A8(0x0004)
	int                                                m_nCurrentQuestMsgID;                                     // 0x07AC(0x0004)
	class UClass*                                      m_CurrentQuestClass;                                      // 0x07B0(0x0008)
	int                                                m_nObjectiveCount;                                        // 0x07B8(0x0004)
	int                                                m_nObjectiveGoal;                                         // 0x07BC(0x0004)
	class ATgPawn*                                     m_CurrentTrainingPlayer;                                  // 0x07C0(0x0008)
	int                                                m_nTutorialSpawnTable;                                    // 0x07C8(0x0004)
	int                                                m_nNumberTutorialGods;                                    // 0x07CC(0x0004)
	int                                                m_nPIESpawnTable;                                         // 0x07D0(0x0004)
	int                                                m_nTargetPlayerCountForMercs;                             // 0x07D4(0x0004)
	float                                              m_fGoldPercAfterTowerDmg;                                 // 0x07D8(0x0004)
	int                                                m_nNeutralTaskForceOverride;                              // 0x07DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle");
		return ptr;
	}


	void UpdateQuest(int QuestID, int Amount);
	void CheckCurrentQuest();
	void SpawnBots();
	int GetPlayerCount();
	void STATIC_CreateMinimapManagers(class UClass* managerClass);
	void ApplyNeutralTaskForceOverride();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	bool STATIC_StartGameTimer();
	void AdjustScore(class ATgRepInfo_TaskForce* tf);
	void TriggerBonusMinions(class ATgRepInfo_TaskForce* tf, int nLane);
	void OnBossMonsterKilled(class ATgPawn* BossMonster, class ATgPawn* KillerPawn);
	void NexusWasDestroyed(class ATgPawn* nexus);
	void STATIC_ReapplyAllGameModeMods();
	void STATIC_ReapplyGameModeModsOnPlayer(int nPlayerId);
	void STATIC_RemoveGameModeModFromPlayer(int nPlayerId, int nItemId, int nStacks);
	void AddGameModeModToPlayer(int nPlayerId, int nItemId, int nStacks, bool bUnique);
	class AActor* STATIC_GetEndMissionFocus(class ATgPawn_Guardian* DestroyedMinotaur);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	class ATgPawn* STATIC_SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	void LoadGameOverrides();
	void STATIC_ForceLoadMercenaries(int SpawnTableID);
	void STATIC_CheckMercenaries();
	bool STATIC_ShouldSpawnSuperMinions(class ATgBotFactory_Minions* minionFactory);
	void STATIC_SetInhibitorRespawn(bool bRespawn);
	void STATIC_CheckTeamAce(class AController* Killer, class AController* Killed);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
	void ApplyTowerImmunity();
	void STATIC_ControllerRespawned(class AController* C);
	float STATIC_GetRespawnTime(class AController* C);
	void BotDied(class ATgAIController* aic);
	void STATIC_PlayerDied(class ATgPlayerController* PC);
	void STATIC_StructureDied(class ATgPawn_Structure* theStructure);
	void STATIC_SendGameStartAlert();
	void STATIC_SendBonusMinionAlerts(class ATgRepInfo_TaskForce* tf, int nLane);
	void UpdateGameWinState(class ATgPawn* nexus);
	void STATIC_ScoreKillCommon(struct FScoreKillData* Data);
};


// Class TgGame.TgGame_Adv_CartDefense
// 0x0050 (0x0830 - 0x07E0)
class ATgGame_Adv_CartDefense : public ATgGame_Battle
{
public:
	TArray<struct FCH06_PLAYER_STATS>                  s_PlayerStats;                                            // 0x07E0(0x0010) (NeedCtorLink)
	TArray<struct FCH06_ROUND_STATS>                   s_RoundStats;                                             // 0x07F0(0x0010) (NeedCtorLink)
	int                                                m_nHunterBuffItemId;                                      // 0x0800(0x0004) (Const)
	int                                                m_nAssassinBuffItemId;                                    // 0x0804(0x0004) (Const)
	int                                                m_nMageBuffItemId;                                        // 0x0808(0x0004) (Const)
	int                                                m_nGuardianBuffItemId;                                    // 0x080C(0x0004) (Const)
	int                                                m_nWarriorBuffItemId;                                     // 0x0810(0x0004) (Const)
	class ATgPawn_Adv_Cart*                            r_FoxPawn;                                                // 0x0814(0x0008) (Net)
	float                                              m_fRoundEndDelay;                                         // 0x081C(0x0004) (Const)
	class ATgGameConfig_CartDefense*                   s_CartConfig;                                             // 0x0820(0x0008)
	float                                              s_fDifficultyWeight;                                      // 0x0828(0x0004)
	float                                              s_fTotalScore;                                            // 0x082C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Adv_CartDefense");
		return ptr;
	}


	bool STATIC_StartGameTimer();
	void STATIC_CartCheckpointReached(class ATgPawn_Adv_Cart* cart, bool bIsTowerPoint, bool bIsTowerExitPoint);
	void AllPlayersReady();
	void ForceEnd(int nWinningTf);
	void MissionTimer();
	void ExitFoxTower();
	void STATIC_CalcRoundScore(int nRoundIndex, int nRoundRank);
	void STATIC_SendRoundStats(int nRoundIndex);
	void STATIC_EndRoundAndRecordScore();
	void UpdateDifficultyWeight(int nRoundRank);
	struct FCH06_ROUND_STATS STATIC_CalculateRoundStats();
	int STATIC_GetRoundRank(int nRoundIndex);
	int STATIC_GetPlayerStatIndex(int nPlayerId);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	void STATIC_SendGameStartAlert();
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Arena
// 0x002C (0x080C - 0x07E0)
class ATgGame_Arena : public ATgGame_Battle
{
public:
	float                                              s_fLastDespawnTime[0x2];                                  // 0x07E0(0x0004)
	float                                              s_fDespawnNotificationDelay;                              // 0x07E8(0x0004)
	int                                                m_nKillValueHero;                                         // 0x07EC(0x0004)
	int                                                m_nKillValueMinion;                                       // 0x07F0(0x0004)
	int                                                m_nKillValueTower;                                        // 0x07F4(0x0004)
	int                                                m_MinScoreToTrackMinionKills;                             // 0x07F8(0x0004)
	unsigned long                                      m_bDoNotScoreMinionKills : 1;                             // 0x07FC(0x0004)
	unsigned long                                      m_bDoNotScorePortalKills : 1;                             // 0x07FC(0x0004)
	unsigned long                                      m_bIsCrowdOnFeet : 1;                                     // 0x07FC(0x0004) (Transient)
	unsigned long                                      m_bAllowMinionAssistScoring : 1;                          // 0x07FC(0x0004)
	int                                                m_nSpawnWaveTime;                                         // 0x0800(0x0004)
	int                                                m_nSpawnWaveDominatingTime;                               // 0x0804(0x0004)
	int                                                m_nMaxDominatingPoints;                                   // 0x0808(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena");
		return ptr;
	}


	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	float GetTaskForceDominatingFactor(int TaskforceNum);
	void STATIC_SpawnWaveTeam2Timer();
	void STATIC_SpawnWaveTeam1Timer();
	class AActor* GetEndFocusActor();
	void CheckGameState();
	void STATIC_OnMinionDespawn(int TaskForce, class ATgPawn* VictimPawn);
	bool STATIC_StartGameTimer();
	void STATIC_CheckMinionAssistScorers(struct FScoreKillData* Data, TArray<class ATgPawn*>* pawnListeners);
	int STATIC_GetGameEndingScore();
	int STATIC_GetStartingScore();
	void STATIC_SendTFScoringMessage(class ATgRepInfo_TaskForce* ScoringTaskforce, class ATgPawn* VictimPawn, int nMsgId, int nScoreChange, bool bBroadcast);
	void STATIC_SendPawnScoringMessage(class ATgPawn* ScorerPawn, class ATgPawn* VictimPawn, int nMsgId, int nScoreChange, bool bBroadcast);
	void STATIC_ForwardOnMinionDespawn(class ATgRepInfo_TaskForce* tf);
	void STATIC_SendDespawnAlert(class ATgRepInfo_TaskForce* tfri);
	void ApplyTowerImmunity();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	void STATIC_EndGameBySurrender(int SurrenderingTaskForce);
	float STATIC_GetRespawnTime(class AController* C);
	void MarkAsReady(class UPlayer* P);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	void LoadGameConfig();
};


// Class TgGame.TgGame_Arena_Capture
// 0x0018 (0x0824 - 0x080C)
class ATgGame_Arena_Capture : public ATgGame_Arena
{
public:
	int                                                s_nCaptureHostilePointXP;                                 // 0x080C(0x0004)
	int                                                s_nCaptureHostilePointGold;                               // 0x0810(0x0004)
	int                                                s_nReclaimPointXP;                                        // 0x0814(0x0004)
	int                                                s_nReclaimPointGold;                                      // 0x0818(0x0004)
	int                                                m_nCurrentActiveCapturePointIndex;                        // 0x081C(0x0004)
	float                                              m_fNewPointTime;                                          // 0x0820(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Capture");
		return ptr;
	}


	void UpdateLockedPointStatus();
	void OnPointCaptureOwnershipChanged(class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner);
	void STATIC_SpawnNeutralBots();
	void STATIC_CapturePointReclaimed(class ATgPawn_Character* PC);
	void STATIC_CapturedPoint(class ATgPawn_Character* PC);
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void PostBeginPlay();
};


// Class TgGame.TgGame_Arena_Escort
// 0x002C (0x0838 - 0x080C)
class ATgGame_Arena_Escort : public ATgGame_Arena
{
public:
	int                                                m_nSpawnEscortTime;                                       // 0x080C(0x0004)
	int                                                m_nEscortSuccessValue;                                    // 0x0810(0x0004)
	unsigned long                                      m_bDoNotSpawnEscort : 1;                                  // 0x0814(0x0004)
	class UTgSeqEvent_SpawnWise*                       s_pEvt[0x2];                                              // 0x0818(0x0008)
	class UTgSeqEvent_Escort_Despawn_Success*          s_pDespawnEvt[0x2];                                       // 0x0828(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Escort");
		return ptr;
	}


	void STATIC_OnEscortDespawn(int TaskForce, class ATgPawn* VictimPawn);
	void LoadGameConfig();
	void STATIC_SendEscortSpawnAlert(class ATgRepInfo_TaskForce* tfri);
};


// Class TgGame.TgGame_Arena_Corrupted
// 0x0010 (0x0848 - 0x0838)
class ATgGame_Arena_Corrupted : public ATgGame_Arena_Escort
{
public:
	int                                                m_nWinPlayerPoints;                                       // 0x0838(0x0004)
	int                                                m_nLosePlayerPoints;                                      // 0x083C(0x0004)
	float                                              m_fPointsPerMinute;                                       // 0x0840(0x0004)
	float                                              m_fBundleOwnedMultiplier;                                 // 0x0844(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Corrupted");
		return ptr;
	}


	void STATIC_ScoreKill(class AController* Killer, class AController* Other);
};


// Class TgGame.TgGame_Arena_Escort_Practice
// 0x0000 (0x0838 - 0x0838)
class ATgGame_Arena_Escort_Practice : public ATgGame_Arena_Escort
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Escort_Practice");
		return ptr;
	}

};


// Class TgGame.TgGame_Arena_SuddenDeath
// 0x0010 (0x0848 - 0x0838)
class ATgGame_Arena_SuddenDeath : public ATgGame_Arena_Escort
{
public:
	TEnumAsByte<EGAME_WIN_STATE>                       m_BonusGameWinState;                                      // 0x0838(0x0001)
	TEnumAsByte<EGAME_WIN_STATE>                       m_TempWinState;                                           // 0x0839(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x083A(0x0002) MISSED OFFSET
	unsigned long                                      m_bOvertimeTimedOut : 1;                                  // 0x083C(0x0004)
	unsigned long                                      m_bHasEnteredOvertime : 1;                                // 0x083C(0x0004)
	float                                              m_fBonusWorshipers;                                       // 0x0840(0x0004)
	float                                              m_fStandardMissionTimer;                                  // 0x0844(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_SuddenDeath");
		return ptr;
	}


	void STATIC_SpawnWaveTeam2Timer();
	void STATIC_SpawnWaveTeam1Timer();
	float ElapsedTime();
	bool IsInOvertime();
	void STATIC_OnEscortDespawn(int TaskForce, class ATgPawn* VictimPawn);
	void STATIC_OnMinionDespawn(int TaskForce, class ATgPawn* VictimPawn);
	void CheckSuddenDeathWinner();
	void CheckGameState();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void MissionTimer();
	void PushDeviceRestartTo(class ATgPawn* PlayerPawn);
	bool STATIC_StartGameTimer();
	float ModeSpecificCurrencyReward(class ATgPlayerController* TgPC);
	void STATIC_StartOvertime();
	void STATIC_PrepPlayersForSuddenDeath();
	void STATIC_PseudoRoundEnd();
	void STATIC_EndGameBySurrender(int SurrenderingTaskForce);
	float MissionTimeElapsed();
	float STATIC_GetRespawnTime(class AController* C);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	void BotDied(class ATgAIController* aic);
	void STATIC_PlayerDied(class ATgPlayerController* PC);
};


// Class TgGame.TgGame_Arena_Practice
// 0x0000 (0x080C - 0x080C)
class ATgGame_Arena_Practice : public ATgGame_Arena
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Practice");
		return ptr;
	}

};


// Class TgGame.TgGame_Arena_Training
// 0x000C (0x0818 - 0x080C)
class ATgGame_Arena_Training : public ATgGame_Arena_Practice
{
public:
	unsigned long                                      m_bEnableGameCompletion : 1;                              // 0x080C(0x0004)
	int                                                m_nScoreCap;                                              // 0x0810(0x0004) (Config)
	float                                              m_fRespawnTime;                                           // 0x0814(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Arena_Training");
		return ptr;
	}


	void STATIC_OnMinionDespawn(int TaskForce, class ATgPawn* VictimPawn);
	void AdjustScore(class ATgRepInfo_TaskForce* tf);
	void UseTickets(int TaskForce, int Tickets);
	float STATIC_GetRespawnTime(class AController* C);
	class ATgPawn* STATIC_SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
};


// Class TgGame.TgGame_Battle_Adventure
// 0x0100 (0x08E0 - 0x07E0)
class ATgGame_Battle_Adventure : public ATgGame_Battle
{
public:
	TArray<int>                                        s_CurrencyMap;                                            // 0x07E0(0x0010) (NeedCtorLink)
	TArray<struct FADV_MOD_INFO>                       m_PlayerMods;                                             // 0x07F0(0x0010) (NeedCtorLink)
	TArray<struct FADV_MOD_INFO>                       m_BotMods;                                                // 0x0800(0x0010) (NeedCtorLink)
	TArray<class ATgBotFactory_Adventure*>             m_AggrodFactories;                                        // 0x0810(0x0010) (NeedCtorLink)
	unsigned long                                      s_bRespawnPaused : 1;                                     // 0x0820(0x0004)
	unsigned long                                      s_bMustUnlockItems : 1;                                   // 0x0820(0x0004)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0824(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgGame_Battle_Adventure.m_ItemLootMap
	int                                                m_nItemStoreId;                                           // 0x086C(0x0004)
	int                                                m_nDeathDebuffId;                                         // 0x0870(0x0004)
	int                                                s_nPlayerQueueEffectId;                                   // 0x0874(0x0004)
	TArray<class ATgGame_Quest_Kill*>                  s_KillQuests;                                             // 0x0878(0x0010) (NeedCtorLink)
	TArray<class ATgGame_Quest_Chest*>                 s_ChestQuests;                                            // 0x0888(0x0010) (NeedCtorLink)
	TArray<class UTgLootTable*>                        s_LootDropsTables;                                        // 0x0898(0x0010) (NeedCtorLink)
	TArray<class UTgLootTable*>                        s_CurrencyDropsTables;                                    // 0x08A8(0x0010) (NeedCtorLink)
	TArray<class UTgLootTable*>                        s_DeployableDropsTables;                                  // 0x08B8(0x0010) (NeedCtorLink)
	TArray<class UTgLootTable*>                        s_CampItemTables;                                         // 0x08C8(0x0010) (NeedCtorLink)
	int                                                s_nQueueId;                                               // 0x08D8(0x0004)
	float                                              s_fTotalMissionTime;                                      // 0x08DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Adventure");
		return ptr;
	}


	bool STATIC_StartGameTimer();
	void ForceEnd(int nWinningTf);
	void MissionTimer();
	class UClass* STATIC_SpecialInventoryClass();
	bool STATIC_HasSpecialInventory();
	void AllPlayersReady();
	bool STATIC_ShouldMissionEnd();
	float MissionTimeElapsed();
	void STATIC_EndGameBySurrender(int SurrenderingTaskForce);
	class UTgLootTable* STATIC_GetSubTableFrom(TEnumAsByte<EAdventureLootType> eLootType, int nLootTableId);
	struct FLootData STATIC_RollLootFrom(TEnumAsByte<EAdventureLootType> eLootType, int nLootTableId, int nPlayerId);
	void AddLootTable(TEnumAsByte<EAdventureLootType> eLootType, int nLootTableId);
	void TriggerModEvent(int nModEvent);
	bool AreModsEnabled();
	void STATIC_CompleteQuestForAll(int nTaskForce, int nActivityId, int nGoalId, int nNumComplete);
	void STATIC_RegisterQuest(class ATgGame_Quest* Quest);
	void STATIC_ChestOpened(class ATgPawn_Adv_Chest* Chest);
	void STATIC_ScoreKill(class AController* Killer, class AController* Other);
	int ItemToLoot(int nItemId);
	void STATIC_RemoveModFromPlayer(class ATgPawn* pPlayerPawn, int nItemId);
	void ApplyModToPlayer(class ATgPawn* pPlayerPawn, int nItemId);
	void STATIC_RemoveBotMod(int nItemId);
	void AddBotMod(int nItemId);
	void STATIC_RemovePlayerMod(int nItemId);
	void AddPlayerMod(int nItemId);
	void UpdateFactoryAggro(class ATgBotFactory_Adventure* Factory);
	void UpdatePlayerStates();
	void STATIC_ForceRespawns();
	bool STATIC_SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	float STATIC_GetRespawnTime(class AController* C);
	void LoadGameConfig();
	int STATIC_GetDifficulty();
	void STATIC_SendGameStartAlert();
	void STATIC_SpoolCurrency();
};


// Class TgGame.TgGame_Battle_Casual
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Casual : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Casual");
		return ptr;
	}


	void STATIC_StructureDied(class ATgPawn_Structure* theStructure);
	bool STATIC_ShouldSpawnSuperMinions(class ATgBotFactory_Minions* minionFactory);
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Battle_Clash
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Clash : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Clash");
		return ptr;
	}


	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	float STATIC_GetRespawnTime(class AController* C);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
};


// Class TgGame.TgGame_Battle_Clash_Practice
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Clash_Practice : public ATgGame_Battle_Clash
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Clash_Practice");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_ClashV2
// 0x0010 (0x07F0 - 0x07E0)
class ATgGame_Battle_ClashV2 : public ATgGame_Battle_Clash
{
public:
	float                                              m_RespawnTimeStart;                                       // 0x07E0(0x0004)
	float                                              m_RespawnTimeIncreasePerInterval;                         // 0x07E4(0x0004)
	float                                              m_RespawnTimeInterval;                                    // 0x07E8(0x0004)
	float                                              m_RespawnTimeMax;                                         // 0x07EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_ClashV2");
		return ptr;
	}


	int STATIC_GetNextVulnerableTowerId(int nBotId);
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Battle_ClashV2_Practice
// 0x0000 (0x07F0 - 0x07F0)
class ATgGame_Battle_ClashV2_Practice : public ATgGame_Battle_ClashV2
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_ClashV2_Practice");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Conquest
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Conquest : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest");
		return ptr;
	}


	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
};


// Class TgGame.TgGame_Battle_Aram
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Aram : public ATgGame_Battle_Conquest
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Aram");
		return ptr;
	}


	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Battle_Aram_Practice
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Aram_Practice : public ATgGame_Battle_Aram
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Aram_Practice");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Conquest_Erez
// 0x0008 (0x07E8 - 0x07E0)
class ATgGame_Battle_Conquest_Erez : public ATgGame_Battle_Conquest
{
public:
	int                                                m_nSpawnSiegeWeaponThreshold;                             // 0x07E0(0x0004)
	unsigned long                                      m_bDoNotSpawnSiegeWeaponFromTickets : 1;                  // 0x07E4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Erez");
		return ptr;
	}


	void SendLanePusherUpdateAlert(bool isAlive, int tf);
	void TriggerLanePusher(class ATgRepInfo_TaskForce* tf, int nLane);
	void PostBeginPlay();
	void STATIC_OnLanePusherSpawned(class AActor* LanePusher, class ATgRepInfo_TaskForce* TaskForce);
	float STATIC_GetRespawnTime(class AController* C);
	void STATIC_SendLanePusherSpawnAlert(int TaskForce);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
	void LoadGameConfig();
};


// Class TgGame.TgGame_Battle_Conquest_Practice
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Conquest_Practice : public ATgGame_Battle_Conquest
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Practice");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Conquest_Training
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Conquest_Training : public ATgGame_Battle_Conquest_Practice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Training");
		return ptr;
	}


	class ATgPawn* STATIC_SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
};


// Class TgGame.TgGame_Battle_Conquest_Tc
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Conquest_Tc : public ATgGame_Battle_Conquest
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Tc");
		return ptr;
	}


	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Battle_Siege2
// 0x0001 (0x07E1 - 0x07E0)
class ATgGame_Battle_Siege2 : public ATgGame_Battle_Conquest
{
public:
	TEnumAsByte<ESIEGE2_BATTLE_PHASE>                  m_BattlePhase;                                            // 0x07E0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Siege2");
		return ptr;
	}


	int STATIC_GetNextVulnerableTowerId(int nBotId);
};


// Class TgGame.TgGame_Battle_CTF
// 0x002C (0x080C - 0x07E0)
class ATgGame_Battle_CTF : public ATgGame_Battle
{
public:
	TArray<class ATgDeployable_CTF_FlagBase*>          m_FlagBases;                                              // 0x07E0(0x0010) (NeedCtorLink)
	float                                              m_fRespawnTime;                                           // 0x07F0(0x0004)
	float                                              m_fOvertimeLength;                                        // 0x07F4(0x0004)
	int                                                m_nScoreLimit;                                            // 0x07F8(0x0004)
	TArray<struct FCTFStats>                           s_Stats;                                                  // 0x07FC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_CTF");
		return ptr;
	}


	class ANavigationPoint* GetReviveLocation(class AController* Player, struct FVector* OutLocation, struct FRotator* OutRotation);
	class ANavigationPoint* FindPlayerStartPoint(class AController* Player, const struct FString& SpawnTagName);
	bool CheckOvertimeStatus();
	void MissionTimer();
	bool STATIC_StartGameTimer();
	void TaskforceScored(class ATgPawn* ScoringPawn);
	float MissionTimeElapsed();
	bool STATIC_SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	void STATIC_SendGameMessage(TEnumAsByte<ECTFMessageEvent> eCTFMsg, class ATgPawn* MessageInstigator, int nTaskForce);
	void STATIC_SendGameStartAlert();
	void UpdateStatsFor(int nPlayerId, TEnumAsByte<ECTFStatEvent> eStatEvent, float fEventValue);
	void STATIC_OnFlagCaptured(class ATgPawn* ScoringPawn);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	void STATIC_ScoreKill(class AController* Killer, class AController* Other);
	void LoadGameConfig();
	class ANavigationPoint* STATIC_TgCTFFindRespawn(class AController* C);
	class ANavigationPoint* STATIC_TgCTFFindInitialSpawn(class AController* C);
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Battle_Encounters
// 0x0034 (0x0814 - 0x07E0)
class ATgGame_Battle_Encounters : public ATgGame_Battle
{
public:
	TEnumAsByte<ERoundState>                           s_eRoundState;                                            // 0x07E0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x07E1(0x0003) MISSED OFFSET
	int                                                s_nCurrentRound;                                          // 0x07E4(0x0004)
	float                                              m_fCumulativePlayTime;                                    // 0x07E8(0x0004)
	TArray<class ATgAIController*>                     m_ControllersToDestroy;                                   // 0x07EC(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_PawnsToDestroy;                                         // 0x07FC(0x0010) (NeedCtorLink)
	class ATgObjectiveVolume_BotList*                  m_ObjectiveVolume;                                        // 0x080C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Encounters");
		return ptr;
	}


	void AllPlayersReady();
	void PushDeviceRestartTo(class ATgPawn* PlayerPawn);
	void ForceEndGame();
	void CheckGameState();
	float MatchDuration();
	void MissionTimer();
	void MissionTimerStart();
	void DestroyPendingBots();
	void HandleBotDied(class ATgAIController* aic);
	int GetNumPlayersAlive();
	bool STATIC_SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	float STATIC_GetDifficultyMultiplier();
	int STATIC_GetDifficulty();
	float MissionTimeElapsed();
	float MissionTimeRemaining();
	void STATIC_FailedRound();
	float STATIC_GetRespawnTime(class AController* C);
	void STATIC_PlayerDied(class ATgPlayerController* PC);
	void BotDied(class ATgAIController* aic);
};


// Class TgGame.TgGame_Battle_Expert
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Expert : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Expert");
		return ptr;
	}


	void TriggerBonusMinions(class ATgRepInfo_TaskForce* tf, int nLane);
};


// Class TgGame.TgGame_Battle_Joust
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Joust : public ATgGame_Battle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Joust");
		return ptr;
	}


	void AllPlayersReady();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void AutoForfeit();
	bool Is1v1();
	void MarkAsReady(class UPlayer* P);
	float STATIC_GetRespawnTime(class AController* C);
	void STATIC_CheckTeamAce(class AController* Killer, class AController* Killed);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
};


// Class TgGame.TgGame_Battle_Joust_Duel
// 0x000C (0x07EC - 0x07E0)
class ATgGame_Battle_Joust_Duel : public ATgGame_Battle_Joust
{
public:
	float                                              m_fMinRespawnTime;                                        // 0x07E0(0x0004)
	float                                              m_fMaxRespawnTime;                                        // 0x07E4(0x0004)
	float                                              m_fRespawnModifier;                                       // 0x07E8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Joust_Duel");
		return ptr;
	}


	float STATIC_GetRespawnTime(class AController* Controller);
};


// Class TgGame.TgGame_Battle_Joust_Practice
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Joust_Practice : public ATgGame_Battle_Joust
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Joust_Practice");
		return ptr;
	}


	void MarkAsReady(class UPlayer* P);
};


// Class TgGame.TgGame_Battle_ShootingRange
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_ShootingRange : public ATgGame_Battle_Joust_Practice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_ShootingRange");
		return ptr;
	}


	void SpawnBots();
	bool Is1v1();
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Battle_Training
// 0x0014 (0x07F4 - 0x07E0)
class ATgGame_Battle_Training : public ATgGame_Battle_Joust_Practice
{
public:
	unsigned long                                      m_bNewTutorial : 1;                                       // 0x07E0(0x0004)
	TArray<int>                                        m_RecommendedItems;                                       // 0x07E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Training");
		return ptr;
	}


	void SpawnBots();
	bool Is1v1();
	class ATgPawn* STATIC_SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Battle_PEP
// 0x0040 (0x0820 - 0x07E0)
class ATgGame_Battle_PEP : public ATgGame_Battle
{
public:
	float                                              m_fRespawnTime;                                           // 0x07E0(0x0004)
	float                                              m_RespawnTimeStart;                                       // 0x07E4(0x0004)
	float                                              m_RespawnTimeIncreasePerInterval;                         // 0x07E8(0x0004)
	float                                              m_RespawnTimeInterval;                                    // 0x07EC(0x0004)
	float                                              m_RespawnTimeMax;                                         // 0x07F0(0x0004)
	float                                              m_fKillGoldRewardMultiplier;                              // 0x07F4(0x0004)
	float                                              m_fKillXpRewardMultiplier;                                // 0x07F8(0x0004)
	int                                                m_nTF1BuffItemId;                                         // 0x07FC(0x0004) (Const)
	int                                                m_nTF2BuffItemId;                                         // 0x0800(0x0004) (Const)
	int                                                m_nTF3BuffItemId;                                         // 0x0804(0x0004) (Const)
	int                                                m_nTF4BuffItemId;                                         // 0x0808(0x0004) (Const)
	int                                                m_nNGMAssassinItemId;                                     // 0x080C(0x0004) (Const)
	int                                                m_nNGMGuardianItemId;                                     // 0x0810(0x0004) (Const)
	int                                                m_nNGMHunterItemId;                                       // 0x0814(0x0004) (Const)
	int                                                m_nNGMMageItemId;                                         // 0x0818(0x0004) (Const)
	int                                                m_nNGMWarriorItemId;                                      // 0x081C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_PEP");
		return ptr;
	}


	void MissionTimer();
	void UpdateConfiguration(class ATgGameConfig* GameConf);
	void STATIC_CacheGameInfoForTaskforces(class ATgGameConfig* GameConf);
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Battle_Racer
// 0x0024 (0x0804 - 0x07E0)
class ATgGame_Battle_Racer : public ATgGame_Battle
{
public:
	TArray<class ATgRacingCheckpoint*>                 m_Checkpoints;                                            // 0x07E0(0x0010) (NeedCtorLink)
	float                                              m_fTotalTrackDistance;                                    // 0x07F0(0x0004)
	int                                                m_nLapsToFinish;                                          // 0x07F4(0x0004)
	int                                                m_nRacersFinished;                                        // 0x07F8(0x0004)
	float                                              m_fStallTime;                                             // 0x07FC(0x0004)
	unsigned long                                      m_bEndGameStarted : 1;                                    // 0x0800(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Racer");
		return ptr;
	}


	bool SetPause(class APlayerController* PC, const struct FScriptDelegate& CanUnpauseDelegate);
	bool CanSpectate(class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget);
	void STATIC_CollectCheckpoints();
	void AllPlayersEndGame(class AActor* EndGameFocus);
	void STATIC_FinishGameForReal();
	void AllPlayersFinishedOrStallTimerExpired();
	void MaxMatchTimeExpired();
	void STATIC_SetCompletedLaps(int Laps);
	void STATIC_ForceAllRacersToFinish(float DeltaTime);
	void STATIC_RestartRace();
	void EnableMovementOnAllPlayers();
	void TriggerCountdownAnimations();
	void AllPlayersReady();
	void PostBeginPlay();
	void STATIC_SendGameStartAlert();
	bool AllowPausing(class APlayerController* PC);
	float STATIC_GetRespawnTime(class AController* C);
	void STATIC_PlayerDied(class ATgPlayerController* PC);
	void STATIC_DeterminePlayerPlacements();
	void STATIC_SetTotalDistanceTraveled(class ATgPawn_Racer* Racer);
	void STATIC_SetLapDistanceTraveled(class ATgPawn_Racer* Racer);
	void STATIC_SetCurrentCheckpointAndLap(class ATgPawn_Racer* Racer);
	bool STATIC_SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	class ATgPawn* STATIC_SpawnPlayerCharacter(class AController* C, const struct FVector& vLocation);
	void LoadGameConfig();
};


// Class TgGame.TgGame_Battle_Round
// 0x003C (0x081C - 0x07E0)
class ATgGame_Battle_Round : public ATgGame_Battle
{
public:
	TEnumAsByte<EBattleRoundState>                     s_eRoundState;                                            // 0x07E0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x07E1(0x0003) MISSED OFFSET
	unsigned long                                      s_bRepeatListOnEnd : 1;                                   // 0x07E4(0x0004)
	int                                                s_nWinningScore;                                          // 0x07E8(0x0004)
	TArray<struct FBattleRoundConfig>                  s_RoundList;                                              // 0x07EC(0x0010) (NeedCtorLink)
	int                                                s_nCurrentRound;                                          // 0x07FC(0x0004)
	int                                                s_nRoundListIndex;                                        // 0x0800(0x0004)
	int                                                s_nRoundWinner;                                           // 0x0804(0x0004)
	float                                              m_fCumulativePlayTime;                                    // 0x0808(0x0004)
	float                                              s_fRoundCooldown;                                         // 0x080C(0x0004)
	float                                              s_fRoundBlackout;                                         // 0x0810(0x0004)
	class ATgPawn*                                     s_LastKiller;                                             // 0x0814(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Round");
		return ptr;
	}


	void KickIdler(class APlayerController* PC);
	void PushDeviceRestartTo(class ATgPawn* PlayerPawn);
	float MatchDuration();
	void MissionTimer();
	void MissionTimerStart();
	int GetNumPlayersAlive(int nTaskForce);
	float GetMissionTime();
	float STATIC_GetSetupTime();
	void AllPlayersReady();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void SetBattleRoundState(TEnumAsByte<EBattleRoundState> eNewState);
	void SendBattleRoundStateEvent(int nEventId);
	void AddScoreToTaskForce(int nTF, int nScore);
	void STATIC_SendRoundData();
	void STATIC_StartNextRound();
	void STATIC_ReapplyEffects();
	void AdjustPlayerRoundStates();
	void STATIC_ResetPlayers();
	int STATIC_GetNextRoundIndex();
	void STATIC_RoundCooldown();
	void STATIC_StartRoundTransition();
	void STATIC_SetWinner();
	bool WantsGameEnd();
	void STATIC_RoundEnd();
	void STATIC_CheckRoundState();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	bool STATIC_SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	float MissionTimeElapsed();
	float MissionTimeRemaining();
	float STATIC_GetRespawnTime(class AController* C);
	void BotDied(class ATgAIController* aic);
	void STATIC_PlayerDied(class ATgPlayerController* PC);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	int STATIC_GetTaskForcePlacement(int nTaskForceNum);
	int STATIC_GetWinningTaskforce();
};


// Class TgGame.TgGame_CH08
// 0x0020 (0x083C - 0x081C)
class ATgGame_CH08 : public ATgGame_Battle_Round
{
public:
	unsigned long                                      m_bPlayerKillsShouldSpawnGoo : 1;                         // 0x081C(0x0004)
	class ATgActor_CH08_GooSpawner*                    s_GooSpawnActor;                                          // 0x0820(0x0008)
	TArray<struct FCH08_MOD_STACKER>                   s_PendingStackerList;                                     // 0x0828(0x0010) (NeedCtorLink)
	int                                                m_nKillBuffItemId;                                        // 0x0838(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_CH08");
		return ptr;
	}


	void AllPlayersReady();
	void STATIC_ResetPlayers();
	void STATIC_StartNewStacker(int nPlayerId, int nItemId, int nStacks, float fStackDelay);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
};


// Class TgGame.TgGame_Ch13_Deathmatch
// 0x0004 (0x0840 - 0x083C)
class ATgGame_Ch13_Deathmatch : public ATgGame_CH08
{
public:
	int                                                m_nBuffItemId;                                            // 0x083C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Ch13_Deathmatch");
		return ptr;
	}

};


// Class TgGame.TgGame_MultiRounds
// 0x0140 (0x0920 - 0x07E0)
class ATgGame_MultiRounds : public ATgGame_Battle
{
public:
	TEnumAsByte<EGameMultiRoundState>                  s_eRoundState;                                            // 0x07E0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x07E1(0x0003) MISSED OFFSET
	class ATgInventory_RandomizedBotShop*              s_RandomizedBotShop;                                      // 0x07E4(0x0008)
	class ATgRoundSchedule*                            m_Schedule;                                               // 0x07EC(0x0008)
	TArray<class ATgArenaManager*>                     m_Arenas;                                                 // 0x07F4(0x0010) (NeedCtorLink)
	TArray<class ATgCollisionProxy*>                   s_ReadyProxies;                                           // 0x0804(0x0010) (NeedCtorLink)
	float                                              m_fCumulativePlayTime;                                    // 0x0814(0x0004)
	struct FOpponentMatchups                           s_PreviousMatchups[0x10];                                 // 0x0818(0x0010)
	int                                                s_nCurrentRound;                                          // 0x0918(0x0004)
	int                                                s_nCurrentRoundCount;                                     // 0x091C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_MultiRounds");
		return ptr;
	}


	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void EnableStorePurchasesFor(class ATgPlayerController* TgPC, bool bEnabled);
	void STATIC_EndStoreEarly();
	void STATIC_CheckStoreAllReady();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void KickIdler(class APlayerController* PC);
	void PushDeviceRestartTo(class ATgPawn* PlayerPawn);
	float MatchDuration();
	void MissionTimer();
	void MissionTimerStart();
	int GetNumPlayersAlive(int nTaskForce);
	float GetMissionTime();
	float STATIC_GetSetupTime();
	void AllPlayersReady();
	void STATIC_OnDestroy(class USeqAct_Destroy* Action);
	void UpdateConfiguration(class ATgGameConfig* GameConf);
	void PostBeginPlay();
	void InitGame(const struct FString& Options, struct FString* ErrorMessage);
	void AddArena(class ATgArenaManager* tgAM);
	void STATIC_ReceiveClientGameEvent(class ATgPlayerController* TgPC, TEnumAsByte<EClientGameEvent> eCGE, int nVal1, int nVal2, float fVal1);
	void UpdateMultiRoundPlayerInfo();
	void UpdateMultiRoundSequenceTimers();
	void UpdateRoundState(TEnumAsByte<EGameMultiRoundState> eState);
	class ATgArenaManager* STATIC_GetArenaFor(class AController* C);
	float STATIC_GetTimeTillNextStore();
	int STATIC_GetTeamTFByRank(int nTeamRank);
	void UpdateArenaGameInfo();
	bool STATIC_IncrementCurrentRound();
	void STATIC_EmptyAllArenas();
	void STATIC_EndRound();
	void ArenaFinished();
	void STATIC_StartRound();
	void STATIC_PrepRoundSchedule();
	void STATIC_EndStorePeriod();
	void BeginStorePeriod();
	void AllPlayersSelectNewInventory();
	void AllPlayersRoundReset();
	void STATIC_CheckRoundState();
	bool STATIC_FinishEndMission();
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	bool STATIC_SwapToNewAIController(class AController* C, class ATgPawn_Character* TgPawn);
	float MissionTimeElapsed();
	float MissionTimeRemaining();
	float STATIC_GetRespawnTime(class AController* C);
	void BotDied(class ATgAIController* aic);
	void STATIC_PlayerDied(class ATgPlayerController* PC);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	int STATIC_GetWinningTaskforce();
};


// Class TgGame.TgGame_PointCapture
// 0x0030 (0x0810 - 0x07E0)
class ATgGame_PointCapture : public ATgGame_Battle
{
public:
	float                                              s_TicketCheckInterval;                                    // 0x07E0(0x0004)
	int                                                s_nCaptureHostilePointXP;                                 // 0x07E4(0x0004)
	int                                                s_nCaptureHostilePointGold;                               // 0x07E8(0x0004)
	int                                                s_nReclaimPointXP;                                        // 0x07EC(0x0004)
	int                                                s_nReclaimPointGold;                                      // 0x07F0(0x0004)
	int                                                s_nCurrentPhase;                                          // 0x07F4(0x0004) (Transient)
	int                                                s_nPhase2Threshold;                                       // 0x07F8(0x0004)
	int                                                s_nPhase3Threshold;                                       // 0x07FC(0x0004)
	int                                                m_nSpawnWaveTime;                                         // 0x0800(0x0004)
	int                                                m_nSpawnWaveDominatingTime;                               // 0x0804(0x0004)
	int                                                m_nMaxDominatingPoints;                                   // 0x0808(0x0004)
	int                                                s_nAboutToLoseThreshold;                                  // 0x080C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_PointCapture");
		return ptr;
	}


	void OnPointCaptureOwnershipChanged(class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner);
	void UpdateLockedPointStatus();
	float GetTaskForceDominatingFactor(int TaskforceNum);
	void STATIC_SpawnWaveTeam2Timer();
	void STATIC_SpawnWaveTeam1Timer();
	void CheckWinState();
	void TrophyMonsterKilled(class ATgPawn* Killer, int RewardAmount);
	void STATIC_CheckWinCondition();
	void STATIC_SubtractTicketsFromTaskForce(class ATgRepInfo_TaskForce* tf, int Amount);
	void STATIC_CheckTicketsForTeam(int TaskForceNumber, int OpposingTaskForceNumber);
	void STATIC_CheckTickets();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	void STATIC_SpawnNeutralBots();
	bool STATIC_StartGameTimer();
	class AActor* GetEndFocusActor();
	int STATIC_GetGameEndingScore();
	int STATIC_GetStartingScore();
	bool STATIC_ShouldSpawnSuperMinions(class ATgBotFactory_Minions* minionFactory);
	int STATIC_GetNextVulnerableTowerId(int nBotId);
	void ApplyTowerImmunity();
	void STATIC_StructureDied(class ATgPawn_Structure* theStructure);
	void STATIC_SendBonusMinionAlerts(class ATgRepInfo_TaskForce* tf, int nLane);
	void UpdateGameWinState(class ATgPawn* nexus);
	void AlertAboutToLose(int nTaskForce);
	void STATIC_CapturePointReclaimed(class ATgPawn_Character* PC);
	void STATIC_CapturedPoint(class ATgPawn_Character* PC);
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	bool BeginEndMission(bool bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride);
	void STATIC_EndGameBySurrender(int SurrenderingTaskForce);
	void MarkAsReady(class UPlayer* P);
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Domination
// 0x0004 (0x0814 - 0x0810)
class ATgGame_Domination : public ATgGame_PointCapture
{
public:
	float                                              m_fRespawnTime;                                           // 0x0810(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Domination");
		return ptr;
	}


	void UpdateLockedPointStatus();
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_SinglePointCaptureAndHold
// 0x0014 (0x0824 - 0x0810)
class ATgGame_SinglePointCaptureAndHold : public ATgGame_PointCapture
{
public:
	int                                                m_nCurrentActiveCapturePointIndex;                        // 0x0810(0x0004)
	int                                                m_nNumTicketsForCapturingPoint;                           // 0x0814(0x0004)
	int                                                m_nNumTicketsForHoldingPoint;                             // 0x0818(0x0004)
	float                                              m_fNewPointTime;                                          // 0x081C(0x0004)
	float                                              m_fDefendingTeamRespawnTime;                              // 0x0820(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_SinglePointCaptureAndHold");
		return ptr;
	}


	void UpdateLockedPointStatus();
	void STATIC_CheckTickets();
	void OnPointCaptureOwnershipChanged(class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner);
	void STATIC_SpawnNeutralBots();
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_CTF
// 0x0024 (0x0764 - 0x0740)
class ATgGame_CTF : public ATgGame_Mission
{
public:
	class ATgCTFFlagBase*                              m_FlagBases[0x2];                                         // 0x0740(0x0008) (Transient)
	float                                              m_fRoundTime;                                             // 0x0750(0x0004)
	float                                              m_fEndOfRoundTime;                                        // 0x0754(0x0004)
	int                                                m_nCurrentRound;                                          // 0x0758(0x0004) (Transient)
	int                                                m_nNumRounds;                                             // 0x075C(0x0004)
	int                                                m_nSpawnWaveTime;                                         // 0x0760(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_CTF");
		return ptr;
	}


	void STATIC_SpawnWaveTimer();
	void STATIC_ScoreFlag(class ATgPawn_Character* FlagCarrier);
	void STATIC_RegisterFlagBase(class ATgCTFFlagBase* FlagBase);
	void MissionTimer();
	void ChangeTimerState(TEnumAsByte<EGameTimerState> eTimerState);
	bool STATIC_StartGameTimer();
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Idol
// 0x0014 (0x0754 - 0x0740)
class ATgGame_Idol : public ATgGame_Mission
{
public:
	class ATgIdol*                                     m_Idols[0x2];                                             // 0x0740(0x0008) (Transient)
	int                                                m_nSpawnWaveTime;                                         // 0x0750(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Idol");
		return ptr;
	}


	void STATIC_SpawnWaveTimer();
	void MissionTimer();
	bool STATIC_StartGameTimer();
	void STATIC_ScoreKillGameType(struct FScoreKillData* Data);
	float STATIC_GetRespawnTime(class AController* C);
};


// Class TgGame.TgGame_Quest
// 0x0008 (0x0268 - 0x0260)
class ATgGame_Quest : public AActor
{
public:
	int                                                m_nActivityId;                                            // 0x0260(0x0004) (Edit)
	int                                                m_nGoalId;                                                // 0x0264(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Quest");
		return ptr;
	}


	void STATIC_OnQuestComplete(int nNumComplete);
	void PostBeginPlay();
};


// Class TgGame.TgGame_Quest_Chest
// 0x0008 (0x0270 - 0x0268)
class ATgGame_Quest_Chest : public ATgGame_Quest
{
public:
	TEnumAsByte<EChestType>                            m_eMinChestType;                                          // 0x0268(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0269(0x0003) MISSED OFFSET
	int                                                m_nNumToOpen;                                             // 0x026C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Quest_Chest");
		return ptr;
	}


	void STATIC_OnChestOpened(TEnumAsByte<EChestType> EChestType);
};


// Class TgGame.TgGame_Quest_Kill
// 0x0024 (0x028C - 0x0268)
class ATgGame_Quest_Kill : public ATgGame_Quest
{
public:
	TArray<int>                                        m_BotIds;                                                 // 0x0268(0x0010) (Edit, NeedCtorLink)
	TArray<int>                                        m_nBotType;                                               // 0x0278(0x0010) (Edit, NeedCtorLink)
	int                                                m_nNumKills;                                              // 0x0288(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Quest_Kill");
		return ptr;
	}


	void STATIC_OnGameScoredKill(class AController* Killer, class AController* Other);
};


// Class TgGame.TgGameConfig
// 0x0038 (0x0298 - 0x0260)
class ATgGameConfig : public AActor
{
public:
	int                                                m_nStoreOverrideId;                                       // 0x0260(0x0004) (Edit)
	int                                                m_nStoreNoNoOverrideId;                                   // 0x0264(0x0004) (Edit)
	int                                                m_nStoreAllowFullRefund;                                  // 0x0268(0x0004) (Edit)
	unsigned long                                      m_bAllowResellAll : 1;                                    // 0x026C(0x0004) (Edit)
	unsigned long                                      m_bAllowMultiTeamSpectating : 1;                          // 0x026C(0x0004) (Edit)
	unsigned long                                      m_bHasRewards : 1;                                        // 0x026C(0x0004) (Edit)
	unsigned long                                      m_bOverridesScore : 1;                                    // 0x026C(0x0004) (Edit)
	int                                                m_nRewardCurrency;                                        // 0x0270(0x0004) (Edit)
	float                                              m_fRewardPerMin;                                          // 0x0274(0x0004) (Edit)
	float                                              m_fWinnerMult;                                            // 0x0278(0x0004) (Edit)
	int                                                m_nBonusItemId;                                           // 0x027C(0x0004) (Edit)
	float                                              m_fBonusItemMult;                                         // 0x0280(0x0004) (Edit)
	TArray<float>                                      m_fCustomRewards;                                         // 0x0284(0x0010) (Edit, NeedCtorLink)
	int                                                m_nGoalScoreOverride;                                     // 0x0294(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameConfig");
		return ptr;
	}


	void ApplyConfigOverride();
	void PostBeginPlay();
};


// Class TgGame.TgGameConfig_Battle
// 0x0048 (0x02E0 - 0x0298)
class ATgGameConfig_Battle : public ATgGameConfig
{
public:
	float                                              s_fMapLength;                                             // 0x0298(0x0004) (Edit)
	float                                              s_fTickCurrencyFreq;                                      // 0x029C(0x0004) (Edit)
	float                                              s_fCurrencyToGivePerTick;                                 // 0x02A0(0x0004) (Edit)
	float                                              s_fXpToGivePerTick;                                       // 0x02A4(0x0004) (Edit)
	int                                                s_nStartingCurrency;                                      // 0x02A8(0x0004) (Edit)
	int                                                s_nStartingLevel;                                         // 0x02AC(0x0004) (Edit)
	unsigned long                                      s_bSplitKillerXP : 1;                                     // 0x02B0(0x0004) (Edit)
	float                                              s_fMultiLaneXpBonus;                                      // 0x02B4(0x0004) (Edit)
	int                                                s_nNumLowestXPSpool;                                      // 0x02B8(0x0004) (Edit)
	float                                              s_fLowestXpTimeThreshold;                                 // 0x02BC(0x0004) (Edit)
	float                                              s_fLowestXpBonusMultiplier;                               // 0x02C0(0x0004) (Edit)
	float                                              s_fCatchupXPSpool;                                        // 0x02C4(0x0004) (Edit)
	float                                              s_fCatchupXPSpoolStartTime;                               // 0x02C8(0x0004) (Edit)
	float                                              s_fMinionKillerBonus;                                     // 0x02CC(0x0004) (Edit)
	float                                              s_fSetupTime;                                             // 0x02D0(0x0004) (Edit)
	float                                              s_fFireGiantRewardDuration;                               // 0x02D4(0x0004) (Edit)
	float                                              s_fBasePlayerGoldReward;                                  // 0x02D8(0x0004) (Edit)
	float                                              s_fGoldPercAfterTowerDmg;                                 // 0x02DC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameConfig_Battle");
		return ptr;
	}


	void ApplyConfigOverride();
};


// Class TgGame.TgGameConfig_Adventure
// 0x0054 (0x0334 - 0x02E0)
class ATgGameConfig_Adventure : public ATgGameConfig_Battle
{
public:
	TArray<int>                                        s_Currencies;                                             // 0x02E0(0x0010) (Edit, NeedCtorLink)
	int                                                s_nItemStoreId;                                           // 0x02F0(0x0004) (Edit)
	int                                                s_nDeathDebuff;                                           // 0x02F4(0x0004) (Edit)
	int                                                s_nPlayerModifier;                                        // 0x02F8(0x0004) (Edit)
	TArray<struct FQueueEffectMap>                     s_QueueEffects;                                           // 0x02FC(0x0010) (Edit, NeedCtorLink)
	TArray<struct FQueueEffectMap>                     s_QueueDeathEffects;                                      // 0x030C(0x0010) (Edit, NeedCtorLink)
	int                                                s_nMissionTime;                                           // 0x031C(0x0004) (Edit)
	TArray<int>                                        s_DisableHealthBars;                                      // 0x0320(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      s_bMustUnlockItems : 1;                                   // 0x0330(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameConfig_Adventure");
		return ptr;
	}


	void ApplyConfigOverride();
};


// Class TgGame.TgGameConfig_BotShop
// 0x0074 (0x0354 - 0x02E0)
class ATgGameConfig_BotShop : public ATgGameConfig_Battle
{
public:
	struct FBotShopBag                                 m_RootBag;                                                // 0x02E0(0x0030) (Edit, Const, NeedCtorLink)
	int                                                m_nReRollCost;                                            // 0x0310(0x0004) (Edit, Const)
	float                                              m_fIndividualEntryBias;                                   // 0x0314(0x0004) (Edit, Const)
	float                                              m_fRejectionBias;                                         // 0x0318(0x0004) (Edit, Const)
	float                                              m_fStarvationBias;                                        // 0x031C(0x0004) (Edit, Const)
	float                                              m_fUnderdogBias;                                          // 0x0320(0x0004) (Edit, Const)
	float                                              m_fUpgradeBias;                                           // 0x0324(0x0004) (Edit, Const)
	TArray<struct FArenaTeamSpawns>                    m_TeamStoreSpawns;                                        // 0x0328(0x0010) (Edit, Const, NeedCtorLink)
	int                                                m_nSurvialScore;                                          // 0x0338(0x0004) (Edit, Const)
	int                                                m_nDrawScore;                                             // 0x033C(0x0004) (Edit, Const)
	TEnumAsByte<EXpPurchaseType>                       m_eXpPurchase;                                            // 0x0340(0x0001) (Edit, Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0341(0x0003) MISSED OFFSET
	float                                              m_fXpPerc;                                                // 0x0344(0x0004) (Edit, Const)
	int                                                m_nXpFlat;                                                // 0x0348(0x0004) (Edit, Const)
	int                                                m_nXpCost;                                                // 0x034C(0x0004) (Edit, Const)
	int                                                m_nGoldShare;                                             // 0x0350(0x0004) (Edit, Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameConfig_BotShop");
		return ptr;
	}


	void STATIC_ChooseRandomBot(struct FBotShopBag* ParentBag, struct FBotShopUnit* ShopUnit);
	void STATIC_CalcAccumulativeWeights(struct FBotShopBag* ParentBag);
};


// Class TgGame.TgGameConfig_CartDefense
// 0x0090 (0x0370 - 0x02E0)
class ATgGameConfig_CartDefense : public ATgGameConfig_Battle
{
public:
	int                                                s_nNumRounds;                                             // 0x02E0(0x0004) (Edit, Const)
	int                                                s_nNumRoundRanks;                                         // 0x02E4(0x0004) (Edit, Const)
	int                                                s_nCurrencyId;                                            // 0x02E8(0x0004) (Edit, Const)
	int                                                s_nMissionTime;                                           // 0x02EC(0x0004) (Edit)
	TArray<struct FCartRoundValues>                    s_DifficultyTable;                                        // 0x02F0(0x0010) (Edit, NeedCtorLink)
	TArray<struct FCartRoundValues>                    s_ScoreTable;                                             // 0x0300(0x0010) (Edit, NeedCtorLink)
	float                                              s_fRoundBaseScore;                                        // 0x0310(0x0004) (Edit)
	float                                              s_fRoundPerfectScore;                                     // 0x0314(0x0004) (Edit)
	TArray<int>                                        s_DeathRankCutoffs;                                       // 0x0318(0x0010) (Edit, NeedCtorLink)
	TArray<float>                                      s_PillarHealthCutoffs;                                    // 0x0328(0x0010) (Edit, NeedCtorLink)
	TArray<float>                                      s_EndOfMatchRanks;                                        // 0x0338(0x0010) (Edit, NeedCtorLink)
	int                                                s_nBonusFoxPointsItemId;                                  // 0x0348(0x0004) (Edit)
	float                                              s_fBonusFoxPointsMultiplier;                              // 0x034C(0x0004) (Edit)
	TArray<float>                                      s_fRoundCumulativeMults;                                  // 0x0350(0x0010) (NeedCtorLink)
	TArray<int>                                        s_nRoundCachedRanks;                                      // 0x0360(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameConfig_CartDefense");
		return ptr;
	}


	int CalculateStarCount(float fTotalScore);
	float CalculateRoundScore(int nCurrentRound, int nCurrentRating);
	float STATIC_GetCumulativeMult(int nRound);
	float CalculateScoreMultiplier(int nCurrentRound, int nCurrentRating);
	float CalculateDifficultyMultiplier(int nCurrentRound, int nCurrentRating);
	int GetRoundRating(int nDeathCount, float fPillarHealthPerc);
	void ApplyConfigOverride();
};


// Class TgGame.TgGameConfig_MultiRounds
// 0x00C8 (0x03A8 - 0x02E0)
class ATgGameConfig_MultiRounds : public ATgGameConfig_Battle
{
public:
	TArray<struct FArenaTeamSpawns>                    m_TeamStoreSpawns;                                        // 0x02E0(0x0010) (Edit, NeedCtorLink)
	TArray<struct FEMR_SHOPINFO>                       m_ShopEndInfo;                                            // 0x02F0(0x0010) (Edit, NeedCtorLink)
	TArray<int>                                        m_ShopItemEffects;                                        // 0x0300(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ERoundStoreType>                       m_eStoreType;                                             // 0x0310(0x0001) (Edit)
	TEnumAsByte<EXpPurchaseType>                       m_eXpPurchase;                                            // 0x0311(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0312(0x0002) MISSED OFFSET
	TArray<int>                                        m_nLootTableIds;                                          // 0x0314(0x0010) (Edit, NeedCtorLink)
	TArray<int>                                        m_nNoNoLootTableIds;                                      // 0x0324(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               m_nmNoNoItemSets;                                         // 0x0334(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               m_nmNoDuplicateItemSets;                                  // 0x0344(0x0010) (Edit, NeedCtorLink)
	int                                                m_nSelectionCount;                                        // 0x0354(0x0004) (Edit)
	int                                                m_nReRollCost;                                            // 0x0358(0x0004) (Edit)
	int                                                m_nBankRollCost;                                          // 0x035C(0x0004) (Edit)
	float                                              m_fTierChances[0x3];                                      // 0x0360(0x0004) (Edit)
	TArray<struct FCustomChanceItem>                   m_CustomChanceItems;                                      // 0x036C(0x0010) (Edit, NeedCtorLink)
	float                                              m_fStarvationBias;                                        // 0x037C(0x0004) (Edit)
	float                                              m_fUnderdogBias;                                          // 0x0380(0x0004) (Edit)
	float                                              m_fRejectionBias;                                         // 0x0384(0x0004) (Edit)
	float                                              m_fUpgradeBias;                                           // 0x0388(0x0004) (Edit)
	float                                              m_fPopularityBias;                                        // 0x038C(0x0004) (Edit)
	int                                                m_nSurvialScore;                                          // 0x0390(0x0004) (Edit)
	int                                                m_nDrawScore;                                             // 0x0394(0x0004) (Edit)
	float                                              m_fXpPerc;                                                // 0x0398(0x0004) (Edit)
	int                                                m_nXpFlat;                                                // 0x039C(0x0004) (Edit)
	int                                                m_nXpCost;                                                // 0x03A0(0x0004) (Edit)
	int                                                m_nGoldShare;                                             // 0x03A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameConfig_MultiRounds");
		return ptr;
	}

};


// Class TgGame.TgGameConfig_PEP
// 0x0044 (0x0324 - 0x02E0)
class ATgGameConfig_PEP : public ATgGameConfig_Battle
{
public:
	TArray<struct FPEPRewardMap>                       s_CampRewards;                                            // 0x02E0(0x0010) (Edit, NeedCtorLink)
	TArray<struct FPEPUpgradeMap>                      s_UpgradeMaps;                                            // 0x02F0(0x0010) (Edit, NeedCtorLink)
	TArray<class ANavigationPoint*>                    m_BaseLocationList;                                       // 0x0300(0x0010) (Edit, NeedCtorLink)
	float                                              m_fGlobalJungleRespawnTime;                               // 0x0310(0x0004) (Edit)
	TArray<struct FPEPTeamSpawnModifier>               m_CampSpawnModifiers;                                     // 0x0314(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameConfig_PEP");
		return ptr;
	}


	int STATIC_GetSpawnModifierByTaskforce(int nTaskForceNum);
	void STATIC_FindTierDowngradeName(const struct FName& EntryTypeName, TEnumAsByte<EPEPRewardTier> eTier, struct FName* UpgradeName);
	void STATIC_FindTierUpgradeName(const struct FName& EntryTypeName, TEnumAsByte<EPEPRewardTier> eTier, struct FName* UpgradeName);
	void STATIC_GetDowngradeRewardMap(const struct FPEPRewardMap& SourceMap, struct FPEPRewardMap* OutMap);
	void STATIC_GenerateRewardPawnData(class ATgPawn* pRewardPawn, const struct FPEPRewardMap& InMap, struct FPEPRewardPawnData* OutData);
	void STATIC_GetUpgradeRewardMap(const struct FPEPRewardMap& SourceMap, struct FPEPRewardMap* OutMap);
	bool STATIC_FindRewardMapFromCamp(class ATgBotFactory_LeashedConfigurable* ParentCamp, struct FPEPRewardMap* OutMap);
	bool STATIC_FindRewardMapByTypeAndTier(TEnumAsByte<EPEPRewardType> eType, TEnumAsByte<EPEPRewardTier> eTier, struct FPEPRewardMap* OutMap);
	bool STATIC_FindRewardMapByProfileID(int nProfileId, struct FPEPRewardMap* OutMap);
	bool STATIC_FindRewardMapByName(const struct FName& EntryName, struct FPEPRewardMap* OutMap);
};


// Class TgGame.TgGameConfig_Rounds
// 0x0020 (0x0300 - 0x02E0)
class ATgGameConfig_Rounds : public ATgGameConfig_Battle
{
public:
	unsigned long                                      s_bRepeatListOnEnd : 1;                                   // 0x02E0(0x0004) (Edit)
	int                                                s_nWinningScore;                                          // 0x02E4(0x0004) (Edit)
	TArray<struct FBattleRoundConfig>                  s_RoundList;                                              // 0x02E8(0x0010) (Edit, NeedCtorLink)
	float                                              s_fRoundCooldown;                                         // 0x02F8(0x0004) (Edit)
	float                                              s_fRoundBlackout;                                         // 0x02FC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameConfig_Rounds");
		return ptr;
	}


	void ApplyConfigOverride();
};


// Class TgGame.TgGameConfig_CH08
// 0x0004 (0x0304 - 0x0300)
class ATgGameConfig_CH08 : public ATgGameConfig_Rounds
{
public:
	unsigned long                                      s_bPlayerKillsShouldSpawnGoo : 1;                         // 0x0300(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameConfig_CH08");
		return ptr;
	}


	void ApplyConfigOverride();
};


// Class TgGame.TgGameTipManager
// 0x0034 (0x0294 - 0x0260)
class ATgGameTipManager : public AActor
{
public:
	TArray<struct FTipSavedState>                      m_TipSavedState;                                          // 0x0260(0x0010) (Config, GlobalConfig, NeedCtorLink)
	TArray<struct FGameTipInfo>                        m_GameTipQueue;                                           // 0x0270(0x0010) (NeedCtorLink)
	unsigned long                                      m_bIsActive : 1;                                          // 0x0280(0x0004)
	class UTgAudioComponent*                           m_AudioComponent;                                         // 0x0284(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nActiveTip;                                             // 0x028C(0x0004)
	int                                                m_nPlaySoundTip;                                          // 0x0290(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameTipManager");
		return ptr;
	}


	int STATIC_GameTipQueueSort(const struct FGameTipInfo& A, const struct FGameTipInfo& B);
	void SortGameTipQueue();
	void SetActive();
	void UnsuppressAllGameTips();
	void STATIC_CompleteHelpText(int nGameTipId);
	void STATIC_SuppressHelpText(int nGameTipId);
	void STATIC_RemoveHelpText(int nGameTipId, bool bDoNotSuppress);
	void STATIC_DismissHelpText(int nGameTipId, bool bDoNotSuppress);
	bool STATIC_RequestHelpText(int nGameTipId, bool bIsFriend, bool bWaitForDismiss);
	bool IsSuppressed(int nGameTipId);
};


// Class TgGame.TgLargeGridMask
// 0x0000 (0x0060 - 0x0060)
class UTgLargeGridMask : public UObject
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgLargeGridMask");
		return ptr;
	}

};


// Class TgGame.TgMapInfo
// 0x003C (0x009C - 0x0060)
class UTgMapInfo : public UMapInfo
{
public:
	class AActor*                                      m_EndFocusActor_TF1;                                      // 0x0060(0x0008) (Edit)
	class AActor*                                      m_EndFocusActor_TF2;                                      // 0x0068(0x0008) (Edit)
	class AStaticMeshActor*                            m_OverlayPathMesh;                                        // 0x0070(0x0008) (Edit)
	struct FVector2D                                   m_vMapCenter;                                             // 0x0078(0x0008) (Edit)
	struct FVector2D                                   m_vTaskForce1BaseLocation;                                // 0x0080(0x0008) (Edit)
	struct FVector2D                                   m_vTaskForce2BaseLocation;                                // 0x0088(0x0008) (Edit)
	float                                              m_fLockViewBufferZoneSize;                                // 0x0090(0x0004) (Edit)
	unsigned long                                      m_bSupportsGuardianThrone : 1;                            // 0x0094(0x0004) (Edit)
	int                                                m_nDefaultMusicThemeItemId;                               // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMapInfo");
		return ptr;
	}

};


// Class TgGame.TgMinimapManager
// 0x006C (0x00CC - 0x0060)
class UTgMinimapManager : public UObject
{
public:
	TEnumAsByte<ETgMapTeam>                            m_LocalTeam;                                              // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	unsigned char                                      UnknownData01[0x48];                                      // 0x0061(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgMinimapManager.m_EntityMap
	unsigned long                                      m_bShouldDisableVisionRange : 1;                          // 0x00AC(0x0004)
	unsigned long                                      m_bSkipWorldGeometryLOS : 1;                              // 0x00AC(0x0004)
	unsigned long                                      m_bRequiresVisionUpdate : 1;                              // 0x00AC(0x0004)
	float                                              m_fFogOfWarAreaRevealTime;                                // 0x00B0(0x0004)
	float                                              m_fUpdateTimer;                                           // 0x00B4(0x0004)
	float                                              m_fLastEntityUpdateTime;                                  // 0x00B8(0x0004)
	TArray<class AReplicationInfo*>                    m_ReferencedRepInfos;                                     // 0x00BC(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMinimapManager");
		return ptr;
	}


	void InitForTaskforce(class ATgRepInfo_TaskForce* tf);
	void STATIC_ForceUpdate(class AReplicationInfo* ri);
	void STATIC_RemoveAllEntities();
	void UpdateThreaded();
	void Update(bool bForce);
};


// Class TgGame.TgPlayerBehaviorTracker
// 0x0034 (0x0294 - 0x0260)
class ATgPlayerBehaviorTracker : public AActor
{
public:
	int                                                s_nScores[0x8];                                           // 0x0260(0x0004)
	unsigned long                                      s_bIsConsole : 1;                                         // 0x0280(0x0004)
	unsigned long                                      s_bIsVGSThrottled : 1;                                    // 0x0280(0x0004)
	int                                                s_nVGSFloodCount;                                         // 0x0284(0x0004)
	unsigned char                                      s_bytPromptType;                                          // 0x0288(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0289(0x0003) MISSED OFFSET
	int                                                s_nRecordType;                                            // 0x028C(0x0004)
	float                                              s_fAFKTimer;                                              // 0x0290(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPlayerBehaviorTracker");
		return ptr;
	}


	void STATIC_TestAFK(class ATgPlayerController* TgPC);
	void AddVGSFlood();
	void STATIC_SetVGSThrottle(bool bIsThrottled);
	void STATIC_TakeActionsForCategory(TEnumAsByte<ETrackedBehaviorCategory> eBehaviorType, int nScore);
	int STATIC_CalcScoreForBehaviorType(TEnumAsByte<ETrackedBehaviorCategory> eBehaviorType);
	int STATIC_CalcFinalScore();
	struct FString LogScores();
	void AddBehaviorScore(TEnumAsByte<ETrackedBehaviorType> eTBT, int nScore);
};


// Class TgGame.TgRacingCheckpoint
// 0x0038 (0x0300 - 0x02C8)
class ATgRacingCheckpoint : public ASplineActor
{
public:
	class ATgVolume*                                   m_CollisionVolume;                                        // 0x02C8(0x0008) (Edit, Const)
	float                                              m_SegmentCalcLength;                                      // 0x02D0(0x0004) (Edit, Const)
	int                                                m_RacingIndex;                                            // 0x02D4(0x0004) (Edit, Const)
	TArray<struct FRaceSegmentData>                    m_Segments;                                               // 0x02D8(0x0010) (Transient, NeedCtorLink)
	TArray<class ATgPawn_Racer*>                       m_NearByPlayers;                                          // 0x02E8(0x0010) (Transient, NeedCtorLink)
	float                                              m_SegmentLength;                                          // 0x02F8(0x0004) (Transient)
	float                                              m_TotalPreviousDistance;                                  // 0x02FC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRacingCheckpoint");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_PrecalculateSegmentData();
	void PreBeginPlay();
	bool IsRacerNearby(class ATgPawn_Racer* Racer);
	struct FVector STATIC_CalculateForwardDirection(const struct FVector& TestLoc);
	void STATIC_CalculateLocalPosition(const struct FVector& TestLoc, float* Fwd);
};


// Class TgGame.TgRepInfo_CapturePoint
// 0x0024 (0x0284 - 0x0260)
class ATgRepInfo_CapturePoint : public AReplicationInfo
{
public:
	class ATgCapturePoint*                             r_OwningCapturePoint;                                     // 0x0260(0x0008) (Net)
	int                                                r_nUniqueCapturePointId;                                  // 0x0268(0x0004) (Net)
	int                                                r_nControlledByTaskForce;                                 // 0x026C(0x0004) (Net)
	float                                              r_fOwnershipPct;                                          // 0x0270(0x0004) (Net)
	int                                                r_nTransitionDirection;                                   // 0x0274(0x0004) (Net)
	unsigned long                                      r_bIsLocked : 1;                                          // 0x0278(0x0004) (Net)
	class UTgSeqEvent_ControlPointOwnershipPercent*    c_OwnershipPercentKismetNode;                             // 0x027C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_CapturePoint");
		return ptr;
	}


	int GetCapturePointIndex();
	void OnOwnershipPctChanged();
	void STATIC_OnTaskForceControlChanged();
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetCurrentLocation();
	void UpdateCapturePointControlUI(int Index);
};


// Class TgGame.TgRepInfo_CH08_GooSpawner
// 0x07D0 (0x0A30 - 0x0260)
class ATgRepInfo_CH08_GooSpawner : public AReplicationInfo
{
public:
	class ATgActor_CH08_GooSpawner*                    r_GooSpawnerOwner;                                        // 0x0260(0x0008) (Net)
	unsigned long                                      c_bReceivedOwner : 1;                                     // 0x0268(0x0004)
	struct FVector                                     r_ApproxLocation;                                         // 0x026C(0x000C) (Net)
	struct FCH08_GOO_EVENT                             r_NewGooEvent[0x14];                                      // 0x0278(0x001C) (Net)
	struct FCH08_GOO_EVENT                             c_PriorGooEvent[0x14];                                    // 0x04A8(0x001C)
	int                                                c_nPriorGooUpdateIndex;                                   // 0x06D8(0x0004)
	int                                                s_nNewGooUpdateIndex;                                     // 0x06DC(0x0004)
	int                                                s_nNewGooId;                                              // 0x06E0(0x0004)
	struct FCH08_GOO_SPAWNER_EVENT                     r_NewSpawnerEvent[0x14];                                  // 0x06E4(0x0014) (Net)
	struct FCH08_GOO_SPAWNER_EVENT                     c_PriorSpawnerEvent[0x14];                                // 0x0874(0x0014)
	int                                                c_nPriorSpawnerUpdateIndex;                               // 0x0A04(0x0004)
	int                                                s_nNewSpawnerUpdateIndex;                                 // 0x0A08(0x0004)
	int                                                s_nNewSpawnerId;                                          // 0x0A0C(0x0004)
	TArray<struct FCH08_GOO_FX>                        c_ActiveGooFx;                                            // 0x0A10(0x0010) (NeedCtorLink)
	TArray<struct FCH08_CLIENT_SPAWNER>                c_GooSpawners;                                            // 0x0A20(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_CH08_GooSpawner");
		return ptr;
	}


	void UpdateGooSpawnerLocation();
	void STATIC_ReceivedGooSpawnerOwner();
	void CleanUpSpawner(int nSpawnerIndex);
	void CleanUpGooFx(int nGooFxIndex);
	void Destroyed();
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetCurrentLocation();
	int STATIC_GetNewGooId();
	int STATIC_GetGooFxIndex(const struct FCH08_GOO_EVENT& gooEvent);
	void STATIC_CloseGooEvent(const struct FCH08_GOO_EVENT& gooEvent);
	void STATIC_StartGooEvent(const struct FCH08_GOO_EVENT& newGooEvent);
	void STATIC_GooEventUpdate();
	void STATIC_FlashGooEvent(const struct FCH08_GOO_EVENT& newGooEvent);
	void STATIC_SendCloseGooSpot(const struct FCH08_GOO_SPOT& closedGooSpot);
	void STATIC_SendNewGooSpot(const struct FCH08_GOO_SPOT& newGooSpot);
	int STATIC_GetNewSpawnerId();
	int STATIC_GetSpawnerIndex(int nSpawnerId);
	void STATIC_CloseSpawnerEvent(const struct FCH08_GOO_SPAWNER_EVENT& spawnerEvent);
	void STATIC_StartSpawnerEvent(const struct FCH08_GOO_SPAWNER_EVENT& newSpawnerEvent);
	void STATIC_SpawnerEventUpdate();
	void STATIC_FlashSpawnerEvent(const struct FCH08_GOO_SPAWNER_EVENT& newSpawnerEvent);
	void UnregisterGooSpawner(class ATgCollisionProxy_CH08* closedProxy);
	void STATIC_RegisterNewGooSpawner(class ATgCollisionProxy_CH08* newProxy);
};


// Class TgGame.TgRepInfo_Deployable
// 0x0198 (0x03F8 - 0x0260)
class ATgRepInfo_Deployable : public AReplicationInfo
{
public:
	int                                                r_nHealthCurrent;                                         // 0x0260(0x0004) (Net)
	int                                                r_nHealthMaximum;                                         // 0x0264(0x0004) (Net)
	float                                              r_fDeployMaxHealthPCT;                                    // 0x0268(0x0004) (Net)
	int                                                r_nDeployableId;                                          // 0x026C(0x0004) (Net)
	int                                                r_nUniqueDeployableId;                                    // 0x0270(0x0004) (Net)
	float                                              r_fLifespanInitial;                                       // 0x0274(0x0004) (Net)
	float                                              r_fLifespanSync;                                          // 0x0278(0x0004) (Net)
	class ATgDeployable*                               r_DeployableOwner;                                        // 0x027C(0x0008) (Net)
	class ATgRepInfo_Player*                           r_InstigatorInfo;                                         // 0x0284(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_TaskforceInfo;                                          // 0x028C(0x0008) (Net)
	unsigned long                                      r_bOwnedByTaskforce : 1;                                  // 0x0294(0x0004) (Net)
	unsigned long                                      c_bReceivedOwner : 1;                                     // 0x0294(0x0004)
	unsigned long                                      r_bMinimapOnlyOwnerSee : 1;                               // 0x0294(0x0004) (Net)
	unsigned long                                      r_bOverlayAlwaysVisible : 1;                              // 0x0294(0x0004) (Net)
	unsigned long                                      r_bInDestroyedState : 1;                                  // 0x0294(0x0004) (Net)
	unsigned long                                      c_bShowHUDLifespanTimer : 1;                              // 0x0294(0x0004)
	unsigned long                                      bIsTargeted : 1;                                          // 0x0294(0x0004) (Transient)
	struct FVector                                     r_ApproxLocation;                                         // 0x0298(0x000C) (Net)
	struct FTG_HUD_INFO                                c_HudInfo;                                                // 0x02A4(0x0140) (NeedCtorLink)
	unsigned char                                      r_bVisibleOnMap[0x6];                                     // 0x03E4(0x0001) (Net)
	TEnumAsByte<EOverlayType>                          r_bOverlayType;                                           // 0x03EA(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x03EB(0x0001) MISSED OFFSET
	float                                              r_fVisionRange;                                           // 0x03EC(0x0004) (Net)
	class UClass*                                      r_cMinimapOnlyClassSee;                                   // 0x03F0(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Deployable");
		return ptr;
	}


	void LifespanTimer();
	void UpdateLifespanTimer();
	void STATIC_SyncLifespanTimer();
	void STATIC_StartLifespanTimer(float fTime);
	void UpdateDeployableLocation();
	void STATIC_ReceivedDeployableOwner();
	void ReplicatedEvent(const struct FName& VarName);
	void Destroyed();
	void PostBeginPlay();
	void STATIC_CheckNotifyGroupChanged();
	bool IsVisibleToLocalPlayer();
	bool IsVisibleToPlayer(class ATgRepInfo_Player* PRI);
	bool IsVisibleToMapTeam(TEnumAsByte<ETgMapTeam> MAPTEAM);
	bool IsVisibleToAnEnemyTeam();
	void UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
	float STATIC_GetMaxLifespan();
	float STATIC_GetLifespan();
	int STATIC_GetCurrentMaxHealth();
	int STATIC_GetCurrentHealth();
	struct FVector STATIC_GetCurrentLocation();
	void STATIC_SetTaskForce(class ATgRepInfo_TaskForce* tf);
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce();
};


// Class TgGame.TgRepInfo_CTF_Flag
// 0x000C (0x0404 - 0x03F8)
class ATgRepInfo_CTF_Flag : public ATgRepInfo_Deployable
{
public:
	class ATgPawn*                                     r_CurrentCarrier;                                         // 0x03F8(0x0008) (Net)
	unsigned long                                      r_bAtBase : 1;                                            // 0x0400(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_CTF_Flag");
		return ptr;
	}


	bool IsVisibleToLocalPlayer();
	int STATIC_GetFlagState(class ATgRepInfo_Player* PRI);
	bool IsOwnedByPlayer(class ATgRepInfo_Player* PRI);
};


// Class TgGame.TgRepInfo_CTF_FlagBase
// 0x0000 (0x03F8 - 0x03F8)
class ATgRepInfo_CTF_FlagBase : public ATgRepInfo_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_CTF_FlagBase");
		return ptr;
	}


	int STATIC_GetBaseState(class ATgRepInfo_Player* PRI);
};


// Class TgGame.TgRepInfo_CH05_IceChains
// 0x0000 (0x03F8 - 0x03F8)
class ATgRepInfo_CH05_IceChains : public ATgRepInfo_CTF_FlagBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_CH05_IceChains");
		return ptr;
	}


	int STATIC_GetBaseState(class ATgRepInfo_Player* PRI);
};


// Class TgGame.TgRepInfo_Deployable_Simulated
// 0x0000 (0x03F8 - 0x03F8)
class ATgRepInfo_Deployable_Simulated : public ATgRepInfo_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Deployable_Simulated");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_Portal
// 0x000C (0x0404 - 0x03F8)
class ATgRepInfo_Portal : public ATgRepInfo_Deployable
{
public:
	class ATgRepInfo_Portal*                           r_TwinDRI;                                                // 0x03F8(0x0008) (Net)
	unsigned long                                      c_bMasterEntity : 1;                                      // 0x0400(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Portal");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_Ward
// 0x0008 (0x0400 - 0x03F8)
class ATgRepInfo_Ward : public ATgRepInfo_Deployable
{
public:
	float                                              r_MinimapDetectionRange;                                  // 0x03F8(0x0004) (Net)
	unsigned long                                      r_bRequireLOS : 1;                                        // 0x03FC(0x0004) (Net)
	unsigned long                                      s_bTeleportIncoming : 1;                                  // 0x03FC(0x0004)
	unsigned long                                      s_bRevealOtherWards : 1;                                  // 0x03FC(0x0004)
	unsigned long                                      s_bMustBeRevealed : 1;                                    // 0x03FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Ward");
		return ptr;
	}


	float GetMinimapDetectionRange();
	void UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
};


// Class TgGame.TgRepInfo_TriggerableWard
// 0x000C (0x040C - 0x0400)
class ATgRepInfo_TriggerableWard : public ATgRepInfo_Ward
{
public:
	unsigned long                                      r_IsTriggered : 1;                                        // 0x0400(0x0004) (Net)
	unsigned long                                      r_bRevealOnlyOnTrigger : 1;                               // 0x0400(0x0004)
	class ATgRepInfo_Player*                           r_TriggererPRI;                                           // 0x0404(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_TriggerableWard");
		return ptr;
	}


	float GetMinimapDetectionRange();
};


// Class TgGame.TgRepInfo_WayPoint
// 0x0000 (0x03F8 - 0x03F8)
class ATgRepInfo_WayPoint : public ATgRepInfo_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_WayPoint");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_DeviceVolume
// 0x0038 (0x0298 - 0x0260)
class ATgRepInfo_DeviceVolume : public AReplicationInfo
{
public:
	int                                                r_nUniqueDevVolId;                                        // 0x0260(0x0004) (Net)
	int                                                r_nMapInfoIndex;                                          // 0x0264(0x0004) (Net)
	class ATgDeviceVolume*                             r_DeviceVolume;                                           // 0x0268(0x0008) (Net)
	unsigned char                                      r_bytActiveStates;                                        // 0x0270(0x0001) (Net)
	unsigned char                                      c_bytClientActiveStates;                                  // 0x0271(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0272(0x0002) MISSED OFFSET
	float                                              c_fActiveStartTime[0x8];                                  // 0x0274(0x0004)
	unsigned long                                      c_bTFRegistered : 1;                                      // 0x0294(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_DeviceVolume");
		return ptr;
	}


	void AttemptRegister();
	void UpdateVisuals();
	void SetActiveState(unsigned char eStateFlags, bool bEnable);
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
};


// Class TgGame.TgRepInfo_Factory
// 0x0078 (0x02D8 - 0x0260)
class ATgRepInfo_Factory : public AReplicationInfo
{
public:
	TEnumAsByte<EReplicatedFactoryState>               s_FactoryState;                                           // 0x0260(0x0001)
	TEnumAsByte<EReplicatedFactoryState>               r_FactoryState[0x6];                                      // 0x0261(0x0001) (Net)
	unsigned char                                      r_bVisibleOnMap[0x6];                                     // 0x0267(0x0001) (Net)
	unsigned char                                      r_bRespawnVisible[0x6];                                   // 0x026D(0x0001) (Net)
	TEnumAsByte<EMinimapFactoryType>                   r_MinimapType;                                            // 0x0273(0x0001) (Net)
	class ATgActorFactory*                             r_FactoryOwner;                                           // 0x0274(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_TaskforceInfo;                                          // 0x027C(0x0008) (Net)
	int                                                r_nFactoryId;                                             // 0x0284(0x0004) (Net)
	class AReplicationInfo*                            r_LastSpawnedRepInfo;                                     // 0x0288(0x0008) (Net)
	float                                              r_fRespawnDelay;                                          // 0x0290(0x0004) (Net)
	float                                              r_fRespawnTimer;                                          // 0x0294(0x0004) (Net)
	unsigned long                                      r_bFirstSpawnWave : 1;                                    // 0x0298(0x0004) (Net)
	unsigned long                                      r_bBlockRespawnMesh : 1;                                  // 0x0298(0x0004) (Net)
	unsigned long                                      r_bSpawnModified : 1;                                     // 0x0298(0x0004) (Net)
	unsigned long                                      r_bFullVisibility : 1;                                    // 0x0298(0x0004) (Net)
	TArray<class ATgPawn*>                             m_TrackedPawns;                                           // 0x029C(0x0010) (NeedCtorLink)
	int                                                r_nTotalSpawns;                                           // 0x02AC(0x0004) (Net)
	int                                                r_nTotalDeaths;                                           // 0x02B0(0x0004) (Net)
	int                                                r_nTotalEmpties;                                          // 0x02B4(0x0004) (Net)
	float                                              r_fModifiedSpawnDuration;                                 // 0x02B8(0x0004) (Net)
	float                                              r_fModifiedSpawnTimer;                                    // 0x02BC(0x0004) (Net)
	float                                              r_fPreSpawnDuration;                                      // 0x02C0(0x0004) (Net)
	float                                              r_fPreSpawnTimer;                                         // 0x02C4(0x0004) (Net)
	class ATgRepInfo_Deployable*                       r_DroppedBuff;                                            // 0x02C8(0x0008) (Net)
	class ATgPawn*                                     r_ClearedBy;                                              // 0x02D0(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Factory");
		return ptr;
	}


	void SetCampKiller(class ATgPawn* ClearedBy);
	void UpdateOwnedMeshes();
	void UpdateFactoryPlaceHolderMesh();
	void RemoveTrackedPawn(class ATgPawn* Pawn);
	void AddTrackedPawn(class ATgPawn* Pawn);
	void StopPreSpawnTimer();
	void UpdatePreSpawnTimer();
	void StartPreSpawnTimer(float fSeconds);
	void StopSpawnModifiedTimer();
	void UpdateSpawnModifiedTimer();
	void StartSpawnModifiedTimer(float fSeconds);
	void StopRespawnTimer();
	void UpdateRespawnTimer();
	void StartRespawnTimer(float fSeconds);
	void UpdateInWorldIndicators();
	void Destroyed();
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void STATIC_InitFor(class ATgActorFactory* Factory);
	float STATIC_GetModifiedSpawnElapsedPercent();
	float STATIC_GetPreSpawnElapsedPercent();
	float STATIC_GetRespawnElapsedPercent();
	bool IsVisibleToLocalPlayer();
	void STATIC_CheckAlignedTaskforceRespawnVisbility();
	void UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
};


// Class TgGame.TgRepInfo_Game
// 0x01AC (0x0494 - 0x02E8)
class ATgRepInfo_Game : public APComRepInfo_Game
{
public:
	TArray<struct FGraphData>                          m_GraphData;                                              // 0x02E8(0x0010) (NeedCtorLink)
	struct FGraphData                                  r_LastDataPoint;                                          // 0x02F8(0x000C)
	float                                              m_GraphUpdateWaitTime;                                    // 0x0304(0x0004)
	int                                                m_nQuestId;                                               // 0x0308(0x0004)
	int                                                m_nQuestCount;                                            // 0x030C(0x0004)
	int                                                m_nQuestGoal;                                             // 0x0310(0x0004)
	TEnumAsByte<ETG_GAME_TYPE>                         r_GameType;                                               // 0x0314(0x0001) (Net)
	TEnumAsByte<ETG_GAME_SEASONAL>                     r_GameSeason;                                             // 0x0315(0x0001) (Net)
	TEnumAsByte<EMissionTimerState>                    r_nMissionTimerState;                                     // 0x0316(0x0001) (Net)
	TEnumAsByte<EGameTimerState>                       r_eGameTimerState;                                        // 0x0317(0x0001) (Net)
	TEnumAsByte<EFlagState>                            r_FlagState[0x2];                                         // 0x0318(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x031A(0x0002) MISSED OFFSET
	unsigned long                                      r_bIsMission : 1;                                         // 0x031C(0x0004) (Net)
	unsigned long                                      r_bIsRanked : 1;                                          // 0x031C(0x0004) (Net)
	unsigned long                                      r_bIntroPlayed : 1;                                       // 0x031C(0x0004) (Net)
	unsigned long                                      r_bEnableDistanceFOW : 1;                                 // 0x031C(0x0004) (Net)
	unsigned long                                      r_bAllowMultiTeamSpectating : 1;                          // 0x031C(0x0004) (Net)
	unsigned long                                      m_bDeadPlayersIgnoreIdle : 1;                             // 0x031C(0x0004)
	unsigned long                                      r_bCinematicHidesNameplates : 1;                          // 0x031C(0x0004) (Net)
	unsigned long                                      r_bHideEnemyNameplates : 1;                               // 0x031C(0x0004) (Net)
	unsigned long                                      r_bDevFeaturesEnabled : 1;                                // 0x031C(0x0004) (Net)
	unsigned long                                      r_bAllowResellAll : 1;                                    // 0x031C(0x0004) (Net)
	unsigned long                                      m_bFinalizedProcessors : 1;                               // 0x031C(0x0004)
	float                                              r_fMissionRemainingTime;                                  // 0x0320(0x0004) (Net)
	int                                                r_nMissionTimerStateChange;                               // 0x0324(0x0004) (Net)
	float                                              r_fMissionTime;                                           // 0x0328(0x0004) (Net)
	float                                              c_fMissionTime;                                           // 0x032C(0x0004)
	float                                              c_fMissionTimeSeconds;                                    // 0x0330(0x0004)
	int                                                r_nCapturePoints[0x5];                                    // 0x0334(0x0004)
	class ATgRepInfo_TaskForce*                        r_Winner;                                                 // 0x0348(0x0008) (Net)
	float                                              r_fPhysicsThreshold;                                      // 0x0350(0x0004) (Net)
	struct FString                                     r_sQueueName;                                             // 0x0354(0x0010) (Net, NeedCtorLink)
	int                                                r_nPauseMode;                                             // 0x0364(0x0004) (Net)
	int                                                r_nPausedTF;                                              // 0x0368(0x0004) (Net)
	int                                                r_nMaxInvItems;                                           // 0x036C(0x0004) (Net)
	int                                                r_nLockedDevices;                                         // 0x0370(0x0004) (Net)
	int                                                r_nNeutralTaskForceNumber;                                // 0x0374(0x0004) (Net)
	TArray<class ATgDeployable*>                       m_Deployables;                                            // 0x0378(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgProjectile*>                       m_Projectiles;                                            // 0x0388(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgDestructible*>                     m_Destructibles;                                          // 0x0398(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgBotFactory*>                       m_BotFactories;                                           // 0x03A8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgRepInfo_Deployable*>               m_DRIArray;                                               // 0x03B8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgRepInfo_DeathFog*>                 m_FogRIArray;                                             // 0x03C8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ATgRepInfo_CapturePoint*>             m_CPRIArray;                                              // 0x03D8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                r_nCurrentCheckpoint[0x2];                                // 0x03E8(0x0004) (Net, Transient)
	int                                                c_nNextClientOnlyProjectileInstanceId;                    // 0x03F0(0x0004) (Transient)
	int                                                r_BannedGodsList[0xA];                                    // 0x03F4(0x0004) (Net)
	int                                                r_nGameTipId;                                             // 0x041C(0x0004) (Net)
	int                                                r_nRoundTitleId;                                          // 0x0420(0x0004) (Net)
	int                                                r_nCurrentRound;                                          // 0x0424(0x0004) (Net)
	int                                                r_nStoreOverrideId;                                       // 0x0428(0x0004) (Net)
	int                                                r_nStoreNoNoOverrideId;                                   // 0x042C(0x0004) (Net)
	int                                                r_nStoreAllowFullRefund;                                  // 0x0430(0x0004) (Net)
	float                                              r_fGameCustomVals[0xA];                                   // 0x0434(0x0004) (Net)
	TArray<TScriptInterface<class UTgPawnSingletonProcessor>> m_PawnCentralProcessors;                                  // 0x045C(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_DeferredActorsToProcess;                                // 0x046C(0x0010) (NeedCtorLink)
	float                                              m_fForceFinalizeProcessorsTime;                           // 0x047C(0x0004) (Const)
	TArray<TScriptInterface<class UTgOwnedPlaceableMesh>> c_OwnedMeshList;                                          // 0x0480(0x0010) (NeedCtorLink)
	int                                                r_nConfigurableMeshID;                                    // 0x0490(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game");
		return ptr;
	}


	void ResetGameProperties(bool bScoreReset);
	float GetMissionTime();
	void SetCheckpoint(int NewCheckpoint, int TaskForce);
	bool STATIC_FlagIsDown(int TeamIndex);
	void STATIC_SetFlagDown(int TeamIndex);
	bool STATIC_FlagIsHeldEnemy(int TeamIndex);
	void STATIC_ProcessMissionTimerEvent(int nEventId, int nWinningTaskForce);
	void SendMissionTimerEvent(int nEventId, int nWinningTaskForce);
	void STATIC_SetFlagHeldEnemy(int TeamIndex);
	bool STATIC_FlagIsHeldFriendly(int TeamIndex);
	void STATIC_SetFlagHeldFriendly(int TeamIndex);
	bool STATIC_FlagsAreHome();
	bool STATIC_FlagIsHome(int TeamIndex);
	void STATIC_SetFlagHome(int TeamIndex);
	int GetNextClientOnlyProjectileInstanceId();
	void STATIC_RemoveDestructible(class ATgDestructible* Dest);
	void AddDestructible(class ATgDestructible* Dest);
	void STATIC_RemoveCPRI(class ATgRepInfo_CapturePoint* CPRI);
	void AddCPRI(class ATgRepInfo_CapturePoint* CPRI);
	void STATIC_RemoveFogRI(class ATgRepInfo_DeathFog* FogRI);
	void AddFogRI(class ATgRepInfo_DeathFog* FogRI);
	void STATIC_RemoveDRI(class ATgRepInfo_Deployable* dri);
	void AddDRI(class ATgRepInfo_Deployable* dri);
	void MissionTimeUpdateAllClients();
	void UpdateMissionTimer();
	void STATIC_InitMissionTime();
	void PostBeginPlay();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateConfigurableMeshes();
	void RegisterOwnedPlaceableMesh(const TScriptInterface<class UTgOwnedPlaceableMesh>& tgMeshActor);
	void STATIC_FinalizeProcessors();
	void UnregisterDeferredActorForProcessing(class AActor* DeferredActor);
	void STATIC_RegisterDeferredActorForProcessing(class AActor* defferedActor);
	void STATIC_RegisterPawnForProcessing(class ATgPawn* pawnType);
	class ATgPawn* NativeFindPawnById(int nPawnId);
	bool IsTraining();
	int STATIC_GetOverriddenWinningTF();
	void STATIC_PushNewStore(int nStoreId);
	bool IsItemAvailable(int nItemId);
	bool STATIC_OverridesItemAvailibility();
	void STATIC_RefreshCTFMeshes();
	void UpdateRoundUI();
	TEnumAsByte<EMAP_LANE> STATIC_GetLane(int nLane, class ATgRepInfo_TaskForce* tfri);
	class ATgProj_Simulated* STATIC_SpawnSimulatedProjectile(int nProjectileInstanceId, int nFireModeId, class AActor* pOwner, const struct FVector& vLocation, const struct FVector& vRotation, int nProjectileIdOverride);
	class ATgProj_Simulated* STATIC_GetSimulatedProjectile(int nProjectileId);
	void UpdateBannedGodsList();
	void UpdateQuest(int Id, int Count, int Goal, int msgId);
	void STATIC_GameBansUpdate();
	void GameTypeSet();
	void STATIC_GameStateChanged();
	void UpdateGameTransitionUI();
	void UpdateGameScoreUI();
	void UpdateGameClockUI();
	bool AreTaskForcesEnemies(class ATgRepInfo_TaskForce* TaskForceA, class ATgRepInfo_TaskForce* TaskForceB);
	bool CheckIsEnemy(class AActor* A, class AActor* B);
	bool STATIC_TaskForceEnumerate(bool bPlayerOnly, class ATgRepInfo_TaskForce** rpTaskForce, int* rnTaskForceNum);
	class ATgRepInfo_TaskForce* STATIC_CreateTaskForce(int nTaskForceNum);
	class ATgRepInfo_TaskForce* STATIC_GetTaskForce(int nTaskForceNum, bool bCreate);
	class ATgRepInfo_TaskForce* STATIC_GetTaskForceFor(class AActor* Actor);
	class ATgProjectile* GetProjectile(int nIndex);
	class ATgDeployable* STATIC_GetDeployable(int nIndex);
	int STATIC_GetDeployableCount();
};


// Class TgGame.TgRepInfo_Game_AdvCart
// 0x0028 (0x04BC - 0x0494)
class ATgRepInfo_Game_AdvCart : public ATgRepInfo_Game
{
public:
	int                                                r_nStoreList[0xA];                                        // 0x0494(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_AdvCart");
		return ptr;
	}


	void STATIC_PushNewStore(int nStoreId);
	bool IsItemAvailable(int nItemId);
	bool STATIC_OverridesItemAvailibility();
};


// Class TgGame.TgRepInfo_Game_Battle_Round
// 0x0050 (0x04E4 - 0x0494)
class ATgRepInfo_Game_Battle_Round : public ATgRepInfo_Game
{
public:
	class ATgRepInfo_TaskForce*                        r_RankedTeams[0xA];                                       // 0x0494(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_Battle_Round");
		return ptr;
	}


	void STATIC_ProcessBattleRoundStateChange(int nEventId);
	void SendBattleRoundStateEvent(int nEventId);
	int STATIC_GetOverriddenWinningTF();
	void UpdateRankedTeams();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgRepInfo_Game_MultiRounds
// 0x0044 (0x0528 - 0x04E4)
class ATgRepInfo_Game_MultiRounds : public ATgRepInfo_Game_Battle_Round
{
public:
	struct FArenaMatchup                               r_MultiRoundArenas[0x4];                                  // 0x04E4(0x0010) (Net)
	int                                                r_nCurrentRoundCount;                                     // 0x0524(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_MultiRounds");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgRepInfo_Game_PEP
// 0x0010 (0x04F4 - 0x04E4)
class ATgRepInfo_Game_PEP : public ATgRepInfo_Game_Battle_Round
{
public:
	float                                              r_fGlobalJungleRespawnTime;                               // 0x04E4(0x0004) (Net)
	float                                              m_fGlobalJungleRespawnTimerPercent;                       // 0x04E8(0x0004)
	unsigned long                                      r_bStartGlobalJungleTimer : 1;                            // 0x04EC(0x0004) (Net)
	int                                                r_nRestartJungleTimer;                                    // 0x04F0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Game_PEP");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	class ATgRepInfo_TaskForce* STATIC_CreateTaskForce(int nTaskForceNum);
	float STATIC_GetGlobalJungleRespawnElapsedPercent();
	void STATIC_GlobalJungleRespawnTimer();
	void STATIC_DisplayDebugScore(class UCanvas* HUDCanvas, class ATgPawn* HUDOwner);
};


// Class TgGame.TgRepInfo_GPBVolume
// 0x000C (0x026C - 0x0260)
class ATgRepInfo_GPBVolume : public AReplicationInfo
{
public:
	class ATgVolume_GroundPlacementBlocker*            r_GPBVol;                                                 // 0x0260(0x0008) (Net)
	unsigned long                                      r_bIsBlockingGroundPlacement : 1;                         // 0x0268(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_GPBVolume");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgRepInfo_OwnedMesh
// 0x0010 (0x0270 - 0x0260)
class ATgRepInfo_OwnedMesh : public AReplicationInfo
{
public:
	class ATgPawn*                                     r_PawnOwner;                                              // 0x0260(0x0008) (Net)
	class AActor*                                      r_LinkedActor;                                            // 0x0268(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_OwnedMesh");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgRepInfo_Player
// 0x0F34 (0x1394 - 0x0460)
class ATgRepInfo_Player : public APlayerReplicationInfo
{
public:
	int                                                r_nPlayerId;                                              // 0x0460(0x0004) (Net)
	int                                                r_nPawnId;                                                // 0x0464(0x0004) (Net)
	int                                                r_nPortalId;                                              // 0x0468(0x0004) (Net)
	unsigned long                                      r_bForceNotBot : 1;                                       // 0x046C(0x0004) (Net)
	unsigned long                                      r_bToxicityShadowBan : 1;                                 // 0x046C(0x0004) (Net)
	unsigned long                                      r_bIsInCombat : 1;                                        // 0x046C(0x0004) (Net)
	unsigned long                                      r_bIsInGodCombat : 1;                                     // 0x046C(0x0004) (Net)
	unsigned long                                      r_bMapHasLoaded : 1;                                      // 0x046C(0x0004) (Net)
	unsigned long                                      r_bWantsPause : 1;                                        // 0x046C(0x0004) (Net)
	unsigned long                                      r_bHasBeenSeenByEnemyTeam : 1;                            // 0x046C(0x0004) (Net)
	unsigned long                                      r_bHasFlag : 1;                                           // 0x046C(0x0004) (Net, Transient)
	unsigned long                                      m_bRegisteredForVoice : 1;                                // 0x046C(0x0004)
	unsigned long                                      r_bHasRegisteredForVoiceLocally : 1;                      // 0x046C(0x0004) (Net)
	unsigned long                                      r_bIsMemberOfTaskForce : 1;                               // 0x046C(0x0004) (Net)
	unsigned long                                      c_bSpeaking : 1;                                          // 0x046C(0x0004)
	unsigned long                                      r_bDropped : 1;                                           // 0x046C(0x0004) (Net)
	unsigned long                                      r_bDisconnected : 1;                                      // 0x046C(0x0004) (Net)
	unsigned long                                      c_bIsDying : 1;                                           // 0x046C(0x0004)
	unsigned long                                      r_bIsStealthed : 1;                                       // 0x046C(0x0004) (Net)
	unsigned long                                      r_bStealthBrokenByWard : 1;                               // 0x046C(0x0004)
	unsigned long                                      r_bIsRecalling : 1;                                       // 0x046C(0x0004) (Net)
	unsigned long                                      r_bHideOnMinimap : 1;                                     // 0x046C(0x0004) (Net)
	unsigned long                                      r_bHasFakeName : 1;                                       // 0x046C(0x0004) (Net)
	int                                                s_nChatRestrictionLevel;                                  // 0x0470(0x0004)
	float                                              c_fLastUpdateTime;                                        // 0x0474(0x0004)
	int                                                r_nHealthCurrent;                                         // 0x0478(0x0004) (Net)
	int                                                r_nHealthMaximum;                                         // 0x047C(0x0004) (Net)
	struct FVector                                     r_ApproxLocation;                                         // 0x0480(0x000C) (Net)
	int                                                r_nPowerCurrent;                                          // 0x048C(0x0004) (Net)
	int                                                r_nPowerMaximum;                                          // 0x0490(0x0004) (Net)
	int                                                r_nPacingType;                                            // 0x0494(0x0004) (Net)
	int                                                r_nShieldCurrent;                                         // 0x0498(0x0004) (Net)
	int                                                r_nShieldMaximum;                                         // 0x049C(0x0004) (Net)
	class ATgRepInfo_Player*                           r_MasterPrep;                                             // 0x04A0(0x0008) (Net)
	class ATgRepInfo_TaskForce*                        r_TaskForce;                                              // 0x04A8(0x0008) (Net)
	class ATgTeamPlayerStart*                          r_SpawnPoint;                                             // 0x04B0(0x0008) (Net)
	float                                              r_fReviveSecs;                                            // 0x04B8(0x0004) (Net)
	unsigned char                                      r_nSurrenderVote;                                         // 0x04BC(0x0001) (Net)
	unsigned char                                      r_bVisibleOnMap[0x6];                                     // 0x04BD(0x0001) (Net)
	unsigned char                                      r_nVisibilityMask;                                        // 0x04C3(0x0001) (Net)
	unsigned char                                      s_nPreferedMask;                                          // 0x04C4(0x0001)
	unsigned char                                      r_DeviceTiers[0x1F];                                      // 0x04C5(0x0001) (Net)
	unsigned char                                      s_IsRevealed[0x6];                                        // 0x04E4(0x0001)
	unsigned char                                      s_ShouldSurpressRevealSound[0x6];                         // 0x04EA(0x0001)
	TArray<class ATgRepInfo_Player*>                   m_PRIArray;                                               // 0x04F0(0x0010) (NeedCtorLink)
	TArray<class ATgRepInfo_Deployable*>               m_DRIArray;                                               // 0x0500(0x0010) (NeedCtorLink)
	class ATgRepInfo_Player*                           c_PriorMasterPrep;                                        // 0x0510(0x0008)
	class ATgRepInfo_TaskForce*                        c_PriorTaskForce;                                         // 0x0518(0x0008)
	int                                                c_fLastHealth;                                            // 0x0520(0x0004)
	float                                              c_fLastDamageTime;                                        // 0x0524(0x0004)
	float                                              r_fVisionRange;                                           // 0x0528(0x0004) (Net)
	class ATgCarriedFlag*                              s_CarriedFlag;                                            // 0x052C(0x0008) (Transient)
	struct FString                                     r_ClanTag;                                                // 0x0534(0x0010) (Net, AlwaysInit, NeedCtorLink)
	int                                                r_ClanId;                                                 // 0x0544(0x0004) (Net)
	struct FString                                     c_PlayerNameWithTag;                                      // 0x0548(0x0010) (AlwaysInit, NeedCtorLink)
	struct FString                                     c_PlayerNameWithTagAndTitle;                              // 0x0558(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                c_PlayerNameTagFormat;                                    // 0x0568(0x0004)
	int                                                r_Scores[0x17];                                           // 0x056C(0x0004) (Net)
	int                                                r_PlayerCustomValsInt[0x8];                               // 0x05C8(0x0004) (Net)
	float                                              r_PlayerCustomValsFloat[0x8];                             // 0x05E8(0x0004) (Net)
	struct FDeviceTeamInfo                             r_PlayerDevices[0x1F];                                    // 0x0608(0x0054) (Net)
	int                                                r_bDeviceIsReady;                                         // 0x1034(0x0004) (Net)
	float                                              c_fDeviceReadyInSecs[0x1F];                               // 0x1038(0x0004)
	float                                              c_fDeviceCooldown[0x1F];                                  // 0x10B4(0x0004)
	float                                              r_fUltReadyInSecs;                                        // 0x1130(0x0004) (Net)
	float                                              r_fActivesReadyInSecs[0x3];                               // 0x1134(0x0004) (Net)
	float                                              c_fLastSpeakingTime;                                      // 0x1140(0x0004)
	int                                                r_nXp;                                                    // 0x1144(0x0004) (Net)
	int                                                r_nLevel;                                                 // 0x1148(0x0004) (Net)
	int                                                r_nProfileId;                                             // 0x114C(0x0004) (Net)
	int                                                c_nSavedSkinId;                                           // 0x1150(0x0004)
	int                                                r_nSkinId;                                                // 0x1154(0x0004) (Net)
	class ATgPawn*                                     r_PawnOwner;                                              // 0x1158(0x0008) (Net)
	int                                                r_nLaneId;                                                // 0x1160(0x0004) (Net)
	int                                                r_nNearbyCount;                                           // 0x1164(0x0004) (Net)
	class ATgRepInfo_Factory*                          s_FactoryInfo;                                            // 0x1168(0x0008)
	int                                                s_KillOrDeathStreakModifier;                              // 0x1170(0x0004)
	struct FsPingInfo                                  r_PingInfo[0x4];                                          // 0x1174(0x0020) (Net)
	struct FVector                                     c_DeathLocation;                                          // 0x11F4(0x000C)
	struct FTG_HUD_INFO                                c_HudInfo;                                                // 0x1200(0x0140) (NeedCtorLink)
	TArray<struct FSocialEmoteInfo>                    m_SocialEmotes;                                           // 0x1340(0x0010) (NeedCtorLink)
	struct FGodEnabledItem                             r_GodEnabledItemList[0x8];                                // 0x1350(0x0008) (Net)
	struct Fdword                                      r_nLayeredBuffEffects;                                    // 0x1390(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Player");
		return ptr;
	}


	void SetHideOnMinimap(bool bHideOnMinimap);
	void STATIC_DestroyTgPRI();
	void UnregisterPlayerFromSession();
	void RegisterAsRemoteTalker();
	void STATIC_ServerNotifyLocallyRegisteredForVoice();
	void STATIC_OnRegisterLocalTalkerComplete(unsigned char LocalUserNum, bool bWasSuccessful);
	void RegisterAsLocalTalker(unsigned char ControllerId);
	void UpdateDeviceReadyTimer(float fTimeRemaining, TEnumAsByte<ETG_EQUIP_POINT> eqpPoint);
	void STATIC_SetFlag(class ATgCarriedFlag* NewFlag);
	void OnDeath();
	void TransferMinionOwnershipTo(class ATgRepInfo_Player* NewOwner);
	void CopyProperties(class APlayerReplicationInfo* PRI);
	void STATIC_OverrideWith(class APlayerReplicationInfo* PRI);
	class APlayerReplicationInfo* Duplicate();
	bool STATIC_ShouldBroadCastWelcomeMessage(bool bExiting);
	class ATgPawn* STATIC_FindLocalPlayerPawn();
	class APlayerController* STATIC_FindLocalController();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdatedTaskForce();
	void UpdatedApproxLocation();
	void UpdatedHealthCurrent();
	unsigned char STATIC_GetTaskForceNumber();
	void UpdateShield(int nCurrentShield, int nMaxShield);
	void UpdatePower(int nCurrentPower, int nMaxPower);
	void UpdateHealth(int nCurrentHealth, int nMaxHealth);
	void UpdatePlayerLocation();
	void UpdateIdAndProfile();
	void Timer();
	void STATIC_RecalculateTeamColor();
	void ClientInitialize(class AController* C);
	void TimerIsInGodCombat();
	void TimerIsInCombat();
	void PostBeginPlay();
	void UpdateTaskForceUI();
	void STATIC_ClearGodEnabledItemList();
	void STATIC_RemoveGodEnabledItemId(int nItemId);
	void AddGodEnabledItemId(int nItemId, unsigned char eTargeterType);
	void STATIC_SetPawnOwner(class ATgPawn* tgPawnOwner);
	void STATIC_SetSpawnPoint(class ATgTeamPlayerStart* tgTPS);
	void STATIC_ForcePrepForDestroy();
	void STATIC_SetBotRankIdFromProfileId();
	void SetFactoryInfo(class ATgRepInfo_Factory* factorInfo);
	void STATIC_GetPlayableVGSEmotes(TArray<struct FSocialEmoteInfo>* PlayableVGSEmotes);
	bool STATIC_CanPlayEmote(TEnumAsByte<EEmote> Emote);
	void UpdatePlayerSocialEmotes();
	void UpdatePlayerNameWithTag();
	void UpdatePlayerReady();
	void UpdatePauseVoting();
	void UpdateSurrenderVoting();
	void STATIC_ClientUpdateItemStoreItems();
	bool SetTaskForceNumber(unsigned char nTaskForce, bool bForce);
	void STATIC_SetVisibilityMask(unsigned char NewMask);
	void UpdateMapVisibility(TEnumAsByte<ETgMapTeam> MAPTEAM, unsigned char bVisible, float fVisionRange, bool bDetected);
	void UpdatePingInfo(class ATgRepInfo_Player* pingedPri, const struct FVector& pingedLoc, TEnumAsByte<EPING_TYPE> Type);
	void STATIC_CheckPingingList();
	bool IsVisibleToLocalPlayer();
	bool IsVisibleToPlayer(class ATgRepInfo_Player* PRI);
	bool IsVisibleToMapTeam(TEnumAsByte<ETgMapTeam> MAPTEAM);
	bool IsVisibleToAnEnemyTeam();
	bool STATIC_HasBeenSeenByEnemyTeam();
	void UpdateFX();
	void UpdatePlayerInfoUI();
	void UpdateSpectatorUI();
	struct FString STATIC_GetPlayerNameForMsgDisplay(bool bBaseNameOnly);
	void TryRegisterRemoteForVoice();
	void TryRegisterSelfForVoice();
	bool IsReadyToPause();
	bool IsDeviceReady(TEnumAsByte<ETG_EQUIP_POINT> eqpPoint);
	void UpdateDeviceIsReady(TEnumAsByte<ETG_EQUIP_POINT> eqpPoint, float fCooldownSecs);
	bool IsHardStealthedClient();
	bool IsStealthedClient();
	struct FVector STATIC_GetCurrentLocation();
	int STATIC_GetCurrentMaxShield();
	int STATIC_GetCurrentShield();
	int STATIC_GetCurrentMaxPower();
	int STATIC_GetCurrentPower();
	int STATIC_GetCurrentMaxHealth();
	int STATIC_GetCurrentHealth();
	void STATIC_CheckMembership();
	void STATIC_RemoveMinion(class AReplicationInfo* pRepInfo);
	void AddMinion(class AReplicationInfo* pRepInfo);
	void SetTeam(class ATgRepInfo_TaskForce* pNewTeamRep);
	void UpdateBroadcastedItems(class ATgInventoryManager* invMgr);
	void UpdateLevel();
	void UpdateScoreboard();
	int STATIC_GetPlayerId();
	bool IsGodDecoy();
	bool IsGod();
	bool STATIC_IsBot();
	bool IsFriendlyWithLocalPlayer();
};


// Class TgGame.TgRepInfo_Player_BotShop
// 0x01EC (0x1580 - 0x1394)
class ATgRepInfo_Player_BotShop : public ATgRepInfo_Player
{
public:
	struct FBotUnit                                    r_BotsActive[0xA];                                        // 0x1394(0x000C) (Net)
	struct FBotUnit                                    r_BotsInactive[0xA];                                      // 0x140C(0x000C) (Net)
	struct FBotBuffPair                                r_BotBuffMap[0x14];                                       // 0x1484(0x0008) (Net)
	TArray<class UTgEffectGroup*>                      s_EffectGroupList;                                        // 0x1524(0x0010) (NeedCtorLink)
	struct FBotUnit                                    r_AvailableBots[0x6];                                     // 0x1534(0x000C) (Net)
	int                                                s_nCurrencyDeficit;                                       // 0x157C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Player_BotShop");
		return ptr;
	}


	void UpdateUnitShopUI(TEnumAsByte<EBotInventoryReplicationType> Type);
	void ReplicatedEvent(const struct FName& VarName);
	void UpdatePlayerStoreWithRandomizedBotShop(class ATgInventory_RandomizedBotShop* RandomBotShop);
	int STATIC_GetUnitPrice(int nBotId);
	class UTgEffectGroup* STATIC_GetEffectGroup(int nEffectGroupId);
	void STATIC_ResetAllPurchases();
	bool STATIC_CanPurchase(int nCost);
	void AdjustCurrency(int nCost);
	void STATIC_SwapUnitPosition(int nInitPosition, bool bInitIsActiveSlot, int nFinalPosition, bool bFinalIsActiveSlot);
	void BuffUnit(struct FBotUnit* BotUnitEntry);
	void STATIC_SellUnit(int nPosition, bool bIsActiveSlot, struct FBotUnit* BotUnitEntry);
	void STATIC_PurchaseUnit(int nShopIndex, int nPosition, bool bIsActiveSlot, struct FBotUnit* BotUnitEntry);
};


// Class TgGame.TgRepInfo_Player_PEP
// 0x0058 (0x13EC - 0x1394)
class ATgRepInfo_Player_PEP : public ATgRepInfo_Player
{
public:
	struct FPEPRewardPawnData                          r_EntourageSpecialUnitData[0x2];                          // 0x1394(0x0020) (Net)
	class ATgGame_Battle_PEP*                          m_CachedGame;                                             // 0x13D4(0x0008)
	class ATgGameConfig_PEP*                           m_CachedConfig;                                           // 0x13DC(0x0008)
	class ATgRepInfo_TaskForce_PEP*                    r_PEPTaskForce;                                           // 0x13E4(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Player_PEP");
		return ptr;
	}


	bool SetTaskForceNumber(unsigned char nTaskForce, bool bForce);
	int STATIC_FindOldestEntourageIndex();
	int STATIC_FindLowestHealthEntourageIndex();
	int STATIC_FindLowestTierEntourageIndex();
	int STATIC_GetLowestTierTypedEntourageIndex(const struct FPEPRewardMap& InRewardMap);
	int STATIC_GetHighestTierTypedEntourageIndex(const struct FPEPRewardMap& InRewardMap);
	bool STATIC_CheckDuplicateEntourageData(int nPawnId);
	void STATIC_SortEntourageData();
	void STATIC_RemoveEntourageDataByID(int nPawnId, int nRemoveLimit);
	void STATIC_RemoveEntourageData(class ATgPawn* pPawn);
	void AddEntourageData(class ATgPawn* pPawn, const struct FPEPRewardMap& InMap);
};


// Class TgGame.TgRepInfo_Player_Store
// 0x0274 (0x1608 - 0x1394)
class ATgRepInfo_Player_Store : public ATgRepInfo_Player
{
public:
	struct FPlayerStoreItemList                        r_AvailableItems;                                         // 0x1394(0x00CC) (Net)
	struct FPlayerStoreItemList                        r_AvailableConsumables;                                   // 0x1460(0x00CC) (Net)
	struct FPlayerStoreItemList                        r_AvailableRelics;                                        // 0x152C(0x00CC) (Net)
	int                                                r_nReRollCost;                                            // 0x15F8(0x0004) (Const, Net)
	int                                                r_nTeamScore;                                             // 0x15FC(0x0004) (Net)
	unsigned char                                      r_nTeamRank;                                              // 0x1600(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x1601(0x0003) MISSED OFFSET
	unsigned long                                      bNetItemsDirty : 1;                                       // 0x1604(0x0004)
	unsigned long                                      bNetConsumablesDirty : 1;                                 // 0x1604(0x0004)
	unsigned long                                      bNetRelicsDirty : 1;                                      // 0x1604(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Player_Store");
		return ptr;
	}


	void STATIC_OnStoreListsChanged(TEnumAsByte<EStoreReplicationType> Type);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_RepopulatePlayerStoreItemList(TArray<int> nItemList, struct FPlayerStoreItemList* StoreList);
	void UpdatePlayerStoreWithRandomizedShop(class ATgInventory_RandomizedShop* randomShop);
};


// Class TgGame.TgRepInfo_TaskForce
// 0x0130 (0x03B0 - 0x0280)
class ATgRepInfo_TaskForce : public ATeamInfo
{
public:
	struct FString                                     c_fsName;                                                 // 0x0280(0x0010) (NeedCtorLink)
	int                                                r_nTeamId;                                                // 0x0290(0x0004) (Net)
	int                                                r_nLeaderPlayerId;                                        // 0x0294(0x0004) (Net)
	unsigned char                                      r_nTaskForce;                                             // 0x0298(0x0001) (Net)
	TEnumAsByte<ETgMapTeam>                            r_MapTeam;                                                // 0x0299(0x0001) (Net)
	unsigned char                                      s_nUsedGodVisionMask;                                     // 0x029A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x029B(0x0001) MISSED OFFSET
	int                                                s_nTaskForceChatId;                                       // 0x029C(0x0004)
	int                                                s_nStrikeForceId;                                         // 0x02A0(0x0004)
	int                                                s_nTaskTeamNum;                                           // 0x02A4(0x0004)
	struct FColor                                      m_Color;                                                  // 0x02A8(0x0004)
	unsigned long                                      r_bIsSurrendering : 1;                                    // 0x02AC(0x0004) (Net)
	unsigned long                                      r_bPauseVoting : 1;                                       // 0x02AC(0x0004) (Net)
	unsigned long                                      r_bSpectator : 1;                                         // 0x02AC(0x0004) (Net)
	unsigned long                                      m_bDestroyOnEmpty : 1;                                    // 0x02AC(0x0004)
	unsigned long                                      s_bUnbalancedSurrender : 1;                               // 0x02AC(0x0004)
	int                                                s_nPlayerStartCount;                                      // 0x02B0(0x0004)
	TArray<struct FTGTEAM_ENTRY>                       m_TeamPlayers;                                            // 0x02B4(0x0010) (NeedCtorLink)
	TArray<struct FTGTEAM_ENTRY>                       m_TeamBots;                                               // 0x02C4(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_OrderedTeamPlayers;                                     // 0x02D4(0x0010) (NeedCtorLink)
	TArray<class ATgRepInfo_Factory*>                  m_Factories;                                              // 0x02E4(0x0010) (NeedCtorLink)
	TArray<class ATgBotFactory_Minions*>               m_MinionFactories;                                        // 0x02F4(0x0010) (NeedCtorLink)
	TArray<class ATgRepInfo_DeviceVolume*>             m_DeviceVolumes;                                          // 0x0304(0x0010) (NeedCtorLink)
	TArray<struct FTEAMTIMEMANAGER_ENTRY>              s_TeamTimerManagers;                                      // 0x0314(0x0010) (NeedCtorLink)
	class UTgAIInfluenceMap*                           s_InfluenceMap;                                           // 0x0324(0x0008)
	class UTgMinimapManager*                           s_MinimapManager;                                         // 0x032C(0x0008)
	int                                                r_nScore;                                                 // 0x0334(0x0004) (Net)
	int                                                r_nScorePercent;                                          // 0x0338(0x0004) (Net)
	int                                                r_nGoldBuffCount;                                         // 0x033C(0x0004) (Net)
	TArray<struct FGLOBALEFFECT_ENTRY>                 m_GlobalEffectGroups;                                     // 0x0340(0x0010) (NeedCtorLink)
	int                                                m_nTowersKilled;                                          // 0x0350(0x0004)
	int                                                m_nPhoenixCount;                                          // 0x0354(0x0004)
	int                                                r_nGodKillCount;                                          // 0x0358(0x0004) (Net)
	int                                                r_nFireGiantKills;                                        // 0x035C(0x0004) (Net)
	int                                                r_nGoldFuryKills;                                         // 0x0360(0x0004) (Net)
	int                                                r_nClearedCampCount;                                      // 0x0364(0x0004) (Net)
	int                                                m_nLastGodIndex;                                          // 0x0368(0x0004)
	int                                                m_nLastGodList;                                           // 0x036C(0x0004)
	TArray<TScriptInterface<class UTgOwnedPlaceableMesh>> c_OwnedMeshList;                                          // 0x0370(0x0010) (NeedCtorLink)
	class ATgPawn*                                     r_RepresentingPawn;                                       // 0x0380(0x0008) (Net)
	float                                              r_fTFCustomVals[0xA];                                     // 0x0388(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_TaskForce");
		return ptr;
	}


	void SetRepresentingPawn(class ATgPawn* tgPawnRep);
	void RegisterOwnedPlaceableMesh(const TScriptInterface<class UTgOwnedPlaceableMesh>& tgOwnedMesh);
	void NotifyScoreChange();
	class ATgPlayerController* STATIC_FindLocalPlayerController();
	void UpdateKismetOnScore();
	void ReplicatedEvent(const struct FName& VarName);
	void ReceivedTaskForceNumber();
	void ReceivedScoringChanges();
	bool STATIC_HasActivePlayers();
	void STATIC_RemoveFromTeam(class AController* Other);
	void CreateInfluenceMaps();
	void STATIC_CreateMinimap(TEnumAsByte<ETgMapTeam> Team, class UClass* managerClass);
	void PostDemoRewind();
	void SetStartingScore();
	void STATIC_RemoveDevVolRI(class ATgRepInfo_DeviceVolume* DevVolRI);
	void AddDevVolRI(class ATgRepInfo_DeviceVolume* DevVolRI);
	void PostInit();
	bool STATIC_HasRankedPauseException();
	class ATgRepInfo_Player* STATIC_FindFlagCarrier();
	class ATgPawn* STATIC_GetASiegeWeapon();
	int LaneOfSiegeWeapon();
	class ATgRepInfo_Player* STATIC_GetNextGod(bool bIncrement, bool bReset);
	void STATIC_ResetGodIterator();
	class ATgRepInfo_Player* STATIC_GetGod(int nIndex);
	int STATIC_GetGodCount();
	void STATIC_RemoveAllGlobalEffectGroups();
	void STATIC_ReapplyGlobalEffectGroups();
	void STATIC_RemoveGlobalEffectGroups(class ATgPawn_Character* aPawn);
	void ApplyGlobalEffectGroups(class ATgPawn_Character* aPawn);
	void STATIC_RemoveGlobalEffectGroup(int nEffectGroupId);
	void AddGlobalEffectGroup(class UTgEffectGroup* eg, class ATgPawn* InstigatorPawn);
	void UpdateTaskForceUI();
	bool IsReadyToPause();
	void UpdatePauseTimer();
	void UpdateSurrenderTimer();
	void STATIC_TeamRemoveFrom(class AController* Other);
	bool IsLeader(class ATgRepInfo_Player* pTgPri);
	class ATgBotFactory_Minions* STATIC_GetMinionFactory(int nIndex);
	class ATgRepInfo_Player* STATIC_GetBot(int nIndex);
	class ATgRepInfo_Player* STATIC_GetPlayerById(int nPawnId);
	class ATgRepInfo_Player* STATIC_GetPlayer(int nIndex);
	int STATIC_GetMinionFactoryCount();
	int STATIC_GetDeadBotCount();
	int STATIC_GetAliveBotCount();
	int STATIC_GetBotCount();
	int STATIC_GetDisconnectedPlayerCount();
	int STATIC_GetActivePlayerCount();
	int STATIC_GetDeadPlayerCount();
	int STATIC_GetAlivePlayerCount();
	int GetPlayerCount();
	bool STATIC_RepEvent(const struct FName& VarName);
	class ATgRepInfo_Player* STATIC_CycleFrom(class ATgRepInfo_Player* pFrom, bool bForward);
};


// Class TgGame.TgRepInfo_TaskForce_PEP
// 0x02B4 (0x0664 - 0x03B0)
class ATgRepInfo_TaskForce_PEP : public ATgRepInfo_TaskForce
{
public:
	class ATgGame_Battle_PEP*                          m_CachedGame;                                             // 0x03B0(0x0008)
	class ATgGameConfig_PEP*                           m_CachedConfig;                                           // 0x03B8(0x0008)
	TArray<struct FPEPRewardEntry>                     m_LaneSpecialRewardEntries;                               // 0x03C0(0x0010) (NeedCtorLink)
	struct FPEPRewardEntry                             r_LaneSpecialUnitEntries;                                 // 0x03D0(0x0014) (Net)
	struct FPEPRewardPawnData                          r_IndependentSpecialUnitData[0x14];                       // 0x03E4(0x0020) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_TaskForce_PEP");
		return ptr;
	}


	void UpdateTFScore();
	void STATIC_RemoveIndependentData(class ATgPawn* pPawn);
	void AddIndependentData(const struct FPEPRewardPawnData& newData);
	void STATIC_RemoveLaneData();
	void AddLaneData(const struct FPEPRewardMap& rewardMap);
	void STATIC_RemoveRewardData(class ATgPawn* pOwnerPawn, class ATgPawn* rewardPawn);
	void AddRewardData(class ATgPawn* pOwnerPawn, class ATgPawn* rewardPawn);
};


// Class TgGame.TgRepInfo_VolumeTimedKill
// 0x0130 (0x0390 - 0x0260)
class ATgRepInfo_VolumeTimedKill : public AReplicationInfo
{
public:
	struct FTimedKillInfo                              r_TimedKillEvents[0xA];                                   // 0x0260(0x0018) (Net)
	int                                                s_nQueueIndex;                                            // 0x0350(0x0004)
	int                                                s_nKillInstance;                                          // 0x0354(0x0004)
	int                                                c_nFlashedInstances[0xA];                                 // 0x0358(0x0004)
	TArray<class ATgVolume_TimedKill*>                 s_RegisteredVolumes;                                      // 0x0380(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_VolumeTimedKill");
		return ptr;
	}


	void RegisterVolume(class ATgVolume_TimedKill* tkVol);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SpawnKillMesh(const struct FTimedKillInfo& tkInfo);
	void STATIC_RegisterKillInfo(const struct FTimedKillInfo& tkInfo);
	void STATIC_FlashKillEvent(class ATgPawn* PawnTarget, int nMeshId);
};


// Class TgGame.TgRepInfo_VortexVolume
// 0x0035 (0x0295 - 0x0260)
class ATgRepInfo_VortexVolume : public AReplicationInfo
{
public:
	class ATgVolume_Vortex*                            r_VortVol;                                                // 0x0260(0x0008) (Net)
	struct FVector                                     r_vDirection;                                             // 0x0268(0x000C) (Net)
	unsigned long                                      r_bRadiallyIn : 1;                                        // 0x0274(0x0004) (Net)
	unsigned long                                      r_bStayOn : 1;                                            // 0x0274(0x0004) (Net)
	float                                              r_fIntensity;                                             // 0x0278(0x0004) (Net)
	float                                              r_fWarmupTime;                                            // 0x027C(0x0004) (Net)
	float                                              r_fPersistDuration;                                       // 0x0280(0x0004) (Net)
	float                                              r_fRampdownTime;                                          // 0x0284(0x0004) (Net)
	float                                              r_fMovementPercMaintained;                                // 0x0288(0x0004)
	float                                              m_fStateTimer;                                            // 0x028C(0x0004)
	float                                              m_fCurrentIntensity;                                      // 0x0290(0x0004)
	TEnumAsByte<EVortexVolumeState>                    r_eVortexState;                                           // 0x0294(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_VortexVolume");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgRoundSchedule
// 0x0014 (0x0274 - 0x0260)
class ATgRoundSchedule : public AActor
{
public:
	TArray<struct FArenaRoundInfo>                     RoundSchedule;                                            // 0x0260(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bLoopSchedule : 1;                                      // 0x0270(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRoundSchedule");
		return ptr;
	}


	void PostBeginPlay();
};


// Class TgGame.TgSurvivalFogVolumeDensityInfo
// 0x0028 (0x029C - 0x0274)
class ATgSurvivalFogVolumeDensityInfo : public AFogVolumeSphericalDensityInfo
{
public:
	unsigned long                                      m_bFogOn : 1;                                             // 0x0274(0x0004)
	float                                              m_fTargetStartDistance;                                   // 0x0278(0x0004)
	float                                              m_fPreviousStartDistance;                                 // 0x027C(0x0004)
	float                                              m_fFogUpdateTimestamp;                                    // 0x0280(0x0004)
	float                                              m_fFogUpdateInterval;                                     // 0x0284(0x0004)
	float                                              m_fConvergenceRate;                                       // 0x0288(0x0004)
	float                                              m_fFadeInRate;                                            // 0x028C(0x0004)
	float                                              m_fFadeOutRate;                                           // 0x0290(0x0004)
	class UFogVolumeSphericalDensityComponent*         SphericalDensityComponent;                                // 0x0294(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSurvivalFogVolumeDensityInfo");
		return ptr;
	}


	void Tick(float DeltaTime);
	void STATIC_ConvergeFog(float fNewStartDistance, float interval, bool bForce);
	void ToggleFog(bool bOn);
	void PostBeginPlay();
	void STATIC_BypassInterpolatedRendering();
};


// Class TgGame.TgAchievement
// 0x0024 (0x0084 - 0x0060)
class UTgAchievement : public UObject
{
public:
	struct FPointer                                    m_pActivity;                                              // 0x0060(0x0008) (Native)
	struct FPointer                                    m_pGoal;                                                  // 0x0068(0x0008) (Native)
	class ATgPlayerController*                         Controller;                                               // 0x0070(0x0008)
	unsigned long                                      m_bCustomValue3IsBotId : 1;                               // 0x0078(0x0004) (Const)
	int                                                m_nBotId;                                                 // 0x007C(0x0004)
	int                                                m_nGameModeLock;                                          // 0x0080(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement");
		return ptr;
	}


	void STATIC_StopTracking();
	bool BelongsToBot(int BotID);
	float STATIC_GetCustomValue5();
	float STATIC_GetCustomValue4();
	float STATIC_GetCustomValue3();
	float STATIC_GetCustomValue2();
	float STATIC_GetCustomValue1();
};


// Class TgGame.TgAchievement_AbilityCombo
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_AbilityCombo : public UTgAchievement
{
public:
	int                                                m_nDevice1Id;                                             // 0x0084(0x0004)
	int                                                m_nDevice2Id;                                             // 0x0088(0x0004)
	int                                                m_nTargetGoal;                                            // 0x008C(0x0004)
	int                                                m_nSuccessCount;                                          // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AbilityCombo");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AbilityMultiHit
// 0x002C (0x00B0 - 0x0084)
class UTgAchievement_AbilityMultiHit : public UTgAchievement
{
public:
	TArray<struct FDeviceEffectPair>                   m_PostPairs;                                              // 0x0084(0x0010) (NeedCtorLink)
	TArray<struct FDeviceHitInfo>                      s_CurrentTrackedInfo;                                     // 0x0094(0x0010) (NeedCtorLink)
	unsigned long                                      m_bCheckPawn : 1;                                         // 0x00A4(0x0004)
	unsigned long                                      m_bCheckDevice : 1;                                       // 0x00A4(0x0004)
	unsigned long                                      m_bCheckHitPawn : 1;                                      // 0x00A4(0x0004)
	unsigned long                                      m_bCheckCustom : 1;                                       // 0x00A4(0x0004)
	unsigned long                                      m_bCheckEffects : 1;                                      // 0x00A4(0x0004)
	unsigned long                                      m_bCustomValue2IsDeviceId : 1;                            // 0x00A4(0x0004)
	unsigned long                                      m_bCustomValue3IsEffectId : 1;                            // 0x00A4(0x0004)
	int                                                m_nDeviceId;                                              // 0x00A8(0x0004)
	int                                                m_nEffectId;                                              // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AbilityMultiHit");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AbilityMultiHeal
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_AbilityMultiHeal : public UTgAchievement_AbilityMultiHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AbilityMultiHeal");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AbilityMultiHit_MultiDeviceMultiEffect
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_AbilityMultiHit_MultiDeviceMultiEffect : public UTgAchievement_AbilityMultiHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AbilityMultiHit_MultiDeviceMultiEffect");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AbilityMultiHit_SingleDeviceSingleEffect
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_AbilityMultiHit_SingleDeviceSingleEffect : public UTgAchievement_AbilityMultiHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AbilityMultiHit_SingleDeviceSingleEffect");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AbilityMultiKill
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_AbilityMultiKill : public UTgAchievement_AbilityMultiHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AbilityMultiKill");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MatchHitsByDevice
// 0x0004 (0x00B4 - 0x00B0)
class UTgAchievement_MatchHitsByDevice : public UTgAchievement_AbilityMultiHit
{
public:
	int                                                m_nNumHits;                                               // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MatchHitsByDevice");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MatchHitsByDevice_AnyTarget
// 0x0000 (0x00B4 - 0x00B4)
class UTgAchievement_MatchHitsByDevice_AnyTarget : public UTgAchievement_MatchHitsByDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MatchHitsByDevice_AnyTarget");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AbilityUnderEffectCat
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_AbilityUnderEffectCat : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nEffectCategory;                                        // 0x0088(0x0004)
	int                                                m_nTargetGoal;                                            // 0x008C(0x0004)
	int                                                m_nSuccessCount;                                          // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AbilityUnderEffectCat");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Adv_ModeWins
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Adv_ModeWins : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Adv_ModeWins");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Adv_RacerWins
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Adv_RacerWins : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Adv_RacerWins");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AfterEffect
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_AfterEffect : public UTgAchievement
{
public:
	int                                                m_nLastScorerPawnId;                                      // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AfterEffect");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AssaultJumpParty
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_AssaultJumpParty : public UTgAchievement
{
public:
	int                                                m_nTargetCount;                                           // 0x0084(0x0004)
	int                                                m_nSuccessCount;                                          // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AssaultJumpParty");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AssistsAfterEvent
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_AssistsAfterEvent : public UTgAchievement
{
public:
	float                                              m_fAllotedTime;                                           // 0x0084(0x0004)
	float                                              s_fRemainingTime;                                         // 0x0088(0x0004)
	int                                                m_nRequiredAssists;                                       // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AssistsAfterEvent");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AssistsAfterDevFire
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_AssistsAfterDevFire : public UTgAchievement_AssistsAfterEvent
{
public:
	int                                                m_nDeviceId;                                              // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AssistsAfterDevFire");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BeastMaster
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_BeastMaster : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BeastMaster");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BotByTime
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_BotByTime : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BotByTime");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ClassKiller
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_ClassKiller : public UTgAchievement
{
public:
	int                                                m_nTargetRoleId;                                          // 0x0084(0x0004)
	int                                                m_currentKillCount;                                       // 0x0088(0x0004)
	int                                                m_nTargetKillCount;                                       // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ClassKiller");
		return ptr;
	}

};


// Class TgGame.TgAchievement_CTF_CapInOT
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_CTF_CapInOT : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CTF_CapInOT");
		return ptr;
	}

};


// Class TgGame.TgAchievement_CTF_CarriersKilledPerMatch
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_CTF_CarriersKilledPerMatch : public UTgAchievement
{
public:
	int                                                s_nCarriersKilled;                                        // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CTF_CarriersKilledPerMatch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_CTF_FlagsCaptured
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_CTF_FlagsCaptured : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CTF_FlagsCaptured");
		return ptr;
	}

};


// Class TgGame.TgAchievement_CTF_NoPressure
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_CTF_NoPressure : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CTF_NoPressure");
		return ptr;
	}

};


// Class TgGame.TgAchievement_CTF_SelfCapPreTime
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_CTF_SelfCapPreTime : public UTgAchievement
{
public:
	unsigned long                                      s_bGrabbedInBase : 1;                                     // 0x0084(0x0004)
	float                                              s_fGrabbedAt;                                             // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CTF_SelfCapPreTime");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeathFromAbove
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_DeathFromAbove : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeathFromAbove");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Destructible
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Destructible : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Destructible");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceCleanseStun
// 0x0020 (0x00A4 - 0x0084)
class UTgAchievement_DeviceCleanseStun : public UTgAchievement
{
public:
	int                                                m_GoalAmount;                                             // 0x0084(0x0004)
	int                                                m_DeviceId;                                               // 0x0088(0x0004)
	int                                                m_TargetCount;                                            // 0x008C(0x0004)
	int                                                m_FiringInstance;                                         // 0x0090(0x0004)
	TArray<class ATgPawn*>                             m_CleanseTargets;                                         // 0x0094(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceCleanseStun");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceEffectDuration
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_DeviceEffectDuration : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nEffectCategory;                                        // 0x0088(0x0004)
	float                                              m_fGoalTime;                                              // 0x008C(0x0004)
	float                                              m_fStartTime;                                             // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceEffectDuration");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceHitAtDistance
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_DeviceHitAtDistance : public UTgAchievement
{
public:
	int                                                m_nHitCount;                                              // 0x0084(0x0004)
	int                                                m_DeviceId;                                               // 0x0088(0x0004)
	int                                                m_HitGoal;                                                // 0x008C(0x0004)
	float                                              m_MinDistance;                                            // 0x0090(0x0004)
	float                                              m_MaxDistance;                                            // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceHitAtDistance");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceHitAtDistance_GodsOnly
// 0x0000 (0x0098 - 0x0098)
class UTgAchievement_DeviceHitAtDistance_GodsOnly : public UTgAchievement_DeviceHitAtDistance
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceHitAtDistance_GodsOnly");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceHits_SingleShotEntireEnemyTeam
// 0x0018 (0x009C - 0x0084)
class UTgAchievement_DeviceHits_SingleShotEntireEnemyTeam : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nFiringInstance;                                        // 0x0088(0x0004)
	TArray<class ATgPawn*>                             m_HitPawns;                                               // 0x008C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceHits_SingleShotEntireEnemyTeam");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceHits_SingleShotPerTarget
// 0x001C (0x00A0 - 0x0084)
class UTgAchievement_DeviceHits_SingleShotPerTarget : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nNumHits;                                               // 0x0088(0x0004)
	struct FShotHitInfo                                m_HitPawns;                                               // 0x008C(0x0014) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceHits_SingleShotPerTarget");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceKillsSingleShot
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_DeviceKillsSingleShot : public UTgAchievement
{
public:
	struct FTrackedKilledTargets                       m_CurrentTracked;                                         // 0x0084(0x0014) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceKillsSingleShot");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceKillsWithHitType
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_DeviceKillsWithHitType : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nHitType;                                               // 0x0088(0x0004)
	int                                                m_nCategoryCode;                                          // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceKillsWithHitType");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceMultiHit_ByType
// 0x0028 (0x00AC - 0x0084)
class UTgAchievement_DeviceMultiHit_ByType : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nHitType;                                               // 0x0088(0x0004)
	int                                                m_nCategoryCode;                                          // 0x008C(0x0004)
	int                                                m_nNumToHit;                                              // 0x0090(0x0004)
	unsigned long                                      m_bGodsOnly : 1;                                          // 0x0094(0x0004)
	struct FTrackedTargets                             m_CurrentTracked;                                         // 0x0098(0x0014) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceMultiHit_ByType");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MultiDeviceMultiHit_ByType
// 0x0004 (0x00B0 - 0x00AC)
class UTgAchievement_MultiDeviceMultiHit_ByType : public UTgAchievement_DeviceMultiHit_ByType
{
public:
	int                                                m_nDevice2Id;                                             // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MultiDeviceMultiHit_ByType");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceOneShot
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_DeviceOneShot : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceOneShot");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceXHits
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_DeviceXHits : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                               // 0x0084(0x0004)
	int                                                m_GoalAmount;                                             // 0x0088(0x0004)
	int                                                m_nNumHits;                                               // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceXHits");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceXHitsEnemy
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_DeviceXHitsEnemy : public UTgAchievement_DeviceXHits
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceXHitsEnemy");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceXHitsWithEffect
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_DeviceXHitsWithEffect : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                               // 0x0084(0x0004)
	int                                                m_GoalAmount;                                             // 0x0088(0x0004)
	int                                                m_EffectCategory;                                         // 0x008C(0x0004)
	int                                                m_nNumHits;                                               // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceXHitsWithEffect");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceXHitsWithEffect_UniqueGod
// 0x0010 (0x00A4 - 0x0094)
class UTgAchievement_DeviceXHitsWithEffect_UniqueGod : public UTgAchievement_DeviceXHitsWithEffect
{
public:
	TArray<class ATgPawn*>                             m_HitGods;                                                // 0x0094(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceXHitsWithEffect_UniqueGod");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MultiDeviceXHitsWithEffect
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_MultiDeviceXHitsWithEffect : public UTgAchievement_DeviceXHitsWithEffect
{
public:
	int                                                m_Device2Id;                                              // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MultiDeviceXHitsWithEffect");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceXKills
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_DeviceXKills : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                               // 0x0084(0x0004)
	int                                                m_KillGoal;                                               // 0x0088(0x0004)
	int                                                m_nNumKills;                                              // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceXKills");
		return ptr;
	}

};


// Class TgGame.TgAchievement_CTF_MeleeKills
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_CTF_MeleeKills : public UTgAchievement_DeviceXKills
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CTF_MeleeKills");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceXKills_BehindWall
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_DeviceXKills_BehindWall : public UTgAchievement_DeviceXKills
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceXKills_BehindWall");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DeviceXKillsAtYPercentOrLess
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_DeviceXKillsAtYPercentOrLess : public UTgAchievement_DeviceXKills
{
public:
	int                                                m_HealthPercent;                                          // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DeviceXKillsAtYPercentOrLess");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MultiDeviceXKills
// 0x0004 (0x0094 - 0x0090)
class UTgAchievement_MultiDeviceXKills : public UTgAchievement_DeviceXKills
{
public:
	int                                                m_Device2Id;                                              // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MultiDeviceXKills");
		return ptr;
	}

};


// Class TgGame.TgAchievement_DistancePerMatch
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_DistancePerMatch : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_DistancePerMatch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_EmoteCounter
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_EmoteCounter : public UTgAchievement
{
public:
	int                                                m_nEmoteEnumId;                                           // 0x0084(0x0004)
	int                                                m_nTargetEmoteCount;                                      // 0x0088(0x0004)
	int                                                m_nEmotePlayedCount;                                      // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_EmoteCounter");
		return ptr;
	}

};


// Class TgGame.TgAchievement_EmoteBeforeMatch
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_EmoteBeforeMatch : public UTgAchievement_EmoteCounter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_EmoteBeforeMatch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_SayHello
// 0x0000 (0x0090 - 0x0090)
class UTgAchievement_SayHello : public UTgAchievement_EmoteCounter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_SayHello");
		return ptr;
	}


	bool IsEnemyVisible();
};


// Class TgGame.TgAchievement_FamiliarGetsXKills
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_FamiliarGetsXKills : public UTgAchievement
{
public:
	int                                                m_nKillCount;                                             // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FamiliarGetsXKills");
		return ptr;
	}

};


// Class TgGame.TgAchievement_FastBlood
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_FastBlood : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FastBlood");
		return ptr;
	}

};


// Class TgGame.TgAchievement_FooledYou
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_FooledYou : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_FooledYou");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Fortitude
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_Fortitude : public UTgAchievement
{
public:
	int                                                m_nAchievementThreshold;                                  // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Fortitude");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GetXEffectStacksByYMinutes
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_GetXEffectStacksByYMinutes : public UTgAchievement
{
public:
	int                                                m_nGoalStacks;                                            // 0x0084(0x0004)
	int                                                m_EffectGroupId;                                          // 0x0088(0x0004)
	int                                                m_nMinutes;                                               // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GetXEffectStacksByYMinutes");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GlobalEmoteAfterKill
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_GlobalEmoteAfterKill : public UTgAchievement
{
public:
	int                                                m_nTimeWindow;                                            // 0x0084(0x0004)
	int                                                m_nEmoteType;                                             // 0x0088(0x0004)
	int                                                m_nTargetCount;                                           // 0x008C(0x0004)
	int                                                m_nSuccessCount;                                          // 0x0090(0x0004)
	float                                              m_fMinWorldTime;                                          // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GlobalEmoteAfterKill");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GodXKillsAtYPercent
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_GodXKillsAtYPercent : public UTgAchievement
{
public:
	int                                                m_nSuccessCount;                                          // 0x0084(0x0004)
	int                                                m_nTargetGoal;                                            // 0x0088(0x0004)
	int                                                m_nHealthPercent;                                         // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GodXKillsAtYPercent");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GoodGame
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_GoodGame : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GoodGame");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Healer
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Healer : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Healer");
		return ptr;
	}

};


// Class TgGame.TgAchievement_HelpingHand
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_HelpingHand : public UTgAchievement
{
public:
	TArray<struct FAssistComboData>                    m_CurrentAssistStreaks;                                   // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HelpingHand");
		return ptr;
	}

};


// Class TgGame.TgAchievement_JumpJump
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_JumpJump : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_JumpJump");
		return ptr;
	}

};


// Class TgGame.TgAchievement_JumpParty
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_JumpParty : public UTgAchievement
{
public:
	int                                                m_nTargetCount;                                           // 0x0084(0x0004)
	int                                                m_nSuccessCount;                                          // 0x0088(0x0004)
	int                                                m_nGameMode;                                              // 0x008C(0x0004)
	unsigned long                                      m_bCheckMode : 1;                                         // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_JumpParty");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Kaboom
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Kaboom : public UTgAchievement
{
public:
	TArray<struct FDeviceDamageInfo>                   s_CurrentTrackedInfo;                                     // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Kaboom");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillAfterAbility
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_KillAfterAbility : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	float                                              m_fTimeLimit;                                             // 0x0088(0x0004)
	float                                              m_fAbilityFireTime;                                       // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillAfterAbility");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillingBlowByBotId
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_KillingBlowByBotId : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillingBlowByBotId");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillingBlowByDeployableId
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_KillingBlowByDeployableId : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillingBlowByDeployableId");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillsOnBotRanks
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_KillsOnBotRanks : public UTgAchievement
{
public:
	int                                                s_nCurrentKillCount;                                      // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillsOnBotRanks");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillsSingleAbility
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_KillsSingleAbility : public UTgAchievement
{
public:
	TArray<struct FDeviceKillsInfo>                    s_CurrentTrackedInfo;                                     // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillsSingleAbility");
		return ptr;
	}

};


// Class TgGame.TgAchievement_KillXWhileTheyAreUnderEffectY
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_KillXWhileTheyAreUnderEffectY : public UTgAchievement
{
public:
	int                                                m_nKillCount;                                             // 0x0084(0x0004)
	int                                                m_nKillGoal;                                              // 0x0088(0x0004)
	int                                                m_EffectGroupCat;                                         // 0x008C(0x0004)
	int                                                m_DeviceId;                                               // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KillXWhileTheyAreUnderEffectY");
		return ptr;
	}

};


// Class TgGame.TgAchievement_LastHit
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_LastHit : public UTgAchievement
{
public:
	int                                                m_nLastHitCount;                                          // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_LastHit");
		return ptr;
	}

};


// Class TgGame.TgAchievement_LineThemUp
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_LineThemUp : public UTgAchievement
{
public:
	TArray<struct FDeviceHitInfo>                      s_CurrentTrackedInfo;                                     // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_LineThemUp");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MaintainEnergy
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_MaintainEnergy : public UTgAchievement
{
public:
	float                                              m_fDuration;                                              // 0x0084(0x0004)
	float                                              m_fMinWorldTime;                                          // 0x0088(0x0004)
	float                                              m_fMinEnergy;                                             // 0x008C(0x0004)
	unsigned long                                      m_bIsMaintained : 1;                                      // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MaintainEnergy");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MaintainStacks
// 0x001C (0x00A0 - 0x0084)
class UTgAchievement_MaintainStacks : public UTgAchievement
{
public:
	float                                              m_fDuration;                                              // 0x0084(0x0004)
	float                                              m_fMinWorldTime;                                          // 0x0088(0x0004)
	int                                                m_nMinStacks;                                             // 0x008C(0x0004)
	int                                                m_nDeviceId;                                              // 0x0090(0x0004)
	int                                                m_nCategoryCode;                                          // 0x0094(0x0004)
	int                                                m_nHitType;                                               // 0x0098(0x0004)
	unsigned long                                      m_bIsMaintained : 1;                                      // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MaintainStacks");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MatchHealingByGod
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_MatchHealingByGod : public UTgAchievement
{
public:
	int                                                m_nTargetMatchHealing;                                    // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MatchHealingByGod");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MatchKillsByDevice
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_MatchKillsByDevice : public UTgAchievement
{
public:
	int                                                m_nNumKills;                                              // 0x0084(0x0004)
	int                                                m_nDeviceId;                                              // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MatchKillsByDevice");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MatchMovementSpeed
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_MatchMovementSpeed : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MatchMovementSpeed");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MaxedOutAttackSpeed
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_MaxedOutAttackSpeed : public UTgAchievement
{
public:
	unsigned long                                      m_bMaxAttackSpeedReached : 1;                             // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MaxedOutAttackSpeed");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MonsterHunter
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_MonsterHunter : public UTgAchievement
{
public:
	TArray<int>                                        m_nUniqueKilledIds;                                       // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nAchievementValue;                                      // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MonsterHunter");
		return ptr;
	}

};


// Class TgGame.TgAchievement_MonsterMadness
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_MonsterMadness : public UTgAchievement
{
public:
	TArray<int>                                        m_nUniqueKilledIds;                                       // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nAchievementValue;                                      // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_MonsterMadness");
		return ptr;
	}

};


// Class TgGame.TgAchievement_NoEscape
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_NoEscape : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_NoEscape");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ObjectiveHunter
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_ObjectiveHunter : public UTgAchievement
{
public:
	unsigned long                                      m_bKilledFireGiant : 1;                                   // 0x0084(0x0004)
	unsigned long                                      m_bKilledGoldFury : 1;                                    // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ObjectiveHunter");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ObjectiveSteal
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_ObjectiveSteal : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nHitBotId;                                              // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ObjectiveSteal");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ObjectiveSteal_FireGiant
// 0x0000 (0x008C - 0x008C)
class UTgAchievement_ObjectiveSteal_FireGiant : public UTgAchievement_ObjectiveSteal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ObjectiveSteal_FireGiant");
		return ptr;
	}

};


// Class TgGame.TgAchievement_OnEffectApplied
// 0x0024 (0x00A8 - 0x0084)
class UTgAchievement_OnEffectApplied : public UTgAchievement
{
public:
	unsigned long                                      m_bUseIgnoreList : 1;                                     // 0x0084(0x0004)
	unsigned long                                      m_bAllowRemoveable : 1;                                   // 0x0084(0x0004)
	TArray<int>                                        m_ExtraPropertyIds;                                       // 0x0088(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_IgnoreList;                                             // 0x0098(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_OnEffectApplied");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Plucked
// 0x0010 (0x00B8 - 0x00A8)
class UTgAchievement_Plucked : public UTgAchievement_OnEffectApplied
{
public:
	TArray<class AActor*>                              m_TrackingActors;                                         // 0x00A8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Plucked");
		return ptr;
	}

};


// Class TgGame.TgAchievement_UpYouGo
// 0x0000 (0x00A8 - 0x00A8)
class UTgAchievement_UpYouGo : public UTgAchievement_OnEffectApplied
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_UpYouGo");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Perfect
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Perfect : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Perfect");
		return ptr;
	}

};


// Class TgGame.TgAchievement_PreciseShot
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_PreciseShot : public UTgAchievement
{
public:
	unsigned long                                      m_bLastKillPassedTest : 1;                                // 0x0084(0x0004)
	unsigned long                                      m_bAchievedAtLeastOnce : 1;                               // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_PreciseShot");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Push
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_Push : public UTgAchievement
{
public:
	int                                                m_nMinionsPushed;                                         // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Push");
		return ptr;
	}

};


// Class TgGame.TgAchievement_QuestionsLater
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_QuestionsLater : public UTgAchievement
{
public:
	unsigned long                                      m_bAchievementValid : 1;                                  // 0x0084(0x0004)
	TArray<int>                                        m_nUniqueDamagedPlayers;                                  // 0x0088(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_QuestionsLater");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Survivor
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Survivor : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Survivor");
		return ptr;
	}

};


// Class TgGame.TgAchievement_TagMatchCountGodKill
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_TagMatchCountGodKill : public UTgAchievement
{
public:
	unsigned long                                      m_bTagMatches : 1;                                        // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_TagMatchCountGodKill");
		return ptr;
	}

};


// Class TgGame.TgAchievement_UseYourFists
// 0x0000 (0x0088 - 0x0088)
class UTgAchievement_UseYourFists : public UTgAchievement_TagMatchCountGodKill
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_UseYourFists");
		return ptr;
	}

};


// Class TgGame.TgAchievement_WhatAHog
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_WhatAHog : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_WhatAHog");
		return ptr;
	}

};


// Class TgGame.TgAchievement_YouRock
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_YouRock : public UTgAchievement
{
public:
	int                                                m_nTimeWindow;                                            // 0x0084(0x0004)
	float                                              m_fTimeWindowEnd;                                         // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_YouRock");
		return ptr;
	}

};


// Class TgGame.TgFadingSpeedTreeActor
// 0x0048 (0x02B0 - 0x0268)
class ATgFadingSpeedTreeActor : public ASpeedTreeActor
{
public:
	unsigned long                                      m_bFaded : 1;                                             // 0x0268(0x0004) (Transient)
	unsigned long                                      bShowFadedInEditor : 1;                                   // 0x0268(0x0004) (Edit)
	float                                              m_fFadeProgress;                                          // 0x026C(0x0004) (Transient)
	float                                              FadeOutTime;                                              // 0x0270(0x0004) (Edit, Const)
	float                                              FadeInTime;                                               // 0x0274(0x0004) (Edit, Const)
	class UMaterialInterface*                          FadingBranch1Material;                                    // 0x0278(0x0008) (Edit, Const)
	class UMaterialInterface*                          FadingBranch2Material;                                    // 0x0280(0x0008) (Edit, Const)
	class UMaterialInterface*                          FadingFrondMaterial;                                      // 0x0288(0x0008) (Edit, Const)
	class UMaterialInterface*                          FadingLeafCardMaterial;                                   // 0x0290(0x0008) (Edit, Const)
	class UMaterialInterface*                          FadingLeafMeshMaterial;                                   // 0x0298(0x0008) (Edit, Const)
	class UMaterialInterface*                          FadingBillboardMaterial;                                  // 0x02A0(0x0008) (Edit, Const)
	class USpeedTreeComponent*                         m_FadingSpeedTreeComponent;                               // 0x02A8(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFadingSpeedTreeActor");
		return ptr;
	}


	void STATIC_SetFading(bool bShouldBeFaded, bool bImmediate);
	void UpdateFadeStatus(float DeltaTime);
};


// Class TgGame.TgAimAccelerationCurves
// 0x00A0 (0x0100 - 0x0060)
class UTgAimAccelerationCurves : public UObject
{
public:
	struct FName                                       SettingsName;                                             // 0x0060(0x0008) (Edit)
	float                                              MaxAccelMultiplierX;                                      // 0x0068(0x0004) (Edit)
	float                                              MaxAccelMultiplierY;                                      // 0x006C(0x0004) (Edit)
	struct FRawDistributionFloat                       AimSpeedX;                                                // 0x0070(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       AimAccelX;                                                // 0x0094(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       AimSpeedY;                                                // 0x00B8(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       AimAccelY;                                                // 0x00DC(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAimAccelerationCurves");
		return ptr;
	}

};


// Class TgGame.TgAimAssistKeyframe
// 0x0030 (0x0090 - 0x0060)
class UTgAimAssistKeyframe : public UObject
{
public:
	struct FName                                       KeyframeName;                                             // 0x0060(0x0008) (Edit)
	struct FRawDistributionFloat                       AimAssistCurve;                                           // 0x0068(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bMirrored : 1;                                            // 0x008C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAimAssistKeyframe");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurveOwner
// 0x0000 (0x0060 - 0x0060)
class UTgGameplayCurveOwner : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurveOwner");
		return ptr;
	}


	class UTgGameplayCurvesSet* STATIC_GetCurrentGameplayCurveSet(TEnumAsByte<ECurveSetTypes> Type);
};


// Class TgGame.TgGameplayCurves
// 0x002C (0x008C - 0x0060)
class UTgGameplayCurves : public UObject
{
public:
	TArray<class UTgGameplayCurvesSet*>                CurveSets;                                                // 0x0060(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgGameplayCurves*>                   InheritedCurves;                                          // 0x0070(0x0010) (Edit, NeedCtorLink, NoClear, EditInline, EditInlineUse)
	unsigned long                                      bShowInheritedCurves : 1;                                 // 0x0080(0x0004) (Edit, Transient)
	unsigned long                                      bInheritedCurvesShareEditorTab : 1;                       // 0x0080(0x0004) (Edit, Transient)
	class UInterpCurveEdSetup*                         CurveEdSetup;                                             // 0x0084(0x0008) (ExportObject)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurves");
		return ptr;
	}


	bool STATIC_GetPrimaryDistributionValueByType(TEnumAsByte<ECurveSetTypes> curveType, float T, float* Value);
	class UTgGameplayCurvesSet* STATIC_GetCurvesSetByType(TEnumAsByte<ECurveSetTypes> curveType);
};


// Class TgGame.TgGameplayCurvesRtpc
// 0x0018 (0x00A4 - 0x008C)
class UTgGameplayCurvesRtpc : public UTgGameplayCurves
{
public:
	struct FPointer                                    VfTable_IRtpcOutput;                                      // 0x008C(0x0008) (Const, Native, NoExport)
	struct FString                                     RtpcName;                                                 // 0x0094(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesRtpc");
		return ptr;
	}


	float STATIC_GetOutValueY(float X);
	struct FString STATIC_GetRtpcName();
};


// Class TgGame.TgGameplayCurvesSet
// 0x0001 (0x0061 - 0x0060)
class UTgGameplayCurvesSet : public UObject
{
public:
	TEnumAsByte<ECurveSetTypes>                        CurveSetType;                                             // 0x0060(0x0001) (Edit, Const, EditConst)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet");
		return ptr;
	}


	bool STATIC_GetPrimaryDistributionValue(float T, float* Value);
	float STATIC_GetDistributionValue(float T, struct FRawDistributionFloat* Distribution);
};


// Class TgGame.TgGameplayCurvesSet_AimAcceleration
// 0x0013 (0x0074 - 0x0061)
class UTgGameplayCurvesSet_AimAcceleration : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<class UTgAimAccelerationCurves*>            AimAccelerationCurves;                                    // 0x0064(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAcceleration");
		return ptr;
	}


	void UpdateAimAcceleration(float DeltaTime, int CurveSetToUse, int AccelerationBoost, int Algorithm, float* TurnSpeedX, float* TurnSpeedY, float* aTurn, float* aLookUp);
};


// Class TgGame.TgGameplayCurvesSet_AimAssistBounds
// 0x0057 (0x00B8 - 0x0061)
class UTgGameplayCurvesSet_AimAssistBounds : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       BoundsScaleHorizByDistance;                               // 0x0064(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       BoundsScaleVertByDistance;                                // 0x0088(0x0024) (Edit, Component, NeedCtorLink)
	unsigned long                                      bUseHorizCurveForVert : 1;                                // 0x00AC(0x0004) (Edit)
	float                                              fBaseHorizMultiplier;                                     // 0x00B0(0x0004) (Edit)
	float                                              fBaseVertMultiplier;                                      // 0x00B4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAssistBounds");
		return ptr;
	}


	void STATIC_GetBoundsScale(float fDistance, float* fHorizBoundsScale, float* fVertBoundsScale);
};


// Class TgGame.TgGameplayCurvesSet_AimAssistKeyframes
// 0x015B (0x01BC - 0x0061)
class UTgGameplayCurvesSet_AimAssistKeyframes : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FAimAssistKeyframeDebugVals                 DebugVals;                                                // 0x0064(0x0104) (Transient)
	unsigned long                                      bSaveDebugVals : 1;                                       // 0x0168(0x0004) (Transient)
	TArray<class UTgAimAssistKeyframe*>                HorizMagnetKeyframes;                                     // 0x016C(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                VertMagnetKeyframes;                                      // 0x017C(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                FrictionKeyframes;                                        // 0x018C(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                TrackingByAccuracyKeyframes;                              // 0x019C(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	TArray<class UTgAimAssistKeyframe*>                TrackingByAngleKeyframes;                                 // 0x01AC(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_AimAssistKeyframes");
		return ptr;
	}


	float STATIC_GetInterpValBetweenFrames(float Time, float inKeyTime, float outKeyTime);
	bool STATIC_GetKeyframeByName(const struct FName& KeyframeName, TArray<class UTgAimAssistKeyframe*>* keyframesToCheck, class UTgAimAssistKeyframe** outKeyframe);
	bool STATIC_GetKeyframesToUse(float Distance, TArray<struct FAimAssistKeyframeData>* keyframeData, TArray<class UTgAimAssistKeyframe*>* keyframesToCheck, class UTgAimAssistKeyframe** keyframe1, class UTgAimAssistKeyframe** keyframe2, float* keyframe1Dist, float* keyframe2Dist);
	float STATIC_GetKeyframeDistributionValue(float T, class UTgAimAssistKeyframe** keyframe);
	float STATIC_GetStrengthScaling(int Strength);
	float STATIC_GetAimAssistValue(float assistValue, float Distance, TArray<struct FAimAssistKeyframeData>* keyframeData, TArray<class UTgAimAssistKeyframe*>* keyframesToCheck);
	void STATIC_SaveDebugInfo(bool bShouldSave);
	float STATIC_GetVertTrackingValue(float assistValue, float desiredTurnAmtPerSec, float Distance, TArray<struct FAimAssistKeyframeData>* VertTrackingByAccuracyKeyframeData, TArray<struct FAimAssistKeyframeData>* VertTrackingByAngleKeyframeData);
	float STATIC_GetHorizTrackingValue(float assistValue, float desiredTurnAmtPerSec, float Distance, TArray<struct FAimAssistKeyframeData>* HorizTrackingByAccuracyKeyframeData, TArray<struct FAimAssistKeyframeData>* HorizTrackingByAngleKeyframeData);
	float STATIC_GetFrictionValue(float assistValue, float Distance, bool bVertical, int Strength, TArray<struct FAimAssistKeyframeData>* FrictionKeyframeData);
	float STATIC_GetVertMagnetValue(float assistValue, float Distance, int Strength, TArray<struct FAimAssistKeyframeData>* MagnetVertKeyframeData);
	float STATIC_GetHorizMagnetValue(float assistValue, float Distance, int Strength, TArray<struct FAimAssistKeyframeData>* MagnetHorizKeyframeData);
};


// Class TgGame.TgGameplayCurvesSet_Simple
// 0x0027 (0x0088 - 0x0061)
class UTgGameplayCurvesSet_Simple : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FRawDistributionFloat                       SimpleDistribution;                                       // 0x0064(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_Simple");
		return ptr;
	}


	bool STATIC_GetPrimaryDistributionValue(float T, float* Value);
};


// Class TgGame.TgGameplayCurvesSet_Aiming
// 0x0000 (0x0088 - 0x0088)
class UTgGameplayCurvesSet_Aiming : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_Aiming");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_Friction
// 0x0000 (0x0088 - 0x0088)
class UTgGameplayCurvesSet_Friction : public UTgGameplayCurvesSet_Simple
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_Friction");
		return ptr;
	}

};


// Class TgGame.TgGameplayCurvesSet_TargetAimTracking
// 0x0053 (0x00B4 - 0x0061)
class UTgGameplayCurvesSet_TargetAimTracking : public UTgGameplayCurvesSet
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<class UTgTargetAimTrackingCurves*>          TargetTrackingCurves;                                     // 0x0064(0x0010) (Edit, NeedCtorLink, NoClear, EditInline)
	struct FTargetAimTrackingDebugVals                 DebugVals;                                                // 0x0074(0x003C) (Transient)
	unsigned long                                      bSaveDebugVals : 1;                                       // 0x00B0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGameplayCurvesSet_TargetAimTracking");
		return ptr;
	}


	void STATIC_SaveDebugInfo(bool bShouldSave);
	float STATIC_GetTargetTrackingStrength(float AssistAmt, float desiredTurnAmtPerSec, int TargetTrackingStrength, struct FRawDistributionFloat* StrengthByAccuracyCurve, struct FRawDistributionFloat* StrengthByDesiredAngleCurve);
	float STATIC_GetTargetTrackingPercY(float VertAssistAmt, float DesiredTurnAmt, int CurveSetToUse, int TargetTrackingStrength, float DeltaTime);
	float STATIC_GetTargetTrackingPercX(float HorizAssistAmt, float DesiredTurnAmt, int CurveSetToUse, int TargetTrackingStrength, float DeltaTime);
};


// Class TgGame.TgTargetAimTrackingCurves
// 0x0098 (0x00F8 - 0x0060)
class UTgTargetAimTrackingCurves : public UObject
{
public:
	struct FName                                       SettingsName;                                             // 0x0060(0x0008) (Edit)
	struct FRawDistributionFloat                       StrengthByAccuracyX;                                      // 0x0068(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthByDesiredAngleX;                                  // 0x008C(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthByAccuracyY;                                      // 0x00B0(0x0024) (Edit, Component, NeedCtorLink)
	struct FRawDistributionFloat                       StrengthByDesiredAngleY;                                  // 0x00D4(0x0024) (Edit, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTargetAimTrackingCurves");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Agni_NoxiousFumes
// 0x0014 (0x03E8 - 0x03D4)
class ATgDeployable_Agni_NoxiousFumes : public ATgDeployable
{
public:
	unsigned long                                      r_IsExploding : 1;                                        // 0x03D4(0x0004) (Net)
	class UCylinderComponent*                          m_CollisionCylinder;                                      // 0x03D8(0x0008) (ExportObject, Component, EditInline)
	class UTgSpecialFx*                                m_ExplodeFX;                                              // 0x03E0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Agni_NoxiousFumes");
		return ptr;
	}


	void STATIC_ExplodeNoxiousFumes();
	void ReplicatedEvent(const struct FName& VarName);
	void Explode();
	void TriggerExplosion();
	void Tick(float DeltaSeconds);
	void EncroachedBy(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ShouldTouchCauseExplosion(class AActor* Other);
};


// Class TgGame.TgDeployable_Agni_PathOfFlames
// 0x0008 (0x03DC - 0x03D4)
class ATgDeployable_Agni_PathOfFlames : public ATgDeployable
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                                      // 0x03D4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Agni_PathOfFlames");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Agni_RainFire
// 0x0008 (0x03DC - 0x03D4)
class ATgDeployable_Agni_RainFire : public ATgDeployable
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                                      // 0x03D4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Agni_RainFire");
		return ptr;
	}


	void STATIC_FireAmmunitionDeployable();
	void AdjustMeshToGround();
};


// Class TgGame.TgDevice_AgniRainFire
// 0x000C (0x0508 - 0x04FC)
class ATgDevice_AgniRainFire : public ATgDevice_Deployable
{
public:
	int                                                r_RainFireAmmunitionCount;                                // 0x04FC(0x0004) (Net)
	float                                              m_ElapsedRechargeTime;                                    // 0x0500(0x0004)
	float                                              m_LastTickCooldownUpdate;                                 // 0x0504(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AgniRainFire");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	void ExpendRainFireAmmunition(bool bSkipDischargeTime);
	bool ShouldCooldownAfterFire();
	void ReplenishRainFireAmmunition();
	void Tick(float DeltaSeconds);
	bool UpdateAmmoRechargeTime(float DeltaSeconds);
	void STATIC_ClientReduceAmmoRechargeTime(float fValue, bool bFull);
	void ReduceAmmoRechargeTime(float fValue, bool bPercentage);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	void RemoveEquipEffects();
	void ApplyEquipEffects();
	void STATIC_SetFireMode(int nFireMode, bool ForceSet);
	bool AllocateDevicePoint();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShowUICanFire();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgPawn_Agni
// 0x004C (0x2604 - 0x25B8)
class ATgPawn_Agni : public ATgPawn_Character
{
public:
	int                                                m_CombustionCounter;                                      // 0x25B8(0x0004)
	int                                                s_nCombustionIncreasePerGodHit;                           // 0x25BC(0x0004)
	int                                                s_nCombustionIncreasePerNonGodHit;                        // 0x25C0(0x0004)
	struct FVector                                     m_LastPathOfFlamesDeployableLocation;                     // 0x25C4(0x000C)
	float                                              m_PathOfFlamesDistanceInterval;                           // 0x25D0(0x0004)
	int                                                r_RainFireAmmunitionCount;                                // 0x25D4(0x0004) (Net)
	int                                                c_RainFireAmmunitionCount;                                // 0x25D8(0x0004)
	TArray<class ATgDeployable*>                       m_CombustingDeployables;                                  // 0x25DC(0x0010) (NeedCtorLink)
	unsigned long                                      c_bCombustionFxActive : 1;                                // 0x25EC(0x0004)
	unsigned long                                      c_bCombustionDisplayGroupActive : 1;                      // 0x25EC(0x0004)
	float                                              c_fCombustionFxWeight;                                    // 0x25F0(0x0004)
	float                                              c_fCombustionFxRate;                                      // 0x25F4(0x0004)
	float                                              c_RemainingAmmoReplenishTime;                             // 0x25F8(0x0004)
	float                                              m_fFlameWaveTargetingRange;                               // 0x25FC(0x0004) (Const)
	float                                              m_fFlameWaveTargetingRadius;                              // 0x2600(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Agni");
		return ptr;
	}


	bool STATIC_IgnoreFaceRotationWithInterp();
	void TickCombustionFx(float DeltaSeconds);
	void STATIC_CombustionForceCombatWary();
	void UpdateCombustionMIC();
	void ToggleCombustionFx(bool bEnable, float fTweenTime);
	void ReceivedPropValues();
	void PostDemoRewind();
	void ReplicatedEvent(const struct FName& VarName);
	void ExpendRainFireAmmunition();
	void STATIC_PlayAndUpdateRainFirePSC(bool IsPlayingDeath, bool IsPlayingRespawn);
	void ReplenishRainFireAmmunition();
	void UpdateRainFireAmmoReplenishTime(float NewTime);
	void Tick(float DeltaSeconds);
	void STATIC_OnRespawn();
	void STATIC_PlayDyingEffects();
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_ConsumeCombustionCounter(bool bForce);
	void STATIC_IncrementCombustionCounter(int nCombustionIncrease);
	void STATIC_SpawnPathOfFlamesFire(const struct FVector& SpawnLocation);
	float STATIC_GetPathOfFlamesDistanceInterval();
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PawnOnSpecialReset();
	void STATIC_PawnOnReduceActiveCooldowns(float fValue, bool bPercentage);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_Anubis
// 0x0008 (0x25C0 - 0x25B8)
class ATgPawn_Anubis : public ATgPawn_Character
{
public:
	int                                                r_nPassiveStacks;                                         // 0x25B8(0x0004) (Net)
	int                                                m_nPassiveEffectGroupId;                                  // 0x25BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Anubis");
		return ptr;
	}


	void PlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	bool CanPlayHitReaction();
	void DeviceOnStartFire(class ATgDevice* Dev);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void STATIC_PlaySkinLevelUpFx();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	bool STATIC_GetPassiveAux(float* fResult);
	class UClass* STATIC_DeviceOnOverrideDamageType(class ATgDevice* Dev, class UTgEffectGroup* EffectGroup);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	struct FVector STATIC_CalculateDeathGazeTargetPosition();
};


// Class TgGame.TgAchievement_Arachnophobia
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Arachnophobia : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Arachnophobia");
		return ptr;
	}

};


// Class TgGame.TgAchievement_WrappedUp
// 0x0014 (0x00BC - 0x00A8)
class UTgAchievement_WrappedUp : public UTgAchievement_OnEffectApplied
{
public:
	TArray<int>                                        s_PawnsAlreadyHit;                                        // 0x00A8(0x0010) (NeedCtorLink)
	int                                                s_nHitsToAchieve;                                         // 0x00B8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_WrappedUp");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByArachneGrasp
// 0x0014 (0x017C - 0x0168)
class UTgAnimBlendByArachneGrasp : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Arachne*                             m_TgPawn;                                                 // 0x0168(0x0008) (Transient)
	float                                              m_MaxSize;                                                // 0x0170(0x0004) (Edit)
	float                                              m_MinSize;                                                // 0x0174(0x0004) (Edit)
	unsigned long                                      m_bUseHeight : 1;                                         // 0x0178(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByArachneGrasp");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByArachneInHand
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendByArachneInHand : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_ArachneV2*                           m_CachedArachne;                                          // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByArachneInHand");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgDeployable_Arachne_Dev4
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeployable_Arachne_Dev4 : public ATgDeploy_EffectVolume_WithCollision
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Arachne_Dev4");
		return ptr;
	}


	void Cleanup();
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
};


// Class TgGame.TgDeploy_PVE_Web
// 0x001C (0x0414 - 0x03F8)
class ATgDeploy_PVE_Web : public ATgDeploy_EffectVolume
{
public:
	float                                              m_fLifeAfterHit;                                          // 0x03F8(0x0004)
	int                                                m_nMaxHits;                                               // 0x03FC(0x0004)
	int                                                r_nHitCount;                                              // 0x0400(0x0004) (Net)
	unsigned long                                      m_bFirstHit : 1;                                          // 0x0404(0x0004)
	unsigned long                                      m_bBroodlingsSpawned : 1;                                 // 0x0404(0x0004)
	class UMeshComponent*                              m_CollisionMesh;                                          // 0x0408(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nCollisionMeshId;                                       // 0x0410(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_PVE_Web");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void STATIC_OnWebHit();
	void HandleTouch(class AActor* Other);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SpawnBroodlings(class AActor* Target);
};


// Class TgGame.TgDeployable_Arachne_Web
// 0x002C (0x0424 - 0x03F8)
class ATgDeployable_Arachne_Web : public ATgDeploy_EffectVolume
{
public:
	float                                              m_fLifeAfterHit;                                          // 0x03F8(0x0004)
	int                                                m_nMaxHits;                                               // 0x03FC(0x0004)
	int                                                r_nHitCount;                                              // 0x0400(0x0004) (Net)
	unsigned long                                      m_bFirstHit : 1;                                          // 0x0404(0x0004)
	unsigned long                                      m_bBroodlingsSpawned : 1;                                 // 0x0404(0x0004)
	class UMeshComponent*                              m_CollisionMesh;                                          // 0x0408(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nCollisionMeshId;                                       // 0x0410(0x0004)
	TArray<class ATgPawn*>                             s_PrevTickHitPawns;                                       // 0x0414(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Arachne_Web");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void STATIC_OnWebHit();
	void TickHandleTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	bool IsInMultithreadedGameThreadWrapper();
};


// Class TgGame.TgDeploy_Arachne_Broodlings
// 0x0000 (0x0434 - 0x0434)
class ATgDeploy_Arachne_Broodlings : public ATgDeployable_TriggerableWard
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Arachne_Broodlings");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_DoTrigger(class ATgRepInfo_Player* TriggererPRI);
	bool STATIC_IsInvisible(class AActor* TestActor);
	void STATIC_SpawnBroodlings(class ATgRepInfo_Player* TriggererPRI);
};


// Class TgGame.TgDevice_Arachne_Stim
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Arachne_Stim : public ATgDevice
{
public:
	TArray<int>                                        m_DoNotBlockFiring;                                       // 0x04F0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Arachne_Stim");
		return ptr;
	}


	bool ShouldInterruptInhand();
	bool ApplyGlobalOffhandCooldown();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Arachne_ComplicatedWebWall
// 0x0014 (0x0510 - 0x04FC)
class ATgDevice_Arachne_ComplicatedWebWall : public ATgDevice_Deployable
{
public:
	int                                                m_nTrailDeviceId;                                         // 0x04FC(0x0004)
	TArray<class UTgDeviceFire*>                       m_TrailSpawningModes;                                     // 0x0500(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Arachne_ComplicatedWebWall");
		return ptr;
	}


	void AttachTrailComponent(class AActor* TrailTarget, class UTgDeviceFire* DeviceModeReference);
};


// Class TgGame.TgDevice_Arachne_NewWeb
// 0x0000 (0x0510 - 0x0510)
class ATgDevice_Arachne_NewWeb : public ATgDevice_Arachne_ComplicatedWebWall
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Arachne_NewWeb");
		return ptr;
	}


	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_ArachneAttach
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_ArachneAttach : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ArachneAttach");
		return ptr;
	}


	void UpdateAimWhileFiring(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Arachne_CreepyCrawlyShooter
// 0x0000 (0x0508 - 0x0508)
class ATgDevice_Arachne_CreepyCrawlyShooter : public ATgDevice_AnvilSlamBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Arachne_CreepyCrawlyShooter");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void STATIC_SpawnDeployable(class UTgDeviceFire* FireMode);
};


// Class TgGame.TgDeviceFire_Arachne_Attach
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Arachne_Attach : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Arachne_Attach");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Arachne_Cocoon
// 0x000C (0x01CC - 0x01C0)
class UTgDeviceFire_Arachne_Cocoon : public UTgDeviceFire
{
public:
	unsigned long                                      m_bUseExplosionRadius : 1;                                // 0x01C0(0x0004)
	struct FPointer                                    m_pBotSetup;                                              // 0x01C4(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Arachne_Cocoon");
		return ptr;
	}


	int STATIC_GetMaxProjectileCount();
	int STATIC_GetMaxDeployableCount();
	class ATgPawn* STATIC_SpawnPet(bool bPet);
	void STATIC_SpawnBroodlings(class AActor* Target);
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceFire_Arachne_TrailSpawner
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Arachne_TrailSpawner : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Arachne_TrailSpawner");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceForm_Arachne_Attach
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Arachne_Attach : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Arachne_Attach");
		return ptr;
	}


	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgEffectForm_Arachne_SpiderGrenade
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_Arachne_SpiderGrenade : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Arachne_SpiderGrenade");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ArachneCocoon
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ArachneCocoon : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ArachneCocoon");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ArachneWebWall
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ArachneWebWall : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ArachneWebWall");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ArachneWrap
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_ArachneWrap : public UTgInventoryObject_Listen
{
public:
	int                                                m_nCurrentStacks;                                         // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ArachneWrap");
		return ptr;
	}


	int STATIC_GetCurrentStacks();
	void STATIC_RemoveStackCount(int nStackCount);
	void STATIC_SetStackCount(int nStackCount);
};


// Class TgGame.TgPawn_Arachne
// 0x0010 (0x25C8 - 0x25B8)
class ATgPawn_Arachne : public ATgPawn_Character
{
public:
	class ATgPawn*                                     r_AttachedTarget;                                         // 0x25B8(0x0008) (Net)
	class UParticleSystemComponent*                    c_CocoonBeamPSC;                                          // 0x25C0(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Arachne");
		return ptr;
	}


	void STATIC_PlayCocoonRetrieve();
	void KillCocoonBeam();
	void SetCocoonBeamTarget(class AActor* Target);
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	struct FVector GetPhysTweenTargetLocation();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void ArachneAttachTweenStart();
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void TickGrab(float DeltaSeconds);
	void STATIC_EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	void DetachFromTarget();
	void AttachToTarget(bool bCallEndTween);
	bool PostPawnSetup();
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_ArachneV2
// 0x0084 (0x263C - 0x25B8)
class ATgPawn_ArachneV2 : public ATgPawn_Character
{
public:
	int                                                c_FangsFXID;                                              // 0x25B8(0x0004)
	unsigned long                                      r_bFangsEnabled : 1;                                      // 0x25BC(0x0004) (Net)
	unsigned long                                      r_bWrapEnabled : 1;                                       // 0x25BC(0x0004) (Net)
	class UTgSpecialFx*                                c_FangsLeftHandFX;                                        // 0x25C0(0x0008) (Transient)
	class UTgSpecialFx*                                c_FangsRightHandFX;                                       // 0x25C8(0x0008) (Transient)
	class ATgPawn*                                     s_WrapTarget;                                             // 0x25D0(0x0008) (Transient)
	int                                                c_CocoonFXID;                                             // 0x25D8(0x0004)
	class UTgSpecialFx*                                c_CocoonLeftHandFX;                                       // 0x25DC(0x0008) (Transient)
	class UTgSpecialFx*                                c_CocoonRightHandFX;                                      // 0x25E4(0x0008) (Transient)
	TEnumAsByte<EArachneUltState>                      r_eUltimateState;                                         // 0x25EC(0x0001) (Net)
	TEnumAsByte<EArachneUltState>                      m_eLocalUltState;                                         // 0x25ED(0x0001)
	TEnumAsByte<ETG_POSTURE>                           c_eUltimatePosture;                                       // 0x25EE(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x25EF(0x0001) MISSED OFFSET
	int                                                c_nUltimatePostureId;                                     // 0x25F0(0x0004)
	struct FName                                       c_UltimateFireAnimName;                                   // 0x25F4(0x0008)
	struct FName                                       c_UltimateCancelAnimName;                                 // 0x25FC(0x0008)
	struct FName                                       c_UltimateDeathAnimName;                                  // 0x2604(0x0008)
	float                                              s_fUltimateCancelTime;                                    // 0x260C(0x0004)
	int                                                c_nUltimateWebFXId;                                       // 0x2610(0x0004)
	class UTgSpecialFx*                                c_UltimateWebFX;                                          // 0x2614(0x0008)
	class UClass*                                      c_UltimateCameraModuleClass;                              // 0x261C(0x0008)
	class UClass*                                      c_PreviousCameraModuleClass;                              // 0x2624(0x0008)
	class UTgCameraModule*                             c_UltimateCameraMod;                                      // 0x262C(0x0008)
	class ATgDeployable_Arachne_Dev4*                  m_Deployable_A04;                                         // 0x2634(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ArachneV2");
		return ptr;
	}


	bool IsInClassSpecificMovement();
	void ResetChainedAttack(TEnumAsByte<ETG_EQUIP_POINT> eqpPoint);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDiruation, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void ToggleUltimateCameraMod(bool bOn);
	void STATIC_EndCancelUltimate();
	void STATIC_SetUltimateFX();
	void UpdateUltimateState(TEnumAsByte<EArachneUltState> NewState);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void STATIC_OnRespawn();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateFangsFX();
	void UpdateWrapFX();
	bool PostPawnSetup();
	void PostDemoRewind();
	void STATIC_InitializeUltimateFX();
	void STATIC_InitializeCocoonFX();
	void STATIC_InitializeFangsFX();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceAdjustPowerScaling(class ATgDevice* Dev, int nScalingType, struct FImpactInfo* Impact, float* fPhysicalPower, float* fMagicPower);
	bool STATIC_DeviceOnCanDeviceCriticalStrike(class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance);
	void STATIC_DeviceOnPostHit(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_Arachne_NGM
// 0x0004 (0x2640 - 0x263C)
class ATgPawn_Arachne_NGM : public ATgPawn_ArachneV2
{
public:
	unsigned long                                      m_bIsGodFollowerBot : 1;                                  // 0x263C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Arachne_NGM");
		return ptr;
	}


	void STATIC_OwnerJumpedTimer();
	void STATIC_SetInitialLevel();
	void STATIC_PostPawnSetupServer();
	void STATIC_OnOwnerJumped();
};


// Class TgGame.TgPawn_Arachne_Leash
// 0x0020 (0x2660 - 0x2640)
class ATgPawn_Arachne_Leash : public ATgPawn_Arachne_NGM
{
public:
	unsigned long                                      m_bLookAtAggressor : 1;                                   // 0x2640(0x0004)
	unsigned long                                      r_bAggressorInLeashVolume : 1;                            // 0x2640(0x0004) (Net)
	int                                                m_RestPostureID;                                          // 0x2644(0x0004)
	int                                                m_FussyPostureID;                                         // 0x2648(0x0004)
	float                                              m_fSecondsBeforeRest;                                     // 0x264C(0x0004)
	class AActor*                                      s_BestAggressor;                                          // 0x2650(0x0008)
	struct FName                                       r_nmDeathAnimOverride;                                    // 0x2658(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Arachne_Leash");
		return ptr;
	}


	void STATIC_RemoveHealthRegenBuff();
	void ApplyHealthRegenBuff();
	bool STATIC_StartIdleInRestPosture(const struct FName& PrevStateName);
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateAgressorInLeashVolume(bool bInVolume);
	bool STATIC_CheckForAggressorInLeashVolume();
};


// Class TgGame.TgPawn_Arachne_Broodling
// 0x0000 (0x2464 - 0x2464)
class ATgPawn_Arachne_Broodling : public ATgPawn_Familiar
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Arachne_Broodling");
		return ptr;
	}


	void STATIC_PlayInitialSpawnFX();
};


// Class TgGame.TgPawn_Arachne_Broodling_PVE
// 0x0004 (0x2468 - 0x2464)
class ATgPawn_Arachne_Broodling_PVE : public ATgPawn_Arachne_Broodling
{
public:
	unsigned long                                      m_bSpecialDamage : 1;                                     // 0x2464(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Arachne_Broodling_PVE");
		return ptr;
	}


	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
};


// Class TgGame.TgProj_Arachne_Web
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Arachne_Web : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Arachne_Web");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_RangeReached();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	struct FVector STATIC_GetDeployablePlacement(const struct FVector& HitLoc);
};


// Class TgGame.TgProj_Cocoon
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Cocoon : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Cocoon");
		return ptr;
	}


	void ClientExplode(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SpawnFlightEffects();
};


// Class TgGame.TgProj_Cocoon_PVE
// 0x0004 (0x03D0 - 0x03CC)
class ATgProj_Cocoon_PVE : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      s_bAlreadyPulled : 1;                                     // 0x03CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Cocoon_PVE");
		return ptr;
	}


	void ClientExplode(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SpawnFlightEffects();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool STATIC_GetValidPullLocation(class ATgPawn* Target, struct FVector* OutLocation);
};


// Class TgGame.TgAchievement_ArtemisStunville
// 0x0024 (0x00A8 - 0x0084)
class UTgAchievement_ArtemisStunville : public UTgAchievement
{
public:
	int                                                m_nUltDevice;                                             // 0x0084(0x0004)
	TArray<int>                                        m_BoarChargeDevices;                                      // 0x0088(0x0010) (NeedCtorLink)
	int                                                m_GoalAmount;                                             // 0x0098(0x0004)
	int                                                m_nFiringInstance;                                        // 0x009C(0x0004)
	int                                                m_nNumHit;                                                // 0x00A0(0x0004)
	int                                                m_nCategoryCode;                                          // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ArtemisStunville");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Artemis_Trap
// 0x0028 (0x0438 - 0x0410)
class ATgDeployable_Artemis_Trap : public ATgDeployable_Ward
{
public:
	unsigned long                                      r_IsTriggered : 1;                                        // 0x0410(0x0004) (Net)
	unsigned long                                      m_bIsTrapMoveable : 1;                                    // 0x0410(0x0004)
	class ATgPawn*                                     m_TargetPawn;                                             // 0x0414(0x0008)
	int                                                r_nTargetPawnId;                                          // 0x041C(0x0004) (Net)
	float                                              m_fMaxPullSpeed;                                          // 0x0420(0x0004)
	float                                              c_Opacity;                                                // 0x0424(0x0004)
	class UMaterialInstanceConstant*                   c_MIC;                                                    // 0x0428(0x0008)
	class UTgSpecialFx*                                m_HiddenFx;                                               // 0x0430(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Artemis_Trap");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	bool IsMovingAwayFromTrap(class ATgPawn* Other);
	bool IsAirborn(class ATgPawn* Other);
	bool STATIC_ContinuePulling(class ATgPawn* Other);
	void STATIC_PullTargetIntoTrap();
	void TriggerUpon(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void InitializeHiddenFx();
	void InitializeMIC();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgInventoryManager_Artemis
// 0x0000 (0x0764 - 0x0764)
class ATgInventoryManager_Artemis : public ATgInventoryManager
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryManager_Artemis");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ArtemisPassive
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ArtemisPassive : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ArtemisPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Artemis
// 0x0000 (0x25B8 - 0x25B8)
class ATgPawn_Artemis : public ATgPawn_Character
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Artemis");
		return ptr;
	}


	struct FName GetDeathAnimName();
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgPawn_Artemis_NGM
// 0x0004 (0x25BC - 0x25B8)
class ATgPawn_Artemis_NGM : public ATgPawn_Artemis
{
public:
	unsigned long                                      m_bIsGodFollowerBot : 1;                                  // 0x25B8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Artemis_NGM");
		return ptr;
	}


	void STATIC_OwnerJumpedTimer();
	void STATIC_SetInitialLevel();
	void STATIC_PostPawnSetupServer();
	void STATIC_OnOwnerJumped();
};


// Class TgGame.TgPawn_Artemis_Boar
// 0x0030 (0x2494 - 0x2464)
class ATgPawn_Artemis_Boar : public ATgPawn_Familiar
{
public:
	TArray<class UTgDeviceFire*>                       m_RushMinionKnockupDeviceModes;                           // 0x2464(0x0010) (AlwaysInit, NeedCtorLink)
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                                   // 0x2474(0x0008)
	TArray<class AActor*>                              m_HitActors;                                              // 0x247C(0x0010) (NeedCtorLink)
	unsigned long                                      m_ShouldSuicide : 1;                                      // 0x248C(0x0004)
	int                                                m_nChargePostureId;                                       // 0x2490(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Artemis_Boar");
		return ptr;
	}


	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	struct FVector GetPhysTweenTargetLocation();
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Suicide();
	void Tick(float DeltaTime);
	bool STATIC_CanSeeActor(class AActor* Other);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgProj_Artemis_Volley_Arrow
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Artemis_Volley_Arrow : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Artemis_Volley_Arrow");
		return ptr;
	}


	float STATIC_GetGravityZ();
};


// Class TgGame.TgAchievement_Bastet_WheresMyKitties
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_Bastet_WheresMyKitties : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nTargetAmount;                                          // 0x0088(0x0004)
	int                                                m_nSuccessCount;                                          // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Bastet_WheresMyKitties");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Bastet_PSV
// 0x0024 (0x02D8 - 0x02B4)
class ATgCollisionProxy_Bastet_PSV : public ATgCollisionProxy
{
public:
	float                                              m_fLifeTime;                                              // 0x02B4(0x0004)
	class ATgPawn*                                     m_pVictimPawn;                                            // 0x02B8(0x0008)
	class ATgPawn_BastetV2*                            m_pOwningBastet;                                          // 0x02C0(0x0008)
	struct FScriptDelegate                             __ProxyDestroyed__Delegate;                               // 0x02C8(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x02C8(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Bastet_PSV");
		return ptr;
	}


	void STATIC_StartLifeTimeTimer();
	void RefreshLifeTime();
	void STATIC_CleanUpProxy();
	void ProxyDestroyed(class ATgCollisionProxy_Bastet_PSV* SourceProxy);
};


// Class TgGame.TgDevice_Bastet_A02
// 0x0020 (0x0510 - 0x04F0)
class ATgDevice_Bastet_A02 : public ATgDevice
{
public:
	class ATgPawn_BastetV2*                            m_BastetOwner;                                            // 0x04F0(0x0008) (Const)
	float                                              r_fAngleOffset[0x2];                                      // 0x04F8(0x0004) (Const, Net)
	TArray<class ATgPawn*>                             m_PrevHitPawns;                                           // 0x0500(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bastet_A02");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void STATIC_RegisterHitActor(class AActor* HitActor);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_SingleSphinxFire(TEnumAsByte<EBastetSphinxPosition> ePosition);
	void STATIC_CalcSingleSphinxAim(TEnumAsByte<EBastetSphinxPosition> ePosition, struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Bastet_A03
// 0x0011 (0x0501 - 0x04F0)
class ATgDevice_Bastet_A03 : public ATgDevice
{
public:
	class ATgPawn_BastetV2*                            m_BastetOwner;                                            // 0x04F0(0x0008)
	float                                              r_fMeetPointOffset;                                       // 0x04F8(0x0004) (Const, Net)
	float                                              r_fHighlightingRange;                                     // 0x04FC(0x0004) (Const, Net)
	TEnumAsByte<EBastetA03FireType>                    r_eFireType;                                              // 0x0500(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bastet_A03");
		return ptr;
	}


	void STATIC_CustomFire();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_CalcSingleSphinxAim(TEnumAsByte<EBastetSphinxPosition> ePosition, struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Bastet_A04
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Bastet_A04 : public ATgDevice
{
public:
	class ATgPawn_BastetV2*                            m_BastetOwner;                                            // 0x04F0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bastet_A04");
		return ptr;
	}


	bool CanJumpWhileFiring();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_BastetCatCall
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_BastetCatCall : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BastetCatCall");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_BastetPounce
// 0x003C (0x052C - 0x04F0)
class ATgDevice_BastetPounce : public ATgDevice
{
public:
	TEnumAsByte<EBastetPounceState>                    m_ePounceState;                                           // 0x04F0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F1(0x0003) MISSED OFFSET
	unsigned long                                      m_ShouldPounceBack : 1;                                   // 0x04F4(0x0004)
	unsigned long                                      m_IsPouncingBack : 1;                                     // 0x04F4(0x0004)
	struct FVector                                     m_PrePounceLocation;                                      // 0x04F8(0x000C)
	struct FVector                                     m_PounceLocation;                                         // 0x0504(0x000C)
	float                                              r_fPounceDuration;                                        // 0x0510(0x0004)
	class ASkeletalMeshActor*                          m_PounceBackPreviewActor;                                 // 0x0514(0x0008)
	class UTgSpecialFx*                                m_PounceBackPreviewSpecialEffect;                         // 0x051C(0x0008)
	class UTgDeviceFire*                               s_ForwardPounceMode;                                      // 0x0524(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BastetPounce");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	void InterruptFiring();
	void STATIC_FireAmmunition();
	void KillPounceBackPreview();
	void STATIC_StopPounceBackwardLogic(bool bNoCooldown);
	void STATIC_StartPounceBackwardLogic();
	void STATIC_PounceBackTimerExpired();
	void STATIC_StartPounceForwardCooldown();
	void STATIC_StopPounceForwardLogic();
	void STATIC_StartPounceForwardLogic();
	bool STATIC_ServerPounceBackward();
	bool STATIC_PounceBackward();
	bool STATIC_ServerPounceForward(const struct FAimData& ClientAim, float EndTraceX, float EndTraceY);
	bool STATIC_PounceForward();
	bool Use();
	void STATIC_ClientSetPounceState(TEnumAsByte<EBastetPounceState> NewState);
	void SetPounceState(TEnumAsByte<EBastetPounceState> NewState, bool bNoCooldown);
	bool CanBeCanceled();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_SpawnPounceBackPreview();
	float GetRefireTime(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgDevice_BastetPounceV2
// 0x0000 (0x052C - 0x052C)
class ATgDevice_BastetPounceV2 : public ATgDevice_BastetPounce
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BastetPounceV2");
		return ptr;
	}


	void STATIC_FireAmmunition();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	void STATIC_StartPounceForwardCooldown();
};


// Class TgGame.TgDevice_Bastet_A01
// 0x0030 (0x055C - 0x052C)
class ATgDevice_Bastet_A01 : public ATgDevice_BastetPounceV2
{
public:
	class UTgDeviceFire*                               m_CachedFire;                                             // 0x052C(0x0008)
	class ATgPawn_BastetV2*                            m_BastetOwner;                                            // 0x0534(0x0008) (Const)
	struct FVector2D                                   r_vSphinxRadius;                                          // 0x053C(0x0008) (Const, Net)
	struct FVector2D                                   r_vSphinxLandingOffset;                                   // 0x0544(0x0008) (Const, Net)
	TArray<class ATgPawn*>                             m_PrevHitPawns;                                           // 0x054C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bastet_A01");
		return ptr;
	}


	bool STATIC_PounceForward();
	void STATIC_FireAmmunition();
	void STATIC_RegisterHitActor(class AActor* HitActor);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_SingleSphinxFire(TEnumAsByte<EBastetSphinxPosition> ePosition);
	void STATIC_CalcSingleSphinxAim(TEnumAsByte<EBastetSphinxPosition> ePosition, struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Bastet_Cat_Charge
// 0x0008 (0x0544 - 0x053C)
class ATgDevice_Bastet_Cat_Charge : public ATgDevice_Charge
{
public:
	class ATgPawn_Bastet_Cat*                          m_CatOwner;                                               // 0x053C(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bastet_Cat_Charge");
		return ptr;
	}

};


// Class TgGame.TgDevice_Bastet_Declaw
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Bastet_Declaw : public ATgDevice_Range
{
public:
	unsigned long                                      m_bShowTargeter : 1;                                      // 0x04F0(0x0004)
	struct FVector                                     m_vHitLocation;                                           // 0x04F4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bastet_Declaw");
		return ptr;
	}


	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDeviceFire_Bastet_A03
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Bastet_A03 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Bastet_A03");
		return ptr;
	}


	class ATgPawn* STATIC_SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_BastetCat_Inhand
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_BastetCat_Inhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BastetCat_Inhand");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	bool STATIC_ShouldUseReducedDamage(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceForm_Bastet_EnhancedOffhand
// 0x0008 (0x0254 - 0x024C)
class UTgDeviceForm_Bastet_EnhancedOffhand : public UTgDeviceForm_AlternateFX
{
public:
	class ATgPawn_BastetV2*                            c_CachedBastet;                                           // 0x024C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Bastet_EnhancedOffhand");
		return ptr;
	}


	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	bool STATIC_CustomShouldBeActive();
};


// Class TgGame.TgInventoryObject_Listen_BastetPassive
// 0x0028 (0x00F8 - 0x00D0)
class UTgInventoryObject_Listen_BastetPassive : public UTgInventoryObject_Listen
{
public:
	class ATgPawn_BastetV2*                            m_InstigatorPawn;                                         // 0x00D0(0x0008)
	float                                              m_fProxyRadius;                                           // 0x00D8(0x0004) (Const)
	float                                              m_fProxyHeight;                                           // 0x00DC(0x0004) (Const)
	float                                              m_fProxyLifetime;                                         // 0x00E0(0x0004) (Const)
	float                                              m_nProxySpawnLimit;                                       // 0x00E4(0x0004) (Const)
	TArray<struct FBastetPSVTrackData>                 m_TrackingData;                                           // 0x00E8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BastetPassive");
		return ptr;
	}


	struct FVector STATIC_FindGroundLocation(class AActor* HitActor);
	class ATgCollisionProxy_Bastet_PSV* BuildProxyAtLocation(class AActor* HitActor, const struct FVector& vSpawnLocation);
	class ATgCollisionProxy_Bastet_PSV* BuildProxy(class AActor* HitActor);
	void TrailProxyDestroyed(class ATgCollisionProxy_Bastet_PSV* SourceProxy);
	void TrailProxyUnTouch(class ATgCollisionProxy* SourceProxy, class AActor* Other);
	void TrailProxyTouch(class ATgCollisionProxy* SourceProxy, class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_GetVictimTrailProxiesOverlapAtPoint(class AActor* VictimActor, const struct FVector& vCheckPoint, TArray<class AActor*>* TrailProxies);
	void STATIC_GetVictimTrailProxiesByDistance(class AActor* VictimActor, float fDistance, TArray<class AActor*>* TrailProxies);
	void STATIC_GetVictimTrailProxiesByTouch(class AActor* VictimActor, TArray<class AActor*>* TrailProxies);
	void LimitProxies(class AActor* HitActor, int nAddedCount);
	void BuildBackfillProxyPath(class AActor* HitActor, int nSourceIndex);
	int STATIC_FindBestBackfillSourceProxy(class AActor* HitActor);
	void AttemptProxyBackfill(class AActor* HitActor);
	void STATIC_SpawnProxy(class AActor* HitActor);
	void STATIC_HandleProxySpawn(class AActor* HitActor);
	void STATIC_SetTrackingDataTravelState(class AActor* HitActor, TEnumAsByte<EBastetPSVTravelState> eTravelState);
	void STATIC_SetTrackingDataSpawnFlag(class AActor* HitActor, bool bSpawnFlag);
	void STATIC_CalcActorTravelState(class AActor* HitActor);
	TEnumAsByte<EBastetPSVTravelState> STATIC_CheckActorTravelState(class AActor* HitActor);
	bool STATIC_CheckActorSpawnFlag(class AActor* HitActor);
	bool STATIC_CheckActorIsBleeding(class AActor* HitActor);
	int STATIC_FindExistingData(class AActor* HitActor);
	void STATIC_DeactivateExistingData(class AActor* HitActor);
	void ActivateExistingData(class AActor* HitActor);
	void STATIC_RegisterNewData(class AActor* HitActor);
};


// Class TgGame.TgPawn_Bastet
// 0x0024 (0x25DC - 0x25B8)
class ATgPawn_Bastet : public ATgPawn_Character
{
public:
	unsigned long                                      r_ShouldPounceBack : 1;                                   // 0x25B8(0x0004) (Net)
	unsigned long                                      r_bIsPouncingBack : 1;                                    // 0x25B8(0x0004) (Net)
	int                                                r_nNumBuffs;                                              // 0x25BC(0x0004) (Net)
	TArray<class ATgAIController*>                     m_CatControllers;                                         // 0x25C0(0x0010) (NeedCtorLink)
	class UMaterialInstanceConstant*                   m_PulsingMIC;                                             // 0x25D0(0x0008)
	float                                              r_fPounceDuration;                                        // 0x25D8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Bastet");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void UpdateUltStacks();
	void KillPounceBack();
	void STATIC_ClientKillPounceBack();
	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_CatSummonTimerExpired();
	void BlinkTimerExpired();
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_ShouldPounceBack(bool Value);
	bool PostPawnSetup();
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_BastetV2
// 0x00D4 (0x26B0 - 0x25DC)
class ATgPawn_BastetV2 : public ATgPawn_Bastet
{
public:
	TArray<int>                                        m_nSphinxMeshIDs;                                         // 0x25DC(0x0010) (Const, NeedCtorLink)
	class ATgDevice*                                   m_BastetAuto;                                             // 0x25EC(0x0008)
	class ATgDevice*                                   m_BastetPSV;                                              // 0x25F4(0x0008)
	class ATgDevice_Bastet_A01*                        m_BastetA01;                                              // 0x25FC(0x0008)
	class ATgDevice_Bastet_A02*                        m_BastetA02;                                              // 0x2604(0x0008)
	class ATgDevice_Bastet_A03*                        m_BastetA03;                                              // 0x260C(0x0008)
	class ATgDevice_Bastet_A04*                        m_BastetA04;                                              // 0x2614(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x261C(0x0004) (Const)
	unsigned long                                      r_bIsA04Active : 1;                                       // 0x261C(0x0004) (Net)
	struct FVector                                     r_vDefaultA01MeshLandOffsets[0x2];                        // 0x2620(0x000C) (Const, Net)
	TEnumAsByte<EBastetA01LeapState>                   r_eA01LeapState;                                          // 0x2638(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2639(0x0003) MISSED OFFSET
	float                                              r_fCurrentPounceTime;                                     // 0x263C(0x0004) (Net)
	int                                                r_nA03CatCount;                                           // 0x2640(0x0004) (Net)
	float                                              r_fA04BonusReductionPercent;                              // 0x2644(0x0004) (Net)
	TArray<class ATgDevice*>                           m_AllowedReductionDevices;                                // 0x2648(0x0010) (NeedCtorLink)
	struct FVector                                     r_vA04MeshLocalOffsets[0x2];                              // 0x2658(0x000C) (Const, Net)
	struct FVector                                     r_vDefaultA04MeshLocalOffsets[0x2];                       // 0x2670(0x000C) (Const, Net)
	struct FBastetSphinxVisualData                     c_SphinxVisuals[0x2];                                     // 0x2688(0x0014) (Component)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BastetV2");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void IncreaseA03CatCount();
	void SetA01LeapState(TEnumAsByte<EBastetA01LeapState> NewState);
	void RegisterSphinxAnimNodeReferences(class UTgSkeletalMeshComponent* SphinxMesh);
	bool PostPawnSetup();
	void STATIC_SetA04BonusReductionPercent(float fPercent);
	struct FVector STATIC_CalcA04MeshWorldLocation(TEnumAsByte<EBastetSphinxPosition> eMeshPosition);
	bool STATIC_SetA04MeshLocalOffset(TEnumAsByte<EBastetSphinxPosition> eMeshPosition, const struct FVector& vNewOffset, bool bSetDefault);
	struct FVector STATIC_GetA04MeshLocalOffset(TEnumAsByte<EBastetSphinxPosition> eMeshPosition);
	bool STATIC_GetA04ActiveState();
	bool STATIC_SetA01MeshLocalOffset(TEnumAsByte<EBastetSphinxPosition> eMeshPosition, const struct FVector& vNewOffset);
	void STATIC_HandleA01Land();
	void STATIC_HandleA01BackwardLeap();
	void STATIC_HandleA01ForwardLeap();
	bool STATIC_PlayFullBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, bool bBlendOutIfVelocityIsGreaterThanZero, bool bHideInHandDevice);
	void STATIC_SetMeshVisibility(bool bVisible);
	void STATIC_DeactivateSphinxVisuals();
	void ActivateSphinxVisuals();
	void STATIC_SetSphinxVisualsState(bool bActive);
	void STATIC_InitializeSphinxVisuals();
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnFire(class ATgDevice* Dev);
	void STATIC_PrecacheDevices();
	void UpdateClientDevices(bool bForce);
};


// Class TgGame.TgPawn_Bastet_Cat
// 0x0024 (0x2488 - 0x2464)
class ATgPawn_Bastet_Cat : public ATgPawn_Familiar
{
public:
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               m_EQPForSetup;                                            // 0x2464(0x0010) (Const, NeedCtorLink)
	int                                                r_nHitsToKill;                                            // 0x2474(0x0004) (Const, Net)
	float                                              r_fMaxPipHealth;                                          // 0x2478(0x0004) (Const, Net)
	float                                              r_fCurrentPipHealth;                                      // 0x247C(0x0004) (Net)
	float                                              r_fMinionDamageReductionPercent;                          // 0x2480(0x0004) (Const, Net)
	float                                              r_fParentA04BonusReductionPercent;                        // 0x2484(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Bastet_Cat");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	struct FName GetDeathAnimName();
	int STATIC_GetPipHealth();
	class ATgPawn_BastetV2* STATIC_GetBastetOwner();
	bool STATIC_ShouldUseReducedDamage(class ATgDevice* Dev, const struct FImpactInfo& Impact);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_SetBonusReductionPercent(float fPercent);
	void STATIC_SetHitsToKill(int nHits);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgAchievement_Hades_Blighted
// 0x0020 (0x00A4 - 0x0084)
class UTgAchievement_Hades_Blighted : public UTgAchievement
{
public:
	TArray<int>                                        m_Devices;                                                // 0x0084(0x0010) (NeedCtorLink)
	TArray<int>                                        m_Tracking;                                               // 0x0094(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Hades_Blighted");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Hades_OhTheAgony
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_Hades_OhTheAgony : public UTgAchievement
{
public:
	TArray<class ATgPawn*>                             m_HitPawns;                                               // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nFiringInstance;                                        // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Hades_OhTheAgony");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Vortex_Hades
// 0x0000 (0x02E0 - 0x02E0)
class ATgCollisionProxy_Vortex_Hades : public ATgCollisionProxy_Vortex
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Vortex_Hades");
		return ptr;
	}


	void Tick(float fDeltaSeconds);
};


// Class TgGame.TgPawn_Hades
// 0x0028 (0x25E0 - 0x25B8)
class ATgPawn_Hades : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_BlightComponent;                                        // 0x25B8(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgMarkComponent*                            m_DevourSoulsMarkComponent;                               // 0x25C0(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class UTgDeviceFire*>                       m_DevourSoulsModes;                                       // 0x25C8(0x0010) (AlwaysInit, NeedCtorLink)
	class ATgCollisionProxy_Vortex_Hades*              m_PillarOfAgonyVortex;                                    // 0x25D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Hades");
		return ptr;
	}


	void PlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnSwapToDestroyedMesh();
	bool CanBePulled(bool bIsActuallyPulling);
	void STATIC_SpawnVortex(class ATgDevice* Dev);
	void BlightExplosion();
	bool STATIC_ShouldPawnMeshBeHiddenThisTick();
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnBeforeHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgCollisionProxy_Wave_Hebo
// 0x0000 (0x02B4 - 0x02B4)
class ATgCollisionProxy_Wave_Hebo : public ATgCollisionProxy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Wave_Hebo");
		return ptr;
	}

};


// Class TgGame.TgDevice_HeBo_CrushingWave
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_HeBo_CrushingWave : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HeBo_CrushingWave");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgPawn_HeBo
// 0x0030 (0x25E8 - 0x25B8)
class ATgPawn_HeBo : public ATgPawn_Character
{
public:
	class UParticleSystemComponent*                    m_Splash;                                                 // 0x25B8(0x0008) (ExportObject, Component, EditInline)
	struct FName                                       m_SplashAttachPoint;                                      // 0x25C0(0x0008)
	class UTgAudioComponent*                           m_MovementSound;                                          // 0x25C8(0x0008) (ExportObject, Component, EditInline)
	class ATgCollisionProxy_Wave_Hebo*                 m_WaveCollision;                                          // 0x25D0(0x0008)
	TArray<class AActor*>                              m_WaveHitActors;                                          // 0x25D8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_HeBo");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void WaveTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void PostDemoRewind();
	void STATIC_ShowScroll();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_PlayDyingEffects();
	void STATIC_OnRespawn();
	bool PostPawnSetup();
	bool STATIC_ShouldPawnMeshBeHiddenThisTick();
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgAchievement_Hel_StanceKills
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Hel_StanceKills : public UTgAchievement
{
public:
	TArray<struct FHelStanceKillTrackingData>          m_TrackingData;                                           // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Hel_StanceKills");
		return ptr;
	}

};


// Class TgGame.TgDevice_HelV3_SwitchStance
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_HelV3_SwitchStance : public ATgDevice_PassiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HelV3_SwitchStance");
		return ptr;
	}


	bool STATIC_ShouldApplyAura();
	bool STATIC_ShouldApplyModeEquipEffects();
	bool STATIC_HasBeenTrained();
};


// Class TgGame.TgDevice_Hel_SwitchStance
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Hel_SwitchStance : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hel_SwitchStance");
		return ptr;
	}


	bool STATIC_HasBeenTrained();
};


// Class TgGame.TgDevice_Hel_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Hel_Dev1 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hel_Dev1");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgPawn_HelV3
// 0x0500 (0x2AB8 - 0x25B8)
class ATgPawn_HelV3 : public ATgPawn_Character
{
public:
	TEnumAsByte<EHEL_STANCE>                           r_CurrentStance;                                          // 0x25B8(0x0001) (Net)
	TEnumAsByte<EHEL_STANCE>                           c_LocalCurrentStance;                                     // 0x25B9(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x25BA(0x0002) MISSED OFFSET
	unsigned long                                      r_StanceSwapLockout : 1;                                  // 0x25BC(0x0004) (Net)
	unsigned long                                      m_bProgressingStance : 1;                                 // 0x25BC(0x0004)
	unsigned long                                      s_bSwitchingStances : 1;                                  // 0x25BC(0x0004)
	float                                              m_fSmoothEnergy;                                          // 0x25C0(0x0004)
	float                                              m_fProgressStanceDelay;                                   // 0x25C4(0x0004)
	float                                              m_fProgressStanceSpeed;                                   // 0x25C8(0x0004)
	int                                                m_DarkDeviceIds[0x1F];                                    // 0x25CC(0x0004)
	int                                                m_LightDeviceIds[0x1F];                                   // 0x2648(0x0004)
	class ATgDevice*                                   m_DarkDevices[0x1F];                                      // 0x26C4(0x0008)
	class ATgDevice*                                   m_LightDevices[0x1F];                                     // 0x27BC(0x0008)
	struct FVector                                     FireLocationOffsetsLight[0x1F];                           // 0x28B4(0x000C)
	float                                              m_fStanceSwapAnimBlendInTime;                             // 0x2A28(0x0004) (Const)
	float                                              m_fStanceSwapAnimBlendOutTime;                            // 0x2A2C(0x0004) (Const)
	int                                                m_StanceMeshAssemblyIds[0x3];                             // 0x2A30(0x0004)
	struct FPointer                                    m_StanceBodyMeshAssemblies[0x3];                          // 0x2A3C(0x0008) (Native)
	struct FPointer                                    m_StanceDestroyedMeshAssemblies[0x3];                     // 0x2A54(0x0008) (Native)
	struct FName                                       m_StanceSwapAnimNames[0x3];                               // 0x2A6C(0x0008)
	class ATgDevice*                                   r_PassiveTrackedDark[0x3];                                // 0x2A84(0x0008) (Net)
	class ATgDevice*                                   r_PassiveTrackedLight[0x3];                               // 0x2A9C(0x0008) (Net)
	float                                              m_fPsvMaxHealingTakenPerc;                                // 0x2AB4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_HelV3");
		return ptr;
	}


	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void PlayDeathAnimation();
	void PostDemoRewind();
	TEnumAsByte<EHEL_STANCE> GetStateStance();
	void ReactivateWhileAliveFxs();
	void StanceSwapLockout();
	void TriggerStanceProgression();
	void TriggerStanceMeshChange();
	void ClientPlayStanceSwapAnimation(TEnumAsByte<EHEL_STANCE> NewStance);
	void TickTargeting(float DeltaSeconds);
	void Tick(float DeltaSeconds);
	void STATIC_InterruptInhand(class ATgDevice* InterruptingDevice);
	void ReplicatedEvent(const struct FName& VarName);
	void SetInitialState();
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_OnRespawn();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	bool CannotJumpNow();
	float STATIC_GetHealingTakenPerc();
	void STATIC_CachePsvMaxHealingPercent();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveBool(int* bResult);
	void TriggerAllSwitchStanceTimers(bool bExcludeProgressingStance, float fBlendOutTime);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_SwapStanceMesh();
	void STATIC_SwapToDestroyedMesh();
	void STATIC_SwapToLiveMesh();
	void STATIC_CalcSmoothEnergy(float DeltaSeconds);
	float STATIC_GetSmoothEnergy();
	void STATIC_SetSpawnEnergy();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void LoadDevicesByStance(TEnumAsByte<EHEL_STANCE> NewStance);
	void STATIC_SwapStance(TEnumAsByte<EHEL_STANCE> NewStance, bool bSkipTransition);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_HelV3Skin
// 0x003C (0x2AF4 - 0x2AB8)
class ATgPawn_HelV3Skin : public ATgPawn_HelV3
{
public:
	TEnumAsByte<EHelSkinState>                         r_eHelSkinState;                                          // 0x2AB8(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2AB9(0x0003) MISSED OFFSET
	int                                                m_nDarkPacMeshId;                                         // 0x2ABC(0x0004) (Const)
	int                                                m_nLightPacMeshId;                                        // 0x2AC0(0x0004) (Const)
	class UTgSkeletalMeshComponent*                    c_meshDarkPac;                                            // 0x2AC4(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    c_meshLightPac;                                           // 0x2ACC(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nA01DarkDepId;                                          // 0x2AD4(0x0004) (Const)
	struct FA01SpawnDarkDepFlashEvent                  r_flashSpawnA01DarkDep;                                   // 0x2AD8(0x001C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_HelV3Skin");
		return ptr;
	}


	void AdjustPawnMeshVisibility();
	void TriggerStanceMeshChange();
	int GetEvolvingItemSkinLevel();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ClientSpawnA01DarkDeployable(struct FVector* vSpawnLoc, struct FRotator* rSpawnRot);
	void STATIC_OnProjectileExploded(class ATgProjectile* ExplodedProjectile, class AActor* HitActor, struct FVector* vHitLocation, struct FVector* vHitNormal);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void STATIC_OnLevelUp(int nLevel);
	bool IsHiddenDueToPolymorph();
	void UpdateVisibilities(bool bIsHidden);
	void STATIC_OnSkinLevelChanged();
	void STATIC_SwapPacMesh(TEnumAsByte<EHEL_STANCE> eHelStance);
	void STATIC_SetupPacMesh(class UTgSkeletalMeshComponent* MeshComp);
	bool STATIC_InitializeLightPac();
	bool STATIC_InitializeDarkPac();
};


// Class TgGame.TgAchievement_Kali_YouThoughtYouHadMe
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_Kali_YouThoughtYouHadMe : public UTgAchievement_DeviceXKillsAtYPercentOrLess
{
public:
	unsigned long                                      m_bSuccessfulSetup : 1;                                   // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Kali_YouThoughtYouHadMe");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Kali_BountyHunter
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_Kali_BountyHunter : public UTgAchievement
{
public:
	int                                                m_nKillCount;                                             // 0x0084(0x0004)
	int                                                m_nTargetGoal;                                            // 0x0088(0x0004)
	int                                                m_nMarkedId;                                              // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Kali_BountyHunter");
		return ptr;
	}

};


// Class TgGame.TgDevice_Kali_Lash
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Kali_Lash : public ATgDevice_Spline
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kali_Lash");
		return ptr;
	}


	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	bool STATIC_CalculateFlightPath(int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim);
};


// Class TgGame.TgDeviceForm_Kali_Lash
// 0x0010 (0x02AC - 0x029C)
class UTgDeviceForm_Kali_Lash : public UTgDeviceForm_SplineTarget
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorB;                            // 0x029C(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFxB;                                       // 0x02A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Kali_Lash");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_KaliIncense
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_KaliIncense : public UTgInventoryObject_Listen
{
public:
	int                                                m_nExtraDamageCategoryCode;                               // 0x00D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_KaliIncense");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_KaliLash
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_KaliLash : public UTgInventoryObject_Listen
{
public:
	int                                                m_nBleedCategoryCode;                                     // 0x00D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_KaliLash");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_KaliNimbleStrike
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_KaliNimbleStrike : public UTgInventoryObject_Listen
{
public:
	TArray<int>                                        m_MissingHealth;                                          // 0x00D0(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_KaliNimbleStrike");
		return ptr;
	}

};


// Class TgGame.TgPawn_KaliV2
// 0x009C (0x2654 - 0x25B8)
class ATgPawn_KaliV2 : public ATgPawn_Character
{
public:
	TArray<class AActor*>                              s_MarkedTargets;                                          // 0x25B8(0x0010) (NeedCtorLink)
	TArray<unsigned char>                              s_MarkedIsLowHealth;                                      // 0x25C8(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_MarkedHistory;                                          // 0x25D8(0x0010) (NeedCtorLink)
	class ATgRepInfo_Player*                           r_MarkedPRIs[0x2];                                        // 0x25E8(0x0008) (Net)
	class ATgRepInfo_Deployable*                       r_MarkedDRIs[0x2];                                        // 0x25F8(0x0008) (Net)
	int                                                r_nKillCount;                                             // 0x2608(0x0004) (Net)
	int                                                m_nMarkedListMin;                                         // 0x260C(0x0004)
	int                                                m_nMarkedListMax;                                         // 0x2610(0x0004)
	int                                                m_nMarkedHistoryMax;                                      // 0x2614(0x0004)
	unsigned long                                      s_bChooseTargetOnRevive : 1;                              // 0x2618(0x0004)
	unsigned long                                      c_UltimateMeshActive : 1;                                 // 0x2618(0x0004)
	int                                                r_nTriggerTargetChoice;                                   // 0x261C(0x0004) (Net)
	int                                                c_nTargetsTriggered;                                      // 0x2620(0x0004)
	struct FVector                                     r_vBloodlashLocation;                                     // 0x2624(0x000C) (Net)
	struct FRotator                                    r_rBloodlashRotation;                                     // 0x2630(0x000C) (Net)
	int                                                r_nBloodlashTicker;                                       // 0x263C(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    c_UltimateMesh;                                           // 0x2640(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              c_UltimateBoneScaleValue;                                 // 0x2648(0x0004) (Transient)
	class USkelControlSingleBone*                      c_UltimateBoneScale;                                      // 0x264C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_KaliV2");
		return ptr;
	}


	void ClearMarkedTargets();
	void OnGroupChange();
	void Destroyed();
	void TickTargeting(float DeltaSeconds);
	void Tick(float DeltaSeconds);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void ToggleUltimateMesh(bool bEnable);
	void STATIC_OnDeviceFormEnteredTargetingMode(class UTgDeviceForm* form);
	void STATIC_EnablePassiveTargeter();
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetGodTargeterState();
	void STATIC_PawnOnRevive();
	bool STATIC_HasDiedByGod();
	bool STATIC_HasOpposingForce();
	void LoadAndPlayBloodLashMesh(const struct FVector& vLocation, const struct FRotator& rRotation);
	class UTgSkeletalMeshComponent* STATIC_SpawnExtraSkeletalMesh(int nMeshId);
	bool STATIC_ChooseNextMarkedTarget(class AActor* PriorityActor, bool bNotifyTarget, TArray<class AActor*>* ExcludeList);
	void STATIC_RemoveMarkedTarget(class AActor* Victim, bool bDoNotFindTarget, bool bSetKilled);
	void STATIC_PawnOnAssisted(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	float STATIC_GetPercPenetration(int nProtectionType, class AActor* Target);
	void STATIC_PawnOnSpecialCleanup();
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceCriticalStrike(class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance);
	bool STATIC_GetPassiveString(struct FString* sResult);
	float STATIC_GetMaxEnergy();
	float STATIC_GetSmoothEnergy();
};


// Class TgGame.TgProj_Kali_Lash
// 0x0020 (0x03CC - 0x03AC)
class ATgProj_Kali_Lash : public ATgProj_SimulatedPassThrough
{
public:
	struct FPointer                                    VfTable_ITgProjGroundTargetInterface;                     // 0x03AC(0x0008) (Const, Native, NoExport)
	float                                              m_fTurnStrength;                                          // 0x03B4(0x0004)
	float                                              m_fVertTurnStrength;                                      // 0x03B8(0x0004)
	struct FVector                                     m_GroundTargetLocation;                                   // 0x03BC(0x000C)
	unsigned long                                      m_bHasPassedTarget : 1;                                   // 0x03C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Kali_Lash");
		return ptr;
	}


	struct FVector GetSeekLocation();
	void UpdateSeekingDirection(float fDeltaTime);
	void Tick(float fDeltaTime);
	bool IsOutsideMinRange(const struct FVector& HitLocation);
	void SetGroundTarget(const struct FVector& GTLocation);
	void ClientTargetUpdate(class AActor* TargetActor, const struct FVector& TargetLocation);
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_Kali_Lash_Spear
// 0x000C (0x03B8 - 0x03AC)
class ATgProj_Kali_Lash_Spear : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_RollVariance;                                           // 0x03AC(0x0004)
	float                                              m_fPitchOffset;                                           // 0x03B0(0x0004)
	float                                              m_fGravityMultiplier;                                     // 0x03B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Kali_Lash_Spear");
		return ptr;
	}


	bool IsOutsideMinRange(const struct FVector& HitLocation);
	void PostBeginPlay();
	float STATIC_GetGravityZ();
	void Init(const struct FVector& Direction);
};


// Class TgGame.TgAchievement_HunBatz_MonkeyBusiness
// 0x0018 (0x009C - 0x0084)
class UTgAchievement_HunBatz_MonkeyBusiness : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nHitCount;                                              // 0x0088(0x0004)
	int                                                m_nLastBounceNum;                                         // 0x008C(0x0004)
	unsigned long                                      m_bValidFire : 1;                                         // 0x0090(0x0004)
	class ATgPawn*                                     m_pLastHit;                                               // 0x0094(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HunBatz_MonkeyBusiness");
		return ptr;
	}

};


// Class TgGame.TgDeployable_HunBatz_FearTotem
// 0x0000 (0x040C - 0x040C)
class ATgDeployable_HunBatz_FearTotem : public ATgDeploy_Wall
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_HunBatz_FearTotem");
		return ptr;
	}

};


// Class TgGame.TgDevice_Monkey_FuriousMonkey
// 0x0021 (0x0515 - 0x04F4)
class ATgDevice_Monkey_FuriousMonkey : public ATgDevice_ProjectileTeleport
{
public:
	class ATgPawn*                                     r_LastHitPawn;                                            // 0x04F4(0x0008) (Net)
	class ATgPawn*                                     c_FxPawn;                                                 // 0x04FC(0x0008) (Transient)
	class UTgSpecialFx*                                c_TargetingDirectionFx;                                   // 0x0504(0x0008) (Transient)
	class UTgSpecialFx*                                c_TargetingPawnFx;                                        // 0x050C(0x0008) (Transient)
	TEnumAsByte<EFuriousMonkeyState>                   m_eMonkeyState;                                           // 0x0514(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Monkey_FuriousMonkey");
		return ptr;
	}


	void UpdateTargetFxs();
	void STATIC_ClearTargetingFxs();
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void ToggleTeleportTimer(bool bEnable);
	void STATIC_TeleportExpire();
	void STATIC_ClientSetMonkeyState(TEnumAsByte<EFuriousMonkeyState> NewState);
	void STATIC_SetMonkeyState(TEnumAsByte<EFuriousMonkeyState> NewState, class ATgPawn* Target, bool bNoCooldown);
	bool STATIC_ServerTeleportToLastTarget();
	bool STATIC_TeleportToLastTarget();
	class ATgProjectile* GetProjectile();
	bool STATIC_DoTeleport(const struct FVector& vLocation, const struct FVector& vClientLocation);
	bool Use();
	bool ShouldCooldownAfterFire();
	void PostDemoRewind();
	void PreDemoRewind();
	void Tick(float DeltaTime);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgInventoryObject_Listen_Monkey_Passive
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Monkey_Passive : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Monkey_Passive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Monkey
// 0x0008 (0x25C0 - 0x25B8)
class ATgPawn_Monkey : public ATgPawn_Character
{
public:
	class ATgProj_FuriousMonkey*                       m_FuriousMonkey;                                          // 0x25B8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Monkey");
		return ptr;
	}


	void SetFuriousMonkey(class ATgProj_FuriousMonkey* Proj);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_ReapplyLoadoutEffects();
	void STATIC_PawnOnExitCombat();
	void STATIC_PawnOnEnterCombat();
	void STATIC_PawnOnRevive();
	bool STATIC_DeviceOnCanDeviceCriticalStrike(class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgProj_FuriousMonkey
// 0x0030 (0x043C - 0x040C)
class ATgProj_FuriousMonkey : public ATgProj_SimulatedArcing
{
public:
	class UTgAnimNodeBlendList*                        m_PhaseBlendList;                                         // 0x040C(0x0008)
	class UTgAnimNodeBlendList*                        m_AttackBlendList;                                        // 0x0414(0x0008)
	float                                              m_fTweenTime;                                             // 0x041C(0x0004)
	float                                              m_fTween;                                                 // 0x0420(0x0004)
	struct FVector                                     m_vTweenSource;                                           // 0x0424(0x000C)
	unsigned long                                      s_bTeleportOnNextHit : 1;                                 // 0x0430(0x0004)
	unsigned long                                      s_bDidTeleport : 1;                                       // 0x0430(0x0004)
	unsigned long                                      m_bSkipAnimations : 1;                                    // 0x0430(0x0004) (Transient)
	class ATgPawn*                                     s_LastHitTarget;                                          // 0x0434(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_FuriousMonkey");
		return ptr;
	}


	void Destroyed();
	void ShutDown();
	bool STATIC_CanTriggerTeleport();
	void STATIC_TeleportToLastHit(class ATgPawn* TgP, const struct FVector& vDest, const struct FRotator& rDest);
	void SetSeekingTarget(class AActor* LockedTarget);
	struct FVector GetSeekLocation();
	void UpdateSeekingDirection(float fDeltaTime);
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void AdvanceToNextTarget(class AActor* NewTargetOverride);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void PostBeginPlay();
	void STATIC_CompleteInitialization();
	void STATIC_PlayJumpAnim();
	void STATIC_PlayAttackAnim();
};


// Class TgGame.TgDeploy_Kukulkan_Tornadoes
// 0x001C (0x03F0 - 0x03D4)
class ATgDeploy_Kukulkan_Tornadoes : public ATgDeployable
{
public:
	TArray<class ATgProj_Tornado*>                     m_Tornadoes;                                              // 0x03D4(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               m_TornadoSpawnFiremode;                                   // 0x03E4(0x0008)
	float                                              m_fTornadoBlend;                                          // 0x03EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Kukulkan_Tornadoes");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	class ATgProj_Tornado* STATIC_GetTornadoFor(class AActor* Actor);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable_AoKuang_Tempest
// 0x001C (0x03F0 - 0x03D4)
class ATgDeployable_AoKuang_Tempest : public ATgDeployable_PulseEffectVolume
{
public:
	TArray<class AActor*>                              m_HitActors;                                              // 0x03D4(0x0010) (NeedCtorLink)
	struct FVector                                     m_vActualLocation;                                        // 0x03E4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_AoKuang_Tempest");
		return ptr;
	}


	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_ShouldHit(class AActor* Other);
};


// Class TgGame.TgDevice_Kukulkan_Dev1
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Kukulkan_Dev1 : public ATgDevice_Range
{
public:
	unsigned long                                      m_bShowTargeter : 1;                                      // 0x04F0(0x0004)
	struct FVector                                     m_vHitLocation;                                           // 0x04F4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kukulkan_Dev1");
		return ptr;
	}


	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgEffectForm_Kukulkan_Slipstream
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_Kukulkan_Slipstream : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Kukulkan_Slipstream");
		return ptr;
	}


	void STATIC_HideEffectForm();
};


// Class TgGame.TgPawn_Kukulkan
// 0x0018 (0x25D0 - 0x25B8)
class ATgPawn_Kukulkan : public ATgPawn_Character
{
public:
	class UTgDeviceFire*                               m_UltimateKnockbackMode;                                  // 0x25B8(0x0008)
	struct FSlipstreamMod                              r_SSM;                                                    // 0x25C0(0x0008) (Net)
	struct FSlipstreamMod                              c_SSM;                                                    // 0x25C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Kukulkan");
		return ptr;
	}


	void DischargeAirBall();
	void STATIC_RechargeAirBall();
	void OnAttackComboTimeout();
	void Tick(float DeltaSeconds);
	void SetSlipstreamMod(float Modifier, float Duration);
	void ReplicatedEvent(const struct FName& VarName);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	float STATIC_GetMagicalPowerItem(const struct FImpactInfo& Impact, float PowerScaling);
};


// Class TgGame.TgPawn_KukulkanSkin
// 0x0001 (0x25D1 - 0x25D0)
class ATgPawn_KukulkanSkin : public ATgPawn_Kukulkan
{
public:
	TEnumAsByte<EWindsOfChangeSkinState>               r_eSkinState;                                             // 0x25D0(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_KukulkanSkin");
		return ptr;
	}


	void STATIC_ServerSetSkinLevel(unsigned char nSkinLevel);
	void DeviceOnStartFire(class ATgDevice* Dev);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void STATIC_IncrementSkinState();
};


// Class TgGame.TgAchievement_Odin_BirdBomb
// 0x0004 (0x0098 - 0x0094)
class UTgAchievement_Odin_BirdBomb : public UTgAchievement_AbilityCombo
{
public:
	unsigned long                                      m_nValidLunge : 1;                                        // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Odin_BirdBomb");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Odin_CageMatch
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Odin_CageMatch : public UTgAchievement
{
public:
	int                                                m_nSuccessCount;                                          // 0x0084(0x0004)
	int                                                m_nTargetGoal;                                            // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Odin_CageMatch");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Odin_Spears
// 0x0030 (0x043C - 0x040C)
class ATgDeploy_Odin_Spears : public ATgDeploy_Wall
{
public:
	struct FPointer                                    VfTable_ITgCustomBlockingTypeInterface;                   // 0x040C(0x0008) (Const, Native, NoExport)
	class UMeshComponent*                              m_CollisionMesh;                                          // 0x0414(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nCollisionMeshId;                                       // 0x041C(0x0004)
	float                                              m_fCollisionHeightAdjust;                                 // 0x0420(0x0004)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x0424(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x0434(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Odin_Spears");
		return ptr;
	}


	bool AllowPassthrough(bool bFriendly);
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void Cleanup();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
	TEnumAsByte<ETG_CUSTOM_BLOCKING_TYPE> STATIC_GetCustomBlockingType();
	bool IsPushable(class AActor* Other);
	void UpdateCollisionOffset();
};


// Class TgGame.TgDeploy_Odin_RingSection
// 0x0020 (0x042C - 0x040C)
class ATgDeploy_Odin_RingSection : public ATgDeploy_Wall_Destructible
{
public:
	class UStaticMeshComponent*                        m_CollisionBox;                                           // 0x040C(0x0008) (Const, ExportObject, Component, EditInline)
	class ATgDeploy_Odin_Spears_V2*                    m_SpearDeployable;                                        // 0x0414(0x0008) (Const)
	TEnumAsByte<EOdinRingSection>                      m_eRingSectionPosition;                                   // 0x041C(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x041D(0x0003) MISSED OFFSET
	float                                              m_fDamagePerHit;                                          // 0x0420(0x0004) (Const)
	float                                              m_fHudOverlayHeightOffset;                                // 0x0424(0x0004) (Const)
	int                                                s_nPreviousQueueIndex;                                    // 0x0428(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Odin_RingSection");
		return ptr;
	}


	void STATIC_IncrementOwnerNextQueueIndex();
	void DestroyIt(bool bSkipFx);
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Tick(float DeltaSeconds);
	bool STATIC_IsInvisible(class AActor* TestActor);
	struct FVector STATIC_GetHudOverlayLocation();
	bool IsPushable(class AActor* Other);
};


// Class TgGame.TgDeploy_Odin_Spears_V2
// 0x01DC (0x05E8 - 0x040C)
class ATgDeploy_Odin_Spears_V2 : public ATgDeploy_Wall_Destructible
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x040C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Odin_V2*                             r_pawnOdin;                                               // 0x0414(0x0008) (Const, Net)
	int                                                r_nStartingHealth;                                        // 0x041C(0x0004) (Net)
	int                                                m_nRingSectionDepId;                                      // 0x0420(0x0004) (Const)
	int                                                r_nComponentHealth[0x8];                                  // 0x0424(0x0004) (Net)
	int                                                r_nUniqueDeployableIds[0x8];                              // 0x0444(0x0004) (Net)
	float                                              r_fRingRadius;                                            // 0x0464(0x0004) (Const, Net)
	int                                                m_fComponentColHeight;                                    // 0x0468(0x0004) (Const)
	float                                              m_fWallThickness;                                         // 0x046C(0x0004) (Const)
	class ATgDeploy_Odin_RingSection*                  m_RingSections[0x8];                                      // 0x0470(0x0008)
	TArray<class AActor*>                              s_SquareTouching;                                         // 0x04B0(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_DiamondTouching;                                        // 0x04C0(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x04D0(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_ProjectileHitList;                                      // 0x04E0(0x0010) (NeedCtorLink)
	TArray<struct FOdinDeferredTarget>                 s_DeferredTouchedList;                                    // 0x04F0(0x0010) (NeedCtorLink)
	TArray<struct FOdinTouchedTarget>                  s_TouchedList;                                            // 0x0500(0x0010) (NeedCtorLink)
	struct FOdinRingNormal                             s_RingNormals[0x8];                                       // 0x0510(0x0018)
	class ATgCollisionProxy_Box*                       m_OctogonSections[0x2];                                   // 0x05D0(0x0008) (Const)
	int                                                r_nProjectilesFired;                                      // 0x05E0(0x0004) (Net)
	int                                                c_nProjGroundExplosionFXId;                               // 0x05E4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Odin_Spears_V2");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_CleanUpTargetLogic();
	void STATIC_InstantFireDeployable();
	void TimeDeviceFiring();
	void STATIC_PlayProjectileGroundExplosionFX();
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	void FireOdinCageProjectile(class AActor* Target);
	void STATIC_RelayUniqueDeployableIds();
	void RelayRingSectionHealth();
	void RelayRingSectionStartingHealth();
	void STATIC_RemoveEffectFromTarget(class AActor* Target);
	void ApplyEffectToTarget(class AActor* Target);
	void DiamondProxyUnTouch(class AActor* Other);
	void DiamondProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SquareProxyUnTouch(class AActor* Other);
	void SquareProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessRingSectionHealthChanged(int Health, TEnumAsByte<EOdinRingSection> RingSectionPosition);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_CleanupRingSections();
	void STATIC_SpawnRingSections();
	void STATIC_CleanupOctogonSections();
	void STATIC_SpawnOctogonSections();
	void STATIC_FlagTouchedForProjCheck(class ATgPawn* TargetPawn);
	void STATIC_RemoveDeferredTouchActor(class ATgPawn* TargetPawn);
	void AddDeferredTouchActor(class ATgPawn* TargetPawn);
	void AddUniqueTouchActor(class ATgPawn* TargetPawn);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDevice_Odin_A04
// 0x0008 (0x0504 - 0x04FC)
class ATgDevice_Odin_A04 : public ATgDevice_Deployable
{
public:
	class ATgDevice*                                   m_SubDevice;                                              // 0x04FC(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Odin_A04");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
};


// Class TgGame.TgDevice_Odin_A03
// 0x0044 (0x0540 - 0x04FC)
class ATgDevice_Odin_A03 : public ATgDevice_HitPulse
{
public:
	int                                                r_nAmmoCount;                                             // 0x04FC(0x0004) (Net)
	int                                                m_nMaxAmmoCount;                                          // 0x0500(0x0004) (Const)
	float                                              m_fProjectilePreFireDelay;                                // 0x0504(0x0004) (Const)
	class ATgPawn_Odin_V2*                             r_OdinPawn;                                               // 0x0508(0x0008) (Const, Net)
	unsigned long                                      r_bFiredProjectile : 1;                                   // 0x0510(0x0004) (Net)
	TEnumAsByte<EOdinSpearState>                       r_eSpearState;                                            // 0x0514(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0515(0x0003) MISSED OFFSET
	int                                                m_nAttackSpeedSituationalType;                            // 0x0518(0x0004) (Const)
	int                                                m_nRegularSpearSituationalType;                           // 0x051C(0x0004) (Const)
	int                                                m_nHomingSpearSituationalType;                            // 0x0520(0x0004) (Const)
	int                                                m_nEnhancedSpearSituationalType;                          // 0x0524(0x0004) (Const)
	int                                                m_nPrimedPostureSituationalType;                          // 0x0528(0x0004) (Const)
	int                                                m_nSpearThrowPostureSituationalType;                      // 0x052C(0x0004) (Const)
	int                                                m_nSpearSituationalType[0x4];                             // 0x0530(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Odin_A03");
		return ptr;
	}


	int STATIC_GetSpearSituationalType(TEnumAsByte<EOdinSpearState> eSpearState);
	bool STATIC_CanAIRefire();
	void STATIC_RemoveSpearThrowPosture();
	void ApplySpearThrowPosture();
	void STATIC_RemovePrimedPosture();
	void ApplyPrimedPosture();
	bool ApplySpearHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, TEnumAsByte<EOdinSpearState> eSpearState);
	void STATIC_FireInstantStim();
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void STATIC_FireSpear();
	void SetAmmoCount(int nAmmoCount);
	void STATIC_SetSpearState(TEnumAsByte<EOdinSpearState> eSpearState);
	bool CanBeCanceled();
	bool CanBeInterrupted();
	void STATIC_PersistTimer();
	bool StartFire();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
	bool STATIC_CanLockOnToTarget(class AActor* Target);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Odin_Lunge
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Odin_Lunge : public ATgDevice
{
public:
	class ATgPawn_Odin_V2*                             r_odin;                                                   // 0x04F0(0x0008) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Odin_Lunge");
		return ptr;
	}


	bool STATIC_CanBeCrippled();
};


// Class TgGame.TgDevice_Odin_LungePVE
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Odin_LungePVE : public ATgDevice_Odin_Lunge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Odin_LungePVE");
		return ptr;
	}


	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceForm_Odin_A03
// 0x0029 (0x0275 - 0x024C)
class UTgDeviceForm_Odin_A03 : public UTgDeviceForm_TargetIndicator
{
public:
	class UTgSpecialFx*                                c_RingTimerFX;                                            // 0x024C(0x0008) (Const)
	class UTgSpecialFx*                                c_SpearTargeterFX;                                        // 0x0254(0x0008) (Const)
	int                                                c_nRingExplosionFXId;                                     // 0x025C(0x0004) (Const)
	int                                                c_nSpeedBurstFXId;                                        // 0x0260(0x0004) (Const)
	unsigned long                                      c_bInitializedRingTimerFX : 1;                            // 0x0264(0x0004) (Const)
	float                                              c_fTimeBetweenExlposions;                                 // 0x0268(0x0004) (Const)
	float                                              c_fRingTimerScale;                                        // 0x026C(0x0004)
	int                                                c_nNumTimesFired;                                         // 0x0270(0x0004)
	TEnumAsByte<EOdinSpearState>                       c_eSpearState;                                            // 0x0274(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Odin_A03");
		return ptr;
	}


	void STATIC_CleanupFX();
	void STATIC_CleanupFiringState();
	void ActivateSpeedBurstFX();
	void ActivateExplosionFX();
	void STATIC_DeactivateSpearTargeterFX();
	void ActivateSpearTargeterFX();
	void STATIC_DeactivateRingTimerFX();
	void ActivateRingTimerFX();
	void STATIC_DeactivateRuneFX();
	void UpdateRuneFX(TEnumAsByte<EOdinSpearState> eSpearState);
	void HandleNumShotsFired(TEnumAsByte<EOdinSpearState> eSpearState);
	void DoInterrupt();
	void StopFire(int nFireModeNum);
	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeSpearTargeterFX();
	void STATIC_InitializeRingTimerFX();
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgEffectForm_Odin_PSV
// 0x0014 (0x0124 - 0x0110)
class UTgEffectForm_Odin_PSV : public UTgEffectForm
{
public:
	struct FName                                       m_nmOdinPassive;                                          // 0x0110(0x0008) (Const)
	class ATgPawn_Odin_V2*                             m_pawnOdin;                                               // 0x0118(0x0008)
	float                                              m_fParamTransitionTime;                                   // 0x0120(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Odin_PSV");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OdinRavenShout
// 0x002C (0x00FC - 0x00D0)
class UTgInventoryObject_Listen_OdinRavenShout : public UTgInventoryObject_Listen
{
public:
	int                                                m_nShieldEffectGroupId;                                   // 0x00D0(0x0004)
	int                                                m_nShieldExtendDeviceId;                                  // 0x00D4(0x0004)
	TArray<int>                                        m_ShieldExtendDevices;                                    // 0x00D8(0x0010) (NeedCtorLink)
	TArray<int>                                        m_ShieldExplodeDevices;                                   // 0x00E8(0x0010) (NeedCtorLink)
	unsigned long                                      RavenShoutTimeChanged : 1;                                // 0x00F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OdinRavenShout");
		return ptr;
	}

};


// Class TgGame.TgPawn_Odin
// 0x0014 (0x25CC - 0x25B8)
class ATgPawn_Odin : public ATgPawn_Character
{
public:
	TArray<class UTgDeviceFire*>                       GungnirsMightSecondHit;                                   // 0x25B8(0x0010) (Transient, NeedCtorLink)
	int                                                GungnirsMightCurrentMode;                                 // 0x25C8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Odin");
		return ptr;
	}


	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_SetSpawnEnergy();
	void STATIC_DoGungnirsMightSecondHit();
	void STATIC_OnUtilityPowerChange();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_Odin_V2
// 0x003C (0x2608 - 0x25CC)
class ATgPawn_Odin_V2 : public ATgPawn_Odin
{
public:
	class ATgDevice_Odin_A03*                          m_devOdinA03;                                             // 0x25CC(0x0008)
	class ATgDevice_Odin_A04*                          m_devOdinA04;                                             // 0x25D4(0x0008)
	class ATgDevice*                                   m_devOdinA04Sub;                                          // 0x25DC(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x25E4(0x0004) (Const)
	int                                                m_nDunkFxId;                                              // 0x25E8(0x0004) (Const)
	struct FName                                       m_nmDunkDisplayGroup;                                     // 0x25EC(0x0008) (Const)
	struct FVector                                     r_vDunkLocation;                                          // 0x25F4(0x000C) (Net)
	class UTgEffectTransitions*                        c_effectTransitions;                                      // 0x2600(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Odin_V2");
		return ptr;
	}


	bool PostPawnSetup();
	void STATIC_SpawnDunkFx(const struct FVector& vSpawnLoc);
	void UpdateDunkLocation(const struct FVector& vDunkLocation);
	void SetTargetingDevice(class ATgDevice* Dev);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_InitializeEffectTransitions();
	void UpdateClientDevices(bool bForce);
	void STATIC_PrecacheDevices();
};


// Class TgGame.TgProj_Odin_A03
// 0x0020 (0x03EC - 0x03CC)
class ATgProj_Odin_A03 : public ATgProj_SimulatedSeeking
{
public:
	TEnumAsByte<EOdinSpearState>                       m_eSpearState;                                            // 0x03CC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03CD(0x0003) MISSED OFFSET
	class ATgDevice_Odin_A03*                          m_devOdinA03;                                             // 0x03D0(0x0008)
	unsigned long                                      m_bInitialHit : 1;                                        // 0x03D8(0x0004)
	unsigned long                                      m_bExplodeOnBlocker : 1;                                  // 0x03D8(0x0004)
	unsigned long                                      m_bSkipFriendlies : 1;                                    // 0x03D8(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x03DC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Odin_A03");
		return ptr;
	}


	void Destroyed();
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HideProjectile();
	bool IsValidTarget(class AActor* A);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool UseAOE();
	void UpdateDisplayGroups();
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgDevice_SearingPain
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_SearingPain : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SearingPain");
		return ptr;
	}


	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgPawn_Ra
// 0x0050 (0x2608 - 0x25B8)
class ATgPawn_Ra : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_SpeedOfLightSelfMarks;                                  // 0x25B8(0x0008) (ExportObject, Component, EditInline)
	class UTgMarkComponent*                            m_DivineLightMarks;                                       // 0x25C0(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgDeviceFire*>                       m_DivineLightDetonationModes;                             // 0x25C8(0x0010) (AlwaysInit, NeedCtorLink)
	class UTgEffectGroup*                              m_DivineLightSlowEffectGroup;                             // 0x25D8(0x0008)
	class UTgEffect*                                   m_DivineLightSlowEffect;                                  // 0x25E0(0x0008)
	class UTgEffectGroup*                              m_DivineLightBlindEffectGroup;                            // 0x25E8(0x0008)
	class UTgEffect*                                   m_DivineLightBlindEffect;                                 // 0x25F0(0x0008)
	class UMaterialInstanceConstant*                   m_DivineLightGlowingMIC;                                  // 0x25F8(0x0008)
	float                                              m_DivineLightPercentageProgress;                          // 0x2600(0x0004)
	float                                              r_fPassiveDuration;                                       // 0x2604(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ra");
		return ptr;
	}


	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	bool STATIC_GetPassiveInt1(int* nResult);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_ResetWeaponDuringDivineLight();
	void Tick(float DeltaSeconds);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool PostPawnSetup();
};


// Class TgGame.TgAchievement_Sobek_ArentYouATank
// 0x0028 (0x00AC - 0x0084)
class UTgAchievement_Sobek_ArentYouATank : public UTgAchievement
{
public:
	TArray<int>                                        m_nDevices;                                               // 0x0084(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nTracking;                                              // 0x0094(0x0010) (NeedCtorLink)
	float                                              m_fDuration;                                              // 0x00A4(0x0004)
	float                                              m_fMinWorldTime;                                          // 0x00A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Sobek_ArentYouATank");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSobekGrab
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeSobekGrab : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSobekGrab");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSobekPool
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeSobekPool : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSobekPool");
		return ptr;
	}

};


// Class TgGame.TgDevice_SobekPool
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_SobekPool : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SobekPool");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
	void StopFire();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool IsToggleDevice();
	bool STATIC_CanBeGrabbed();
	bool STATIC_CanBeDisarmed();
	bool STATIC_CanBeSilenced();
	bool STATIC_CanBeStunned();
};


// Class TgGame.TgInventoryObject_Listen_SobekPassive
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_SobekPassive : public UTgInventoryObject_Listen_SuccessfulHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SobekPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Sobek
// 0x0104 (0x26BC - 0x25B8)
class ATgPawn_Sobek : public ATgPawn_Character
{
public:
	class UTgSkeletalMeshComponent*                    c_PassiveArmorMeshComponent;                              // 0x25B8(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMaterialInstanceConstant*                   c_PassiveArmorMIC;                                        // 0x25C0(0x0008)
	float                                              c_PassiveArmorOpacity;                                    // 0x25C8(0x0004)
	float                                              r_fPassiveDuration;                                       // 0x25CC(0x0004) (Net)
	int                                                r_nPassiveStacks;                                         // 0x25D0(0x0004) (Net)
	class ATgCollisionProxy_Cylinder*                  m_RushCollisionProxy;                                     // 0x25D4(0x0008)
	class ATgPawn*                                     TargetToThrow;                                            // 0x25DC(0x0008)
	float                                              PercentageOfPoolDamage;                                   // 0x25E4(0x0004)
	TArray<class UTgAnimNodeSobekGrab*>                c_GrabBlendNodes;                                         // 0x25E8(0x0010) (NeedCtorLink)
	class UTgEffectGroup*                              m_ThrowEffectGroup;                                       // 0x25F8(0x0008)
	int                                                r_GrabNotify;                                             // 0x2600(0x0004) (Net)
	float                                              r_fRushGrabRadius;                                        // 0x2604(0x0004) (Net)
	TArray<class AActor*>                              m_SickeningStrikeTargetsHit;                              // 0x2608(0x0010) (NeedCtorLink)
	struct FVector                                     r_vSickeningStrikeLocation;                               // 0x2618(0x000C) (Net)
	struct FRotator                                    r_rSickeningStrikeRotation;                               // 0x2624(0x000C) (Net)
	int                                                r_nSickeningStrikeTicker;                                 // 0x2630(0x0004) (Net)
	class ATgCollisionProxy_Cylinder*                  m_TailSpinCollisionProxy;                                 // 0x2634(0x0008)
	TArray<class AActor*>                              m_ActorsAffectedByTailSpin;                               // 0x263C(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                c_TailWhipFX;                                             // 0x264C(0x0008) (Transient)
	class ATgCollisionProxy_Cylinder*                  m_PoolCollisionProxy;                                     // 0x2654(0x0008)
	TArray<class AActor*>                              m_ActorsAffectedByPool;                                   // 0x265C(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeSobekPool*>                c_PoolBlendNodes;                                         // 0x266C(0x0010) (NeedCtorLink)
	class UMeshComponent*                              c_PoolMeshComponent;                                      // 0x267C(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgSkeletalMeshComponent*                    c_PoolCrocodilesMeshComponents[0x4];                      // 0x2684(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMaterialInstanceConstant*                   c_PoolMIC;                                                // 0x26A4(0x0008)
	unsigned long                                      c_PoolIsFiring : 1;                                       // 0x26AC(0x0004)
	float                                              c_PoolFiringProgress;                                     // 0x26B0(0x0004)
	class UTgDeviceFire*                               PoolProtectionsMode;                                      // 0x26B4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Sobek");
		return ptr;
	}


	bool IsInClassSpecificChannel();
	void RemovePoolProtections();
	void STATIC_OnThrowEnd();
	void STATIC_StartThrow();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void RemovePoolSlow(class AActor* Other);
	void ApplyPoolSlow(class AActor* Other);
	void PoolCollisionProxyOnUntouch(class AActor* Other);
	void PoolCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TailSpinCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void RushCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_DetachCrocodiles();
	void STATIC_DetachPool();
	void Tick(float DeltaTime);
	bool PostPawnSetup();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_PlayTailWhipFX();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_OnGrabNotify();
	bool CannotJumpNow();
	bool CanBePulled(bool bIsActuallyPulling);
	void AttemptApplyMissedRushTouch(class ATgDevice* devRush);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_SetSpawnEnergy();
	void LoadAndPlaySickeningStrikeMesh(const struct FVector& vLocation, const struct FRotator& rRotation);
	void STATIC_OnUtilityPowerChange();
	void ApplyPoolHit();
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	bool STATIC_InitializeCrocodileMeshComponents();
	bool STATIC_InitializeTailWhipFX();
	bool STATIC_InitializeThrowEffectGroup();
	bool STATIC_InitializePassiveArmorMeshComponent();
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgAchievement_Vamana_BabySmash
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Vamana_BabySmash : public UTgAchievement
{
public:
	int                                                m_nTargetKills;                                           // 0x0084(0x0004)
	int                                                m_nDeviceId;                                              // 0x0088(0x0004)
	int                                                m_nKillCount;                                             // 0x008C(0x0004)
	unsigned long                                      m_bValidStart : 1;                                        // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Vamana_BabySmash");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_VamanaHealthShield
// 0x0004 (0x00EC - 0x00E8)
class UTgInventoryObject_Listen_VamanaHealthShield : public UTgInventoryObject_Listen_ShieldOverTime
{
public:
	unsigned long                                      m_bShieldActive : 1;                                      // 0x00E8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_VamanaHealthShield");
		return ptr;
	}


	void ToggleShield(bool bShieldOn);
	float STATIC_GetMaxShieldTimer();
	float STATIC_GetMaxShieldValue();
	float STATIC_GetShieldTimer();
	float STATIC_GetShieldGainValue();
	void AttemptTimerStart();
};


// Class TgGame.TgPawn_Vamana
// 0x0040 (0x25F8 - 0x25B8)
class ATgPawn_Vamana : public ATgPawn_Character
{
public:
	TEnumAsByte<EVAMANA_SIZE>                          r_eVamanaSize;                                            // 0x25B8(0x0001) (Net)
	TEnumAsByte<EVAMANA_SIZE>                          c_eLocalVamanaSize;                                       // 0x25B9(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x25BA(0x0002) MISSED OFFSET
	float                                              s_DurationAsGiant;                                        // 0x25BC(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                                   // 0x25C0(0x0008)
	float                                              m_ScalingProgress;                                        // 0x25C8(0x0004)
	unsigned long                                      m_IsFinishingTransition : 1;                              // 0x25CC(0x0004)
	TArray<struct FChargeHitInfo>                      m_ChargeHitInfos;                                         // 0x25D0(0x0010) (NeedCtorLink)
	class ATgDevice*                                   s_GiantInHandDevice;                                      // 0x25E0(0x0008)
	class ATgDevice*                                   s_InHandDevice;                                           // 0x25E8(0x0008)
	float                                              r_fPassiveTimer;                                          // 0x25F0(0x0004) (Net)
	float                                              s_fUltDurationModifier;                                   // 0x25F4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Vamana");
		return ptr;
	}


	bool UsesV1ScaleMultiplier();
	void ReplicatedEvent(const struct FName& VarName);
	void ChargeCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnFinishedShrinking();
	void BeginShrinking();
	void STATIC_OnFinishedGrowing();
	void BeginGrowing();
	void STATIC_GrowCollision(float NewRadius, float NewHeight);
	void UpdateVamanaSizeState(TEnumAsByte<EVAMANA_SIZE> NewSize);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_FinishTransition();
	void Tick(float DeltaSeconds);
	void STATIC_OnRespawn();
	void SetTargetingDevice(class ATgDevice* Dev);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	float STATIC_GetDefaultMeshScale();
	void STATIC_CorrectLocationWhileChangingSize(float HeightDelta);
	void STATIC_GetSmallCollisionCylinderSize(float* Radius, float* Height);
	void STATIC_GetGiantCollisionCylinderSize(float* Radius, float* Height);
	void STATIC_SwapToGiantMesh();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	float STATIC_GetPhysicalPowerItem(const struct FImpactInfo& Impact, float PowerScaling);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
};


// Class TgGame.TgProj_VamanaUmbrella
// 0x0008 (0x03B4 - 0x03AC)
class ATgProj_VamanaUmbrella : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      m_ShouldReturnToVamana : 1;                               // 0x03AC(0x0004)
	float                                              m_fTurnStrength;                                          // 0x03B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_VamanaUmbrella");
		return ptr;
	}


	void STATIC_PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	struct FVector GetSeekLocation();
	void UpdateSeekingDirection(float fDeltaTime);
	void Tick(float fDeltaTime);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void STATIC_RangeReached();
};


// Class TgGame.TgAchievement_Ymir_WhySoCold
// 0x0000 (0x00B4 - 0x00B4)
class UTgAchievement_Ymir_WhySoCold : public UTgAchievement_MatchHitsByDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Ymir_WhySoCold");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeYmirShards
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeYmirShards : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeYmirShards");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Ymir_IceWall
// 0x0000 (0x040C - 0x040C)
class ATgDeployable_Ymir_IceWall : public ATgDeploy_Wall
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ymir_IceWall");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ymir_A01
// 0x0000 (0x0514 - 0x0514)
class ATgDevice_Ymir_A01 : public ATgDevice_TogglableDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ymir_A01");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ymir_Explosion
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Ymir_Explosion : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ymir_Explosion");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
	void StopFire();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanJumpWhileFiring();
	bool IsToggleDevice();
	bool STATIC_CanBeGrabbed();
	bool STATIC_CanBeDisarmed();
	bool STATIC_CanBeSilenced();
	bool STATIC_CanBeStunned();
};


// Class TgGame.TgPawn_Ymir
// 0x0054 (0x260C - 0x25B8)
class ATgPawn_Ymir : public ATgPawn_Character
{
public:
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x25B8(0x0008) (ExportObject, Component, EditInline)
	class ATgCollisionProxy_Cylinder*                  m_ShardsOfIceCollisionProxy;                              // 0x25C0(0x0008)
	TArray<class AActor*>                              m_ActorsAffectedByShardsOfIce;                            // 0x25C8(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              m_fPercentShardsOfIceDamage;                              // 0x25D8(0x0004)
	float                                              m_fChargeTimeStart;                                       // 0x25DC(0x0004)
	TArray<class UTgAnimNodeYmirShards*>               c_ShardsOfIceBlendNodes;                                  // 0x25E0(0x0010) (NeedCtorLink)
	float                                              m_fShardsOfIceDelay;                                      // 0x25F0(0x0004) (Const)
	class UTgDeviceFire*                               s_ShardsOfIceHitMode;                                     // 0x25F4(0x0008)
	class UAudioComponent*                             m_ShardsOfIceAC;                                          // 0x25FC(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgSpecialFx*                                m_ShardsOfIceFX;                                          // 0x2604(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ymir");
		return ptr;
	}


	void Destroyed();
	void STATIC_PlayShardsExplosion();
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	float ApplyPitchLimit(float fPitch);
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void RemoveShardsOfIceSlow(class AActor* Other);
	void ApplyShardsOfIceSlow(class AActor* Other);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ShardsOfIceCollisionProxyOnUntouch(class AActor* Other);
	void ShardsOfIceCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_IgnoreFaceRotationWithInterp();
	bool CannotJumpNow();
	bool CanBePulled(bool bIsActuallyPulling);
	void AudioComponentAttached(class UAudioComponent* AC, int DatabaseID, int LoopIndex);
	bool PostPawnSetup();
	bool STATIC_InitializeShardsExplosionFX();
	void STATIC_OnPostureChange();
	void ApplyShardsOfIceHit();
	void STATIC_EndShardsOfIce(bool bSkipHit);
	void STATIC_SpawnIceSpikes();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
};


// Class TgGame.TgAchievement_Zeus_Detonate
// 0x0008 (0x00A0 - 0x0098)
class UTgAchievement_Zeus_Detonate : public UTgAchievement_DeviceKillsSingleShot
{
public:
	int                                                m_DeviceId;                                               // 0x0098(0x0004)
	int                                                m_KillGoal;                                               // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Zeus_Detonate");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Zeus_WatchItBounce
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Zeus_WatchItBounce : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                               // 0x0084(0x0004)
	int                                                m_BounceGoal;                                             // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Zeus_WatchItBounce");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByZeusShieldRecover
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByZeusShieldRecover : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByZeusShieldRecover");
		return ptr;
	}


	bool STATIC_Recover();
};


// Class TgGame.TgDeployable_Zeus_LightningStorm
// 0x001C (0x03F0 - 0x03D4)
class ATgDeployable_Zeus_LightningStorm : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03E4(0x0008)
	unsigned long                                      bCleaningUp : 1;                                          // 0x03EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Zeus_LightningStorm");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void Cleanup();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_Zeus_ChainLightning
// 0x0000 (0x0500 - 0x0500)
class ATgDevice_Zeus_ChainLightning : public ATgDevice_ArcingBeam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Zeus_ChainLightning");
		return ptr;
	}


	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Zeus_SuperLightningBolt
// 0x0001 (0x04F1 - 0x04F0)
class ATgDevice_Zeus_SuperLightningBolt : public ATgDevice_Range
{
public:
	TEnumAsByte<ELightningBoltState>                   m_eBoltState;                                             // 0x04F0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Zeus_SuperLightningBolt");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_ClientSetBoltState(TEnumAsByte<ELightningBoltState> NewState);
	void STATIC_SetBoltState(TEnumAsByte<ELightningBoltState> NewState, class ATgPawn* Target, bool bNoCooldown);
	class ATgProjectile* GetProjectile();
	bool ShouldCooldownAfterFire();
};


// Class TgGame.TgDevice_Zeus_Shield
// 0x0000 (0x0508 - 0x0508)
class ATgDevice_Zeus_Shield : public ATgDevice_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Zeus_Shield");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void STATIC_FireAmmunition();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_ClientInterrupt();
	void STATIC_OnStateSet(TEnumAsByte<ETwoPhaseState> PrevState, TEnumAsByte<ETwoPhaseState> CurrentState);
	float STATIC_GetToggleMaxTime(int nMode);
};


// Class TgGame.TgDevice_Zeus_ForkedLightning
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_Zeus_ForkedLightning : public ATgDevice
{
public:
	TArray<struct FArcingInfo>                         m_ArcingList;                                             // 0x04F0(0x0010) (NeedCtorLink)
	int                                                m_nLastImpactIndex;                                       // 0x0500(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Zeus_ForkedLightning");
		return ptr;
	}


	void TriggerArc(int Index);
	float STATIC_GetArcDamageMultiplier(float previousDamageMultiplier);
	void STATIC_EndArcing(int Index);
	void BeginArcing(class AActor* initialTarget, class UTgDeviceFire_Zeus_ForkedLightning* FireMode);
	void Tick(float DeltaTime);
	void STATIC_DeviceAdjustDamage(int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	class AActor* STATIC_DetermineNextTarget(int Index);
};


// Class TgGame.TgDeviceFire_Zeus_ChainLightning
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Zeus_ChainLightning : public UTgDeviceFire_ArcingBeam
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Zeus_ChainLightning");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Zeus_BasicAttack
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Zeus_BasicAttack : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Zeus_BasicAttack");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Zeus_ChainLightning_PVE
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Zeus_ChainLightning_PVE : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Zeus_ChainLightning_PVE");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	void ApplyEquipEffects();
};


// Class TgGame.TgDeviceFire_Zeus_ForkedLightning
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Zeus_ForkedLightning : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Zeus_ForkedLightning");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgInventoryObject_Listen_ZeusDualWield
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_ZeusDualWield : public UTgInventoryObject_Listen_InHand
{
public:
	unsigned long                                      s_bActive : 1;                                            // 0x00D0(0x0004)
	int                                                s_nActiveCategoryCode;                                    // 0x00D4(0x0004) (Const)
	int                                                s_nProcOnHitsAboveFiringInstance;                         // 0x00D8(0x0004)
	int                                                s_nProcOnHitsBelowFiringInstance;                         // 0x00DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ZeusDualWield");
		return ptr;
	}

};


// Class TgGame.TgMarkComponent_Zeus_Lockon
// 0x0000 (0x00BC - 0x00BC)
class UTgMarkComponent_Zeus_Lockon : public UTgMarkComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_Zeus_Lockon");
		return ptr;
	}


	void UpdateLockonState();
	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgPawn_Zeus
// 0x0058 (0x2610 - 0x25B8)
class ATgPawn_Zeus : public ATgPawn_Character
{
public:
	class UTgMarkComponent_Zeus_Lockon*                m_ChargeComponent;                                        // 0x25B8(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class UTgDeviceFire*>                       m_DetonateFxModes;                                        // 0x25C0(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                r_nLocksActive;                                           // 0x25D0(0x0004) (Net)
	TEnumAsByte<EZeusShieldThrowState>                 r_eShieldThrowState;                                      // 0x25D4(0x0001) (Net)
	TEnumAsByte<EZeusShieldThrowState>                 c_eLocalShieldThrowState;                                 // 0x25D5(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x25D6(0x0002) MISSED OFFSET
	TArray<class USkelControlBase*>                    c_ShieldThrowSkelControls;                                // 0x25D8(0x0010) (NeedCtorLink)
	struct FName                                       c_ShieldThrowSkelControlName;                             // 0x25E8(0x0008)
	TArray<class UTgAnimBlendByZeusShieldRecover*>     c_ShieldReturnAnimNodes;                                  // 0x25F0(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_MaxChargedDetonatedActors;                              // 0x2600(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Zeus");
		return ptr;
	}


	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void STATIC_ForceShieldAttach();
	void STATIC_QueueUpForceShieldAttach();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UpdateShieldState(TEnumAsByte<EZeusShieldThrowState> NewState);
	void STATIC_OnRespawn();
	bool DeviceOverrideLockedDown(class ATgDevice* Dev);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_DetonateMarks();
	void ApplyMark(class AActor* Target);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
};


// Class TgGame.TgPawn_ZeusV2
// 0x0010 (0x2620 - 0x2610)
class ATgPawn_ZeusV2 : public ATgPawn_Zeus
{
public:
	int                                                m_nMaxPassiveDamageMultiplier;                            // 0x2610(0x0004)
	int                                                m_nPassiveIncreasedDamagePerCharge;                       // 0x2614(0x0004)
	class ATgProj_Zeus_LightningBolt*                  m_LightningBolt;                                          // 0x2618(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ZeusV2");
		return ptr;
	}


	void SetLightningBolt(class ATgProj_Zeus_LightningBolt* Proj);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_DetonateMarks();
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
};


// Class TgGame.TgProj_Zeus_Shield
// 0x000C (0x03D0 - 0x03C4)
class ATgProj_Zeus_Shield : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:
	struct FVector                                     m_ActualGroundLocation;                                   // 0x03C4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Zeus_Shield");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SetGroundTarget(const struct FVector& GTLocation);
};


// Class TgGame.TgProj_Zeus_LightningBolt
// 0x0008 (0x0414 - 0x040C)
class ATgProj_Zeus_LightningBolt : public ATgProj_SimulatedArcing
{
public:
	unsigned long                                      m_bFirstHit : 1;                                          // 0x040C(0x0004)
	int                                                m_nMeshId;                                                // 0x0410(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Zeus_LightningBolt");
		return ptr;
	}


	void AdvanceToNextTarget(class AActor* NewTargetOverride);
	void Destroyed();
	void ShutDown();
	void STATIC_SwapMesh();
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgAchievement_GuanYu_TheWarriorsWill
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_GuanYu_TheWarriorsWill : public UTgAchievement_AbilityMultiHeal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GuanYu_TheWarriorsWill");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByGuanYuV2Ult
// 0x000C (0x0174 - 0x0168)
class UTgAnimBlendByGuanYuV2Ult : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_GuanYuV2*                            m_GuanYuPawn;                                             // 0x0168(0x0008)
	unsigned long                                      m_bAlternateFireAnim : 1;                                 // 0x0170(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByGuanYuV2Ult");
		return ptr;
	}


	void STATIC_PlayMountAnim();
	void STATIC_PlayDismountAnim();
	void STATIC_PlayFireAnim();
};


// Class TgGame.TgInventoryObject_Listen_GuanYuPassive
// 0x001C (0x013C - 0x0120)
class UTgInventoryObject_Listen_GuanYuPassive : public UTgInventoryObject_Listen_Stack
{
public:
	unsigned long                                      m_bHitAppliedThisTick : 1;                                // 0x0120(0x0004)
	TArray<int>                                        m_nStackRemovingDevices;                                  // 0x0124(0x0010) (NeedCtorLink)
	int                                                s_nModifiedDeviceId;                                      // 0x0134(0x0004)
	int                                                s_nModifiedDeviceFiringInstance;                          // 0x0138(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GuanYuPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_GuanYuV2
// 0x00F0 (0x26A8 - 0x25B8)
class ATgPawn_GuanYuV2 : public ATgPawn_Character
{
public:
	unsigned long                                      m_bHasInitializedPassiveEnergy : 1;                       // 0x25B8(0x0004)
	unsigned long                                      m_HasHitWithThisHeal : 1;                                 // 0x25B8(0x0004)
	unsigned long                                      m_NeedsToShortenHealCooldown : 1;                         // 0x25B8(0x0004)
	unsigned long                                      m_HasHitWithThisCharge : 1;                               // 0x25B8(0x0004)
	unsigned long                                      m_NeedsToShortenChargeCooldown : 1;                       // 0x25B8(0x0004)
	unsigned long                                      r_bHasDismountBeenCalled : 1;                             // 0x25B8(0x0004) (Net)
	unsigned long                                      r_bAnimIsRidingHorse : 1;                                 // 0x25B8(0x0004) (Net)
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                                   // 0x25BC(0x0008)
	TArray<struct FSavedChargeHitV2>                   m_SavedChargeHits;                                        // 0x25C4(0x0010) (NeedCtorLink)
	class UStaticMeshComponent*                        c_GuanDaoMeshComponent;                                   // 0x25D4(0x0008) (ExportObject, Component, EditInline)
	class UTgMarkComponent*                            m_TripleJumpSlamMarkComponent;                            // 0x25DC(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              m_TimeSinceInitiatedUltimate;                             // 0x25E4(0x0004)
	float                                              m_fUltPhase1RemainingTime;                                // 0x25E8(0x0004)
	float                                              r_fUltPhase1Time;                                         // 0x25EC(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    m_WarHorseMesh;                                           // 0x25F0(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fUltPhase1MaxSpeedMultiplier;                           // 0x25F8(0x0004)
	float                                              m_fUltPhase2MaxSpeedMultiplier;                           // 0x25FC(0x0004)
	float                                              m_fUltPhase3GallopSpeed;                                  // 0x2600(0x0004)
	int                                                m_nUltTurnRate;                                           // 0x2604(0x0004)
	float                                              r_fUltPhase2SlowMaxSpeedMultiplier;                       // 0x2608(0x0004) (Net)
	TEnumAsByte<EGuanYuUltPhase>                       r_CurrentUltPhase;                                        // 0x260C(0x0001) (Net)
	TEnumAsByte<EGuanYuPassiveState>                   r_ePassiveFXState;                                        // 0x260D(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x260E(0x0002) MISSED OFFSET
	float                                              m_fUltHorseZOffset;                                       // 0x2610(0x0004)
	struct FVector                                     m_vUltHorseInitialLocation;                               // 0x2614(0x000C)
	struct FVector                                     m_vGallopAwayHorseSourceLocation;                         // 0x2620(0x000C)
	struct FVector                                     m_vGallopAwayTargetLocation;                              // 0x262C(0x000C)
	float                                              m_fGallopAwayRemainingTime;                               // 0x2638(0x0004)
	float                                              r_fGallopAwayTime;                                        // 0x263C(0x0004) (Net)
	class UTgAnimNodeAimOffset*                        m_GuanYuLeanAimNode;                                      // 0x2640(0x0008)
	class UTgAnimNodeAimOffset*                        m_HorseLeanAimNode;                                       // 0x2648(0x0008)
	float                                              m_fTurnSlowPct;                                           // 0x2650(0x0004)
	float                                              m_fPassiveHealingMultiplier;                              // 0x2654(0x0004)
	class ATgDevice*                                   r_UltShooterDevice;                                       // 0x2658(0x0008) (Net)
	class ATgDevice*                                   r_UltDismountDevice;                                      // 0x2660(0x0008) (Net)
	class ATgDevice*                                   m_DefaultInHandDevice;                                    // 0x2668(0x0008)
	int                                                m_nUltHitIndex;                                           // 0x2670(0x0004)
	int                                                r_nNumTotalUltHits;                                       // 0x2674(0x0004) (Net)
	class UTgAnimBlendByGuanYuV2Ult*                   m_UltAnimNode;                                            // 0x2678(0x0008)
	class UTgAnimNodeSequence*                         m_UltFire01SeqNode;                                       // 0x2680(0x0008)
	class UTgAnimNodeSequence*                         m_UltFire02SeqNode;                                       // 0x2688(0x0008)
	TArray<struct FGuanYuV2UltTarget>                  m_UltTargets;                                             // 0x2690(0x0010) (NeedCtorLink)
	struct FName                                       m_nmActivatePSVWarningFXFunction;                         // 0x26A0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_GuanYuV2");
		return ptr;
	}


	bool STATIC_CanFireDeviceWhenInvulnerable(class ATgDevice* Dev);
	bool STATIC_CanFireDeviceInStasis(class ATgDevice* Dev);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_ServerForceUltDismount();
	void STATIC_OnRightMousePressed();
	void STATIC_CustomFireLockout();
	void PostDemoRewind();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void EndHorse();
	void PlayUltFire();
	void PlayDismount();
	void StopCharging();
	void OnUltFinished();
	void PlayWarhorseStage2Effects();
	void SpawnWarhorse(bool bPlayMount);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_ClientSetStun();
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	float STATIC_GetChargeTurnRate();
	void ChargeCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ReplicatedEvent(const struct FName& VarName);
	void PreDemoRewind();
	void ActivatePassiveWarningFX();
	void STATIC_EnablePassiveFX(TEnumAsByte<EGuanYuPassiveState> eEnabled);
	int STATIC_GetModifiedSituationalType(class ATgDevice* Dev);
	bool STATIC_ShouldModifyDevice(class ATgDevice* Dev);
	float STATIC_GetSmoothEnergy();
	void STATIC_PostPawnSetupServer();
	void STATIC_SetSpawnEnergy();
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_ForceDismountFire();
	void UpdateHorse(float DeltaTime);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceAdjustHeal(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DeviceOnPostHit(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgAchievement_Baka_Butcher
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_Baka_Butcher : public UTgAchievement
{
public:
	int                                                m_nNumKills;                                              // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Baka_Butcher");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByBakasuraInHand
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendByBakasuraInHand : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Bakasura*                            m_CachedBakasura;                                         // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByBakasuraInHand");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimNodeBlendPerBone_Bakasura_ConsumeMinion
// 0x0010 (0x0168 - 0x0158)
class UTgAnimNodeBlendPerBone_Bakasura_ConsumeMinion : public UAnimNodeBlendPerBone
{
public:
	class ATgPawn_Bakasura*                            c_OwningBakasuraPawn;                                     // 0x0158(0x0008) (Transient)
	class ATgPawn*                                     c_CachedConsumedPawn;                                     // 0x0160(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendPerBone_Bakasura_ConsumeMinion");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Bakasura_EatMinion_FX
// 0x0000 (0x02D0 - 0x02D0)
class ATgCollisionProxy_Bakasura_EatMinion_FX : public ATgCollisionProxy_FX
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Bakasura_EatMinion_FX");
		return ptr;
	}


	bool STATIC_ShouldRemoveFx(class ATgPawn* Target);
	bool STATIC_ShouldApplyFx(class ATgPawn* Target);
};


// Class TgGame.TgDeploy_Bakasura_VomitPool
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeploy_Bakasura_VomitPool : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Bakasura_VomitPool");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void PostBeginPlay();
};


// Class TgGame.TgDevice_Bakasura_EatMinion
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Bakasura_EatMinion : public ATgDevice
{
public:
	class ATgCollisionProxy_Bakasura_EatMinion_FX*     c_EatMinionFxProxy;                                       // 0x04F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bakasura_EatMinion");
		return ptr;
	}


	void TurnOffEatMinionProxy();
	void TurnOnEatMinionProxy();
	void STATIC_ClientCooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void ClientStartCooldown(int nMode, float fCooldownTime);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SpawnEatMinionFxProxy();
};


// Class TgGame.TgDevice_BakasuraSpitMinion
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_BakasuraSpitMinion : public ATgDevice
{
public:
	int                                                m_nAmmoCount;                                             // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BakasuraSpitMinion");
		return ptr;
	}


	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	bool ReplenishMinionAmmunition(class ATgPawn* KilledPawn);
};


// Class TgGame.TgDeviceFire_BakasuraConsumeMinion
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_BakasuraConsumeMinion : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BakasuraConsumeMinion");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgPawn_Bakasura
// 0x008C (0x2644 - 0x25B8)
class ATgPawn_Bakasura : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_MinionAmmunitionMarkComponent;                          // 0x25B8(0x0008) (ExportObject, Transient, Component, EditInline)
	class ATgDevice*                                   m_BasicAttackDevice;                                      // 0x25C0(0x0008)
	class ATgDevice*                                   m_ChompDevice;                                            // 0x25C8(0x0008)
	int                                                r_PawnIdToBeConsumed;                                     // 0x25D0(0x0004) (Net)
	class ATgPawn*                                     c_PawnToBeConsumed;                                       // 0x25D4(0x0008)
	float                                              c_PawnConsumptionStartTimestamp;                          // 0x25DC(0x0004)
	float                                              c_ConsumedPawnInitialScale;                               // 0x25E0(0x0004)
	unsigned long                                      c_bConsumingPawn : 1;                                     // 0x25E4(0x0004)
	unsigned long                                      m_bTrueDamageBuffActive : 1;                              // 0x25E4(0x0004)
	unsigned long                                      c_HasTrueDamageBlades : 1;                                // 0x25E4(0x0004)
	unsigned long                                      c_bIsInUltimate : 1;                                      // 0x25E4(0x0004)
	struct FName                                       m_ConsumeBone;                                            // 0x25E8(0x0008)
	TArray<class UTgDeviceFire*>                       m_TrueDamageDeviceModes;                                  // 0x25F0(0x0010) (NeedCtorLink)
	int                                                m_nTrueDamageBuffFiringInstance;                          // 0x2600(0x0004)
	class UTgSkeletalMeshComponent*                    c_BladesMeshComponent;                                    // 0x2604(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMaterialInstanceConstant*                   c_BladesMIC;                                              // 0x260C(0x0008) (Transient)
	float                                              c_BladeOpacity;                                           // 0x2614(0x0004)
	class UTgSpecialFx*                                c_LeftBladeSpecialFX;                                     // 0x2618(0x0008) (Transient)
	class UTgSpecialFx*                                c_RightBladeSpecialFX;                                    // 0x2620(0x0008) (Transient)
	struct FName                                       m_LeftBladeSocket;                                        // 0x2628(0x0008)
	struct FName                                       m_RightBladeSocket;                                       // 0x2630(0x0008)
	float                                              r_fUltimateDuration;                                      // 0x2638(0x0004) (Net)
	float                                              r_fPassiveDuration;                                       // 0x263C(0x0004) (Net)
	int                                                r_nPassiveStacks;                                         // 0x2640(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Bakasura");
		return ptr;
	}


	void UltimateComplete();
	bool BlendInHandToUltimate();
	struct FName GetDeathAnimName();
	void OnBotDied(class ATgPawn* DeadPawn);
	void EndChompMode();
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void Tick(float DeltaSeconds);
	void STATIC_FinishedIntro();
	void STATIC_PlaySpawnFx();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void DestroyConsumedPawn();
	void STATIC_PawnOnRevive();
	void STATIC_OnPawnDied();
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_PostPawnSetupServer();
	void STATIC_SetSpawnEnergy();
	void STATIC_ReapplyLoadoutEffects();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_InitializeBladeSpecialFX();
	bool STATIC_InitializeBladeMeshComponent();
};


// Class TgGame.TgPawn_BakasuraV1
// 0x001C (0x2660 - 0x2644)
class ATgPawn_BakasuraV1 : public ATgPawn_Bakasura
{
public:
	class UTgSkeletalMeshComponent*                    c_HeadMeshComponent;                                      // 0x2644(0x0008) (ExportObject, Transient, Component, EditInline)
	unsigned long                                      c_ShouldHideHeadBone : 1;                                 // 0x264C(0x0004)
	class UTgSpecialFx*                                c_HoodSmokeSpecialFX;                                     // 0x2650(0x0008) (Transient)
	class UTgSpecialFx*                                c_HeadSmokeSpecialFX;                                     // 0x2658(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BakasuraV1");
		return ptr;
	}


	void UltimateComplete();
	struct FName GetDeathAnimName();
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_ShrinkHead();
	void STATIC_FinishedIntro();
	void STATIC_PlaySpawnFx();
	bool PostPawnSetup();
	void Tick(float DeltaSeconds);
	void STATIC_SetMeshVisibility(bool bVisible);
	bool STATIC_InitializeSmokeSpecialFX();
	bool STATIC_InitializeHeadMeshComponent();
};


// Class TgGame.TgPawn_BakasuraV2
// 0x0030 (0x2674 - 0x2644)
class ATgPawn_BakasuraV2 : public ATgPawn_Bakasura
{
public:
	class UTgSkeletalMeshComponent*                    c_TentacleMeshComponent;                                  // 0x2644(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              m_fTentacleDuration;                                      // 0x264C(0x0004)
	struct FName                                       m_TentacleSkelControlName;                                // 0x2650(0x0008)
	class USkelControlBase*                            m_TentacleSkelControl;                                    // 0x2658(0x0008)
	unsigned long                                      m_bShowTentacles : 1;                                     // 0x2660(0x0004)
	class UTgSkeletalMeshComponent*                    c_UltimateMeshComponent;                                  // 0x2664(0x0008) (ExportObject, Transient, Component, EditInline)
	struct FName                                       c_UltimateSocketName;                                     // 0x266C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BakasuraV2");
		return ptr;
	}


	void SetUltimateMesh(bool bAttach);
	void UltimateComplete();
	void SetTentacleMesh(bool bAttach);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void Tick(float DeltaSeconds);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	bool PostPawnSetup();
	bool STATIC_InitializeTentacleMeshComponent();
	bool STATIC_InitializeUltimateMeshComponent();
};


// Class TgGame.TgProj_Bakasura_Spat_Minion
// 0x0004 (0x03C0 - 0x03BC)
class ATgProj_Bakasura_Spat_Minion : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:
	int                                                m_nMinionCount;                                           // 0x03BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Bakasura_Spat_Minion");
		return ptr;
	}


	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	class ATgPawn* STATIC_SpawnTheBot(const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgSkelCon_BakasuraHead
// 0x0008 (0x0108 - 0x0100)
class UTgSkelCon_BakasuraHead : public USkelControlSingleBone
{
public:
	class ATgPawn_BakasuraV1*                          m_OwningPawn;                                             // 0x0100(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_BakasuraHead");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Anhur_Wall
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Anhur_Wall : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Anhur_Wall");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Anhur_Consecrate
// 0x0000 (0x0440 - 0x0440)
class ATgDeploy_Anhur_Consecrate : public ATgDeploy_SandPillar
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Anhur_Consecrate");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_AnhurDisarm
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_AnhurDisarm : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AnhurDisarm");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceForm_Anhur_Disarm
// 0x0014 (0x024C - 0x0238)
class UTgDeviceForm_Anhur_Disarm : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorPBAOE;                        // 0x0238(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFxPBAOE;                                   // 0x0240(0x0008)
	int                                                c_nTargetingModeFxPBAOEId;                                // 0x0248(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Anhur_Disarm");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgPawn_Anhur
// 0x0000 (0x25B8 - 0x25B8)
class ATgPawn_Anhur : public ATgPawn_Character
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Anhur");
		return ptr;
	}


	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgProj_Anhur_Spear
// 0x0008 (0x03A0 - 0x0398)
class ATgProj_Anhur_Spear : public ATgProj_Simulated
{
public:
	float                                              m_RollVariance;                                           // 0x0398(0x0004)
	float                                              m_fPitchOffset;                                           // 0x039C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Anhur_Spear");
		return ptr;
	}


	void PostBeginPlay();
	bool IsOutsideMinRange(const struct FVector& HitLocation);
	float STATIC_GetGravityZ();
	void Init(const struct FVector& Direction);
};


// Class TgGame.TgProj_Anhur_ImpalingSpear
// 0x0014 (0x03B4 - 0x03A0)
class ATgProj_Anhur_ImpalingSpear : public ATgProj_Anhur_Spear
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x03A0(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x03A4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Anhur_ImpalingSpear");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_PerformWallKnockback(class ATgPawn* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Anhur_SpearVolley
// 0x0014 (0x03B4 - 0x03A0)
class ATgProj_Anhur_SpearVolley : public ATgProj_Anhur_Spear
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x03A0(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x03A4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Anhur_SpearVolley");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAchievement_Cupid_SpreadTheLove
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_Cupid_SpreadTheLove : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	TArray<class ATgPawn*>                             m_TrackedSaved;                                           // 0x0088(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Cupid_SpreadTheLove");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Cupid_HeartMineField
// 0x0010 (0x0408 - 0x03F8)
class ATgDeployable_Cupid_HeartMineField : public ATgDeploy_EffectVolume
{
public:
	class UMaterialInstanceConstant*                   c_MIC;                                                    // 0x03F8(0x0008)
	float                                              m_SecondsSinceDeployed;                                   // 0x0400(0x0004)
	int                                                s_LovestruckCount;                                        // 0x0404(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Cupid_HeartMineField");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void InitializeMIC();
};


// Class TgGame.TgDeployable_Cupid_HealingHearts
// 0x0018 (0x03EC - 0x03D4)
class ATgDeployable_Cupid_HealingHearts : public ATgDeployable
{
public:
	unsigned long                                      m_Triggered : 1;                                          // 0x03D4(0x0004)
	int                                                s_LovestruckCount;                                        // 0x03D8(0x0004)
	float                                              r_InitialMeshOffset;                                      // 0x03DC(0x0004) (Net)
	struct FVector                                     m_TargetMeshOffset;                                       // 0x03E0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Cupid_HealingHearts");
		return ptr;
	}


	void TriggerHeart(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
};


// Class TgGame.TgDeviceFire_Cupid_HealingHearts
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Cupid_HealingHearts : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cupid_HealingHearts");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgEffectForm_Cupid_Mark
// 0x0004 (0x0124 - 0x0120)
class UTgEffectForm_Cupid_Mark : public UTgEffectForm_WithMeshes
{
public:
	int                                                c_CupidHeartMarkExplosionFXId;                            // 0x0120(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Cupid_Mark");
		return ptr;
	}


	void AdjustHidden();
	void Detach();
	void STATIC_Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgInventoryObject_Listen_Cupid_HeartBomb
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Cupid_HeartBomb : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Cupid_HeartBomb");
		return ptr;
	}

};


// Class TgGame.TgMarkComponent_Cupid_TimedBomb
// 0x0004 (0x00C0 - 0x00BC)
class UTgMarkComponent_Cupid_TimedBomb : public UTgMarkComponent
{
public:
	int                                                s_LovestruckCount;                                        // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_Cupid_TimedBomb");
		return ptr;
	}


	void STATIC_RemoveMarkByIndex(int nIndex);
};


// Class TgGame.TgPawn_Cupid
// 0x0054 (0x260C - 0x25B8)
class ATgPawn_Cupid : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_PassiveMarkComponent;                                   // 0x25B8(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgSpecialFx*                                c_PassiveSpecialFX;                                       // 0x25C0(0x0008) (Transient)
	int                                                m_TimedBombProjectileLovestruckCount;                     // 0x25C8(0x0004)
	int                                                m_TimedBombLovestruckCount;                               // 0x25CC(0x0004)
	class UTgMarkComponent_Cupid_TimedBomb*            m_TimedBombMarkComponent;                                 // 0x25D0(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class UTgDeviceFire*>                       m_TimedBombModes;                                         // 0x25D8(0x0010) (AlwaysInit, NeedCtorLink)
	class UTgEffectGroup*                              m_TimedBombInstantExplosionEffectGroup;                   // 0x25E8(0x0008)
	int                                                m_HealingHeartsLovestruckCounter;                         // 0x25F0(0x0004)
	struct FVector                                     m_LastSpeedPadDeployableLocation;                         // 0x25F4(0x000C)
	float                                              m_SpeedPadDistanceInterval;                               // 0x2600(0x0004)
	class UTgSkeletalMeshComponent*                    c_GhostMeshComponent;                                     // 0x2604(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Cupid");
		return ptr;
	}


	bool STATIC_IgnoreFaceRotationWithInterp();
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void Tick(float DeltaSeconds);
	bool PostPawnSetup();
	void STATIC_SpawnSpeedPad(const struct FVector& SpawnLocation);
	float STATIC_GetSpeedPadDistanceInterval();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void TimedBombExplosion(class AActor* ExplodingActor, bool ShouldStun);
	bool STATIC_EffectGroupCanBeHardCleared(class UTgEffectGroup* EffectGroup);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceAdjustHeal(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PostPawnSetupServer();
	void STATIC_ResetGhostMeshComponent();
	bool STATIC_InitializeGhostMeshComponent();
	bool STATIC_InitializePassiveSpecialFX();
};


// Class TgGame.TgProj_Cupid_HeartBomb
// 0x0004 (0x039C - 0x0398)
class ATgProj_Cupid_HeartBomb : public ATgProj_Simulated
{
public:
	int                                                s_LovestruckCount;                                        // 0x0398(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Cupid_HeartBomb");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgSkelCon_Cupid_HeartMineField
// 0x0008 (0x0108 - 0x0100)
class UTgSkelCon_Cupid_HeartMineField : public USkelControlSingleBone
{
public:
	class ATgDeployable_Cupid_HeartMineField*          m_OwningDeployable;                                       // 0x0100(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Cupid_HeartMineField");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Thor_HammerSlam
// 0x0030 (0x043C - 0x040C)
class ATgDeployable_Thor_HammerSlam : public ATgDeploy_Wall
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x040C(0x0010) (NeedCtorLink)
	class UMeshComponent*                              m_CollisionMesh;                                          // 0x041C(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nCollisionMeshId;                                       // 0x0424(0x0004)
	float                                              m_fCollisionHeightAdjust;                                 // 0x0428(0x0004)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x042C(0x0008)
	int                                                m_nHitMeshId;                                             // 0x0434(0x0004)
	float                                              m_fHitHeightAdjust;                                       // 0x0438(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Thor_HammerSlam");
		return ptr;
	}


	void Destroyed();
	void NotifyCollisionOff();
	void NotifyCollisionOn();
	bool STATIC_ShouldHit(class AActor* Other);
	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeployComplete();
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool UpdateOverlappingActorByIndex(int Index, const struct FVector& PushDirection);
	void ToggleCollisionMesh(bool bCollide);
	void UpdateMeshOffset();
};


// Class TgGame.TgDevice_ThorPassive
// 0x0004 (0x0528 - 0x0524)
class ATgDevice_ThorPassive : public ATgDevice_PassiveAura
{
public:
	int                                                m_nNumInRange;                                            // 0x0524(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ThorPassive");
		return ptr;
	}


	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
};


// Class TgGame.TgDevice_Thor_BerserkerBarrage
// 0x0010 (0x0558 - 0x0548)
class ATgDevice_Thor_BerserkerBarrage : public ATgDevice_RadialSweep_MultiHit
{
public:
	class ATgPawn_Thor*                                m_ThorPawn;                                               // 0x0548(0x0008) (Const)
	float                                              m_fTimeToStrike;                                          // 0x0550(0x0004) (Const)
	unsigned long                                      m_bDeliverSpecialHitsInstead : 1;                         // 0x0554(0x0004)
	unsigned long                                      m_bUseStrikeAim : 1;                                      // 0x0554(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thor_BerserkerBarrage");
		return ptr;
	}


	void DeliverQueuedPendingHits();
	void STATIC_DoStrikeAttack();
	void ProxyEndSweep(bool bInterrupt);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_ThorTeleportHammer
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_ThorTeleportHammer : public ATgDevice_ProjectileTeleport
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ThorTeleportHammer");
		return ptr;
	}


	bool STATIC_DoTeleport(const struct FVector& vLocation, const struct FVector& vClientLocation);
	class ATgProjectile* GetProjectile();
};


// Class TgGame.TgDevice_ThorAnvilStaging
// 0x0000 (0x0528 - 0x0528)
class ATgDevice_ThorAnvilStaging : public ATgDevice_Staging
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ThorAnvilStaging");
		return ptr;
	}


	bool STATIC_FireEndStageDevice();
	void OnStageShooterStopFire(bool bInterrupted);
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_ThorAnvilSlam
// 0x0000 (0x0508 - 0x0508)
class ATgDevice_ThorAnvilSlam : public ATgDevice_AnvilSlamBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ThorAnvilSlam");
		return ptr;
	}


	void InterruptFiring();
	bool SimulateStartFire();
	void STATIC_SpawnWarningDeployable();
};


// Class TgGame.TgDeviceFire_Thor_BerserkerBarrage
// 0x000C (0x01CC - 0x01C0)
class UTgDeviceFire_Thor_BerserkerBarrage : public UTgDeviceFire
{
public:
	class ATgDevice_Thor_BerserkerBarrage*             m_OwnerDev;                                               // 0x01C0(0x0008) (Const)
	float                                              m_fConeAngleOverride;                                     // 0x01C8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Thor_BerserkerBarrage");
		return ptr;
	}


	float GetConeAttackAngleOffset();
	float GetConeAttackAngle();
};


// Class TgGame.TgDeviceForm_Thor_HammerJump
// 0x0004 (0x023C - 0x0238)
class UTgDeviceForm_Thor_HammerJump : public UTgDeviceForm
{
public:
	unsigned long                                      m_bHasAdjustedCamera : 1;                                 // 0x0238(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Thor_HammerJump");
		return ptr;
	}


	void NotifyExitTargetingMode(bool bDeployed);
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void NotifyEnterTargetingMode();
};


// Class TgGame.TgInventoryObject_Listen_AnvilOfDawn
// 0x0028 (0x00F8 - 0x00D0)
class UTgInventoryObject_Listen_AnvilOfDawn : public UTgInventoryObject_Listen_Staging
{
public:
	int                                                m_nMaxNumBounces;                                         // 0x00D0(0x0004) (Const)
	int                                                m_fBounceRadius;                                          // 0x00D4(0x0004) (Const)
	class ATgPawn_Thor*                                m_Thor;                                                   // 0x00D8(0x0008) (Const)
	unsigned long                                      s_bIsActive : 1;                                          // 0x00E0(0x0004) (Const)
	int                                                s_nLightningInstance;                                     // 0x00E4(0x0004) (Const)
	TArray<struct FThorLightningTarget>                s_LightningTargets;                                       // 0x00E8(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AnvilOfDawn");
		return ptr;
	}

};


// Class TgGame.TgPawn_Thor
// 0x0044 (0x25FC - 0x25B8)
class ATgPawn_Thor : public ATgPawn_Character
{
public:
	class ATgProj_Thor_TeleportHammer*                 m_TeleportHammer;                                         // 0x25B8(0x0008)
	class UTgSpecialFx*                                m_TeleportHammerEnterFx;                                  // 0x25C0(0x0008) (Transient)
	class UTgSpecialFx*                                m_TeleportHammerExitFx;                                   // 0x25C8(0x0008) (Transient)
	unsigned long                                      r_bInAnvilJump : 1;                                       // 0x25D0(0x0004) (Net)
	unsigned char                                      r_nTriggerAnvilDismount;                                  // 0x25D4(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x25D5(0x0003) MISSED OFFSET
	class UTgSpecialFx*                                m_AnvilSpinFx;                                            // 0x25D8(0x0008) (Transient)
	class UTgSkeletalMeshComponent*                    c_SkinTransitionComponent;                                // 0x25E0(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgSkeletalMeshComponent*>            c_SkinDeathTransitionComponents;                          // 0x25E8(0x0010) (ExportObject, Component, AlwaysInit, NeedCtorLink, EditInline)
	int                                                r_nPassiveAux;                                            // 0x25F8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Thor");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	bool IsInClassSpecificMovement();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_CancelTeleportAnim(float fBlendTime);
	bool TeleportToHammer(const struct FVector& vClientLocation);
	bool STATIC_FindTeleportSpot(const struct FVector& Extent, struct FVector* TeleportLocation);
	void CatchHammer();
	void SetTeleportHammer(class ATgProj_Thor_TeleportHammer* hammer);
	float ApplyPitchLimit(float fPitch);
	void ReplicatedEvent(const struct FName& VarName);
	void StopAnvilFBAnimIfDead();
	void TriggerAnvilDismount();
	bool PostPawnSetup();
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void STATIC_EndSkinLevelUp();
	void STATIC_PlaySkinLevelUpFx();
	void STATIC_OnSkinLevelChanged();
	void STATIC_PawnOnRevive();
	bool STATIC_OverrideDistanceFadeRange();
	void STATIC_EndAnvilJump();
	void STATIC_StartAnvilJump();
	bool STATIC_GetPassiveAux(float* fResult);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void STATIC_InitializeSkinDeathComponents();
	bool STATIC_InitializeAnvilSpinFX();
};


// Class TgGame.TgProj_Thor_TeleportHammer
// 0x0018 (0x03C4 - 0x03AC)
class ATgProj_Thor_TeleportHammer : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      m_ShouldReturnToOwner : 1;                                // 0x03AC(0x0004)
	float                                              m_fTurnStrength;                                          // 0x03B0(0x0004)
	TArray<class AActor*>                              m_HitActors;                                              // 0x03B4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Thor_TeleportHammer");
		return ptr;
	}


	void Destroyed();
	void ShutDown();
	void STATIC_ReturnToOwner();
	void STATIC_RangeReached();
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ProximityReached(class AActor* A, const struct FVector& HitLocation, const struct FVector& HitNormal);
	struct FVector GetSeekLocation();
	void UpdateSeekingDirection(float fDeltaTime);
	void Tick(float fDeltaTime);
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_Thor_Hammer
// 0x0008 (0x03A0 - 0x0398)
class ATgProj_Thor_Hammer : public ATgProj_Simulated
{
public:
	unsigned long                                      m_ShouldReturnToOwner : 1;                                // 0x0398(0x0004)
	float                                              m_fTurnStrength;                                          // 0x039C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Thor_Hammer");
		return ptr;
	}


	void STATIC_ReturnToOwner();
	void STATIC_RangeReached();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ProximityReached(class AActor* A, const struct FVector& HitLocation, const struct FVector& HitNormal);
	struct FVector GetSeekLocation();
	void UpdateSeekingDirection(float fDeltaTime);
	void Tick(float fDeltaTime);
};


// Class TgGame.TgDeployable_Ares_ChainPylon
// 0x003C (0x0410 - 0x03D4)
class ATgDeployable_Ares_ChainPylon : public ATgDeployable
{
public:
	TArray<class UTgSkeletalMeshComponent*>            m_TetherMeshComponents;                                   // 0x03D4(0x0010) (ExportObject, Component, NeedCtorLink, EditInline)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x03E4(0x0008)
	TArray<class ATgPawn*>                             m_TetheredPawns;                                          // 0x03EC(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               m_PullDeviceMode;                                         // 0x03FC(0x0008)
	class UMeshComponent*                              m_CollisionMesh;                                          // 0x0404(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nCollisionMeshId;                                       // 0x040C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ares_ChainPylon");
		return ptr;
	}


	void Destroyed();
	void UntetherPawn(class ATgPawn* TetheredPawn);
	void STATIC_TetherPawn(class ATgPawn* TouchedPawn);
	void CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void InitializeCollisionProxy();
	class UTgSkeletalMeshComponent* STATIC_CreateTetherSkeletalMeshComponent();
};


// Class TgGame.TgDevice_Ares_Shackles
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Ares_Shackles : public ATgDevice
{
public:
	int                                                m_ShackleComboCount;                                      // 0x04F0(0x0004)
	unsigned long                                      r_CanComboShot : 1;                                       // 0x04F4(0x0004) (Net)
	unsigned long                                      m_bHitOccured : 1;                                        // 0x04F4(0x0004)
	int                                                m_MaxShackleCount;                                        // 0x04F8(0x0004)
	float                                              m_fComboTimeLimit;                                        // 0x04FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ares_Shackles");
		return ptr;
	}


	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_OnReshackleTimerExpired();
	void STATIC_FireAmmunition();
	void OnHit(const struct FImpactInfo& Impact);
	void STATIC_CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	bool IsDeviceCoolingDown();
	void STATIC_SetCanComboShot(bool bCanComboShot);
	void ReplicatedEvent(const struct FName& VarName);
	unsigned char STATIC_IncrementFiringInstance();
	void UpdateManaUseVitals(class ATgPlayerController* PC);
};


// Class TgGame.TgDevice_Ares_AuraShield
// 0x0004 (0x0528 - 0x0524)
class ATgDevice_Ares_AuraShield : public ATgDevice_Aura
{
public:
	int                                                m_ShackleStackCount;                                      // 0x0524(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ares_AuraShield");
		return ptr;
	}


	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_FireAmmunition();
	void RemoveExtraBuff(class AActor* Other);
	void UpdateExtraBuff(class AActor* Other);
	void ApplyExtraBuff(class AActor* Other);
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
	void Tick(float DeltaTime);
	bool IsAuraActive();
};


// Class TgGame.TgDeviceFire_Ares_Spewing_Shield
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Ares_Spewing_Shield : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ares_Spewing_Shield");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	bool STATIC_CanHitTargetWithPercentDamage(class AActor* HitActor);
};


// Class TgGame.TgEffectForm_Ares_Aura
// 0x0010 (0x0120 - 0x0110)
class UTgEffectForm_Ares_Aura : public UTgEffectForm
{
public:
	int                                                m_InstigatorFXId;                                         // 0x0110(0x0004)
	class UTgSpecialFx*                                m_InstigatorFX;                                           // 0x0114(0x0008)
	int                                                m_DespawnFXId;                                            // 0x011C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Ares_Aura");
		return ptr;
	}


	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgPawn_Ares
// 0x0190 (0x2748 - 0x25B8)
class ATgPawn_Ares : public ATgPawn_Character
{
public:
	TArray<class ATgPawn*>                             m_ShackledPawns;                                          // 0x25B8(0x0010) (NeedCtorLink)
	class ATgPawn*                                     r_ShackledPawns[0x5];                                     // 0x25C8(0x0008) (Net)
	class ATgPawn*                                     c_ShackledPawns[0x5];                                     // 0x25F0(0x0008) (Transient)
	class UTgStaticMeshComponent*                      c_ShackleMeshComponents[0x5];                             // 0x2618(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgStaticMeshComponent*                      c_BreakingShackleMeshComponents[0x5];                     // 0x2640(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              c_ShackleDestroyProgressPercentage[0x5];                  // 0x2668(0x0004) (Transient)
	class UTgMarkComponent*                            m_ShackleSpeedMarkComponent;                              // 0x267C(0x0008) (ExportObject, Component, EditInline)
	TArray<class ATgPawn*>                             m_TetheredPawns;                                          // 0x2684(0x0010) (NeedCtorLink)
	class ATgPawn*                                     r_TetheredPawns[0x5];                                     // 0x2694(0x0008) (Net)
	class ATgPawn*                                     c_TetheredPawns[0x5];                                     // 0x26BC(0x0008) (Transient)
	class UTgStaticMeshComponent*                      c_TetherMeshComponents[0x5];                              // 0x26E4(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              c_TetherAttachProgressPercentage;                         // 0x270C(0x0004) (Transient)
	class UTgSpecialFx*                                c_TetherSpecialFX[0x5];                                   // 0x2710(0x0008) (Transient)
	int                                                m_EquippedAuraDeviceCount;                                // 0x2738(0x0004)
	float                                              m_fUltMovementSpeedPct;                                   // 0x273C(0x0004) (Const)
	class UTgSkeletalMeshComponent*                    c_DeathChainMeshComponent;                                // 0x2740(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ares");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void Tick(float DeltaSeconds);
	void STATIC_RemoveShackleEffectGroups(class ATgPawn* TargetPawn);
	void UpdateTetherChainComponents(float DeltaSeconds);
	void UpdateShackleChainComponents(float DeltaSeconds);
	void STATIC_OnRespawn();
	int GetTetheredPawnCount();
	int GetShackledPawnCount();
	bool PostPawnSetup();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_ResetDeathChainMeshComponent();
	bool STATIC_InitializeDeathChainMeshComponent();
	class UTgSpecialFx* STATIC_CreateTetherSpecialFX();
	class UTgStaticMeshComponent* STATIC_CreateTetherMeshComponent();
	class UTgStaticMeshComponent* STATIC_CreateShackleMeshComponent();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateTetheredPawns();
	void UpdateShackledPawns();
	void PreDemoRewind();
	struct FName STATIC_GetTetherSocketNameForTarget(int nTargetIndex);
	float STATIC_GetStrafePercent();
	float STATIC_GetBackpedalPercent();
	int STATIC_GetAuraItemCount();
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgPawn_AresSkin
// 0x0000 (0x2748 - 0x2748)
class ATgPawn_AresSkin : public ATgPawn_Ares
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_AresSkin");
		return ptr;
	}


	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
};


// Class TgGame.TgSkelCon_Ares_ChainTether
// 0x0000 (0x011C - 0x011C)
class UTgSkelCon_Ares_ChainTether : public USkelControl_CCD_IK
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_Ares_ChainTether");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFreyaInHand
// 0x0001 (0x0169 - 0x0168)
class UTgAnimBlendByFreyaInHand : public UTgAnimNodeBlendList
{
public:
	TEnumAsByte<ETgPawn_Freya_WeaponType>              m_InHandLastAnim;                                         // 0x0168(0x0001) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFreyaInHand");
		return ptr;
	}


	void STATIC_PrepareInHandAttack(TEnumAsByte<ETgPawn_Freya_WeaponType> NextAttackType);
};


// Class TgGame.TgAnimNodeBlendByFreyaUltimate
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendByFreyaUltimate : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bOutroNextTick : 1;                                     // 0x0168(0x0004) (Transient)
	unsigned long                                      m_bFireNextTick : 1;                                      // 0x0168(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByFreyaUltimate");
		return ptr;
	}


	void STATIC_ResetChain();
	void STATIC_Outro();
	void Fire();
};


// Class TgGame.TgAnimNodeFreyaCloak
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeFreyaCloak : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeFreyaCloak");
		return ptr;
	}


	void OnDeath();
	void OnIntro();
	void OnFall();
	void OnFire();
	void OnLift();
};


// Class TgGame.TgDeployable_Freya_Banish
// 0x0014 (0x03E8 - 0x03D4)
class ATgDeployable_Freya_Banish : public ATgDeployable
{
public:
	int                                                m_nBanishEGId;                                            // 0x03D4(0x0004) (Const)
	TArray<class ATgPawn*>                             m_BanishedPawnsList;                                      // 0x03D8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Freya_Banish");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void TransmitTiDiServer();
	int STATIC_GetCachedBanishEGId();
	void ModifyBanishEffectTiDi(class ATgPawn* Pawn);
	void AddToBanishList(class AActor* Pawn);
};


// Class TgGame.TgDevice_Freya_A01
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Freya_A01 : public ATgDevice
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                                       // 0x04F0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Freya_A01");
		return ptr;
	}


	void HandleActiveState();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_Freya_A02
// 0x000C (0x0500 - 0x04F4)
class ATgDevice_Freya_A02 : public ATgDevice_Toggle
{
public:
	int                                                r_nDeviceStateUpdated;                                    // 0x04F4(0x0004) (Net)
	class ATgPawn_Freya*                               m_pFreyaOwner;                                            // 0x04F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Freya_A02");
		return ptr;
	}


	void HandleActiveState();
	bool CanBeCanceledByRightMouse();
	bool IsActiveWhilefiring();
	bool ShouldTriggerCastReactionItems();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
	unsigned char STATIC_GetCurrentFiringInstance();
};


// Class TgGame.TgDeviceFire_Freya_Levitate
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Freya_Levitate : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Freya_Levitate");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool ValidateApplyHit(const struct FImpactInfo& Impact);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgInventoryObject_Listen_Freya_A01
// 0x001C (0x00EC - 0x00D0)
class UTgInventoryObject_Listen_Freya_A01 : public UTgInventoryObject_Listen
{
public:
	TArray<struct FFreyaExplosionInfo>                 s_ExplosionTracker;                                       // 0x00D0(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               s_CachedFireMode;                                         // 0x00E0(0x0008)
	int                                                s_nCurrentBasicFiringInstance;                            // 0x00E8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Freya_A01");
		return ptr;
	}


	void DeviceCleanup();
};


// Class TgGame.TgInventoryObject_Listen_Freya_A02
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Freya_A02 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Freya_A02");
		return ptr;
	}


	void DeviceCleanup();
};


// Class TgGame.TgInventoryObject_Listen_Freya_PSV
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_Freya_PSV : public UTgInventoryObject_Listen
{
public:
	TArray<struct FABILITY_HIT_INFO>                   m_previousHits;                                           // 0x00D0(0x0010) (NeedCtorLink)
	int                                                m_currentFiringInstance;                                  // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Freya_PSV");
		return ptr;
	}

};


// Class TgGame.TgMarkComponent_Freya_AttackBuff
// 0x0000 (0x00BC - 0x00BC)
class UTgMarkComponent_Freya_AttackBuff : public UTgMarkComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_Freya_AttackBuff");
		return ptr;
	}


	void STATIC_RemoveMarkByIndex(int nIndex);
};


// Class TgGame.TgPawn_Freya
// 0x00DC (0x2694 - 0x25B8)
class ATgPawn_Freya : public ATgPawn_Character
{
public:
	TEnumAsByte<ETgPawn_Freya_WeaponType>              r_EquippedInHand;                                         // 0x25B8(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x25B9(0x0003) MISSED OFFSET
	class ATgDevice*                                   s_InHandMelee;                                            // 0x25BC(0x0008)
	class ATgDevice*                                   s_InHandRanged;                                           // 0x25C4(0x0008)
	class ATgDevice*                                   s_InHandUltimate;                                         // 0x25CC(0x0008)
	unsigned long                                      s_bInHandSwapOnHold : 1;                                  // 0x25D4(0x0004) (Transient)
	unsigned long                                      r_bGlowingOn : 1;                                         // 0x25D4(0x0004) (Net)
	unsigned long                                      m_bDoScaledDamage : 1;                                    // 0x25D4(0x0004) (Transient)
	unsigned long                                      r_bInCloakJump : 1;                                       // 0x25D4(0x0004) (Net)
	unsigned long                                      r_bInCloakTakedown : 1;                                   // 0x25D4(0x0004) (Net)
	struct FVector                                     m_InHandFireLocationOffset[0x3];                          // 0x25D8(0x000C)
	class UTgAnimBlendByFreyaInHand*                   m_InHandAnimNode;                                         // 0x25FC(0x0008)
	class UTgMarkComponent*                            m_DamageBuffMarkComponent;                                // 0x2604(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMaterialInstanceConstant*                   m_GlowingTattooMIC;                                       // 0x260C(0x0008) (Transient)
	float                                              m_fGlowProgress;                                          // 0x2614(0x0004) (Transient)
	float                                              m_fGlowSpeed;                                             // 0x2618(0x0004)
	TArray<struct FFreyaExplodingInhand>               s_ExplodingInhands;                                       // 0x261C(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_RangedAOEModes;                                         // 0x262C(0x0010) (AlwaysInit, NeedCtorLink)
	class UTgSpecialFx*                                m_RangedAOEVisualFX;                                      // 0x263C(0x0008) (Transient)
	class UTgSpecialFx*                                m_RangedGauntletFx[0x2];                                  // 0x2644(0x0008) (Transient)
	class UTgMarkComponent*                            m_CloakOfFeathersMarkComponent;                           // 0x2654(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgSkeletalMeshComponent*                    c_CloakMeshComponent;                                     // 0x265C(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class UTgAnimNodeFreyaCloak*>               c_FreyaCloakAnimNodes;                                    // 0x2664(0x0010) (NeedCtorLink)
	class UTgAnimNodeBlendByFreyaUltimate*             m_UltimateCycleBlendList;                                 // 0x2674(0x0008)
	int                                                r_nCloakOfFeathersAmmoCount;                              // 0x267C(0x0004) (Net)
	TArray<struct FName>                               m_DeathAnimList;                                          // 0x2680(0x0010) (NeedCtorLink)
	int                                                m_nLastDeathAnim;                                         // 0x2690(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Freya");
		return ptr;
	}


	struct FName GetDeathAnimName();
	bool IsInClassSpecificMovement();
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	float ApplyPitchLimit(float fPitch);
	void GauntletsDeactivate();
	void GauntletsActivate();
	void TattoosDeactivate();
	void TattoosActivate();
	void Tick(float DeltaSeconds);
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_DetachCloak();
	void STATIC_PlaySpawnFx();
	bool STATIC_InitTattooAndLightFX();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	bool PostPawnSetup();
	void PreDemoRewind();
	void ReplicatedEvent(const struct FName& VarName);
	bool CannotJumpNow();
	void ChangedEquippedInHand();
	void STATIC_OnPawnDied();
	void STATIC_EndRangedAttack(bool bForce);
	float STATIC_GetPhysicalPowerItem(const struct FImpactInfo& Impact, float PowerScaling);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	bool STATIC_InitRangedAoeFX();
	bool STATIC_InitRangedGauntletFX();
	bool STATIC_InitializeCloakMeshComponent();
};


// Class TgGame.TgAchievement_Loki_MadeYouLook
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Loki_MadeYouLook : public UTgAchievement
{
public:
	TArray<int>                                        m_DecoyDeviceIds;                                         // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Loki_MadeYouLook");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_Loki_Assassinate
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendList_Loki_Assassinate : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Loki*                                OwningLokiPawn;                                           // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Loki_Assassinate");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_Loki_BackStab
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendList_Loki_BackStab : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Loki*                                OwningLokiPawn;                                           // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Loki_BackStab");
		return ptr;
	}


	void STATIC_ReplayAnim();
};


// Class TgGame.TgDeployable_Loki_V2_A02
// 0x001C (0x03F0 - 0x03D4)
class ATgDeployable_Loki_V2_A02 : public ATgDeployable
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03D4(0x0008) (Const, Native, NoExport)
	class ATgPawn_Loki_V2*                             m_Loki;                                                   // 0x03DC(0x0008) (Const)
	class UCylinderComponent*                          m_cylinderCollision;                                      // 0x03E4(0x0008) (Const, ExportObject, Component, EditInline)
	float                                              m_fPersistPulseTime;                                      // 0x03EC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Loki_V2_A02");
		return ptr;
	}


	void STATIC_InstantFireDeployable();
	void TimeDeviceFiring();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void ApplyHitPulse();
};


// Class TgGame.TgDevice_Loki_V2_A04
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Loki_V2_A04 : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Loki_V2_A04");
		return ptr;
	}


	bool ApplyGlobalOffhandCooldown();
	bool ShouldCancelStealth();
	void FireSubDevice();
	bool CanBeInterrupted();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Loki_V2_A03
// 0x0004 (0x0500 - 0x04FC)
class ATgDevice_Loki_V2_A03 : public ATgDevice_HitPulse
{
public:
	unsigned long                                      m_bInFinalStrike : 1;                                     // 0x04FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Loki_V2_A03");
		return ptr;
	}


	void STATIC_FireFinalStrikePreHitDelay();
	bool ShouldCancelStealth();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	class UTgDeviceFire* STATIC_GetCurrentFire();
};


// Class TgGame.TgDevice_Loki_V2_A02
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Loki_V2_A02 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Loki_V2_A02");
		return ptr;
	}

};


// Class TgGame.TgDevice_Loki_V2_A04_Sub
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Loki_V2_A04_Sub : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Loki_V2_A04_Sub");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Loki_PVEDecoy
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Loki_PVEDecoy : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Loki_PVEDecoy");
		return ptr;
	}


	class ATgPawn* STATIC_SpawnPet(bool bPet);
};


// Class TgGame.TgEffectDamage_Backstab
// 0x0004 (0x00BC - 0x00B8)
class UTgEffectDamage_Backstab : public UTgEffectDamage
{
public:
	unsigned long                                      m_bIsBackstab : 1;                                        // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_Backstab");
		return ptr;
	}


	void AddInstigatorScaling(class ATgPawn* InstigatorPawn, class AActor* Target, const struct FImpactInfo& Impact, float* fProratedAmount);
	void STATIC_SendDamageMessages(class AActor* Source, class AActor* Target, float fDamage, float fMitigated, const struct FImpactInfo& thisImpact, bool bWasCritical);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
	bool IsTargetAttackedFromBehind(const struct FImpactInfo& Impact);
	bool IsValidBackStabTargetType(class ATgPawn* Target);
};


// Class TgGame.TgEffectDamage_Loki_V2_Backstab
// 0x0000 (0x00BC - 0x00BC)
class UTgEffectDamage_Loki_V2_Backstab : public UTgEffectDamage_Backstab
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_Loki_V2_Backstab");
		return ptr;
	}


	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
	bool IsTargetLokiBlinded(class ATgPawn* Target);
};


// Class TgGame.TgEffectForm_Loki_RevealStealth
// 0x0014 (0x0124 - 0x0110)
class UTgEffectForm_Loki_RevealStealth : public UTgEffectForm
{
public:
	struct FName                                       c_nmHideLokiStealthMesh;                                  // 0x0110(0x0008) (Const)
	float                                              c_fRevealStealthTime;                                     // 0x0118(0x0004) (Const)
	class ATgPawn_Loki_V2*                             c_pawnLoki;                                               // 0x011C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Loki_RevealStealth");
		return ptr;
	}


	void AdjustHidden();
};


// Class TgGame.TgEffectForm_Loki_V2_PostProcess
// 0x0010 (0x0164 - 0x0154)
class UTgEffectForm_Loki_V2_PostProcess : public UTgEffectForm_PostProcess
{
public:
	struct FName                                       m_nmPositionA;                                            // 0x0154(0x0008) (Const)
	struct FName                                       m_nmPositionB;                                            // 0x015C(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Loki_V2_PostProcess");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Loki_Vanish
// 0x0004 (0x0114 - 0x0110)
class UTgEffectForm_Loki_Vanish : public UTgEffectForm_Stealth
{
public:
	int                                                m_BreakingStealthFXId;                                    // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Loki_Vanish");
		return ptr;
	}


	void STATIC_HideEffectForm();
};


// Class TgGame.TgEffectForm_Loki_V2_Vanish
// 0x0000 (0x0114 - 0x0114)
class UTgEffectForm_Loki_V2_Vanish : public UTgEffectForm_Loki_Vanish
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Loki_V2_Vanish");
		return ptr;
	}


	bool STATIC_ShouldShowEffectForm();
};


// Class TgGame.TgInventoryObject_Listen_BackStab
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_BackStab : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BackStab");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Loki_V2_A01
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Loki_V2_A01 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Loki_V2_A01");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Loki_V2_A02
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Loki_V2_A02 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Loki_V2_A02");
		return ptr;
	}

};


// Class TgGame.TgPawn_Loki
// 0x002C (0x25E4 - 0x25B8)
class ATgPawn_Loki : public ATgPawn_Character
{
public:
	TArray<class UTgDeviceFire*>                       m_StimSubDeviceModes;                                     // 0x25B8(0x0010) (AlwaysInit, NeedCtorLink)
	unsigned long                                      s_IsLokiStealthedThisTick : 1;                            // 0x25C8(0x0004)
	unsigned long                                      r_HasVanishBuff : 1;                                      // 0x25C8(0x0004) (Net)
	class AActor*                                      r_AssassinateBaseActor;                                   // 0x25CC(0x0008) (Net)
	class AActor*                                      c_AssassinateBaseActor;                                   // 0x25D4(0x0008)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x25DC(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Loki");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void Tick(float DeltaSeconds);
	void NormalizeRotationPitch(struct FRotator* rRotation);
	void STATIC_SetControllerRotation(const struct FRotator& rNewRotation);
	void STATIC_SetPawnRotation(const struct FRotator& rNewRotation);
	void STATIC_ClientSetLocationAndRotation(const struct FVector& vNewLocation, const struct FRotator& rNewRotation, const struct FRotator& rNewControllerRotation);
	void DetachFromTarget(class AActor* TargetActor);
	void AttachToTarget(class AActor* TargetActor);
	void STATIC_EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	void STATIC_ClientAssassinateTeleport(float TeleportLocationX, float TeleportLocationY, float TeleportLocationZ, int TeleportYaw);
	void AssassinateTeleport(float TeleportLocationX, float TeleportLocationY, float TeleportLocationZ, int TeleportYaw);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_CalcStealthFadeValue(float fDeltaTime);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_CH05_Boss
// 0x0000 (0x25E4 - 0x25E4)
class ATgPawn_CH05_Boss : public ATgPawn_Loki
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH05_Boss");
		return ptr;
	}


	void STATIC_PlayDyingEffects();
	struct FName GetDeathAnimName();
};


// Class TgGame.TgPawn_Loki_V2
// 0x004C (0x2630 - 0x25E4)
class ATgPawn_Loki_V2 : public ATgPawn_Loki
{
public:
	class ATgDevice_ChainedMelee*                      m_deviceAuto;                                             // 0x25E4(0x0008)
	class ATgDevice*                                   m_devicePsv;                                              // 0x25EC(0x0008)
	class ATgDevice*                                   m_deviceA01;                                              // 0x25F4(0x0008)
	class ATgDevice_Loki_V2_A02*                       m_deviceA02;                                              // 0x25FC(0x0008)
	class ATgDevice*                                   m_subDeviceA02;                                           // 0x2604(0x0008)
	class ATgDevice_Loki_V2_A03*                       m_deviceA03;                                              // 0x260C(0x0008)
	class ATgDevice*                                   m_subDeviceA03;                                           // 0x2614(0x0008)
	class ATgDevice_Loki_V2_A04*                       m_deviceA04;                                              // 0x261C(0x0008)
	class ATgDevice*                                   m_subDeviceA04;                                           // 0x2624(0x0008)
	unsigned long                                      m_bDevicesCached : 1;                                     // 0x262C(0x0004) (Const)
	unsigned long                                      r_bInLokiStealth : 1;                                     // 0x262C(0x0004) (Net)
	unsigned long                                      m_bStealthRevealed : 1;                                   // 0x262C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Loki_V2");
		return ptr;
	}


	void STATIC_HideLokiStealthMesh();
	bool STATIC_ShouldPawnMeshBeHiddenThisTick();
	void UpdateClientDevices(bool bForce);
};


// Class TgGame.TgPawn_Loki_Decoy
// 0x0000 (0x2464 - 0x2464)
class ATgPawn_Loki_Decoy : public ATgPawn_Familiar
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Loki_Decoy");
		return ptr;
	}


	void STATIC_PlayDyingEffects();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
};


// Class TgGame.TgAnimNodeBlend_Bacchus_Inebriation
// 0x0008 (0x012C - 0x0124)
class UTgAnimNodeBlend_Bacchus_Inebriation : public UAnimNodeBlend
{
public:
	class ATgPawn_Bacchus*                             OwningBacchusPawn;                                        // 0x0124(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlend_Bacchus_Inebriation");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_Bacchus_Inebriation
// 0x0018 (0x0180 - 0x0168)
class UTgAnimNodeBlendList_Bacchus_Inebriation : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Bacchus*                             OwningBacchusPawn;                                        // 0x0168(0x0008) (Transient)
	TArray<struct FInebriationLevelInfo>               InebriationLevels;                                        // 0x0170(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Bacchus_Inebriation");
		return ptr;
	}

};


// Class TgGame.TgDevice_Bacchus_Intoxicate
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Bacchus_Intoxicate : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bacchus_Intoxicate");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	int STATIC_GetFxID();
};


// Class TgGame.TgPawn_Bacchus
// 0x004C (0x2604 - 0x25B8)
class ATgPawn_Bacchus : public ATgPawn_Character
{
public:
	TArray<int>                                        m_nEmoteSuffixSkinIds;                                    // 0x25B8(0x0010) (NeedCtorLink)
	float                                              m_fSmoothEnergy;                                          // 0x25C8(0x0004)
	float                                              m_fSmoothEnergySpeed;                                     // 0x25CC(0x0004)
	TEnumAsByte<ETgPawn_Bacchus_DrunkType>             m_CurrentDrunkType;                                       // 0x25D0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x25D1(0x0003) MISSED OFFSET
	unsigned long                                      c_DrunkFxSuccessfulLoad : 1;                              // 0x25D4(0x0004) (Transient)
	class UTgSpecialFx*                                c_DrunkStateFx[0x3];                                      // 0x25D8(0x0008) (Transient)
	float                                              m_fBelchRadiusFeet;                                       // 0x25F0(0x0004)
	class UTgSpecialFx*                                m_BelchConeEffect;                                        // 0x25F4(0x0008) (Transient)
	class UTgSpecialFx*                                c_BelchCameraShakeFx;                                     // 0x25FC(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Bacchus");
		return ptr;
	}


	void STATIC_PlayDyingEffects();
	void STATIC_DeactivateBelchEffects();
	void ActivateBelchEffects();
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void Tick(float DeltaSeconds);
	bool ShouldRechargeSpecial();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnRespawn();
	bool PostPawnSetup();
	void STATIC_CancelBelch();
	void BelchFromLocation();
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	bool STATIC_InitDrunkFX();
	void UpdateDrunkStatus();
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_CalcSmoothEnergy(float fDelta);
	void STATIC_RegainEnergyPool(float fDelta);
	void STATIC_OnUtilityPowerChange();
	void STATIC_SetSpawnEnergy();
	float STATIC_GetSmoothEnergy();
};


// Class TgGame.TgDevice_Xbalanque_Splitting_Projectile_Stim
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Xbalanque_Splitting_Projectile_Stim : public ATgDevice_Toggle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Xbalanque_Splitting_Projectile_Stim");
		return ptr;
	}


	bool CanBeCanceledByRightMouse();
	bool IsActiveWhilefiring();
	bool ShouldTriggerCastReactionItems();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool CanBeInterrupted();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Xbalanque_DashAndJump
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Xbalanque_DashAndJump : public ATgDevice
{
public:
	unsigned long                                      m_IsUpdatingAimWhileFiring : 1;                           // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Xbalanque_DashAndJump");
		return ptr;
	}


	bool CanBeInterrupted();
	void UpdateAimWhileFiring(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Xbalanque_DashAndJump
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Xbalanque_DashAndJump : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Xbalanque_DashAndJump");
		return ptr;
	}


	float STATIC_GetRange();
};


// Class TgGame.TgDeviceFire_Xbalanque_Dev2
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Xbalanque_Dev2 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Xbalanque_Dev2");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceForm_Xbalanque_Inhand
// 0x0004 (0x023C - 0x0238)
class UTgDeviceForm_Xbalanque_Inhand : public UTgDeviceForm
{
public:
	unsigned long                                      c_bWasActive : 1;                                         // 0x0238(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Xbalanque_Inhand");
		return ptr;
	}


	bool UsesTargetingMode();
};


// Class TgGame.TgEffectForm_Xbalanque_ApocalypseShroud
// 0x001C (0x012C - 0x0110)
class UTgEffectForm_Xbalanque_ApocalypseShroud : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0110(0x0008) (Const, Native, NoExport)
	class UMeshComponent*                              m_CounterMesh;                                            // 0x0118(0x0008) (ExportObject, Component, EditInline)
	int                                                m_ShroudFXId;                                             // 0x0120(0x0004)
	int                                                m_OutroFXId;                                              // 0x0124(0x0004)
	unsigned long                                      m_bAllowShroudAttach : 1;                                 // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Xbalanque_ApocalypseShroud");
		return ptr;
	}


	void STATIC_DetachMeshes();
	void AttachMeshes(class AActor* pOwner);
	void AdjustHidden();
	void Detach();
	void STATIC_Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgEffectForm_Xbalanque_SplittingProjectileStim
// 0x0008 (0x0118 - 0x0110)
class UTgEffectForm_Xbalanque_SplittingProjectileStim : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0110(0x0008) (Const, Native, NoExport)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Xbalanque_SplittingProjectileStim");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_XbalanquePassive
// 0x0014 (0x0134 - 0x0120)
class UTgInventoryObject_Listen_XbalanquePassive : public UTgInventoryObject_Listen_Stack
{
public:
	int                                                m_nPassiveStackCount;                                     // 0x0120(0x0004)
	int                                                m_nMaxPassiveStack;                                       // 0x0124(0x0004)
	float                                              m_fDamagePerStack;                                        // 0x0128(0x0004)
	float                                              m_fAccumulatedDamage;                                     // 0x012C(0x0004)
	int                                                m_nMaxDamageStack;                                        // 0x0130(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_XbalanquePassive");
		return ptr;
	}


	void AddStackCount(int nStackCount);
};


// Class TgGame.TgInventoryObject_Listen_XbalanqueBranchingBola
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_XbalanqueBranchingBola : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_XbalanqueBranchingBola");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_XbalanquePoisonDarts
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_XbalanquePoisonDarts : public UTgInventoryObject_Listen
{
public:
	float                                              m_fAdditionalHitScaling;                                  // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_XbalanquePoisonDarts");
		return ptr;
	}

};


// Class TgGame.TgPawn_Xbalanque
// 0x0088 (0x2640 - 0x25B8)
class ATgPawn_Xbalanque : public ATgPawn_Character
{
public:
	TArray<class UTgDeviceFire*>                       m_SplitProjectileDeviceModes;                             // 0x25B8(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_RainingDartsDeviceModes;                                // 0x25C8(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_RainingPoisonDartsDeviceModes;                          // 0x25D8(0x0010) (NeedCtorLink)
	int                                                m_RainingDartsTargetCount;                                // 0x25E8(0x0004)
	TArray<class AActor*>                              m_RainingDartsTargets;                                    // 0x25EC(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_RainingDartsHitTargets;                                 // 0x25FC(0x0010) (NeedCtorLink)
	unsigned long                                      r_HasRainingDartsTargets : 1;                             // 0x260C(0x0004) (Net)
	unsigned long                                      m_bHasInitializedPassiveEnergy : 1;                       // 0x260C(0x0004)
	class UTgSpecialFx*                                c_RainingDartsTargeterSpecialFX;                          // 0x2610(0x0008) (Transient)
	TArray<class UTgDeviceFire*>                       m_ApocalyseShroudStunDeviceModes;                         // 0x2618(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               m_DarkestOfNightsLastFireMode;                            // 0x2628(0x0008)
	TArray<class UTgSpecialFx*>                        c_BolaGlowFXs;                                            // 0x2630(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Xbalanque");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void ToggleBolaFX(bool bEnable);
	void STATIC_SpawnRainingDartProjectile(class AActor* TargetActor);
	void STATIC_CalculateRainingDartProjectileTargets(TArray<class AActor*>* Targets);
	class UTgDeviceFire* STATIC_GetCurrentSplitProjectileMode(int* nMode);
	void STATIC_PostPawnSetupServer();
	void STATIC_SetSpawnEnergy();
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_EndDarkestOfNights();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_InitializeBolaGlowFX();
	void STATIC_InitializeRainingDartsTargeterSpecialFX();
	bool PostPawnSetup();
};


// Class TgGame.TgProj_Xbalanque_Split_Projectile
// 0x0010 (0x03DC - 0x03CC)
class ATgProj_Xbalanque_Split_Projectile : public ATgProj_SimulatedSeeking
{
public:
	TArray<class AActor*>                              m_ExcludedTargets;                                        // 0x03CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Xbalanque_Split_Projectile");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Xbalanque_Splitting_Projectile
// 0x000C (0x03A4 - 0x0398)
class ATgProj_Xbalanque_Splitting_Projectile : public ATgProj_Simulated
{
public:
	class UTgDeviceFire*                               m_SplitProjectileDeviceMode;                              // 0x0398(0x0008)
	int                                                m_nCachedMode;                                            // 0x03A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Xbalanque_Splitting_Projectile");
		return ptr;
	}


	void STATIC_CalculateSplitProjectileTargets(class AActor* HitActor, const struct FVector& SpawnLocation, const struct FVector& ConeDirection, TArray<class AActor*>* Targets);
	void STATIC_SpawnSplitProjectiles(class AActor* HitActor, const struct FVector& originLocation, const struct FVector& ConeDirection);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgAchievement_Hercules_Earthbreaker
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Hercules_Earthbreaker : public UTgAchievement
{
public:
	int                                                m_GoalAmount;                                             // 0x0084(0x0004)
	int                                                m_nNumHits;                                               // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Hercules_Earthbreaker");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Hercules_Ricochet
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_Hercules_Ricochet : public UTgAchievement
{
public:
	TArray<class ATgPawn*>                             m_TrackedSaved;                                           // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nDeviceId;                                              // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Hercules_Ricochet");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Hercules_HercSmash
// 0x003C (0x0434 - 0x03F8)
class ATgDeployable_Hercules_HercSmash : public ATgDeploy_EffectVolume
{
public:
	int                                                m_iLobsDone;                                              // 0x03F8(0x0004)
	float                                              m_fMaxLobHeight;                                          // 0x03FC(0x0004)
	TArray<struct FHercSmashHitInfo>                   m_HitEntities;                                            // 0x0400(0x0010) (NeedCtorLink)
	struct FVector                                     m_vHitExtent;                                             // 0x0410(0x000C)
	float                                              m_fLastFirePercentage;                                    // 0x041C(0x0004)
	float                                              m_fCurrentFirePercentage;                                 // 0x0420(0x0004)
	float                                              r_fKnockbackMinRange;                                     // 0x0424(0x0004) (Net)
	float                                              r_fKnockbackMaxRange;                                     // 0x0428(0x0004)
	float                                              r_fKnockbackRadius;                                       // 0x042C(0x0004)
	float                                              r_fMoveDist;                                              // 0x0430(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Hercules_HercSmash");
		return ptr;
	}


	void Cleanup();
	bool STATIC_CanBeKnockedUp(const struct FHercSmashHitInfo& HitInfo);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TickFire(float DeltaSeconds);
	void LobPawn(class ATgPawn* Other);
	bool STATIC_InKnockUpArea(class AActor* Other, const struct FVector& HitLocation);
	void STATIC_DetectHits(float DeltaSeconds);
};


// Class TgGame.TgDevice_Hercules_A04
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Hercules_A04 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hercules_A04");
		return ptr;
	}


	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	void STATIC_GetClientGroundTargetAim(struct FAimData* Aim);
	bool STATIC_ServerShouldUseClientSideAim();
};


// Class TgGame.TgDevice_Hercules_BoulderThrower
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Hercules_BoulderThrower : public ATgDevice
{
public:
	unsigned long                                      m_bFireTimerExpired : 1;                                  // 0x04F0(0x0004)
	unsigned long                                      m_bOverrideStartLocation : 1;                             // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hercules_BoulderThrower");
		return ptr;
	}


	void STATIC_ClientSimulateStartFire();
	bool StartFireOnTimerExpired();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgInventoryObject_Listen_Hercules_Dev3
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Hercules_Dev3 : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_Record : 1;                                             // 0x00D0(0x0004)
	int                                                m_HealthLost;                                             // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Hercules_Dev3");
		return ptr;
	}

};


// Class TgGame.TgPawn_Hercules
// 0x0084 (0x263C - 0x25B8)
class ATgPawn_Hercules : public ATgPawn_Character
{
public:
	int                                                r_nPassiveBonusPower;                                     // 0x25B8(0x0004) (Net)
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                                   // 0x25BC(0x0008)
	TArray<struct FChargeHitInfo>                      m_ChargeHitInfos;                                         // 0x25C4(0x0010) (NeedCtorLink)
	struct FVector                                     m_fChargeStartLocation;                                   // 0x25D4(0x000C)
	float                                              r_fChargePunchRadius;                                     // 0x25E0(0x0004) (Net)
	unsigned long                                      s_bTrackDamage : 1;                                       // 0x25E4(0x0004)
	unsigned long                                      c_bBoulderPickupInterrupted : 1;                          // 0x25E4(0x0004)
	unsigned long                                      r_bBoulderOverhead : 1;                                   // 0x25E4(0x0004) (Net)
	unsigned long                                      r_bBoulderFireInterrupted : 1;                            // 0x25E4(0x0004) (Net)
	unsigned long                                      s_bBoulderHasFired : 1;                                   // 0x25E4(0x0004)
	float                                              s_fDamageTakenWhileTracking;                              // 0x25E8(0x0004)
	class UTgDeviceFire*                               s_HealthReturnFireMode;                                   // 0x25EC(0x0008)
	float                                              s_fHealthBeforeTracking;                                  // 0x25F4(0x0004)
	class ATgDevice*                                   s_NormalInHand;                                           // 0x25F8(0x0008)
	class ATgDevice*                                   s_BoulderThrower;                                         // 0x2600(0x0008)
	float                                              m_fBoulderSpeedModifier;                                  // 0x2608(0x0004)
	class UTgDeviceFire*                               s_BoulderThrowerCCProtection;                             // 0x260C(0x0008)
	class UMeshComponent*                              c_BoulderMeshComponent;                                   // 0x2614(0x0008) (ExportObject, Transient, Component, EditInline)
	class USkeletalMeshComponent*                      c_BoulderEruptionMeshComponent;                           // 0x261C(0x0008) (ExportObject, Transient, Component, EditInline)
	struct FVector                                     m_InHandFireOffsets[0x2];                                 // 0x2624(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Hercules");
		return ptr;
	}


	bool STATIC_IgnoreFaceRotationWithInterp();
	void STATIC_PlayDyingEffects();
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayTime, float ExcessTime);
	void OnAnimPlay(class UAnimNodeSequence* SeqNode);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	struct FVector GetWeaponStartTraceLocation(class ATgDevice* Dev);
	void DeactivateBoulder(bool bWasInterrupted);
	void PrepareBoulderIntro();
	void DeactivateEruption(bool bWasInterrupted);
	void ActivateEruption(float Rate);
	bool PostPawnSetup();
	void ChargeCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool STATIC_CanTrackDamageDoneBy(class AActor* DamagerCauser);
	void ReplicatedEvent(const struct FName& VarName);
	void RepBoulderOverheadChanged();
	void STATIC_OnPawnDied();
	void STATIC_EndBoulderThrower(bool bWasInterrupted);
	void STATIC_StartBoulderThrower(class ATgDevice* Dev, float Duration);
	bool STATIC_InitializeBoulderEruptionMeshComponent();
	bool STATIC_InitializeBoulderMeshComponent();
	void BeginHealingFromDamageTaken();
	void BeginDamageTracking(class UTgDeviceFire* devFire);
	void AttemptApplyMissedPunchTouch(class ATgDevice* devPunch);
	void STATIC_PerformPunchKnockback(class ATgPawn* HitActor);
	float STATIC_GetPhysicalPowerItem(const struct FImpactInfo& Impact, float PowerScaling);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
};


// Class TgGame.TgPawn_Hercules_NGM
// 0x0004 (0x2640 - 0x263C)
class ATgPawn_Hercules_NGM : public ATgPawn_Hercules
{
public:
	unsigned long                                      m_bIsGodFollowerBot : 1;                                  // 0x263C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Hercules_NGM");
		return ptr;
	}


	void STATIC_OwnerJumpedTimer();
	void STATIC_SetInitialLevel();
	void STATIC_PostPawnSetupServer();
	void STATIC_OnOwnerJumped();
};


// Class TgGame.TgProj_Hercules_Boulder
// 0x005C (0x0418 - 0x03BC)
class ATgProj_Hercules_Boulder : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:
	unsigned long                                      m_bIsRolling : 1;                                         // 0x03BC(0x0004)
	unsigned long                                      m_bApplyBounceVelocity : 1;                               // 0x03BC(0x0004)
	float                                              m_fGroundDistTraveled;                                    // 0x03C0(0x0004)
	float                                              m_fGroundRange;                                           // 0x03C4(0x0004)
	float                                              m_fRollingDampening;                                      // 0x03C8(0x0004)
	struct FVector                                     m_vBounceVelocity;                                        // 0x03CC(0x000C)
	int                                                m_iNumBounces;                                            // 0x03D8(0x0004)
	TArray<struct FBoulderHitInfo>                     m_HitActors;                                              // 0x03DC(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_HitActorsThisWallBounce;                                // 0x03EC(0x0010) (NeedCtorLink)
	int                                                s_nDamageEffectGroupId;                                   // 0x03FC(0x0004)
	TArray<struct FCannotTouchInfo>                    s_CannotTouchList;                                        // 0x0400(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                c_GroundHitFx;                                            // 0x0410(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Hercules_Boulder");
		return ptr;
	}


	void STATIC_RangeReached();
	bool STATIC_CheckTargetDistance(const struct FVector& vLocOverride);
	void STATIC_TargetReached();
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void HitWall(const struct FVector& HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void STATIC_SpawnGroundHitEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_StartCollision();
	void ProxyUnTouch(class AActor* Other);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	float TimeUntilActorCanBeReTouched(class AActor* Target);
};


// Class TgGame.TgAchievement_Vulcan_LaL
// 0x0000 (0x0098 - 0x0098)
class UTgAchievement_Vulcan_LaL : public UTgAchievement_DeviceKillsSingleShot
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Vulcan_LaL");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Vulcan_Meatball
// 0x0000 (0x0098 - 0x0098)
class UTgAchievement_Vulcan_Meatball : public UTgAchievement_DeviceKillsSingleShot
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Vulcan_Meatball");
		return ptr;
	}

};


// Class TgGame.TgDevice_Vulcan_UltimateForge
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Vulcan_UltimateForge : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Vulcan_UltimateForge");
		return ptr;
	}


	bool STATIC_ShouldInterruptReload();
	bool IsToggleDevice();
	void STATIC_FireAmmunition();
	bool StartFire();
	bool STATIC_CanDeviceFireInTargetingMode();
	bool IsToggledOn();
	void UpdateUIToggleState();
};


// Class TgGame.TgDevice_Vulcan_ForgeCharge
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Vulcan_ForgeCharge : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Vulcan_ForgeCharge");
		return ptr;
	}


	void DeviceConsumePowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDeviceFire_Vulcan_ForgeCharge
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Vulcan_ForgeCharge : public UTgDeviceFire
{
public:
	float                                              m_EnergyCostOfCurrentShot;                                // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Vulcan_ForgeCharge");
		return ptr;
	}


	float STATIC_GetShotPowerCost(int nPacingType, bool bBaseOnly);
};


// Class TgGame.TgDeviceFire_Vulcan_InfernoCannon
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Vulcan_InfernoCannon : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Vulcan_InfernoCannon");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Vulcan_ShatterBomb
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Vulcan_ShatterBomb : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Vulcan_ShatterBomb");
		return ptr;
	}


	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceFire_Vulcan_Shockwave
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Vulcan_Shockwave : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Vulcan_Shockwave");
		return ptr;
	}


	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgInventoryObject_Listen_VulcanPassive
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_VulcanPassive : public UTgInventoryObject_Listen_OffHand_SuccessfulHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_VulcanPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Vulcan
// 0x000C (0x25C4 - 0x25B8)
class ATgPawn_Vulcan : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_BackFireMarks;                                          // 0x25B8(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      m_bInTurretRange : 1;                                     // 0x25C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Vulcan");
		return ptr;
	}


	void ApplyBackFireMark(class AActor* Target);
	bool STATIC_GetPassiveAux(float* fResult);
	void DeviceOnStopFire(class ATgDevice* Dev, bool bWasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
};


// Class TgGame.TgPawn_VulcanV2
// 0x0008 (0x25C0 - 0x25B8)
class ATgPawn_VulcanV2 : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_TurretTargetMarks;                                      // 0x25B8(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_VulcanV2");
		return ptr;
	}


	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
};


// Class TgGame.TgPawn_Vulcan_NGM
// 0x0004 (0x25C4 - 0x25C0)
class ATgPawn_Vulcan_NGM : public ATgPawn_VulcanV2
{
public:
	unsigned long                                      m_bIsGodFollowerBot : 1;                                  // 0x25C0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Vulcan_NGM");
		return ptr;
	}


	void STATIC_OwnerJumpedTimer();
	void STATIC_SetInitialLevel();
	void STATIC_PostPawnSetupServer();
	void STATIC_OnOwnerJumped();
};


// Class TgGame.TgPawn_Vulcan_Familiar
// 0x0020 (0x2484 - 0x2464)
class ATgPawn_Vulcan_Familiar : public ATgPawn_Familiar
{
public:
	class ATgDevice*                                   m_BasicDevice;                                            // 0x2464(0x0008)
	class ATgDevice*                                   m_UltimateDevice;                                         // 0x246C(0x0008)
	class UMaterialInstanceConstant*                   c_UltimateMIC;                                            // 0x2474(0x0008)
	unsigned long                                      r_IsBuffedByUltimate : 1;                                 // 0x247C(0x0004) (Net)
	float                                              m_ScalingProgress;                                        // 0x2480(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Vulcan_Familiar");
		return ptr;
	}


	void PlayDeathAnimation();
	void Tick(float DeltaSeconds);
	bool PostPawnSetup();
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DirtyAttachmentTransforms();
	float STATIC_GetDefaultMeshScale();
	void STATIC_CorrectLocationWhileChangingSize(float HeightDelta);
	void STATIC_GetSmallCollisionCylinderSize(float* Radius, float* Height);
	void STATIC_GetGiantCollisionCylinderSize(float* Radius, float* Height);
};


// Class TgGame.TgPawn_Vulcan_ConeTurret
// 0x0034 (0x24B8 - 0x2484)
class ATgPawn_Vulcan_ConeTurret : public ATgPawn_Vulcan_Familiar
{
public:
	class UTgSpecialFx*                                c_BeamFX;                                                 // 0x2484(0x0008) (Transient)
	struct FRotator                                    r_InitialOrientation;                                     // 0x248C(0x000C) (Net)
	class UParticleSystemComponent*                    c_AimVisibilityMesh;                                      // 0x2498(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    c_AimVisibilityMeshUlt;                                   // 0x24A0(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      c_bTargetingFxIntialized : 1;                             // 0x24A8(0x0004) (Const)
	int                                                c_nTurretTargeterFXId;                                    // 0x24AC(0x0004)
	class UTgSpecialFx*                                c_TurretTargeterFX;                                       // 0x24B0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Vulcan_ConeTurret");
		return ptr;
	}


	void STATIC_PlayDyingEffects();
	void SetAimVisibilityMesh();
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void STATIC_OnMeshSwapped();
	void STATIC_InitTargetingFx();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool STATIC_CanSeeActor(class AActor* Other);
};


// Class TgGame.TgPawn_Vulcan_Thumper
// 0x0000 (0x2484 - 0x2484)
class ATgPawn_Vulcan_Thumper : public ATgPawn_Vulcan_Familiar
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Vulcan_Thumper");
		return ptr;
	}

};


// Class TgGame.TgPawn_VulcanV2_ConeTurret
// 0x0014 (0x2478 - 0x2464)
class ATgPawn_VulcanV2_ConeTurret : public ATgPawn_Familiar
{
public:
	struct FRotator                                    r_InitialOrientation;                                     // 0x2464(0x000C) (Net)
	class UParticleSystemComponent*                    c_AimVisibilityMesh;                                      // 0x2470(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_VulcanV2_ConeTurret");
		return ptr;
	}


	void STATIC_PlayDyingEffects();
	void SetAimVisibilityMesh();
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
	bool STATIC_CanSeeActor(class AActor* Other);
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
};


// Class TgGame.TgProj_Vulcan_ShatterBomb
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Vulcan_ShatterBomb : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Vulcan_ShatterBomb");
		return ptr;
	}


	void UpdateVisualsOnSetGroundTarget();
};


// Class TgGame.TgProj_Vulcan_CannonTurretBall
// 0x0004 (0x03C0 - 0x03BC)
class ATgProj_Vulcan_CannonTurretBall : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:
	unsigned long                                      m_IsFallingHarmlessly : 1;                                // 0x03BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Vulcan_CannonTurretBall");
		return ptr;
	}


	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
};


// Class TgGame.TgProj_Vulcan_ForgeProjectile
// 0x0004 (0x03B0 - 0x03AC)
class ATgProj_Vulcan_ForgeProjectile : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      m_bHasHitGod : 1;                                         // 0x03AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Vulcan_ForgeProjectile");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgAnimBlendByNeithUltimate
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByNeithUltimate : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByNeithUltimate");
		return ptr;
	}


	void Fire();
};


// Class TgGame.TgDeployable_Neith_BrokenWeave
// 0x002C (0x0400 - 0x03D4)
class ATgDeployable_Neith_BrokenWeave : public ATgDeployable
{
public:
	class ATgPawn_Neith*                               s_pawnOwner;                                              // 0x03D4(0x0008)
	class ATgDevice*                                   s_PawnOwnerHealDevice;                                    // 0x03DC(0x0008)
	unsigned long                                      s_bEffectApplied : 1;                                     // 0x03E4(0x0004)
	unsigned long                                      m_bForceDestroy : 1;                                      // 0x03E4(0x0004)
	unsigned long                                      m_bTimerDestroy : 1;                                      // 0x03E4(0x0004)
	class UTgDeviceFire*                               s_EffectModeApplied;                                      // 0x03E8(0x0008)
	TEnumAsByte<ESceneDepthPriorityGroup>              c_CurrentNetOwnerDepthGroup;                              // 0x03F0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03F1(0x0003) MISSED OFFSET
	class UTgSpecialFx*                                c_defaultHiddenFX;                                        // 0x03F4(0x0008)
	int                                                m_nDefaultHiddenFXID;                                     // 0x03FC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Neith_BrokenWeave");
		return ptr;
	}


	bool StopsProjectile(class AProjectile* P);
	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void SpecialDestroyIt(bool bSkipFx);
	void STATIC_HealOwner();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetSelected(bool bIsSelected);
	void AdjustWardsDepthPriorityGroup(TEnumAsByte<ESceneDepthPriorityGroup> DepthPriorityGroup);
	void AbsorbNearbyWeaves(float Radius);
};


// Class TgGame.TgDevice_Neith_BrokenWeave
// 0x0024 (0x0520 - 0x04FC)
class ATgDevice_Neith_BrokenWeave : public ATgDevice_Deployable
{
public:
	TEnumAsByte<EWeaveSpawnType>                       s_eNextWeaveSpawnType;                                    // 0x04FC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04FD(0x0003) MISSED OFFSET
	class ATgPawn*                                     s_NextSourcePawn;                                         // 0x0500(0x0008)
	class ATgDeployable_Neith_BrokenWeave*             s_BackflipWeave;                                          // 0x0508(0x0008)
	TArray<struct FWeaveSpawnInfo>                     s_PawnDeathWeaves;                                        // 0x0510(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Neith_BrokenWeave");
		return ptr;
	}


	void OnDeployableSpawned(class ATgDeployable* deployable);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
};


// Class TgGame.TgDevice_Neith_Backflip
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Neith_Backflip : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Neith_Backflip");
		return ptr;
	}


	void STATIC_GetConeTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Neith_BrokenWeaveUser
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Neith_BrokenWeaveUser : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Neith_BrokenWeaveUser");
		return ptr;
	}


	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Neith_SpiritArrow
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Neith_SpiritArrow : public ATgDevice_Neith_BrokenWeaveUser
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Neith_SpiritArrow");
		return ptr;
	}

};


// Class TgGame.TgDevice_Neith_WorldWeaver
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Neith_WorldWeaver : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Neith_WorldWeaver");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Neith_BrokenWeaveUser
// 0x0010 (0x01D0 - 0x01C0)
class UTgDeviceFire_Neith_BrokenWeaveUser : public UTgDeviceFire
{
public:
	class ATgPawn_Neith*                               m_OwningNeith;                                            // 0x01C0(0x0008)
	class UTgDeviceFire*                               m_BrokenWeaveFireMode;                                    // 0x01C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Neith_BrokenWeaveUser");
		return ptr;
	}


	void ApplyBrokenWeaveHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	float GetBrokenWeaveAbsorbRadius();
	bool IsBrokenWeaveModeAOE();
	bool IsValidBrokenWeaveUser();
	struct FImpactInfo STATIC_CalcBrokenWeaveWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	void AddBrokenWeaveEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
	bool STATIC_CheckTeamPassThrough(class AActor* HitActor);
	bool IsOwnersBrokenWeave(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType);
	bool IsValidBrokenWeaveTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType);
	bool IsValidNormalTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceForm_Neith_SpiritArrow
// 0x0030 (0x0268 - 0x0238)
class UTgDeviceForm_Neith_SpiritArrow : public UTgDeviceForm
{
public:
	TArray<class AActor*>                              c_SelectedBrokenWeaves;                                   // 0x0238(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_WeaveRangeFxList;                                       // 0x0248(0x0010) (NeedCtorLink)
	struct FName                                       c_nmRangeFxSocketName;                                    // 0x0258(0x0008)
	unsigned long                                      c_bUseWeaveRangeFx : 1;                                   // 0x0260(0x0004)
	int                                                c_nWeaveRangeFxID;                                        // 0x0264(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Neith_SpiritArrow");
		return ptr;
	}


	void ExitTargetingMode();
	void NotifyTargetingModeStatusChange();
	void NotifyEnterTargetingMode();
	void NotifyExitTargetingMode(bool bDeployed);
};


// Class TgGame.TgDeviceForm_Neith_WorldWeaver
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceForm_Neith_WorldWeaver : public UTgDeviceForm_Neith_SpiritArrow
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Neith_WorldWeaver");
		return ptr;
	}


	void SetTargetingModeFXToForeground();
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgEffectForm_Neith_RootBreak
// 0x0000 (0x011C - 0x011C)
class UTgEffectForm_Neith_RootBreak : public UTgEffectForm_BulwarkOfHope
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Neith_RootBreak");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Neith_A02
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Neith_A02 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Neith_A02");
		return ptr;
	}

};


// Class TgGame.TgPawn_Neith
// 0x0310 (0x28C8 - 0x25B8)
class ATgPawn_Neith : public ATgPawn_Character
{
public:
	class ATgPlayerController*                         c_CachedController;                                       // 0x25B8(0x0008)
	class UMaterialInstanceConstant*                   c_BodyArt;                                                // 0x25C0(0x0008)
	unsigned long                                      c_bEnableBodyArt : 1;                                     // 0x25C8(0x0004)
	unsigned long                                      c_bEnableWorldWeaverSphere : 1;                           // 0x25C8(0x0004)
	unsigned long                                      r_bInUltimateSetup : 1;                                   // 0x25C8(0x0004) (Net)
	unsigned long                                      c_bUltimateSetupInterrupted : 1;                          // 0x25C8(0x0004)
	unsigned long                                      r_bUltHasFired : 1;                                       // 0x25C8(0x0004) (Net)
	unsigned long                                      s_bCanTeleport : 1;                                       // 0x25C8(0x0004)
	float                                              c_fBodyArtCurrentScale;                                   // 0x25CC(0x0004)
	float                                              c_fBodyArtTweenRate;                                      // 0x25D0(0x0004)
	class UTgSpecialFx*                                c_UnravelBlastFx;                                         // 0x25D4(0x0008) (Transient)
	int                                                s_UnravelWeaveHealCount;                                  // 0x25DC(0x0004)
	int                                                s_UnravelPawnHealCount;                                   // 0x25E0(0x0004)
	int                                                s_UnravelMaxPawnHeals;                                    // 0x25E4(0x0004)
	int                                                s_UnravelMaxWeaveHeals;                                   // 0x25E8(0x0004)
	class UTgDeviceFire*                               s_UnravelPawnFireMode;                                    // 0x25EC(0x0008)
	class UTgDeviceFire*                               s_UnravelWeaveFireMode;                                   // 0x25F4(0x0008)
	class UTgSpecialFx*                                c_WorldWeaverOnFireSoundFx;                               // 0x25FC(0x0008) (Transient)
	class UTgSpecialFx*                                c_WorldWeaverSphereFx;                                    // 0x2604(0x0008) (Transient)
	int                                                s_iFireYaw;                                               // 0x260C(0x0004)
	float                                              c_fWorldWeaverSphereCurrentScale;                         // 0x2610(0x0004)
	float                                              c_fWorldWeaverSphereTweenRate;                            // 0x2614(0x0004)
	float                                              s_fWorldWeaverDamageScaleFactor;                          // 0x2618(0x0004)
	float                                              m_fSmoothEnergy;                                          // 0x261C(0x0004)
	float                                              m_fSmoothEnergySpeed;                                     // 0x2620(0x0004)
	int                                                c_iUltimatePostureID;                                     // 0x2624(0x0004)
	class ATgDevice*                                   r_InHandBasic;                                            // 0x2628(0x0008) (Net)
	class ATgDevice*                                   r_InHandUltimate;                                         // 0x2630(0x0008) (Net)
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                                       // 0x2638(0x0140) (NeedCtorLink)
	struct FTG_HUD_INFO                                c_ChargeHudInfo;                                          // 0x2778(0x0140) (NeedCtorLink)
	TArray<class UTgAnimBlendByNeithUltimate*>         m_NeithUltAnimNodes;                                      // 0x28B8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Neith");
		return ptr;
	}


	void PlayUltHitEffects();
	void ClientWorldWeaverTeleport(float TeleportLocationX, float TeleportLocationY, float TeleportLocationZ, int TeleportYaw);
	void WorldWeaverTeleport(float TeleportLocationX, float TeleportLocationY, float TeleportLocationZ, int TeleportYaw);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void TickWorldWeaverSphereVisibility(float DeltaTime);
	void TickThreadOfLifeFxs(float DeltaTime);
	void TickBodyArt(float DeltaTime);
	void ToggleWorldWeaverSphereVisibility(bool bOn, float TweenTime);
	void ToggleUltimateCameraModule(bool bOn);
	void ToggleBodyArt(bool bOn, float TweenTime);
	void DeactivateUltimatePosture(bool bWasInterrupted);
	void ActivateUltimatePosture();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void SetTargetingDevice(class ATgDevice* Dev);
	void ForceUltConsumePowerPool();
	void Tick(float DeltaSeconds);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PawnOnSpecialCleanup();
	bool STATIC_OverrideDistanceFadeRange();
	void STATIC_OnBrokenWeaveHitByWorldWeaver(class ATgDeployable_Neith_BrokenWeave* Weave);
	void STATIC_OnPawnDied();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	class UTgSpecialFx* STATIC_GetUnusedThreadOfLifeFx();
	bool STATIC_InitializeUnravelAOEFx();
	bool STATIC_InitializeWorldWeaverSoundFx();
	bool STATIC_InitializeWorldWeaverSphereFx();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	bool STATIC_DeviceOverrideManaUseVitals(class ATgDevice* Dev, class ATgPlayerController* PC);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	bool IsMyBrokenWeave(class AActor* HitActor);
	void STATIC_CalcSmoothEnergy(float fDelta);
	void STATIC_SetSpawnEnergy();
	float STATIC_GetSmoothEnergy();
	void STATIC_EndUltimateSetup(bool bForce);
	void STATIC_StartUltimateSetup(class ATgDevice* Dev);
	void STATIC_StartBackFlip();
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_DeviceAdjustHeal(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgProj_Neith_SeekingBrokenWeaveUser
// 0x000C (0x03D8 - 0x03CC)
class ATgProj_Neith_SeekingBrokenWeaveUser : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bDestroyWeaveOnHit : 1;                                 // 0x03CC(0x0004)
	unsigned long                                      m_bSkipFxOnDestroyWeave : 1;                              // 0x03CC(0x0004)
	class UTgDeviceFire_Neith_BrokenWeaveUser*         s_OwnerSpecialFireMode;                                   // 0x03D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Neith_SeekingBrokenWeaveUser");
		return ptr;
	}


	bool STATIC_CheckTeamPassThrough(class AActor* Other);
	void STATIC_HandleBrokenWeaveHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool IsValidTarget(class AActor* A);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Neith_WorldWeaver
// 0x0018 (0x03F0 - 0x03D8)
class ATgProj_Neith_WorldWeaver : public ATgProj_Neith_SeekingBrokenWeaveUser
{
public:
	class UTgSpecialFx*                                c_TargetFx;                                               // 0x03D8(0x0008)
	class UTgSpecialFx*                                c_TargetHitSoundFx;                                       // 0x03E0(0x0008)
	class UTgSpecialFx*                                c_TargetWarningArrowFx;                                   // 0x03E8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Neith_WorldWeaver");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float fDeltaTime);
	void ShutDown();
	bool IsValidTarget(class AActor* A);
	void STATIC_PlayTargetHitSound(class AActor* Target);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ClientTargetUpdate(class AActor* TargetActor, const struct FVector& TargetLocation);
};


// Class TgGame.TgDeployable_Poseidon_Surge
// 0x0004 (0x0480 - 0x047C)
class ATgDeployable_Poseidon_Surge : public ATgDeploy_MovingEffectVolume_CustomCollisionExtent
{
public:
	float                                              m_fTide;                                                  // 0x047C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Poseidon_Surge");
		return ptr;
	}


	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable_Poseidon_Whirlpool
// 0x0004 (0x0404 - 0x0400)
class ATgDeployable_Poseidon_Whirlpool : public ATgDeployable_Whirlpool
{
public:
	float                                              m_fTide;                                                  // 0x0400(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Poseidon_Whirlpool");
		return ptr;
	}


	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable_Poseidon_Kraken
// 0x001C (0x03F0 - 0x03D4)
class ATgDeployable_Poseidon_Kraken : public ATgDeployable
{
public:
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03D4(0x0008)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03DC(0x0010) (NeedCtorLink)
	float                                              m_fTide;                                                  // 0x03EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Poseidon_Kraken");
		return ptr;
	}


	void ApplyInitialHit();
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_ShouldHit(class AActor* Other);
	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDevice_Poseidon_TridentShot
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Poseidon_TridentShot : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Poseidon_TridentShot");
		return ptr;
	}


	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
};


// Class TgGame.TgPawn_Poseidon
// 0x0064 (0x261C - 0x25B8)
class ATgPawn_Poseidon : public ATgPawn_Character
{
public:
	unsigned long                                      r_bTridentActive : 1;                                     // 0x25B8(0x0004) (Net)
	unsigned long                                      s_bInHandSwapOnHold : 1;                                  // 0x25B8(0x0004)
	unsigned long                                      c_bLeftFootForward : 1;                                   // 0x25B8(0x0004)
	unsigned long                                      c_bFeetFxActive : 1;                                      // 0x25B8(0x0004)
	TArray<class UTgDeviceFire*>                       s_TridentSplitDeviceModes;                                // 0x25BC(0x0010) (NeedCtorLink)
	class ATgDevice*                                   s_NormalInHand;                                           // 0x25CC(0x0008)
	class ATgDevice*                                   s_TridentInHand;                                          // 0x25D4(0x0008)
	class ATgProj_Poseidon_TridentShot*                m_HittingTridentProjectile;                               // 0x25DC(0x0008)
	class ATgDeployable_Poseidon_Surge*                m_HittingSurge;                                           // 0x25E4(0x0008)
	class ATgDeployable_Poseidon_Whirlpool*            m_HittingWhirlpool;                                       // 0x25EC(0x0008)
	class ATgDeployable_Poseidon_Kraken*               m_HittingKraken;                                          // 0x25F4(0x0008)
	class UTgSpecialFx*                                c_FeetFx[0x2];                                            // 0x25FC(0x0008) (Transient)
	class USkelControlBase*                            c_FeetSkelController;                                     // 0x260C(0x0008)
	class UTgEffectGroup*                              s_PassiveEffectGroup;                                     // 0x2614(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Poseidon");
		return ptr;
	}


	void UpdateTridentFx(bool bActivate);
	void UpdateFeetFx();
	void Tick(float DeltaTime);
	void NotifyRightFootForward();
	void NotifyLeftFootForward();
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* SkelComp);
	class UTgDeviceFire* STATIC_GetTridentFireMode();
	void TideUpdated();
	bool PostPawnSetup();
	void STATIC_OnRespawn();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_StopTridentAttack(bool bForce);
	void STATIC_StartTridentAttack(class UTgDeviceFire* FireMode);
	void STATIC_ReapplyLoadoutEffects();
	void STATIC_ResetTideStack();
	bool STATIC_InitializeFeetFX();
	float STATIC_GetUIGroundSpeed();
	void STATIC_SetSpawnEnergy();
	void STATIC_OnPawnDied();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStopFire(class ATgDevice* Dev, bool bWasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
};


// Class TgGame.TgProj_Poseidon_TridentShot
// 0x0008 (0x03A0 - 0x0398)
class ATgProj_Poseidon_TridentShot : public ATgProj_Simulated
{
public:
	float                                              m_fTide;                                                  // 0x0398(0x0004)
	unsigned long                                      m_bApplyItemEffects : 1;                                  // 0x039C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Poseidon_TridentShot");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgAchievement_Aphrodite_KissMe
// 0x0018 (0x009C - 0x0084)
class UTgAchievement_Aphrodite_KissMe : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nNumGods;                                               // 0x0088(0x0004)
	TArray<class ATgPawn*>                             m_TrackedSaved;                                           // 0x008C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Aphrodite_KissMe");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Aphrodite_LoveBirds
// 0x000C (0x044C - 0x0440)
class ATgDeployable_Aphrodite_LoveBirds : public ATgDeploy_EffectVolume_RollingLine
{
public:
	float                                              m_fPreFireDelay;                                          // 0x0440(0x0004)
	struct FName                                       m_nmDelayBuildProxy;                                      // 0x0444(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Aphrodite_LoveBirds");
		return ptr;
	}


	void STATIC_DelayBuildProxy();
	void BuildProxy();
	void STATIC_FireAmmunitionDeployable();
};


// Class TgGame.TgDeployable_Aphrodite_FlowerBed
// 0x0000 (0x0404 - 0x0404)
class ATgDeployable_Aphrodite_FlowerBed : public ATgDeployable_GroundTrail
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Aphrodite_FlowerBed");
		return ptr;
	}

};


// Class TgGame.TgDevice_Aphrodite_GetAway
// 0x005C (0x054C - 0x04F0)
class ATgDevice_Aphrodite_GetAway : public ATgDevice
{
public:
	unsigned long                                      m_bCachedUseSoulMateDeviceMode : 1;                       // 0x04F0(0x0004)
	class ATgPawn*                                     m_CachedSoulMate;                                         // 0x04F4(0x0008)
	struct FAimData                                    m_CachedSoulMateAim;                                      // 0x04FC(0x0030)
	TArray<struct FImpactInfo>                         PendingSoulMateImpact;                                    // 0x052C(0x0010) (Component, NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_SoulMateFireMode;                                       // 0x053C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aphrodite_GetAway");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void DeliverQueuedPendingHits();
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_PerformKnockback(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void STATIC_GetSoulMateAim(struct FAimData* Aim);
	class UTgDeviceFire* STATIC_GetCurrentSoulMateFire();
	struct FAimData STATIC_CacheAim();
	void STATIC_GetCachedSoulMateAim(struct FAimData* Aim);
	class ATgPawn* STATIC_GetSoulMate();
	bool UseSoulMateFireMode();
	bool ValidSoulMate(class ATgPawn* SoulMate);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Aphrodite_SoulMates
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Aphrodite_SoulMates : public ATgDevice
{
public:
	unsigned long                                      m_bDisableCooldown : 1;                                   // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aphrodite_SoulMates");
		return ptr;
	}


	void StartCooldown(int nMode, float fCooldownTimeOverride);
	class AActor* STATIC_GetTrackingTarget(int nFireIndex);
	void STATIC_FireAmmunition();
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Aphrodite_SoulMates_PVE
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Aphrodite_SoulMates_PVE : public ATgDevice_Aphrodite_SoulMates
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aphrodite_SoulMates_PVE");
		return ptr;
	}


	class AActor* STATIC_GetTrackingTarget(int nFireIndex);
};


// Class TgGame.TgDeviceForm_Aphrodite_GetAway
// 0x0044 (0x027C - 0x0238)
class UTgDeviceForm_Aphrodite_GetAway : public UTgDeviceForm
{
public:
	TEnumAsByte<ETargetingModeStatus>                  c_eSoulMateModeStatus;                                    // 0x0238(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0239(0x0003) MISSED OFFSET
	struct FAimData                                    c_SoulMateAim;                                            // 0x023C(0x0030)
	class ATgSkeletalMeshActor*                        c_SoulMateModeMeshIndicator;                              // 0x026C(0x0008)
	class UTgSpecialFx*                                c_SoulMateModeFx;                                         // 0x0274(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Aphrodite_GetAway");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void ToggleSoulMateMode(bool bEnable);
	void UpdateSoulMateModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateSoulMateModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
};


// Class TgGame.TgEffectForm_Aphrodite_Birds
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_Aphrodite_Birds : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Aphrodite_Birds");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AphroditeMarkedDamageBuff
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_AphroditeMarkedDamageBuff : public UTgInventoryObject_Listen
{
public:
	class AActor*                                      MarkedActor;                                              // 0x00D0(0x0008)
	float                                              m_fDamageMultipler;                                       // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AphroditeMarkedDamageBuff");
		return ptr;
	}

};


// Class TgGame.TgMarkComponent_Aphrodite_Base
// 0x0028 (0x00E4 - 0x00BC)
class UTgMarkComponent_Aphrodite_Base : public UTgMarkComponent
{
public:
	unsigned long                                      m_bUseOwningDeviceEffectGroup : 1;                        // 0x00BC(0x0004)
	unsigned long                                      m_bReapplyOnDeviceModeChange : 1;                         // 0x00BC(0x0004)
	class UTgDeviceFire*                               m_OwningDeviceMode;                                       // 0x00C0(0x0008)
	float                                              m_fLinkRange;                                             // 0x00C8(0x0004)
	float                                              m_fAbsoluteLinkRange;                                     // 0x00CC(0x0004)
	float                                              m_fWorryMoveDistance;                                     // 0x00D0(0x0004)
	TArray<struct FVector>                             s_LastTickLocation;                                       // 0x00D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_Aphrodite_Base");
		return ptr;
	}


	void STATIC_DeviceOnSetFireMode(class UTgDeviceFire* DeviceMode);
	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgMarkComponent_Aphrodite_FertileGround
// 0x0028 (0x010C - 0x00E4)
class UTgMarkComponent_Aphrodite_FertileGround : public UTgMarkComponent_Aphrodite_Base
{
public:
	TArray<class UTgTrailComponent_GroundTrail*>       s_TrailList;                                              // 0x00E4(0x0010) (ExportObject, Component, NeedCtorLink, EditInline)
	class UTgDeviceFire*                               m_PendingDeviceMode;                                      // 0x00F4(0x0008)
	class UTgDeviceFire*                               m_PendingTrailFireMode;                                   // 0x00FC(0x0008)
	class UTgDeviceFire*                               m_TrailFireMode;                                          // 0x0104(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_Aphrodite_FertileGround");
		return ptr;
	}


	void STATIC_SetTrailFireMode(class UTgDeviceFire* DeviceMode);
	void STATIC_DeviceOnSetFireMode(class UTgDeviceFire* DeviceMode);
	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgMarkComponent_Aphrodite_KissDamageBuff
// 0x001C (0x0100 - 0x00E4)
class UTgMarkComponent_Aphrodite_KissDamageBuff : public UTgMarkComponent_Aphrodite_Base
{
public:
	int                                                m_nDamageBuffDeviceId;                                    // 0x00E4(0x0004)
	TArray<class UTgInventoryObject*>                  s_DamageBuffInvObj;                                       // 0x00E8(0x0010) (NeedCtorLink)
	class AActor*                                      s_KissedActor;                                            // 0x00F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_Aphrodite_KissDamageBuff");
		return ptr;
	}


	void STATIC_SetKissedActor(class AActor* KissedActor);
	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgMarkComponent_Aphrodite_SoulMates
// 0x0014 (0x00F8 - 0x00E4)
class UTgMarkComponent_Aphrodite_SoulMates : public UTgMarkComponent_Aphrodite_Base
{
public:
	float                                              m_fGracePeriod;                                           // 0x00E4(0x0004)
	TArray<float>                                      s_GracePeriodTimes;                                       // 0x00E8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_Aphrodite_SoulMates");
		return ptr;
	}


	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgMinionGoal_Aphrodite
// 0x0000 (0x036C - 0x036C)
class ATgMinionGoal_Aphrodite : public ATgMinionGoal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMinionGoal_Aphrodite");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgPawn_Aphrodite
// 0x00D0 (0x2688 - 0x25B8)
class ATgPawn_Aphrodite : public ATgPawn_Character
{
public:
	unsigned long                                      m_bAllowLinksToDieOut : 1;                                // 0x25B8(0x0004)
	unsigned long                                      c_bSoulMateActive : 1;                                    // 0x25B8(0x0004)
	unsigned long                                      m_bEnableJealousDamageBuff : 1;                           // 0x25B8(0x0004)
	unsigned long                                      m_bEnableUndyingLove : 1;                                 // 0x25B8(0x0004)
	float                                              m_fDeadLinkShrinkRate;                                    // 0x25BC(0x0004)
	struct FVector                                     m_vSpineOffset;                                           // 0x25C0(0x000C)
	TArray<struct FSoulMateLinkInfo>                   c_DeadSoulMateLinks;                                      // 0x25CC(0x0010) (Transient, NeedCtorLink)
	struct FSoulMateLinkInfo                           c_ActiveSoulMateLink;                                     // 0x25DC(0x003C) (Transient)
	class UTgSpecialFx*                                c_SoulMateLinkExplosion;                                  // 0x2618(0x0008) (Transient)
	class UTgSpecialFx*                                c_SoulMateLinkWarning;                                    // 0x2620(0x0008) (Transient)
	class UTgMarkComponent_Aphrodite_SoulMates*        m_SoulMateMark;                                           // 0x2628(0x0008) (ExportObject, Component, EditInline)
	class AActor*                                      r_SoulMateLinkActor;                                      // 0x2630(0x0008) (Net)
	float                                              r_fWorryMoveDistance;                                     // 0x2638(0x0004) (Net)
	float                                              r_fLinkRange;                                             // 0x263C(0x0004) (Net)
	float                                              s_fForceBreakRange;                                       // 0x2640(0x0004)
	float                                              s_fGracePeriod;                                           // 0x2644(0x0004)
	float                                              s_fLeftOverTransferableHealth;                            // 0x2648(0x0004)
	float                                              s_fLeftOverTransferableMana;                              // 0x264C(0x0004)
	float                                              s_fTransferableHealth;                                    // 0x2650(0x0004)
	float                                              s_fTransferableMana;                                      // 0x2654(0x0004)
	class UTgMarkComponent_Aphrodite_Base*             m_JealousDamageBuffMark;                                  // 0x2658(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgDeviceFire*>                       m_JealousDeviceModes;                                     // 0x2660(0x0010) (NeedCtorLink)
	float                                              m_fGetAwayPulseValue;                                     // 0x2670(0x0004)
	float                                              m_fGetAwayPulseRate;                                      // 0x2674(0x0004)
	float                                              r_fGetAwayPulseDuration;                                  // 0x2678(0x0004) (Net)
	class UTgMarkComponent_Aphrodite_Base*             m_UndyingLoveMark;                                        // 0x267C(0x0008) (ExportObject, Transient, Component, EditInline)
	int                                                r_nPassiveAux;                                            // 0x2684(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Aphrodite");
		return ptr;
	}


	void STATIC_OnDeviceFormStartFire(int nEquipPoint, float fFireDuration, int nFireMode);
	void TickGetAwayPulse(float DeltaTime);
	void StartGetAwayPulse(float fDuration);
	void UpdateLinkVisibility(struct FSoulMateLinkInfo* LinkInfo);
	bool UpdateSoulMateLink(float DeltaTime, struct FSoulMateLinkInfo* LinkInfo);
	void TickSoulMateLinks(float DeltaTime);
	void SetSoulMateLinkActor(class AActor* SoulMate, bool bEnable);
	struct FSoulMateLinkInfo STATIC_CreateSoulMateLink(class AActor* SoulMate);
	void STATIC_DeactivateSoulMateLink();
	void Tick(float DeltaSeconds);
	void PostDemoRewind();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_OnPawnDied();
	void STATIC_EndUndyingLove(bool bWasInterrupted);
	void STATIC_StartUndyingLove(class ATgDevice* Dev);
	void STATIC_EndJealousDamageBuff(bool bWasInterrupted);
	void STATIC_StartJealousDamageBuff(class ATgDevice* Dev, class AActor* Target);
	class AActor* STATIC_GetSoulMateServer(int* Index);
	bool IsSoulMate(class AActor* Other);
	bool STATIC_HasSoulMate();
	void ApplySoulMateHeals();
	void STATIC_StartSoulMateHealsTimer();
	void STATIC_CalcSoulMateLinkLocation(class AActor* SoulMate, struct FVector* LinkLocation);
	class UTgSpecialFx* STATIC_GetSoulMateLinkFxAndMic(class UMaterialInstanceConstant* MIC);
	bool STATIC_InitSoulMateLinkExplosionFx();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_RegainPools(float DeltaSeconds);
	void STATIC_PawnOnHealed(struct FOnHealedParams* Params);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
};


// Class TgGame.TgAnimBlendByApolloPassive
// 0x0014 (0x017C - 0x0168)
class UTgAnimBlendByApolloPassive : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      bControllingNode : 1;                                     // 0x0168(0x0004) (Edit)
	unsigned long                                      m_bEnablePassive : 1;                                     // 0x0168(0x0004)
	TArray<struct FName>                               FiringAnimNames;                                          // 0x016C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByApolloPassive");
		return ptr;
	}


	void TogglePassive(bool bEnable);
};


// Class TgGame.TgDevice_Apollo_SoBeautiful
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Apollo_SoBeautiful : public ATgDevice
{
public:
	class ATgProj_SimulatedPassThrough*                m_SoBeautifulProj;                                        // 0x04F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Apollo_SoBeautiful");
		return ptr;
	}


	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
};


// Class TgGame.TgDevice_Apollo_SkyJump
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Apollo_SkyJump : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Apollo_SkyJump");
		return ptr;
	}


	void OnDeployableSpawned(class ATgDeployable* deployable);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	bool CanBeCanceled();
	bool ApplyGlobalOffhandCooldown();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Apollo_ChariotSummon
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Apollo_ChariotSummon : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Apollo_ChariotSummon");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDeviceFire_Apollo_SkyJump
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Apollo_SkyJump : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Apollo_SkyJump");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgPawn_Apollo
// 0x0124 (0x26DC - 0x25B8)
class ATgPawn_Apollo : public ATgPawn_Character
{
public:
	unsigned long                                      r_bPassiveActive : 1;                                     // 0x25B8(0x0004) (Net)
	unsigned long                                      c_bLocalPassiveActive : 1;                                // 0x25B8(0x0004)
	unsigned long                                      m_bSkyJumpAtLocation : 1;                                 // 0x25B8(0x0004)
	unsigned long                                      m_bSkyJumpHasFired : 1;                                   // 0x25B8(0x0004)
	TArray<class UTgSpecialFx*>                        c_PassiveFx;                                              // 0x25BC(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgAnimBlendByApolloPassive*>         c_PassiveNodes;                                           // 0x25CC(0x0010) (NeedCtorLink)
	TArray<struct FName>                               m_InHandSkelControlNames;                                 // 0x25DC(0x0010) (NeedCtorLink)
	TArray<class USkelControlSingleBone*>              m_InHandSkelControls;                                     // 0x25EC(0x0010) (Transient, NeedCtorLink)
	float                                              m_fInHandTargetScale;                                     // 0x25FC(0x0004)
	float                                              m_fInHandCurrentScale;                                    // 0x2600(0x0004)
	float                                              m_fInHandScalingRate;                                     // 0x2604(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                                   // 0x2608(0x0008)
	TArray<struct FChargeHitInfo>                      m_ChargeHitInfos;                                         // 0x2610(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_ChargeExplosionModes;                                   // 0x2620(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              r_fTheMovesAOERadius;                                     // 0x2630(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    c_ChariotComponent;                                       // 0x2634(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgSkeletalMeshComponent*                    c_FuselageComponent;                                      // 0x263C(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgAnimNodeAimOffset*                        c_ChariotAimOffset;                                       // 0x2644(0x0008) (Transient)
	class UTgAnimNodeAimOffset*                        c_ApolloChariotAimOffset;                                 // 0x264C(0x0008) (Transient)
	TArray<class UAudioComponent*>                     c_ChariotAudioComponents;                                 // 0x2654(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	class ATgDevice*                                   r_SkyJumpInHandDevice;                                    // 0x2664(0x0008) (Net)
	class ATgDevice*                                   r_InHandDevice;                                           // 0x266C(0x0008) (Net)
	class ATgDevice*                                   r_ApolloPassive;                                          // 0x2674(0x0008) (Net)
	class UTgDeviceFire*                               m_SkyJumpKnockBackMode;                                   // 0x267C(0x0008)
	TArray<class USoundCue*>                           m_ChariotSoundCues;                                       // 0x2684(0x0010) (Transient, NeedCtorLink)
	int                                                r_nSkyJumpCameraYaw;                                      // 0x2694(0x0004) (Net)
	float                                              m_fAimOffsetMax;                                          // 0x2698(0x0004)
	TEnumAsByte<ESkyJumpPhase>                         r_SkyJumpPhase;                                           // 0x269C(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x269D(0x0003) MISSED OFFSET
	struct FVector                                     r_SkyJumpStartLocation;                                   // 0x26A0(0x000C) (Net)
	struct FVector                                     r_SkyJumpBackupLocation;                                  // 0x26AC(0x000C) (Net)
	class UTgSpecialFx*                                c_SkyJumpBeamFx;                                          // 0x26B8(0x0008) (Transient)
	class AActor*                                      r_SkyJumpBeamTarget;                                      // 0x26C0(0x0008) (Net)
	class AActor*                                      c_SkyJumpBeamActor;                                       // 0x26C8(0x0008) (Transient)
	struct FVector                                     m_vSkyJumpBeamOffset;                                     // 0x26D0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Apollo");
		return ptr;
	}


	bool IsInClassSpecificMovement();
	bool STATIC_IgnoreFaceRotationWithInterp();
	void STATIC_SetInHandScaleDownTimer();
	void STATIC_ScaleInHandDownFast();
	void STATIC_ScaleInHandDown();
	void STATIC_ScaleInHandUpAndSetTimer();
	void UpdateInHandWeapons();
	void ToggleInHandWeapons(bool bEnable, float fTweenTime);
	void TickInHandWeapons(float DeltaTime);
	void TickSkyJumpBeam(float DeltaSeconds);
	void UpdateSkyBeamFx(float DeltaTime);
	void SetSkyJumpBeamActor(class AActor* Target);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void SetTargetingDevice(class ATgDevice* Dev);
	float ApplyPitchLimit(float fPitch);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void ChargeCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void PlayDeathAnimation();
	void UpdateSkyJumpPhase();
	void UpdatePassiveFx();
	void STATIC_OnRespawn();
	void ClearSkyJumpAfterDeath();
	void PostDemoRewind();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void TickSkyJumpMeshVisibility(float fDelta);
	bool STATIC_OverrideDistanceFadeRange();
	bool STATIC_ShowImmunityHighlight();
	void STATIC_SkyJumpKnockback();
	void STATIC_RegainManaPool(float fDelta);
	class ATgSkeletalMeshActorSpawnable_ApolloChariot* STATIC_DetachChariot(bool bRagdoll);
	void AttachChariot();
	void STATIC_EndSkyJump();
	void STATIC_StartSkyJump();
	bool STATIC_InitializeSkyJumpBeamFx();
	bool STATIC_InitializePassiveFx();
	bool STATIC_InitializeChariotSoundCues();
	void STATIC_ChargeExplosion();
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void DeviceOnStopFire(class ATgDevice* Dev, bool bWasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_SetPassiveActive(bool bActive);
	bool TryToTogglePassive();
	void ApplyAudacityCharge(bool bRemove, float fAudacityAmount);
	void STATIC_OnPawnDied();
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
};


// Class TgGame.TgSkeletalMeshActorSpawnable_ApolloChariot
// 0x0008 (0x0324 - 0x031C)
class ATgSkeletalMeshActorSpawnable_ApolloChariot : public ATgSkeletalMeshActorSpawnable
{
public:
	unsigned long                                      m_bShouldScaleWithLifeSpan : 1;                           // 0x031C(0x0004)
	float                                              m_fScaleMeshAtLifeSpan;                                   // 0x0320(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable_ApolloChariot");
		return ptr;
	}

};


// Class TgGame.TgAchievement_NeZha_TwosACrowd
// 0x001C (0x00A0 - 0x0084)
class UTgAchievement_NeZha_TwosACrowd : public UTgAchievement
{
public:
	TArray<struct FBounceData>                         m_TrackedData;                                            // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nTargetPawnCount;                                       // 0x0094(0x0004)
	int                                                m_nTargetHitCount;                                        // 0x0098(0x0004)
	int                                                m_nDeviceId;                                              // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_NeZha_TwosACrowd");
		return ptr;
	}

};


// Class TgGame.TgAchievement_NeZha_WatchThis
// 0x0018 (0x009C - 0x0084)
class UTgAchievement_NeZha_WatchThis : public UTgAchievement
{
public:
	class ATgPawn*                                     m_TargetGod;                                              // 0x0084(0x0008)
	int                                                m_nTimeLimit;                                             // 0x008C(0x0004)
	int                                                m_nTimeStamp;                                             // 0x0090(0x0004)
	int                                                m_nDeviceId;                                              // 0x0094(0x0004)
	int                                                m_nDevice2Id;                                             // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_NeZha_WatchThis");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByNeZhaArmillarySash
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendByNeZhaArmillarySash : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByNeZhaArmillarySash");
		return ptr;
	}


	void STATIC_SashMiss();
	void STATIC_SashHit();
};


// Class TgGame.TgDevice_NeZha_UltQte
// 0x0040 (0x0530 - 0x04F0)
class ATgDevice_NeZha_UltQte : public ATgDevice
{
public:
	float                                              r_CenterPoints[0x6];                                      // 0x04F0(0x0004) (Net, Transient)
	float                                              r_SmoothSpeeds[0x6];                                      // 0x0508(0x0004) (Net, Transient)
	unsigned long                                      bHasReleased : 1;                                         // 0x0520(0x0004) (Transient)
	float                                              SmoothedEnergy;                                           // 0x0524(0x0004) (Transient)
	int                                                CurrentHitTiming;                                         // 0x0528(0x0004) (Transient)
	int                                                LastHitSubmitted;                                         // 0x052C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NeZha_UltQte");
		return ptr;
	}


	bool STATIC_ServerPerformQuickTimeEvent(float ClientEnergy, int ClientHit);
	void StopFire();
	bool Use();
	void STATIC_PlayMissSound();
	void STATIC_PlayHitSound();
	void ApplyEquipEffects();
};


// Class TgGame.TgDevice_NeZha_ArmillarySash
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_NeZha_ArmillarySash : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NeZha_ArmillarySash");
		return ptr;
	}


	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_NeZha_ChildOfLotus
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_NeZha_ChildOfLotus : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NeZha_ChildOfLotus");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceForm_NeZha_Reincarnate
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_NeZha_Reincarnate : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_NeZha_Reincarnate");
		return ptr;
	}

};


// Class TgGame.TgEffectDamage_NeZha_UltCrit
// 0x0004 (0x00BC - 0x00B8)
class UTgEffectDamage_NeZha_UltCrit : public UTgEffectDamage
{
public:
	unsigned long                                      bIsSuccessfulHit : 1;                                     // 0x00B8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_NeZha_UltCrit");
		return ptr;
	}


	bool AddCriticalStrikeDamage(class ATgPawn* InstigatorPawn, const struct FImpactInfo& Impact, float* ProratedAmount);
	TEnumAsByte<EApplyEffectResult> ApplyEffect(class AActor* Target, const struct FImpactInfo& Impact, bool bConvertDOT);
};


// Class TgGame.TgEffectForm_NeZha_UltCrit
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_NeZha_UltCrit : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_NeZha_UltCrit");
		return ptr;
	}


	bool STATIC_ShouldShowEffectForm();
};


// Class TgGame.TgInventoryObject_Listen_NeZhaPassive
// 0x0030 (0x0100 - 0x00D0)
class UTgInventoryObject_Listen_NeZhaPassive : public UTgInventoryObject_Listen
{
public:
	TArray<int>                                        m_nStackBuildingDevices;                                  // 0x00D0(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nStackConsumingDevices;                                 // 0x00E0(0x0010) (NeedCtorLink)
	int                                                m_nStackBuildingCategoryCode;                             // 0x00F0(0x0004)
	int                                                m_nStackConsumedCategorycode;                             // 0x00F4(0x0004)
	int                                                m_nStackBuildingSituationalType;                          // 0x00F8(0x0004)
	int                                                m_nStackConsumedSituationalType;                          // 0x00FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NeZhaPassive");
		return ptr;
	}


	void STATIC_ConsumePassiveStacks();
};


// Class TgGame.TgPawn_NeZha
// 0x0170 (0x2728 - 0x25B8)
class ATgPawn_NeZha : public ATgPawn_Character
{
public:
	TArray<struct FUniverseRingTossDamageTracker>      UniverseRingTossBounces;                                  // 0x25B8(0x0010) (Transient, NeedCtorLink)
	TEnumAsByte<EArmillarySashPhase>                   r_ArmillarySashPhase;                                     // 0x25C8(0x0001) (Net, Transient)
	TEnumAsByte<EWindFireWheelsPhase>                  r_WindFireWheelsPhase;                                    // 0x25C9(0x0001) (Net, Transient)
	TEnumAsByte<ENEZHA_PASSIVE_STATE>                  r_ePassiveState;                                          // 0x25CA(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x25CB(0x0001) MISSED OFFSET
	unsigned long                                      r_bArmillarySashHitOrMissed : 1;                          // 0x25CC(0x0004) (Net, Transient)
	unsigned long                                      m_bDoArmillarySashAoeOnStunFail : 1;                      // 0x25CC(0x0004) (Const)
	unsigned long                                      bWindFireAirDashQueuedHit : 1;                            // 0x25CC(0x0004) (Transient)
	unsigned long                                      bHasNewAirDashHit : 1;                                    // 0x25CC(0x0004) (Transient)
	unsigned long                                      r_bPassiveFXEnabled : 1;                                  // 0x25CC(0x0004) (Net)
	TArray<class UTgDeviceFire*>                       SashAoeBlastModes;                                        // 0x25D0(0x0010) (Transient, NeedCtorLink)
	class ATgPawn*                                     r_ArmillarySashTarget;                                    // 0x25E0(0x0008) (Net, Transient)
	class UTgAnimNodeBlendByNeZhaArmillarySash*        SashAnimBlend;                                            // 0x25E8(0x0008) (Transient)
	class USkelControlSingleBone*                      SashSkelControlDistance;                                  // 0x25F0(0x0008) (Transient)
	class USkelControlLookAt*                          SashSkelControlAim;                                       // 0x25F8(0x0008) (Transient)
	class USkelControlSingleBone*                      SashSkelScale;                                            // 0x2600(0x0008) (Transient)
	class ATgProj_NeZha_ArmillarySash*                 m_SashProjectile;                                         // 0x2608(0x0008) (Transient)
	float                                              WindFireLiftDuration;                                     // 0x2610(0x0004)
	float                                              WindFireAirDashDuration;                                  // 0x2614(0x0004)
	float                                              WindFireKnockDownDuration;                                // 0x2618(0x0004)
	float                                              WindFireLandedDuration;                                   // 0x261C(0x0004)
	TArray<class UTgDeviceFire*>                       WindFireAirDashModes;                                     // 0x2620(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgDeviceFire*>                       WindFireKnockDownModes;                                   // 0x2630(0x0010) (Transient, NeedCtorLink)
	TArray<class UTgDeviceFire*>                       WindFireLandedBlastModes;                                 // 0x2640(0x0010) (Transient, NeedCtorLink)
	struct FWindFireWheelsQteStatus                    WindFireHudInfo[0x3];                                     // 0x2650(0x0020) (Transient)
	int                                                r_WindFireAirDashHits;                                    // 0x26B0(0x0004) (Net, Transient)
	class ATgCollisionProxy_Cylinder*                  WindFireChargeCollisionProxy;                             // 0x26B4(0x0008) (Transient)
	class ATgPawn*                                     r_WindFireTarget;                                         // 0x26BC(0x0008) (Net, Transient)
	class ATgPawn*                                     c_WindFirePostProcessTarget;                              // 0x26C4(0x0008) (Transient)
	class UTgSpecialFx*                                WindFireLandedFx;                                         // 0x26CC(0x0008) (Transient)
	class ATgDevice_NeZha_UltQte*                      r_WindFireAirDashTiming;                                  // 0x26D4(0x0008) (Net, Transient)
	class UTgDeviceFire*                               WindFireInitialDeviceFireMode;                            // 0x26DC(0x0008) (Transient)
	struct FVector                                     WindFireStartLocation;                                    // 0x26E4(0x000C) (Transient)
	class UPostProcessChain*                           m_UltPostProcessChain;                                    // 0x26F0(0x0008)
	class ATgDevice*                                   r_InHandDevice;                                           // 0x26F8(0x0008) (Net, Transient)
	class UTgSkeletalMeshComponent*                    c_SashMeshComponent;                                      // 0x2700(0x0008) (ExportObject, Transient, Component, EditInline)
	class UTgSkeletalMeshComponent*                    c_PACSashMeshComponent;                                   // 0x2708(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              c_fPassiveTimer;                                          // 0x2710(0x0004)
	float                                              r_fPassiveTransitionTime;                                 // 0x2714(0x0004) (Net)
	int                                                m_nSashAOEBlastOverrideSubId;                             // 0x2718(0x0004)
	int                                                m_nWFADOverrideSubId;                                     // 0x271C(0x0004)
	int                                                m_nWFKDOverrideSubId;                                     // 0x2720(0x0004)
	int                                                m_nWFLBOverrideSubId;                                     // 0x2724(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_NeZha");
		return ptr;
	}


	void STATIC_SwapToDefaultCamera(bool bUnlockInput);
	void STATIC_SwapToUltCamera();
	bool IsInClassSpecificMovement();
	bool STATIC_IgnoreFaceRotationWithInterp();
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_OnRespawn();
	bool PostPawnSetup();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDyingEffects();
	void STATIC_StopWindFireEffects();
	void STATIC_PlayWindFireMissEffects();
	void STATIC_PlayWindFireLiftMissEffects();
	void STATIC_PlayWindFireLandedEffects();
	void STATIC_PlayWindFireKnockDownEffects();
	void STATIC_PlayWindFireDashEffects();
	void STATIC_PlayWindFireLiftEffects();
	void WindFireLandedUpdate();
	void WindFireAirDashUpdate();
	void STATIC_StartWindFireAirDashDamage();
	void STATIC_EndWindFireAirDash();
	void SetUltPostProcess(class ATgPawn* OtherTarget);
	void ClearUltPostProcess();
	void UpdateUltPostProcess();
	void STATIC_StartWindFireAirDash();
	void WindFireSelfLift();
	void WindFireTargetLift();
	void UpdateWindFireWheelsPhase(TEnumAsByte<EWindFireWheelsPhase> NewPhase);
	void UpdateWindFireWheelsTargetEffect(class AActor* Other, bool bEnable);
	void STATIC_SetArmillarySashProjectile(class ATgProj_NeZha_ArmillarySash* Proj);
	void UpdateArmillarySashEffects(float DeltaSeconds);
	void UpdateArmillarySashPhase(TEnumAsByte<EArmillarySashPhase> NewPhase);
	void UpdateArmillarySashTarget(class ATgPawn* Target);
	void UpdatePassiveState(TEnumAsByte<ENEZHA_PASSIVE_STATE> ePassiveState);
	void Tick(float DeltaSeconds);
	void WindFireChargeCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool CanBePulled(bool bIsActuallyPulling);
	void KnockdownTweenEnd(bool bInterrupted);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void PreDemoRewind();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_EnablePassiveFX(bool bEnabled);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveAux(float* fResult);
	void STATIC_CalcSmoothEnergy(float DeltaSeconds);
	void STATIC_SetSpawnEnergy();
	float STATIC_GetUltEnergy();
	float STATIC_GetSmoothEnergy();
	void WindFireWheelsLandedTweenTrace(struct FVector* SelfTweenLoc, struct FVector* TargetTweenLoc);
	void WindFireWheelsLandedHit();
	void WindFireWheelsKnockDownHit();
	void WindFireWheelsAirDashHit();
	void STATIC_DetachSashMesh();
	void AttachSashMesh();
	void ArmillarySashAoeBlast(const struct FVector& OverrideLocation);
	void STATIC_OnMeshSwapped();
	void STATIC_OnPawnDied();
	int STATIC_GetCustomParticleSystemFilter();
	void DeviceOnHit(class ATgDevice* Device, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Device, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Device);
	void DeviceOnStartFire(class ATgDevice* Device);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Device);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Device, int nPropertyId, struct FImpactInfo* Impact, float* DamageAmt);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Device, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Device, unsigned char FireMode, bool bDeviceFailLog, struct FAimData* Aim);
	bool STATIC_InitializeSashMeshComponent();
	void STATIC_InitializeUltPostProcess();
	void STATIC_CreateWindFireLandedFx();
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_NeZha_PVE
// 0x0000 (0x2728 - 0x2728)
class ATgPawn_NeZha_PVE : public ATgPawn_NeZha
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_NeZha_PVE");
		return ptr;
	}

};


// Class TgGame.TgProj_NeZha_UniverseRing
// 0x0000 (0x040C - 0x040C)
class ATgProj_NeZha_UniverseRing : public ATgProj_SimulatedArcing
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_NeZha_UniverseRing");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Fenrir_UnleashTheBeast
// 0x0000 (0x00AC - 0x00AC)
class UTgAchievement_Fenrir_UnleashTheBeast : public UTgAchievement_DeviceMultiHit_ByType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Fenrir_UnleashTheBeast");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Fenrir_EndOfDays
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Fenrir_EndOfDays : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Fenrir_EndOfDays");
		return ptr;
	}

};


// Class TgGame.TgDevice_Fenrir_Maul
// 0x0004 (0x0500 - 0x04FC)
class ATgDevice_Fenrir_Maul : public ATgDevice_HitPulse
{
public:
	float                                              fBonusPowerScaling;                                       // 0x04FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fenrir_Maul");
		return ptr;
	}


	bool CanBeCanceled();
	bool STATIC_CanLockOnToTarget(class AActor* Target);
	void UpdateAimWhileFiring(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Fenrir_Bite
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Fenrir_Bite : public ATgDevice_Melee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fenrir_Bite");
		return ptr;
	}


	void STATIC_FireAmmunition();
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	struct FVector STATIC_GetCylinderExtent(class AActor* A);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	float GetRefireTime(int nMode);
	bool STATIC_CanBeDisarmed();
};


// Class TgGame.TgDeviceForm_Fenrir_DoubleLeap
// 0x000C (0x0244 - 0x0238)
class UTgDeviceForm_Fenrir_DoubleLeap : public UTgDeviceForm
{
public:
	int                                                c_nBoundingRingFxID;                                      // 0x0238(0x0004)
	class UTgSpecialFx*                                c_BoundingRingFx;                                         // 0x023C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Fenrir_DoubleLeap");
		return ptr;
	}


	void ExitTargetingMode();
	void TurnOffBoundingRing();
	void TurnOnBoundingRing();
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgPawn_Fenrir
// 0x00E8 (0x26A0 - 0x25B8)
class ATgPawn_Fenrir : public ATgPawn_Character
{
public:
	float                                              s_fLeapComboPoints;                                       // 0x25B8(0x0004)
	TEnumAsByte<EBiteState>                            r_eBiteState;                                             // 0x25BC(0x0001) (Net)
	TEnumAsByte<EBiteState>                            m_eLocalBiteState;                                        // 0x25BD(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x25BE(0x0002) MISSED OFFSET
	int                                                m_nBiteBigPostureID;                                      // 0x25C0(0x0004)
	int                                                m_nBiteGrabPostureID;                                     // 0x25C4(0x0004)
	class ATgDevice*                                   r_BiteInHand;                                             // 0x25C8(0x0008) (Net)
	class ATgDevice*                                   r_NormalInHand;                                           // 0x25D0(0x0008) (Net)
	unsigned long                                      s_bNoComboPointsForNextHit : 1;                           // 0x25D8(0x0004)
	unsigned long                                      m_bEndMaulOnTweenEnd : 1;                                 // 0x25D8(0x0004)
	unsigned long                                      m_bUseBestMaulLocation : 1;                               // 0x25D8(0x0004)
	unsigned long                                      s_bInEndMaul : 1;                                         // 0x25D8(0x0004)
	unsigned long                                      r_bIsHowling : 1;                                         // 0x25D8(0x0004) (Net)
	float                                              s_fBiteComboPoints;                                       // 0x25DC(0x0004)
	class UTgEffectGroup*                              s_GrabTargetCCImmunity;                                   // 0x25E0(0x0008)
	class UTgAnimBlendByFire*                          m_EnragedFireNode;                                        // 0x25E8(0x0008)
	float                                              m_fScalingProgress;                                       // 0x25F0(0x0004)
	float                                              m_fScalingRate;                                           // 0x25F4(0x0004)
	float                                              m_fMaxMeshScale;                                          // 0x25F8(0x0004)
	float                                              m_fMaxCollisionRadius;                                    // 0x25FC(0x0004)
	float                                              m_fMaxCollisionHeight;                                    // 0x2600(0x0004)
	float                                              m_fThrowdownDuration;                                     // 0x2604(0x0004)
	int                                                c_nLocalJumpCount;                                        // 0x2608(0x0004)
	TArray<class UTgSpecialFx*>                        c_BiteFxs;                                                // 0x260C(0x0010) (Transient, NeedCtorLink)
	float                                              s_fMaulComboPoints;                                       // 0x261C(0x0004)
	class AActor*                                      r_MaulTarget;                                             // 0x2620(0x0008) (Net)
	class AActor*                                      c_MaulTarget;                                             // 0x2628(0x0008)
	TArray<class UTgDeviceFire*>                       s_MaulDamageModes;                                        // 0x2630(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       s_MaulBonusDamageModes;                                   // 0x2640(0x0010) (NeedCtorLink)
	int                                                s_nMaulJumpCount;                                         // 0x2650(0x0004)
	int                                                s_nMaulExplosionCount;                                    // 0x2654(0x0004)
	struct FVector                                     m_BestMaulLocation;                                       // 0x2658(0x000C)
	float                                              s_fHowlComboPoints;                                       // 0x2664(0x0004)
	TArray<class UTgSpecialFx*>                        c_HowlFxs;                                                // 0x2668(0x0010) (Transient, NeedCtorLink)
	class UTgSkeletalMeshComponent*                    c_HowlMeshComponent;                                      // 0x2678(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMaterialInstanceConstant*                   c_HowlMIC;                                                // 0x2680(0x0008)
	class UMaterialInstanceConstant*                   c_MeshMIC;                                                // 0x2688(0x0008)
	float                                              c_fHowlTargetScale;                                       // 0x2690(0x0004)
	float                                              c_fHowlCurrentScale;                                      // 0x2694(0x0004)
	float                                              c_fHowlScalingRate;                                       // 0x2698(0x0004)
	float                                              c_fDefaultScaleUpTime;                                    // 0x269C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Fenrir");
		return ptr;
	}


	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void STATIC_ClientBestMaulLocation(float MaulX, float MaulY, float MaulZ);
	void SetBestMaulLocation(const struct FVector& BestLocation, bool bInTweenEnd);
	void UpdateMaulTarget(class AActor* Target);
	void STATIC_OnEndShrink(TEnumAsByte<EBiteState> OldState);
	void STATIC_StartShrink(TEnumAsByte<EBiteState> OldState);
	void STATIC_OnEndGrow(TEnumAsByte<EBiteState> OldState);
	void STATIC_StartGrow(TEnumAsByte<EBiteState> OldState);
	void AdjustScaleAndCollision(float fProgress);
	void BiteThrowdown(TEnumAsByte<EBiteState> OldState);
	void STATIC_OnBiteFail(TEnumAsByte<EBiteState> OldState);
	void BiteGrab(TEnumAsByte<EBiteState> OldState);
	void UpdateBite(TEnumAsByte<EBiteState> eNextBiteState);
	void ClientBiteSuccessful();
	void STATIC_ClientBiteFailed();
	void STATIC_EndThrowdown();
	void TickBite(float DeltaSeconds);
	void UpdatedHowl();
	void ToggleHowl(bool bEnable, float fTweenTime);
	void TickHowl(float DeltaSeconds);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void STATIC_OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	struct FVector GetPhysTweenTargetLocation();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void MaulTweenEnd(bool bInterrupted);
	void MaulTweenStart(bool bRemoveRoots);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void Tick(float DeltaSeconds);
	void SetTargetingDevice(class ATgDevice* Dev);
	bool CannotJumpNow();
	void PostDemoRewind();
	bool PostPawnSetup();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_EndHowl(bool bInterrupted);
	void BeginHowl(class ATgDevice* Dev);
	bool STATIC_InitializeHowlMeshComponent();
	bool STATIC_InitializeHowlFxs();
	void MaulExplosion();
	void STATIC_StartMaulJump(class ATgDevice* Dev);
	void STATIC_EndMaul(bool bInterrupted, bool bEndInTween);
	void BeginMaul(class ATgDevice* Dev, class AActor* Target);
	struct FName STATIC_GetBiteAttachSocketName();
	float STATIC_GetGiantMeshScale();
	float STATIC_GetDefaultMeshScale();
	void STATIC_CorrectLocationWhileChangingSize(float HeightDelta);
	void STATIC_GetSmallCollisionCylinderSize(float* Radius, float* Height);
	void STATIC_GetGiantCollisionCylinderSize(float* Radius, float* Height);
	bool STATIC_InitializeBiteFxs();
	void STATIC_EndBite(bool bInterrupted);
	void BeginBite(class ATgDevice* Dev);
	void EndCharge(bool bInterrupted);
	void StartCharge(class ATgDevice* Dev);
	void STATIC_OnPawnDied();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_PawnOnAssisted(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	float STATIC_ConsumeComboPoints();
	float STATIC_GetSmoothEnergy();
	void STATIC_SetSpawnEnergy();
};


// Class TgGame.TgPawn_Fenrir_PVE
// 0x0000 (0x26A0 - 0x26A0)
class ATgPawn_Fenrir_PVE : public ATgPawn_Fenrir
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Fenrir_PVE");
		return ptr;
	}


	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void STATIC_OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void UpdateBite(TEnumAsByte<EBiteState> eNextBiteState);
	void TickBite(float DeltaSeconds);
	void STATIC_PostPawnSetupServer();
	void STATIC_EndBite(bool bInterrupted);
};


// Class TgGame.TgPawn_Fenrir_PVE_Tier2
// 0x0000 (0x26A0 - 0x26A0)
class ATgPawn_Fenrir_PVE_Tier2 : public ATgPawn_Fenrir_PVE
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Fenrir_PVE_Tier2");
		return ptr;
	}


	void Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgAchievement_Isis_StayInTheCircle
// 0x0020 (0x00A4 - 0x0084)
class UTgAchievement_Isis_StayInTheCircle : public UTgAchievement
{
public:
	TArray<class ATgPawn*>                             m_TrackedSaved;                                           // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nDeviceId;                                              // 0x0094(0x0004)
	int                                                m_nTargetHealCount;                                       // 0x0098(0x0004)
	int                                                m_nTargetKillCount;                                       // 0x009C(0x0004)
	int                                                m_nEarnedKillCount;                                       // 0x00A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Isis_StayInTheCircle");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Isis_CircleOfProtection
// 0x002C (0x043C - 0x0410)
class ATgDeployable_Isis_CircleOfProtection : public ATgDeployable_Ward
{
public:
	TArray<class AActor*>                              ActorsWithEffects;                                        // 0x0410(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bHasFired : 1;                                            // 0x0420(0x0004) (Transient)
	float                                              CurrentChargePool;                                        // 0x0424(0x0004) (Transient)
	float                                              r_CurrentChargeValue;                                     // 0x0428(0x0004) (Net, Transient)
	int                                                r_MaxChargeValue;                                         // 0x042C(0x0004) (Net, Transient)
	int                                                CurrentChargeStep;                                        // 0x0430(0x0004) (Transient)
	class ATgCollisionProxy_PawnListener*              CollisionProxyListener;                                   // 0x0434(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Isis_CircleOfProtection");
		return ptr;
	}


	void SetVisibleToEnemies(bool Value);
	void InitReplicationInfo();
	void Cleanup();
	void STATIC_DeviceFired();
	void STATIC_FireAmmunitionDeployable();
	void Destroyed();
	void DestroyIt(bool SkipFx);
	void Tick(float DeltaSeconds);
	void UpdateChargeFx();
	void PostDemoRewind();
	void CollisionProxyOnPawnDamaged(class ATgPawn* Other, struct FOnDamagedParams* DamageParams);
	void CollisionProxyOnUnTouch(class AActor* Other);
	void CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
	void ReplicatedEvent(const struct FName& VarName);
	int STATIC_GetDisplayMaxHealth();
	int STATIC_GetDisplayHealth();
	void UpdateHealth();
	struct FVector STATIC_GetHudOverlayLocation();
};


// Class TgGame.TgDevice_Isis_FuneralRites
// 0x0008 (0x052C - 0x0524)
class ATgDevice_Isis_FuneralRites : public ATgDevice_PassiveAura
{
public:
	class ATgCollisionProxy_PawnListener*              CollisionProxyListener;                                   // 0x0524(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Isis_FuneralRites");
		return ptr;
	}


	void Destroyed();
	void ApplyDispelMagic(class UTgDeviceFire* FireMode, int StackCount);
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
	void STATIC_ReapplyHitAuraWithStack(int StackCount);
	void STATIC_CollisionProxyOnPawnDied(class ATgPawn* Other);
	void UpdateCollisionProxyDelegates();
	void ApplyShieldAtDispelMagicLoc(class ATgDevice* DispelMagicDevice, int nStackCount);
};


// Class TgGame.TgDevice_Isis_CircleOfProtection
// 0x0000 (0x0514 - 0x0514)
class ATgDevice_Isis_CircleOfProtection : public ATgDevice_TogglableDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Isis_CircleOfProtection");
		return ptr;
	}


	void OnDeployableDestroyed(class ATgDeployable* deployable);
	bool CanBeCanceled();
	bool STATIC_CanBeGrabbed();
	bool STATIC_CanBeDisarmed();
	bool STATIC_CanBeSilenced();
	bool STATIC_CanBeStunned();
};


// Class TgGame.TgDevice_Isis_SpiritBall
// 0x000C (0x04FC - 0x04F0)
class ATgDevice_Isis_SpiritBall : public ATgDevice
{
public:
	unsigned long                                      bHasPressed : 1;                                          // 0x04F0(0x0004) (Transient)
	unsigned long                                      r_bIsDeployed : 1;                                        // 0x04F0(0x0004) (Net, Transient)
	unsigned long                                      c_bWaitingForDeploy : 1;                                  // 0x04F0(0x0004) (Transient)
	unsigned long                                      c_bForceNoToggle : 1;                                     // 0x04F0(0x0004)
	class ATgProjectile*                               SpawnedProj;                                              // 0x04F4(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Isis_SpiritBall");
		return ptr;
	}


	void STATIC_ClientTurnOffOverrides();
	void InterruptFiring();
	void STATIC_OnProjectileDestroyed(class AProjectile* Proj);
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void STATIC_ServerDoRemoteDetonation(int FireMode);
	bool Use();
	bool CanBeCanceled();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Isis_DeathWard
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_Isis_DeathWard : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Isis_DeathWard");
		return ptr;
	}

};


// Class TgGame.TgPawn_Isis
// 0x002C (0x25E4 - 0x25B8)
class ATgPawn_Isis : public ATgPawn_Character
{
public:
	int                                                r_FuneralRiteStackCount;                                  // 0x25B8(0x0004) (Net, Transient)
	unsigned long                                      r_bIsMagicPenApplied : 1;                                 // 0x25BC(0x0004)
	int                                                DispelMagicStackCount;                                    // 0x25C0(0x0004) (Transient)
	class UTgSpecialFx*                                DispelMagicBuildupFx;                                     // 0x25C4(0x0008) (Transient)
	unsigned char                                      StaffBoneScaleFlash;                                      // 0x25CC(0x0001) (Net, Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x25CD(0x0003) MISSED OFFSET
	class USkelControlSingleBone*                      StaffBoneScale;                                           // 0x25D0(0x0008) (Transient)
	class USkelControlSingleBone*                      m_HaloBoneScale;                                          // 0x25D8(0x0008) (Transient)
	float                                              m_fDesiredHaloScale;                                      // 0x25E0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Isis");
		return ptr;
	}


	void STATIC_RestoreStaff();
	void STATIC_OnRespawn();
	void STATIC_PlayDyingEffects();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_PlayTeleportFx(int TeleportId, const struct FVector& FXLocation);
	void STATIC_DeviceAdjustHeal(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Device, int nPropertyId, struct FImpactInfo* Impact, float* DamageAmt);
	void DeviceOnHit(class ATgDevice* Device, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Device, bool bWasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Device);
	float STATIC_GetSmoothEnergy();
};


// Class TgGame.TgProj_Isis_SpiritBall
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Isis_SpiritBall : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Isis_SpiritBall");
		return ptr;
	}


	void Destroyed();
	void ShutDown();
	void STATIC_RangeReached();
	void PostProjectileInitialize();
};


// Class TgGame.TgProj_IsisFinalWingblade
// 0x0000 (0x0398 - 0x0398)
class ATgProj_IsisFinalWingblade : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_IsisFinalWingblade");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgCollisionProxy_AthenaShieldWall
// 0x0000 (0x02B4 - 0x02B4)
class ATgCollisionProxy_AthenaShieldWall : public ATgCollisionProxy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_AthenaShieldWall");
		return ptr;
	}

};


// Class TgGame.TgDevice_Athena_LeapingLunge
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Athena_LeapingLunge : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Athena_LeapingLunge");
		return ptr;
	}


	void InterruptFiring();
	bool ShouldInterruptInhand();
	bool ShouldTriggerCastReactionItems();
	unsigned char STATIC_IncrementFiringInstance();
};


// Class TgGame.TgDeviceFire_AthenaInHand
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_AthenaInHand : public UTgDeviceFire
{
public:
	float                                              m_fLastEnemyHitTimestamp;                                 // 0x01C0(0x0004)
	float                                              m_fPassiveDamageReductionPct;                             // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AthenaInHand");
		return ptr;
	}


	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceForm_AthenaLeapingLunge
// 0x0008 (0x0240 - 0x0238)
class UTgDeviceForm_AthenaLeapingLunge : public UTgDeviceForm
{
public:
	class UMaterialInstanceConstant*                   c_TargetingModeMIC;                                       // 0x0238(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AthenaLeapingLunge");
		return ptr;
	}


	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgPawn_Athena
// 0x0200 (0x27B8 - 0x25B8)
class ATgPawn_Athena : public ATgPawn_Character
{
public:
	class ATgDevice*                                   r_LeapingLungeDevice;                                     // 0x25B8(0x0008) (Net)
	class UTgSpecialFx*                                m_LeapingLungeFX;                                         // 0x25C0(0x0008)
	class ATgDevice*                                   m_PassiveDevice;                                          // 0x25C8(0x0008)
	class ATgDevice*                                   r_UltShooterDevice;                                       // 0x25D0(0x0008) (Net)
	TArray<class UTgDeviceFire*>                       m_UltExplosionFireModes;                                  // 0x25D8(0x0010) (AlwaysInit, NeedCtorLink)
	class UTgDeviceFire*                               m_AllOutFriendlyReflectDamageFireMode;                    // 0x25E8(0x0008)
	class ATgDevice*                                   r_DefaultBasicAttackDevice;                               // 0x25F0(0x0008) (Net)
	float                                              m_fLeapingLungeChargeTime;                                // 0x25F8(0x0004) (Const)
	float                                              m_fRemainingLeapingLungeChargeTime;                       // 0x25FC(0x0004)
	unsigned long                                      r_bIsLeapingLungeFullyCharged : 1;                        // 0x2600(0x0004) (Net)
	unsigned long                                      s_LastLeapingLungeHit : 1;                                // 0x2600(0x0004)
	unsigned long                                      s_LastLeapingLungeHitAnyTarget : 1;                       // 0x2600(0x0004)
	unsigned long                                      r_bReachingStrikeEffectsActive : 1;                       // 0x2600(0x0004) (Net)
	unsigned long                                      c_bIsCurentlyLeaping : 1;                                 // 0x2600(0x0004)
	unsigned long                                      r_bIsZoomedForUlt : 1;                                    // 0x2600(0x0004) (Net)
	unsigned long                                      r_bHasBasicAttackAbsorb : 1;                              // 0x2600(0x0004) (Net)
	unsigned long                                      r_bIsCurrentlyUltTweening : 1;                            // 0x2600(0x0004) (Net)
	class ATgCollisionProxy_PawnListener*              m_AllOutCollisionProxyListener;                           // 0x2604(0x0008)
	TArray<class AActor*>                              m_ActorsWithEffects;                                      // 0x260C(0x0010) (NeedCtorLink)
	TEnumAsByte<ELeapingLungeState>                    r_eLeapingLungeState;                                     // 0x261C(0x0001) (Net)
	TEnumAsByte<ELeapingLungeState>                    c_eLocalLeapingLungeState;                                // 0x261D(0x0001)
	unsigned char                                      r_AllOutSpearReturnNotify;                                // 0x261E(0x0001) (Net)
	unsigned char                                      r_UltBeginEffects;                                        // 0x261F(0x0001) (Net)
	unsigned char                                      r_UltEndEffects;                                          // 0x2620(0x0001) (Net)
	unsigned char                                      c_bFxHiddenLastTick;                                      // 0x2621(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x2622(0x0002) MISSED OFFSET
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                                   // 0x2624(0x0008)
	TArray<struct FChargeHitInfo>                      m_ChargeHitInfos;                                         // 0x262C(0x0010) (NeedCtorLink)
	class UTgAnimNodeBlendList*                        m_PassiveBlendNode;                                       // 0x263C(0x0008)
	class ATgPawn*                                     r_UltTargetPawn;                                          // 0x2644(0x0008) (Net)
	struct FVector                                     m_vLastUltTargetPawnLocation;                             // 0x264C(0x000C)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x2658(0x0008) (ExportObject, Component, EditInline)
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                                       // 0x2660(0x0140) (NeedCtorLink)
	class UTgSpecialFx*                                c_UltSphereFX;                                            // 0x27A0(0x0008)
	int                                                c_UltPostureId;                                           // 0x27A8(0x0004)
	struct FVector                                     m_vLeapingLungeInitialLocation;                           // 0x27AC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Athena");
		return ptr;
	}


	void DetachFromTarget(class AActor* TargetActor);
	void AttachToTarget(class AActor* TargetActor);
	void STATIC_EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	struct FVector STATIC_GetFireLocationOffset(class ATgDevice* Dev);
	void PostDemoRewind();
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void ToggleUltSphereFx();
	void STATIC_StopBasicAttackAbsorbEffects();
	void STATIC_PlayBasicAttackAbsorbEffects();
	void PropertySet(int nPropertyId, float fPreviousValue, float fNewValue);
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	struct FVector GetPhysTweenTargetLocation();
	void ToggleUltimateCameraModule(bool bOn);
	bool AnimNotifySound(class USoundCue* Cue, class UAnimNodeSequence* OwningNode, class UTgAnimNotify_Sound* OwningNotify, float VolumeMultipler, float PitchMultipler);
	bool STATIC_ShouldManageParticleFX(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void EndUltEffects();
	void BeginUltEffects();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void OnRedirectedDamageOriginUpdated(const struct FVector& Origin);
	void StopReachingStrikeEffects();
	void PlayReachingStrikeEffects();
	void ChargeCollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void CollisionProxyOnUnTouch(class AActor* Other);
	void CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void MitigateDamageFromAllOut(class ATgPawn* Other, class ATgPawn* attacker, class UTgEffectGroup* Effect, int nPropertyId, float* Damage);
	void InitializeCollisionProxyListener();
	void PlayAllOutSpearReturn();
	void UpdateLeapingLungeState();
	void StopLeapingLungeFullyChargedEffects();
	void PlayLeapingLungeFullyChargedEffects();
	void SetTargetingDevice(class ATgDevice* Dev);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void SpecialFXAttached(class UTgSpecialFx* NewFX, int FxId);
	void SetHiddenInDeath(bool bHiddenDueToDeath);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_GetTeleportDestination(struct FVector* Destination);
	bool IsShooterTargetValid(class ATgPawn* PawnTarget, class ATgDevice* Dev);
	bool STATIC_GetPassiveBool(int* bResult);
	void STATIC_SetMeshVisibility(bool bVisible);
	bool STATIC_ShouldPawnMeshBeHiddenThisTick();
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	bool STATIC_DeviceOverrideManaUseVitals(class ATgDevice* Dev, class ATgPlayerController* PC);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnFire(class ATgDevice* Dev);
};


// Class TgGame.TgAchievement_Chronos_HandsOfTime
// 0x0020 (0x00A4 - 0x0084)
class UTgAchievement_Chronos_HandsOfTime : public UTgAchievement
{
public:
	TArray<int>                                        m_nAllPassives;                                           // 0x0084(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nUsedPassives;                                          // 0x0094(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Chronos_HandsOfTime");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Chronos_ReRewind
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Chronos_ReRewind : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nStartAmount;                                           // 0x0088(0x0004)
	int                                                m_nFinishAmount;                                          // 0x008C(0x0004)
	unsigned long                                      m_nValidStart : 1;                                        // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Chronos_ReRewind");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByChronosHasten
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByChronosHasten : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByChronosHasten");
		return ptr;
	}


	void STATIC_OnOtherDeviceFire();
	void ToggleHasten(bool bEnable, bool bSkipTransition);
};


// Class TgGame.TgDevice_Chronos_Fast
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Chronos_Fast : public ATgDevice_TogglableHitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chronos_Fast");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanBeCanceled();
};


// Class TgGame.TgDeviceFire_Chronos_Fast
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Chronos_Fast : public UTgDeviceFire
{
public:
	int                                                m_nShotsTilMaxCost;                                       // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Chronos_Fast");
		return ptr;
	}


	float STATIC_GetShotPowerCost(int nPacingType, bool bBaseOnly);
};


// Class TgGame.TgInventoryObject_Listen_ChronosPassive
// 0x000C (0x0130 - 0x0124)
class UTgInventoryObject_Listen_ChronosPassive : public UTgInventoryObject_Listen_Timed_Stack
{
public:
	unsigned long                                      r_bHasMatchStarted : 1;                                   // 0x0124(0x0004)
	int                                                r_nPassiveStacks;                                         // 0x0128(0x0004)
	float                                              r_nMatchStartTime;                                        // 0x012C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ChronosPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Chronos
// 0x00EC (0x26A4 - 0x25B8)
class ATgPawn_Chronos : public ATgPawn_Character
{
public:
	unsigned long                                      r_bPhaseShiftEnabled : 1;                                 // 0x25B8(0x0004) (Net)
	unsigned long                                      r_bHastenActive : 1;                                      // 0x25B8(0x0004) (Net)
	unsigned long                                      r_bIsRewinding : 1;                                       // 0x25B8(0x0004) (Net)
	unsigned long                                      c_bReceivedReplicatedRewindInfo : 1;                      // 0x25B8(0x0004)
	float                                              SmoothedEnergy;                                           // 0x25BC(0x0004)
	float                                              SmoothedEnergyTolerance;                                  // 0x25C0(0x0004)
	float                                              SmoothedEnergyCorrectionNeeded;                           // 0x25C4(0x0004)
	float                                              LastServerEnergy;                                         // 0x25C8(0x0004)
	int                                                LastPhaseShiftQuadrant;                                   // 0x25CC(0x0004)
	int                                                s_nQuadrantToActivate[0x4];                               // 0x25D0(0x0004)
	int                                                r_nActiveQuadrant;                                        // 0x25E0(0x0004) (Net)
	int                                                c_nChronosHastenState;                                    // 0x25E4(0x0004)
	TArray<class UTgAnimBlendByChronosHasten*>         c_HastenAnimNodes;                                        // 0x25E8(0x0010) (NeedCtorLink)
	float                                              r_fTargetHastenMultipler;                                 // 0x25F8(0x0004) (Net)
	float                                              r_fHastenTweenRate;                                       // 0x25FC(0x0004) (Net)
	float                                              m_fHastenMultipler;                                       // 0x2600(0x0004)
	float                                              c_fLastHUDHastenMultipler;                                // 0x2604(0x0004)
	TArray<class UTgSpecialFx*>                        c_HastenFXs;                                              // 0x2608(0x0010) (Transient, NeedCtorLink)
	TArray<struct FName>                               c_HastenSkelControlNames;                                 // 0x2618(0x0010) (NeedCtorLink)
	int                                                m_nHastenActiveDeviceMode;                                // 0x2628(0x0004)
	int                                                r_nHUDHastenTicker;                                       // 0x262C(0x0004) (Net)
	int                                                r_nRewindTicker;                                          // 0x2630(0x0004) (Net)
	float                                              r_fRewindTargetTimeStamp;                                 // 0x2634(0x0004) (Net)
	float                                              r_fRewindRate;                                            // 0x2638(0x0004) (Net)
	float                                              r_fRewindLocationZ;                                       // 0x263C(0x0004) (Net)
	float                                              m_fRewindTargetTimeStamp;                                 // 0x2640(0x0004)
	float                                              m_fRewindRate;                                            // 0x2644(0x0004)
	float                                              m_fRewindProgress;                                        // 0x2648(0x0004)
	float                                              m_fRewindDuration;                                        // 0x264C(0x0004)
	TArray<struct FRewindInfo>                         s_RewindArray;                                            // 0x2650(0x0010) (NeedCtorLink)
	float                                              s_fRewindTime;                                            // 0x2660(0x0004)
	float                                              s_fRewindSavePeriod;                                      // 0x2664(0x0004)
	int                                                s_nMaxRewindHistory;                                      // 0x2668(0x0004)
	class USkeletalMeshComponent*                      c_RewindMeshComponent;                                    // 0x266C(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class UTgSpecialFx*>                        c_RewindFXs;                                              // 0x2674(0x0010) (NeedCtorLink)
	TArray<struct FName>                               c_AliveSkelControlNames;                                  // 0x2684(0x0010) (NeedCtorLink)
	TArray<struct FName>                               c_DeadSkelControlNames;                                   // 0x2694(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Chronos");
		return ptr;
	}


	void ToggleSkelControls(bool bAlive);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void STATIC_DisablePassive();
	void TickPhaseShift(float DeltaSeconds);
	void TogglePhaseShift(bool bEnable);
	void TickHasten(float DeltaSeconds);
	void StartHastenTween(float fTargetMultipler, float fTweenTime);
	void TickRewind(float DeltaSeconds);
	void UpdateRewindHistory();
	void Tick(float DeltaSeconds);
	bool STATIC_HastenAreOtherDevicesFiring();
	void UpdateHastenState(bool bEnable);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void DeactivateRewindMesh(bool bWasInterrupted);
	void ActivateRewindMesh(float Rate);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnRespawn();
	void SetRewindProgress(float fProgress);
	void SetRewindRate(float fRewindRate);
	void SetRewindTargetTimeStamp(float fRewindTargetTimeStamp);
	void ReplicateRewindInfo();
	void ToggleRewind();
	void ReceivedActiveQuadrant();
	void STATIC_ClientRestartRewindHistory();
	void STATIC_RestartRewindHistory();
	void RestartRewindFromNative();
	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	void SetEnergySyncPoint(float fEnergy);
	void PropertySet(int nPropertyId, float fPreviousValue, float fNewValue);
	void ReceivedHastenTicker();
	void ReceivedPropValues();
	void PostDemoRewind();
	void ReplicatedEvent(const struct FName& VarName);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	bool PostPawnSetup();
	bool STATIC_ShouldPawnMeshBeHiddenThisTick();
	void AttachAndActivateRewindFXsToMesh(class UMeshComponent* RewindMesh);
	void STATIC_EndRewind();
	void BeginRewind(class ATgDevice* Dev, float fDelta);
	bool STATIC_InitializeRewindMeshComponent();
	void STATIC_ChangePassive(class ATgDevice* Dev);
	void STATIC_EndHasten(bool bWasInterrupted);
	void BeginHasten(class ATgDevice* Dev);
	bool STATIC_InitializeHastenFXs();
	void STATIC_OnAttackDamagePropertyChange();
	void STATIC_RegainEnergyPool(float fDelta);
	void STATIC_CalcSmoothEnergy(float fDelta);
	void STATIC_SetSpawnEnergy();
	float STATIC_GetSmoothEnergy();
	float STATIC_GetUIGroundSpeed();
	void STATIC_DeviceAdjustDamage(class ATgDevice* Device, int nPropertyId, struct FImpactInfo* Impact, float* DamageAmt);
	void STATIC_PawnOnSwapSetup();
	void STATIC_PawnOnSpecialReset();
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_PawnOnDodged(struct FOnDodgedParams* Params);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgAchievement_ChangE_JadeGo
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_ChangE_JadeGo : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                               // 0x0084(0x0004)
	int                                                m_GoalAmount;                                             // 0x0088(0x0004)
	int                                                m_nNumHits;                                               // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ChangE_JadeGo");
		return ptr;
	}

};


// Class TgGame.TgAchievement_ChangE_MyHipsDontLie
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_ChangE_MyHipsDontLie : public UTgAchievement
{
public:
	int                                                m_nTargetGoal;                                            // 0x0084(0x0004)
	int                                                m_nDeviceId;                                              // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ChangE_MyHipsDontLie");
		return ptr;
	}

};


// Class TgGame.TgDeployable_ChangE_Sweep
// 0x0000 (0x047C - 0x047C)
class ATgDeployable_ChangE_Sweep : public ATgDeploy_MovingEffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_ChangE_Sweep");
		return ptr;
	}

};


// Class TgGame.TgPawn_ChangE
// 0x0014 (0x25CC - 0x25B8)
class ATgPawn_ChangE : public ATgPawn_Character
{
public:
	unsigned long                                      r_bUltIsActive : 1;                                       // 0x25B8(0x0004) (Net)
	unsigned long                                      r_bDodgeIsActive : 1;                                     // 0x25B8(0x0004) (Net)
	int                                                s_nNumAvoidedHits;                                        // 0x25BC(0x0004)
	int                                                s_nNumUltGodHits;                                         // 0x25C0(0x0004)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x25C4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ChangE");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void SetMICMode();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_OnRespawn();
	void STATIC_CourierPhaseChanged(TEnumAsByte<ECourierPetPhase> Phase);
	void STATIC_DespawnPet();
	void STATIC_SpawnPet();
	void STATIC_HealAlliesAfterDodge();
	void STATIC_PostPawnSetupServer();
	void STATIC_PlayTeleportFx(int TeleportId, const struct FVector& FXLocation);
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_OnPawnDied();
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	class ATgPawn_Courier* STATIC_GetAvailableCourier();
};


// Class TgGame.TgPawn_ChangE_Rabbit
// 0x0000 (0x24BC - 0x24BC)
class ATgPawn_ChangE_Rabbit : public ATgPawn_Courier
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ChangE_Rabbit");
		return ptr;
	}


	void STATIC_PlaySpawnFx();
	void STATIC_PrepareIntro();
	bool STATIC_OwnerPlayedSound(class USoundCue* Cue);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	bool IsNonCombat();
};


// Class TgGame.TgAchievement_Tyr_ILikeToJuggle
// 0x0024 (0x00A8 - 0x0084)
class UTgAchievement_Tyr_ILikeToJuggle : public UTgAchievement
{
public:
	TArray<class ATgPawn*>                             m_TrackedSaved;                                           // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nDeviceId;                                              // 0x0094(0x0004)
	int                                                m_nDevice2Id;                                             // 0x0098(0x0004)
	int                                                m_nFearlessId;                                            // 0x009C(0x0004)
	int                                                m_nTargetCount;                                           // 0x00A0(0x0004)
	int                                                m_nSuccessCount;                                          // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Tyr_ILikeToJuggle");
		return ptr;
	}

};


// Class TgGame.TgDevice_Tyr_AggressiveStance1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Tyr_AggressiveStance1 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tyr_AggressiveStance1");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Tyr_ChangeStance
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Tyr_ChangeStance : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tyr_ChangeStance");
		return ptr;
	}


	bool STATIC_ShouldApplyModeEquipEffects();
	bool STATIC_HasBeenTrained();
};


// Class TgGame.TgPawn_Tyr
// 0x00EC (0x26A4 - 0x25B8)
class ATgPawn_Tyr : public ATgPawn_Character
{
public:
	class ATgDevice*                                   r_AggressiveNum1Device;                                   // 0x25B8(0x0008) (Net)
	TArray<class ATgPawn*>                             m_A01CannotBeGrabbedList;                                 // 0x25C0(0x0010) (NeedCtorLink)
	class ATgDevice*                                   r_AggressiveNum1Stage2Device;                             // 0x25D0(0x0008) (Net)
	class ATgDevice*                                   r_AggressiveNum1Stage3Device;                             // 0x25D8(0x0008) (Net)
	class ATgDevice*                                   m_AggressiveBasicAttackDevice;                            // 0x25E0(0x0008)
	class ATgDevice*                                   r_DefensiveNum1Device;                                    // 0x25E8(0x0008) (Net)
	class ATgDevice*                                   m_DefensiveNum1Stage1Device;                              // 0x25F0(0x0008)
	class ATgDevice*                                   m_DefensiveNum1Stage2Device;                              // 0x25F8(0x0008)
	class ATgDevice*                                   m_DefensiveNum1Stage3Device;                              // 0x2600(0x0008)
	class ATgDevice*                                   m_AggressiveNum2Device;                                   // 0x2608(0x0008)
	class ATgDevice*                                   m_DefensiveNum2Device;                                    // 0x2610(0x0008)
	class ATgDevice*                                   m_AggressiveNum4Device;                                   // 0x2618(0x0008)
	class ATgDevice*                                   m_DefensiveNum4Device;                                    // 0x2620(0x0008)
	class ATgDevice*                                   m_AggressiveNum3Device;                                   // 0x2628(0x0008)
	class ATgDevice*                                   m_DefensiveNum3Device;                                    // 0x2630(0x0008)
	class ATgDevice*                                   m_DefensiveBasicAttackDevice;                             // 0x2638(0x0008)
	float                                              m_fRemainingChargeTime;                                   // 0x2640(0x0004)
	TArray<class ATgPawn*>                             m_ChargeVictimList;                                       // 0x2644(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_ChargeVictimIgnoreList;                                 // 0x2654(0x0010) (NeedCtorLink)
	unsigned long                                      r_bForceZeroChargeVelocity : 1;                           // 0x2664(0x0004) (Net)
	unsigned long                                      r_bIsPassiveBuffEnabled : 1;                              // 0x2664(0x0004) (Net)
	unsigned long                                      m_bCooldownReentrantLock : 1;                             // 0x2664(0x0004)
	int                                                m_DefensiveMeshAssemblyId;                                // 0x2668(0x0004)
	struct FPointer                                    m_DefensiveMeshAssembly;                                  // 0x266C(0x0008) (Native)
	TArray<class UAnimSet*>                            m_DefensiveAnimsets;                                      // 0x2674(0x0010) (NeedCtorLink)
	TEnumAsByte<ETyrStance>                            r_CurrentStance;                                          // 0x2684(0x0001) (Net)
	TEnumAsByte<ETyrStance>                            c_LocalCurrentStance;                                     // 0x2685(0x0001)
	unsigned char                                      r_DefensiveNum1HitNotify;                                 // 0x2686(0x0001) (Net)
	unsigned char                                      r_PlayAggressiveBuff;                                     // 0x2687(0x0001) (Net)
	unsigned char                                      r_PlayDefensiveBuff;                                      // 0x2688(0x0001) (Net)
	unsigned char                                      r_PlayAggressiveNum2Audio;                                // 0x2689(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x268A(0x0002) MISSED OFFSET
	float                                              m_fRemainingTimeTillPassiveEnabled;                       // 0x268C(0x0004)
	float                                              r_fTotalPassiveTime;                                      // 0x2690(0x0004) (Net)
	TArray<class AActor*>                              m_DefensiveNum2TargetList;                                // 0x2694(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tyr");
		return ptr;
	}


	void STATIC_OnResetCooldown(class UTgSeqAct_ResetCooldown* inAction);
	bool IsInClassSpecificMovement();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void PlayAggressiveNum2Audio();
	void PostDemoRewind();
	void VerifyStanceEffects();
	bool STATIC_IgnoreFaceRotationWithInterp();
	void PlayDefensiveNum1Hit();
	void StopPassiveBuffEffects();
	void PlayPassiveBuffEffects(TEnumAsByte<ETyrStance> StanceType);
	void PlaySwapStanceEffects();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_CheckProcPassive();
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveBool(int* bResult);
	void STATIC_PawnOnSpecialReset();
	void STATIC_PawnOnModifyEffectLifeTime(class UTgEffectGroup* eg, float* fLifeTime);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	float STATIC_GetSmoothEnergy();
	void STATIC_EnablePassiveBuff(bool bEnabled);
	void STATIC_SwapToLiveMesh();
	void STATIC_SwapStance(TEnumAsByte<ETyrStance> NewStance);
	void STATIC_DeviceOnStartCooldown(class ATgDevice* Dev, float fCooldown);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnFire(class ATgDevice* Dev);
};


// Class TgGame.TgAnimBlendByFire_ZhongKui
// 0x0039 (0x0225 - 0x01EC)
class UTgAnimBlendByFire_ZhongKui : public UTgAnimBlendByFire
{
public:
	unsigned long                                      m_bForceScrollChargedAnimToAlwaysPlay : 1;                // 0x01EC(0x0004) (Edit)
	unsigned long                                      m_bCanManipulateControlStrength : 1;                      // 0x01EC(0x0004) (Edit)
	unsigned long                                      m_bActivateControlOnScrollCharged : 1;                    // 0x01EC(0x0004) (Edit)
	unsigned long                                      m_bCanManipulateControlBoneScale : 1;                     // 0x01EC(0x0004) (Edit)
	unsigned long                                      m_bHideMeshWhenDischarged : 1;                            // 0x01EC(0x0004) (Edit)
	unsigned long                                      m_bInHandIsFiring : 1;                                    // 0x01EC(0x0004) (Transient)
	TArray<struct FName>                               m_ScrollScaleControlNames;                                // 0x01F0(0x0010) (Edit, NeedCtorLink)
	TArray<class USkelControlBase*>                    m_ScrollScaleControls;                                    // 0x0200(0x0010) (NeedCtorLink)
	float                                              m_bScrollChargeTime;                                      // 0x0210(0x0004) (Edit)
	float                                              m_bScrollDischargeTime;                                   // 0x0214(0x0004) (Edit)
	float                                              m_bDesiredChargedBoneScale;                               // 0x0218(0x0004) (Edit)
	float                                              m_bDesiredDischargedBoneScale;                            // 0x021C(0x0004) (Edit)
	int                                                m_nScrollDischargeDeviceEqpSlot;                          // 0x0220(0x0004) (Edit, Const)
	TEnumAsByte<EDemonScrollState>                     m_bScrollState;                                           // 0x0224(0x0001) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFire_ZhongKui");
		return ptr;
	}


	void STATIC_SetScrollCharged(bool bCharged);
	void STATIC_OnDeviceFormStopFire(class UTgDeviceForm* DeviceForm);
	void STATIC_OnDeviceFormStartFire(class UTgDeviceForm* DeviceForm, float FireDuration);
	void STATIC_OnDeviceFormBuildup(class UTgDeviceForm* DeviceForm, float BuildupTime);
};


// Class TgGame.TgAnimBlendByZhongKuiExorcism
// 0x0014 (0x017C - 0x0168)
class UTgAnimBlendByZhongKuiExorcism : public UTgAnimNodeBlendList
{
public:
	struct FName                                       ScrollScaleSkelControlName;                               // 0x0168(0x0008) (Edit)
	class USkelControlBase*                            SkelControl_ScrollScale;                                  // 0x0170(0x0008)
	int                                                m_nDesiredActiveChild;                                    // 0x0178(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByZhongKuiExorcism");
		return ptr;
	}


	void SetExorcismCharged(bool bCharged);
};


// Class TgGame.TgAnimNodeSequence_ZhongKui_Exorcism
// 0x0000 (0x01B4 - 0x01B4)
class UTgAnimNodeSequence_ZhongKui_Exorcism : public UTgAnimNodeSequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_ZhongKui_Exorcism");
		return ptr;
	}

};


// Class TgGame.TgDevice_ZhongKui_PSV
// 0x0000 (0x0528 - 0x0528)
class ATgDevice_ZhongKui_PSV : public ATgDevice_AchieveOnNearbyDeath
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ZhongKui_PSV");
		return ptr;
	}


	int STATIC_GetStacksFor(class ATgPawn* Other);
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
};


// Class TgGame.TgDevice_ZhongKui_Exorcism
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_ZhongKui_Exorcism : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ZhongKui_Exorcism");
		return ptr;
	}


	void STATIC_CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_ZhongKui_RecallDemons
// 0x0058 (0x0554 - 0x04FC)
class ATgDevice_ZhongKui_RecallDemons : public ATgDevice_HitPulse
{
public:
	int                                                m_nMaxTargets;                                            // 0x04FC(0x0004)
	int                                                m_nShotLimit;                                             // 0x0500(0x0004) (Const)
	float                                              m_fShotDelay;                                             // 0x0504(0x0004) (Const)
	TArray<class AActor*>                              m_CurrentTargets;                                         // 0x0508(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_EnemyProjectileFireModes;                               // 0x0518(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_FriendlyProjectileFireModes;                            // 0x0528(0x0010) (NeedCtorLink)
	int                                                m_nEnemyProjectileId;                                     // 0x0538(0x0004)
	int                                                m_nFriendlyProjectileId;                                  // 0x053C(0x0004)
	unsigned long                                      m_bWaveIsCharged : 1;                                     // 0x0540(0x0004)
	struct FPointer                                    m_pProjSetupEnemy;                                        // 0x0544(0x0008) (Native)
	struct FPointer                                    m_pProjSetupFriendly;                                     // 0x054C(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ZhongKui_RecallDemons");
		return ptr;
	}


	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	class AProjectile* STATIC_DemonProjectileFire(int ProjectileIndex, struct FAimData* Aim);
	void STATIC_CustomFire();
	void STATIC_DeferredFire();
	bool ShouldTriggerCastReactionItems();
	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CancelledByJumping();
	bool CanJumpWhileFiring();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void UpdateTargetList(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_ZhongKui_RecallDemons
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_ZhongKui_RecallDemons : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ZhongKui_RecallDemons");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_ZhongKui_FierceGlare
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_ZhongKui_FierceGlare : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_ZhongKui_FierceGlare");
		return ptr;
	}


	void AttachMeshes(class AActor* pOwner);
};


// Class TgGame.TgMarkComponent_ZhongKui_BookOfDemons
// 0x0010 (0x00CC - 0x00BC)
class UTgMarkComponent_ZhongKui_BookOfDemons : public UTgMarkComponent
{
public:
	class ATgDevice*                                   s_Device;                                                 // 0x00BC(0x0008)
	class UTgDeviceFire*                               s_DeviceMode;                                             // 0x00C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_ZhongKui_BookOfDemons");
		return ptr;
	}


	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgMorphNode_ZhongKui_DemonBag
// 0x0020 (0x00A8 - 0x0088)
class UTgMorphNode_ZhongKui_DemonBag : public UMorphNodePose
{
public:
	struct FInterpCurveFloat                           MorphWeightCurve;                                         // 0x0088(0x0014) (Edit, NeedCtorLink)
	unsigned long                                      bPlaying : 1;                                             // 0x009C(0x0004) (Edit)
	unsigned long                                      bLooping : 1;                                             // 0x009C(0x0004) (Edit)
	unsigned long                                      bDoNotResetIfPlaying : 1;                                 // 0x009C(0x0004) (Edit)
	float                                              CurrentTime;                                              // 0x00A0(0x0004) (Edit)
	float                                              Rate;                                                     // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMorphNode_ZhongKui_DemonBag");
		return ptr;
	}


	void STATIC_StopMorph();
	void STATIC_ReplayMorph();
	void STATIC_PlayMorph(bool bLoop, float InRate, float StartTime);
};


// Class TgGame.TgPawn_ZhongKui
// 0x0220 (0x27D8 - 0x25B8)
class ATgPawn_ZhongKui : public ATgPawn_Character
{
public:
	TArray<int>                                        c_BagFxIds;                                               // 0x25B8(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_BagFxs;                                                 // 0x25C8(0x0010) (Transient, NeedCtorLink)
	float                                              c_fBagFxInterval;                                         // 0x25D8(0x0004)
	unsigned long                                      c_bEnableBagFxLevelZero : 1;                              // 0x25DC(0x0004)
	unsigned long                                      c_bCanPlayBagConsumeFx : 1;                               // 0x25DC(0x0004)
	unsigned long                                      r_bSkipExorcismFX : 1;                                    // 0x25DC(0x0004) (Net)
	unsigned long                                      r_bIsExorcismCharged : 1;                                 // 0x25DC(0x0004) (Net)
	unsigned long                                      c_bEnableBagMorph : 1;                                    // 0x25DC(0x0004)
	float                                              c_fLastEnergyChange;                                      // 0x25E0(0x0004)
	int                                                c_nCurrentBagFxLevel;                                     // 0x25E4(0x0004)
	int                                                r_nFierceGlareQueueIndex;                                 // 0x25E8(0x0004) (Net)
	int                                                c_nFierceGlareQueueIndex;                                 // 0x25EC(0x0004)
	struct FVector                                     r_FierceGlareLocations[0x10];                             // 0x25F0(0x000C) (Net)
	unsigned char                                      r_FierceGlareGoToBag[0x10];                               // 0x26B0(0x0001) (Net)
	TEnumAsByte<EZhongKuiAbsorbState>                  c_eLocalAbsorbState;                                      // 0x26C0(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x26C1(0x0003) MISSED OFFSET
	float                                              r_FierceGlareReturnTime[0x10];                            // 0x26C4(0x0004) (Net)
	struct FVector2D                                   m_FierceGlareReturnTimeRange;                             // 0x2704(0x0008)
	TArray<struct FFierceGlareInfo>                    c_FierceGlareInfos;                                       // 0x270C(0x0010) (Transient, Component, NeedCtorLink)
	TArray<class UTgDeviceFire*>                       s_FierceGlareHealModes;                                   // 0x271C(0x0010) (NeedCtorLink)
	TArray<struct FFierceGlareHealInfo>                s_FierceGlareHeals;                                       // 0x272C(0x0010) (NeedCtorLink)
	float                                              s_FierceGlareHealDelayBase;                               // 0x273C(0x0004)
	float                                              c_fBagConsumeFxDelay;                                     // 0x2740(0x0004)
	float                                              c_nAbsorbMICPercentage;                                   // 0x2744(0x0004)
	int                                                r_nExorcismTicker;                                        // 0x2748(0x0004) (Net)
	class USkeletalMeshComponent*                      c_Scroll;                                                 // 0x274C(0x0008) (ExportObject, Component, EditInline)
	class UTgAnimNodeSlot*                             m_ScrollFullBodyNode;                                     // 0x2754(0x0008)
	float                                              c_fBagTime;                                               // 0x275C(0x0004)
	struct FInterpCurveFloat                           m_BagMorphCurve;                                          // 0x2760(0x0014) (NeedCtorLink)
	class UMorphNodePose*                              c_BagMorphNode;                                           // 0x2774(0x0008)
	float                                              r_ReplicatedBagMorphCurve[0xA];                           // 0x277C(0x0004) (Net)
	class UTgSkelCon_ZhongKui_BagGrowth*               c_SkelConBag;                                             // 0x27A4(0x0008)
	float                                              s_fStartEnergy;                                           // 0x27AC(0x0004)
	float                                              s_fEnergyConsumePerShot;                                  // 0x27B0(0x0004)
	int                                                s_nDemonConsumeCount;                                     // 0x27B4(0x0004)
	class ATgDevice*                                   s_ScrollInHand;                                           // 0x27B8(0x0008)
	struct FVector                                     m_ScrollInHandOffset;                                     // 0x27C0(0x000C)
	struct FVector                                     m_ScrollEndTraceOffset;                                   // 0x27CC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ZhongKui");
		return ptr;
	}


	void ToggleDemonBagMorph(bool bEnable);
	void STATIC_DisableAbsorbGhostMIC();
	void UpdateAbsorbGhostMIC(float DeltaSeconds);
	void STATIC_EnableAbsorbGhostMIC();
	void UpdateBagFxs();
	void HandleFierceGlareMesh(class USkeletalMeshComponent* FierceMesh);
	void FireScrollInHand();
	void STATIC_ResetBagConsumeFxTimer();
	void PropertySet(int nPropertyId, float fPreviousValue, float fNewValue);
	void STATIC_OnRespawn();
	void STATIC_StopFullBodyAnimation(float BlendOutTime);
	struct FVector STATIC_GetFireLocationOffset(class ATgDevice* Dev);
	void SetExorcismCharged(bool bCharged, bool bSkipFx);
	void STATIC_ForceExorcismSync(bool bSkipFx);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	struct FRotator STATIC_GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	void Tick(float DeltaSeconds);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ReceivedPropValues();
	void PreDemoRewind();
	void ReplicatedEvent(const struct FName& VarName);
	bool PostPawnSetup();
	void STATIC_CleanUpDemons();
	bool STATIC_ConsumeDemon();
	void AddDemons(int nDemonCount);
	void STATIC_SetSpawnEnergy();
	bool STATIC_RemoveFierceGlareInfo(int nIndex);
	void UpdateFierceGlareLocations();
	void STATIC_FlashFierceGlare(const struct FVector& Loc, float ReturnTime, bool bGoToBag);
	void MakeBagMorphCurveFromReplicatedData();
	bool STATIC_InitializeBagOfDemonsFXs();
	int STATIC_GetPassiveStackCount();
	struct FVector STATIC_CalcScrollProjEndTrace(struct FAimData* BasicAim);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void AdjustMeshTranslation();
	bool STATIC_PlayFullBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, bool bBlendOutIfVelocityIsGreaterThanZero, bool bHideInHandDevice);
	void STATIC_SetMeshVisibility(bool bVisible);
	void STATIC_InitScrollMesh();
	void STATIC_SwapToLiveMesh();
};


// Class TgGame.TgSkelCon_ZhongKui_BagGrowth
// 0x0054 (0x0154 - 0x0100)
class UTgSkelCon_ZhongKui_BagGrowth : public USkelControlSingleBone
{
public:
	struct FBagGrowthDef                               m_BagGrowth;                                              // 0x0100(0x0030) (Edit)
	int                                                m_NumDemonsInBag;                                         // 0x0130(0x0004) (Transient)
	float                                              m_fUnclampedScale;                                        // 0x0134(0x0004) (Transient)
	float                                              m_fScaleVelocity;                                         // 0x0138(0x0004) (Transient)
	float                                              m_fDesiredScale;                                          // 0x013C(0x0004) (Transient)
	float                                              m_fNextGrowthImpulse;                                     // 0x0140(0x0004) (Transient)
	float                                              m_fNextShrinkImpulse;                                     // 0x0144(0x0004) (Transient)
	unsigned long                                      m_bResetImpulseTimerActive : 1;                           // 0x0148(0x0004) (Transient)
	unsigned long                                      m_bInitialized : 1;                                       // 0x0148(0x0004) (Transient)
	float                                              m_fTimeUntilResetImpulse;                                 // 0x014C(0x0004) (Transient)
	float                                              m_fResetImpulseTime;                                      // 0x0150(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_ZhongKui_BagGrowth");
		return ptr;
	}


	void STATIC_ShrinkBag(int NumDemons);
	void STATIC_GrowBag(int NumDemons);
	void STATIC_SetBagGrowthDef(const struct FBagGrowthDef& BagGrowth);
};


// Class TgGame.TgAchievement_Thana_Silence
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Thana_Silence : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Thana_Silence");
		return ptr;
	}

};


// Class TgGame.TgDevice_Thanatos_HoveringDeathStrike
// 0x0002 (0x04F8 - 0x04F6)
class ATgDevice_Thanatos_HoveringDeathStrike : public ATgDevice_TimerFromParent
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x04F6(0x0002) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thanatos_HoveringDeathStrike");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void InterruptFiring();
	bool CanBeCanceled();
	bool ApplyGlobalOffhandCooldown();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Thanatos_ScentOfDeath
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Thanatos_ScentOfDeath : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Thanatos_ScentOfDeath");
		return ptr;
	}


	bool IsPotentialValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgPawn_Thanatos
// 0x020C (0x27C4 - 0x25B8)
class ATgPawn_Thanatos : public ATgPawn_Character
{
public:
	TArray<struct FLowHealthInfo>                      m_LowHealthGods;                                          // 0x25B8(0x0010) (Transient, NeedCtorLink)
	int                                                r_nHarvesterBallQueueIndex;                               // 0x25C8(0x0004) (Net)
	int                                                c_nHarvesterBallQueueIndex;                               // 0x25CC(0x0004)
	struct FVector                                     r_HarvesterBallLocations[0x10];                           // 0x25D0(0x000C) (Net)
	unsigned char                                      r_HarvesterBallIsGod[0x10];                               // 0x2690(0x0001) (Net)
	TEnumAsByte<EHoveringDeathState>                   r_eHoveringDeathState;                                    // 0x26A0(0x0001) (Net)
	TEnumAsByte<EHoveringDeathState>                   c_eLocalHoveringDeathState;                               // 0x26A1(0x0001) (Transient)
	TEnumAsByte<ETG_POSTURE>                           c_eHoveringDeathPosture;                                  // 0x26A2(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x26A3(0x0001) MISSED OFFSET
	float                                              r_HarvesterBallReturnTime[0x10];                          // 0x26A4(0x0004) (Net)
	struct FVector2D                                   m_HarvesterBallReturnTimeRange;                           // 0x26E4(0x0008)
	TArray<struct FKillBallInfo>                       c_HarvesterBallInfos;                                     // 0x26EC(0x0010) (Transient, Component, NeedCtorLink)
	unsigned long                                      c_bCanPlayBallConsumeFx : 1;                              // 0x26FC(0x0004)
	unsigned long                                      c_bShadowVisionEnabled : 1;                               // 0x26FC(0x0004)
	unsigned long                                      m_bHungeringDeathActive : 1;                              // 0x26FC(0x0004)
	unsigned long                                      m_bHoveringDeathAtLocation : 1;                           // 0x26FC(0x0004)
	unsigned long                                      m_bHoveringDeathHasFired : 1;                             // 0x26FC(0x0004)
	unsigned long                                      c_bAllowHoveringDeathLaugh : 1;                           // 0x26FC(0x0004)
	float                                              c_fBallConsumeFxDelay;                                    // 0x2700(0x0004)
	float                                              r_fLowHealthPercentQualifier;                             // 0x2704(0x0004) (Net)
	class UPostProcessChain*                           c_ShadowVisionPostProcess;                                // 0x2708(0x0008)
	class UTgSpecialFx*                                c_HarvesterHeartbeatFx;                                   // 0x2710(0x0008) (Transient)
	class ATgDevice*                                   s_BasicInHand;                                            // 0x2718(0x0008)
	int                                                m_nDeathGripCount;                                        // 0x2720(0x0004)
	int                                                c_nHoveringDeathPostureId;                                // 0x2724(0x0004)
	struct FName                                       c_HoveringDeathDashAnimName;                              // 0x2728(0x0008)
	struct FName                                       c_HoveringDeathCancelAnimName;                            // 0x2730(0x0008)
	class ATgDevice*                                   s_HoveringDeathInHand;                                    // 0x2738(0x0008)
	struct FVector                                     r_HoveringDeathStartLocation;                             // 0x2740(0x000C) (Net)
	struct FVector                                     r_HoveringDeathBackupLocation;                            // 0x274C(0x000C) (Net)
	class UTgSpecialFx*                                c_HoveringDeathExecuteFx;                                 // 0x2758(0x0008)
	int                                                r_nHoveringDeathExecutionQueueIndex;                      // 0x2760(0x0004) (Net)
	int                                                c_nHoveringDeathExecutionQueueIndex;                      // 0x2764(0x0004)
	int                                                r_nHoveringDeathExecutionPawnIds[0x10];                   // 0x2768(0x0004) (Net)
	float                                              c_fHoveringDeathLaughDelay;                               // 0x27A8(0x0004)
	int                                                r_nPlayLandFx;                                            // 0x27AC(0x0004) (Net)
	class USkelControlSingleBone*                      m_FlapControl;                                            // 0x27B0(0x0008)
	float                                              c_fFlutterScale;                                          // 0x27B8(0x0004)
	float                                              c_fFlutterScaleUpRate;                                    // 0x27BC(0x0004)
	float                                              c_fFlutterCooldownRate;                                   // 0x27C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Thanatos");
		return ptr;
	}


	void STATIC_PlayLandFx();
	bool IsInClassSpecificMovement();
	void AllowExecuteLaugh();
	void PlayExecuteLaugh();
	void TickFlutter(float DeltaSeconds);
	void STATIC_ResetBallConsumeFxTimer();
	void HandleHarvesterBallMesh(class USkeletalMeshComponent* BallMesh);
	void UpdateShadowVision(bool bEnable);
	void STATIC_ResetHoveringDeath();
	void ClearHoveringDeathAfterSelfDeath();
	void STATIC_ClientUpdateHungeringDeath(bool bEnable);
	void TickHungeringDeath(float DeltaSeconds);
	void TickHoveringDeath(float DeltaSeconds);
	void UpdateHoveringDeath();
	void UpdateHeartbeat();
	void TriggerFlapDown();
	void Tick(float DeltaSeconds);
	void STATIC_OnRespawn();
	float ApplyPitchLimit(float fPitch);
	void StopFiringAllDevices(bool bClearEquipEffectFlag, bool bResetCooldowns);
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayTime, float ExcessTime);
	void OnAnimPlay(class UAnimNodeSequence* SeqNode);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void ReceivedPropValues();
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void CleanupPostTempSpawn();
	void PostDemoRewind();
	void PreDemoRewind();
	void ReplicatedEvent(const struct FName& VarName);
	bool PostPawnSetup();
	void STATIC_InitializeShadowVisionPostProcess();
	void TickLowHealthList(float DeltaSeconds);
	bool STATIC_OverrideDistanceFadeRange();
	void UpdateExecution();
	void STATIC_FlashExecution(class ATgPawn* Victim);
	void STATIC_EndHoveringDeath(bool bFired);
	void BeginHoveringDeath(class ATgDevice* Dev);
	void BeginHoveringDeathRise(class ATgDevice* Dev);
	void STATIC_PrepareHoveringDeath(class ATgDevice* Dev);
	bool STATIC_RemoveHarvesterBallInfo(int nIndex);
	void UpdateHarvesterBalls();
	void STATIC_FlashHarvesterBall(const struct FVector& Loc, float ReturnTime, bool bIsGod);
	float STATIC_CalcBearing(class AActor* Target, float fPreviousBearing, float DeltaSeconds);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	float STATIC_GetUIGroundSpeed();
};


// Class TgGame.TgDeployable_Mercury_Num4Rift
// 0x0024 (0x03F8 - 0x03D4)
class ATgDeployable_Mercury_Num4Rift : public ATgDeployable
{
public:
	float                                              r_fMaxLengthPct;                                          // 0x03D4(0x0004) (Net)
	float                                              r_fTotalEruptTime;                                        // 0x03D8(0x0004) (Net)
	float                                              m_fRemainingEruptTime;                                    // 0x03DC(0x0004)
	float                                              m_fTimeBeforeFading;                                      // 0x03E0(0x0004)
	float                                              m_fRemainingTimeBeforeFading;                             // 0x03E4(0x0004)
	float                                              m_fFadeOutTime;                                           // 0x03E8(0x0004)
	float                                              m_fRemainingFadeOutTime;                                  // 0x03EC(0x0004)
	class UMaterialInstanceConstant*                   m_mic;                                                    // 0x03F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Mercury_Num4Rift");
		return ptr;
	}


	void STATIC_DeployComplete();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
};


// Class TgGame.TgDevice_Mercury_4Shooter
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Mercury_4Shooter : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mercury_4Shooter");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Mercury_Num2
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Mercury_Num2 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mercury_Num2");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDeviceFire_Mercury_Num4Shooter
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Mercury_Num4Shooter : public UTgDeviceFire
{
public:
	float                                              m_fCachedRangeTimestamp;                                  // 0x01C0(0x0004)
	float                                              m_fCachedRange;                                           // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Mercury_Num4Shooter");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
	float STATIC_GetRange();
};


// Class TgGame.TgDeviceForm_Mercury_Num4Shooter
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Mercury_Num4Shooter : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Mercury_Num4Shooter");
		return ptr;
	}


	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgDeviceForm_Mercury_Num1
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Mercury_Num1 : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Mercury_Num1");
		return ptr;
	}


	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_Mercury_Num2
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Mercury_Num2 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Mercury_Num2");
		return ptr;
	}

};


// Class TgGame.TgPawn_Mercury
// 0x021C (0x27D4 - 0x25B8)
class ATgPawn_Mercury : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_DefaultBasicAttackDevice;                               // 0x25B8(0x0008)
	float                                              m_fPassiveConvertPct;                                     // 0x25C0(0x0004)
	unsigned long                                      s_bNeedToRecalculatePassivePhysicalPower : 1;             // 0x25C4(0x0004)
	unsigned long                                      s_bHasBeenDisplaced : 1;                                  // 0x25C4(0x0004)
	unsigned long                                      r_bIsInvisibleFromNum1 : 1;                               // 0x25C4(0x0004) (Net)
	unsigned long                                      r_bIsWhirlwinding : 1;                                    // 0x25C4(0x0004) (Net)
	unsigned long                                      s_bWhirlwindEffectsApplied : 1;                           // 0x25C4(0x0004)
	unsigned long                                      s_bTriggerEndWhirlwind : 1;                               // 0x25C4(0x0004)
	unsigned long                                      s_bWhirlwindInterrupted : 1;                              // 0x25C4(0x0004)
	unsigned long                                      r_bIsZoomedForUlt : 1;                                    // 0x25C4(0x0004) (Net)
	unsigned long                                      r_bIsUltSprinting : 1;                                    // 0x25C4(0x0004) (Net)
	unsigned long                                      r_bUltIsBuildingUp : 1;                                   // 0x25C4(0x0004) (Net)
	float                                              r_fPassivePhysicalPower;                                  // 0x25C8(0x0004) (Net)
	float                                              r_fPassiveDistanceTraveled;                               // 0x25CC(0x0004) (Net)
	float                                              r_fMaxPassiveDistance;                                    // 0x25D0(0x0004) (Net)
	float                                              m_fPassiveDistanceMultiplier;                             // 0x25D4(0x0004)
	float                                              m_fRemainingPausePassiveDistanceTime;                     // 0x25D8(0x0004)
	float                                              s_fDisplacementPassiveRefreshTime;                        // 0x25DC(0x0004)
	class ATgDevice*                                   m_Num1SubDevice;                                          // 0x25E0(0x0008)
	class ATgDeployable_Scaling*                       m_Num1Deployable;                                         // 0x25E8(0x0008)
	class ATgProj_Mercury_Num1*                        m_Num1Projectile;                                         // 0x25F0(0x0008)
	class ATgCollisionProxy_Cylinder*                  m_Num3CollisionProxy;                                     // 0x25F8(0x0008)
	class ATgPawn*                                     m_TargetToThrow;                                          // 0x2600(0x0008)
	class UTgDeviceFire*                               m_WhirlwindFireMode;                                      // 0x2608(0x0008)
	class UTgSpecialFx*                                m_WhirlwindTargeterFX;                                    // 0x2610(0x0008)
	class ATgDevice*                                   r_UltShooterDevice;                                       // 0x2618(0x0008) (Net)
	class ATgPawn*                                     r_UltTargetPawn;                                          // 0x2620(0x0008) (Net)
	struct FVector                                     m_vLastUltTargetPawnLocation;                             // 0x2628(0x000C)
	class UTgSpecialFx*                                c_UltSphereFX;                                            // 0x2634(0x0008)
	int                                                c_UltPostureId;                                           // 0x263C(0x0004)
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                                       // 0x2640(0x0140) (NeedCtorLink)
	class ATgPathfinder*                               m_Pathfinder;                                             // 0x2780(0x0008) (Edit, EditInline)
	float                                              m_fUltPathSpeed;                                          // 0x2788(0x0004) (Edit)
	class ATgDeployable*                               m_UltDeployable;                                          // 0x278C(0x0008)
	class ATgCollisionProxy_Cylinder*                  m_Num4CollisionProxy;                                     // 0x2794(0x0008)
	class ATgDevice*                                   r_Num4ShooterDevice;                                      // 0x279C(0x0008) (Net)
	class ATgSkeletalMeshActorSpawnable*               m_UltAvatarTargeter;                                      // 0x27A4(0x0008)
	float                                              m_fTotalUltChargeUpTime;                                  // 0x27AC(0x0004)
	float                                              m_fRemainingUltChargeUpTime;                              // 0x27B0(0x0004)
	TArray<class AActor*>                              UltHitTargets;                                            // 0x27B4(0x0010) (NeedCtorLink)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x27C4(0x0008) (ExportObject, Component, EditInline)
	class UTgSpecialFx*                                m_UltTargeterFX;                                          // 0x27CC(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Mercury");
		return ptr;
	}


	void UpdateBasicAttackFromPassive(bool bForce);
	void ClearPassiveBasicAttackBonus(bool bDied);
	void PlayUltBuildupEffects();
	void Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void TurnOffNum1Invisibility();
	void STATIC_PostWhirlwindTimer();
	void STATIC_PlayUltOutroAnim();
	void PlayUltSprintingEffects();
	void TickTargeting(float DeltaSeconds);
	void OnNum4CollisionProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ChargeEnding(bool bIsInterrupted);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void Silence(bool bSilenced);
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	bool STATIC_IgnoreFaceRotationWithInterp();
	void StopWhirlwindEffects();
	void PlayWhirlwindEffects();
	void OnNum3CollisionProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void STATIC_OnGrabTargetAttach(TEnumAsByte<EGrabState> newGrabState, class ATgPawn* Target);
	void SetTargetingDevice(class ATgDevice* Dev);
	void SpecialFXAttached(class UTgSpecialFx* NewFX, int FxId);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_EndWhirlWind(bool bInterrupted);
	float STATIC_CalcSpecialDeliveryTime();
	void STATIC_SwapToLiveMesh();
	void STATIC_CheckValidCharge();
	void STATIC_OnAttackDamagePropertyChange();
	float STATIC_GetMaxEnergy();
	float STATIC_GetSmoothEnergy();
	float STATIC_GetPhysicalPowerItem(const struct FImpactInfo& Impact, float PowerScaling);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool STATIC_DeviceOverrideManaUseVitals(class ATgDevice* Dev, class ATgPlayerController* PC);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgProj_Mercury_Num1
// 0x0028 (0x03C0 - 0x0398)
class ATgProj_Mercury_Num1 : public ATgProj_Simulated
{
public:
	struct FVector                                     m_vSourceLocation;                                        // 0x0398(0x000C)
	struct FVector                                     m_vTargetLocation;                                        // 0x03A4(0x000C)
	float                                              m_fTotalToTargetTime;                                     // 0x03B0(0x0004)
	float                                              m_fRemainingToTargetTime;                                 // 0x03B4(0x0004)
	float                                              m_fTotalToMercuryTime;                                    // 0x03B8(0x0004)
	float                                              m_fRemainingToMercuryTime;                                // 0x03BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Mercury_Num1");
		return ptr;
	}


	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void Tick(float fDeltaTime);
};


// Class TgGame.TgAnimBlendByWukongCharge
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendByWukongCharge : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_SunWukong*                           m_CachedWukong;                                           // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByWukongCharge");
		return ptr;
	}

};


// Class TgGame.TgDevice_SunWukong_Transform
// 0x0018 (0x0554 - 0x053C)
class ATgDevice_SunWukong_Transform : public ATgDevice_Charge
{
public:
	TEnumAsByte<EWUKONG_TRANSFORM>                     r_eTransformType;                                         // 0x053C(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x053D(0x0003) MISSED OFFSET
	unsigned long                                      m_bDoNotNotifyOthers : 1;                                 // 0x0540(0x0004) (Transient)
	float                                              m_fTransformRanges[0x4];                                  // 0x0544(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SunWukong_Transform");
		return ptr;
	}


	void InstantFire();
	void STATIC_ParentInterruptFiring();
	void InterruptFiring();
	void ResetCooldown(int nMode, float fCooldownTimeOverride);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void TransformBack();
	void TransformTo();
	bool CanBeCanceled();
	TEnumAsByte<EWUKONG_TRANSFORM> STATIC_GetBestTransform(const struct FAimData& Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_SetPointsAllocated(int nPoints);
	bool AllocateDevicePoint();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_SunWukong_SomersaultCloud
// 0x000C (0x04FC - 0x04F0)
class ATgDevice_SunWukong_SomersaultCloud : public ATgDevice
{
public:
	class ATgPawn_SunWukong*                           s_CachedWukong;                                           // 0x04F0(0x0008)
	unsigned long                                      m_bCalcBotPlacementAim : 1;                               // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SunWukong_SomersaultCloud");
		return ptr;
	}


	void STATIC_CustomFire();
	void InstantFire();
	bool ShouldCancelStealth();
	bool CanBeCanceled();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_SunWukong_MastersWill
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_SunWukong_MastersWill : public UTgDeviceFire
{
public:
	class UTgDeviceFire*                               m_ReturnFireMode;                                         // 0x01C0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SunWukong_MastersWill");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_SunWukong_Transform
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_SunWukong_Transform : public UTgDeviceForm_72Transformations
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SunWukong_Transform");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_SunWukong_MastersWill
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_SunWukong_MastersWill : public UTgDeviceForm_SunWukong_Transform
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_SunWukong_MastersWill");
		return ptr;
	}

};


// Class TgGame.TgPawn_SunWukong
// 0x00CC (0x2684 - 0x25B8)
class ATgPawn_SunWukong : public ATgPawn_Character
{
public:
	unsigned long                                      m_bPassiveIgnoreHealthChange : 1;                         // 0x25B8(0x0004) (Transient)
	unsigned long                                      m_bTransformInProgress : 1;                               // 0x25B8(0x0004)
	unsigned long                                      r_bTransformPouncing : 1;                                 // 0x25B8(0x0004) (Net)
	unsigned long                                      m_bUltimateHasFired : 1;                                  // 0x25B8(0x0004)
	class ATgDevice*                                   s_NormalInHand;                                           // 0x25BC(0x0008)
	TEnumAsByte<EWUKONG_TRANSFORM>                     r_CurrentTransformState;                                  // 0x25C4(0x0001) (Net)
	TEnumAsByte<EWUKONG_TRANSFORM>                     c_PrevTransformState;                                     // 0x25C5(0x0001)
	TEnumAsByte<EWUKONG_TRANSFORM>                     c_LocalTransformState;                                    // 0x25C6(0x0001) (Transient)
	unsigned char                                      r_nOxHitTicker[0x2];                                      // 0x25C7(0x0001) (Net)
	unsigned char                                      c_nLocalOxHitTicker[0x2];                                 // 0x25C9(0x0001)
	TEnumAsByte<EWUKONG_ULTIMATE>                      r_CurrentUltimateState;                                   // 0x25CB(0x0001) (Net)
	TEnumAsByte<EWUKONG_ULTIMATE>                      c_LocalUltimateState;                                     // 0x25CC(0x0001) (Transient)
	TEnumAsByte<ETG_POSTURE>                           c_eUltimatePosture;                                       // 0x25CD(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x25CE(0x0002) MISSED OFFSET
	class ATgDevice_SunWukong_Transform*               r_TransformDevices[0x4];                                  // 0x25D0(0x0008) (Net)
	struct FName                                       c_TigerPounceAnimName;                                    // 0x25F0(0x0008)
	float                                              m_fTransformPounceRecoverTime;                            // 0x25F8(0x0004) (Const)
	class UTgEffectGroup*                              s_TransformPouceRoot;                                     // 0x25FC(0x0008)
	class UTgAnimNodeSlot*                             c_PounceSlot;                                             // 0x2604(0x0008)
	struct FName                                       m_OxHitAnimName[0x2];                                     // 0x260C(0x0008)
	class UTgAnimNodeSlot*                             c_OxHitSlot;                                              // 0x261C(0x0008)
	TArray<class UTgAnimNodeAimOffset*>                c_TransformAimOffsets;                                    // 0x2624(0x0010) (NeedCtorLink)
	int                                                r_nTransformYawOffset;                                    // 0x2634(0x0004) (Net)
	float                                              m_fTransformAimOffsetMax;                                 // 0x2638(0x0004) (Const)
	int                                                c_nUltimatePostureId;                                     // 0x263C(0x0004)
	struct FName                                       c_UltimateAttackAnimName;                                 // 0x2640(0x0008)
	struct FName                                       c_UltimateCancelAnimName;                                 // 0x2648(0x0008)
	class ATgDevice*                                   s_UltimateInHand;                                         // 0x2650(0x0008)
	struct FVector                                     r_UltimateCancelLocation;                                 // 0x2658(0x000C)
	float                                              m_fUltimateCancelTime;                                    // 0x2664(0x0004)
	float                                              m_fInheritableGroundSpeed;                                // 0x2668(0x0004)
	class UTgEffectGroup*                              s_UltimateCancelRoot;                                     // 0x266C(0x0008)
	TArray<class UTgSpecialFx*>                        c_UltimateBuildupFxs;                                     // 0x2674(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SunWukong");
		return ptr;
	}


	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void UpdateOxHits();
	void OnOxHit(const struct FVector& HitLocation);
	void STATIC_EndTigerPounce();
	void BeginTigerPounce();
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormHit(int nEquipSlot, class ATgPawn* TargetPawn);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	struct FVector STATIC_GetLookAtLocation();
	void STATIC_StopSomersaultCloud(bool bInterrupted);
	void STATIC_ClearUltimateStateAfterDeath();
	void STATIC_SetUltimateInactive();
	void ToggleUltimateRoot(bool bEnable);
	float ApplyPitchLimit(float fPitch);
	void UpdateSomersaultCloud(TEnumAsByte<EWUKONG_ULTIMATE> NextState);
	void LeapBackTweenEnd(bool bInterrupted);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void SetTargetingDevice(class ATgDevice* Dev);
	bool PostPawnSetup();
	void PostDemoRewind();
	void ReplicatedEvent(const struct FName& VarName);
	int STATIC_GetCustomParticleSystemFilter();
	void STATIC_OnTransformTransitionEnd(bool bTriggeredInAnimTick);
	void STATIC_StartTransform(TEnumAsByte<EWUKONG_TRANSFORM> NewStance, bool bSkipTransition);
	void STATIC_ReapplyPassive(bool bForceReapply);
	void STATIC_ReapplyLevelEffectGroups(int nPrevLevel, int nCurrentLevel, bool bPreserveParams);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_SunWukong_DarkLord
// 0x0080 (0x2704 - 0x2684)
class ATgPawn_SunWukong_DarkLord : public ATgPawn_SunWukong
{
public:
	class UTgAnimBlendByWukongCharge*                  m_ChargeAnimNode;                                         // 0x2684(0x0008)
	struct FName                                       m_ChargeAimOffsetProfileNames[0x4];                       // 0x268C(0x0008)
	int                                                m_ChargeAnimSetStringIds[0x4];                            // 0x26AC(0x0004)
	class UAnimSet*                                    m_ChargeAnimSets[0x4];                                    // 0x26BC(0x0008)
	class UMaterialInterface*                          m_ChargeMaterials[0x4];                                   // 0x26DC(0x0008)
	class UMaterialInstanceConstant*                   m_FriendlyFadeOverlayMaterial;                            // 0x26FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SunWukong_DarkLord");
		return ptr;
	}


	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void STATIC_OnTransformTransitionEnd(bool bTriggeredInAnimTick);
	void STATIC_SwapToLiveMesh();
};


// Class TgGame.TgPawn_SunWukong_Default
// 0x0070 (0x26F4 - 0x2684)
class ATgPawn_SunWukong_Default : public ATgPawn_SunWukong
{
public:
	class UAnimNodeSequence*                           m_TransformIntroSequenceNode;                             // 0x2684(0x0008)
	unsigned long                                      m_bTriggerTransformMeshChange : 1;                        // 0x268C(0x0004)
	struct FName                                       c_TransformOutroAnimName;                                 // 0x2690(0x0008)
	int                                                m_TransformMeshAssemblyIds[0x4];                          // 0x2698(0x0004)
	struct FPointer                                    m_TransformBodyMeshAssemblies[0x4];                       // 0x26A8(0x0008) (Native)
	struct FPointer                                    m_TransformDestroyedMeshAssemblies[0x4];                  // 0x26C8(0x0008) (Native)
	int                                                m_TransformDesiredAssemblyId;                             // 0x26E8(0x0004)
	int                                                m_TransformDesiredDestroyedAssemblyId;                    // 0x26EC(0x0004)
	float                                              m_fEagleTranslationOffset;                                // 0x26F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SunWukong_Default");
		return ptr;
	}


	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_OnTransformTransitionEnd(bool bTriggeredInAnimTick);
	void AdjustMeshTranslation();
	void STATIC_SwapTransformMesh();
	void STATIC_SwapToDestroyedMesh();
	void STATIC_SwapToLiveMesh();
	void STATIC_OnPostureChange();
};


// Class TgGame.TgPawn_SunWukong_Decoy
// 0x0008 (0x246C - 0x2464)
class ATgPawn_SunWukong_Decoy : public ATgPawn_Familiar
{
public:
	float                                              m_fSpawnHealthPercent;                                    // 0x2464(0x0004)
	unsigned long                                      s_bTriggerSuicide : 1;                                    // 0x2468(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SunWukong_Decoy");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void STATIC_SpawnReturnProjectile();
	void STATIC_PawnOnHardCCed(const struct FImpactInfo& Impact, class UTgEffectGroup* eg);
	void STATIC_OnOwnerGroundSpeedChange();
	void STATIC_SetSpawnHealth();
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgAchievement_AhMuzenCab_HowSweet
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_AhMuzenCab_HowSweet : public UTgAchievement
{
public:
	int                                                m_nSuccessCount;                                          // 0x0084(0x0004)
	int                                                m_nTargetGoal;                                            // 0x0088(0x0004)
	int                                                m_nDeviceId;                                              // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AhMuzenCab_HowSweet");
		return ptr;
	}

};


// Class TgGame.TgAhMuzenCabSwarmInstance
// 0x0028 (0x0288 - 0x0260)
class ATgAhMuzenCabSwarmInstance : public AInfo
{
public:
	int                                                m_nStrainId;                                              // 0x0260(0x0004)
	unsigned long                                      m_bBasicAttackStrain : 1;                                 // 0x0264(0x0004)
	unsigned long                                      m_bDoNotAdjustStrainLifeSpan : 1;                         // 0x0264(0x0004)
	TArray<class AActor*>                              m_PreviouslyInfected;                                     // 0x0268(0x0010) (Const, NeedCtorLink)
	TArray<struct FInfectedInfo>                       m_CurrentlyInfected;                                      // 0x0278(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAhMuzenCabSwarmInstance");
		return ptr;
	}


	void Destroyed();
	void Timer();
	void PostBeginPlay();
	float STATIC_GetSpreadTime();
	void STATIC_SetStrainLifeSpan(float fNewLifeSpan);
	bool STATIC_ImmuneToThisStrain(class AActor* Target);
	void AddToInfectionList(class AActor* Target, float fInfectionDuration);
};


// Class TgGame.TgDeployable_AhMuzenCab_HoneyPool
// 0x0024 (0x03F8 - 0x03D4)
class ATgDeployable_AhMuzenCab_HoneyPool : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03E4(0x0008)
	unsigned long                                      r_bIsBuffedWithBees : 1;                                  // 0x03EC(0x0004) (Net)
	class ATgDeployable_AhMuzenCab_Hive*               r_HiveBuffing;                                            // 0x03F0(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_AhMuzenCab_HoneyPool");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
	void STATIC_PlayHiveBuffingEffects();
	void STATIC_PlayHiveBuffingEffectsTimer();
	void STATIC_PlayBuffedWithBeesEffects();
	void BuffWithBees(bool bBuffPreviousHoneyPools);
	void BuffWithBeesTimer();
	void STATIC_StartBuffWithBeesTimer(float Time);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeployable_AhMuzenCab_Stinger
// 0x0018 (0x03EC - 0x03D4)
class ATgDeployable_AhMuzenCab_Stinger : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_AhMuzenCab_Stinger");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_AhMuzenCab_Hive
// 0x0028 (0x0438 - 0x0410)
class ATgDeployable_AhMuzenCab_Hive : public ATgDeployable_Ward
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x0410(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x0420(0x0008)
	TArray<class ATgPawn_AhMuzenCab_BeeFlock*>         m_BeeFlocks;                                              // 0x0428(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_AhMuzenCab_Hive");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
	void STATIC_CreditKill(class AController* PC);
	bool STATIC_IsInvisible(class AActor* TestActor);
	void STATIC_SpawnNewBeeFlock();
};


// Class TgGame.TgDevice_AhMuzenCab_Hive
// 0x000C (0x0508 - 0x04FC)
class ATgDevice_AhMuzenCab_Hive : public ATgDevice_Deployable
{
public:
	int                                                r_nCurrentAmmo;                                           // 0x04FC(0x0004) (Net)
	float                                              m_fElapsedAddAmmoTime;                                    // 0x0500(0x0004)
	unsigned long                                      m_bUseAmmo : 1;                                           // 0x0504(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AhMuzenCab_Hive");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void AddAmmo(int Amount);
	void Tick(float DeltaSeconds);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShowUICanFire();
};


// Class TgGame.TgDevice_AhMuzenCab_Honey
// 0x0014 (0x0510 - 0x04FC)
class ATgDevice_AhMuzenCab_Honey : public ATgDevice_Deployable
{
public:
	int                                                m_nRemainingDeployables;                                  // 0x04FC(0x0004)
	struct FVector                                     m_vLastDeployLocation;                                    // 0x0500(0x000C)
	float                                              m_fDistanceBetweenDeployables;                            // 0x050C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AhMuzenCab_Honey");
		return ptr;
	}


	void OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_CustomFire();
	void DeployNextHoney();
	bool StartFire();
};


// Class TgGame.TgEffectForm_AMC_Infect
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_AMC_Infect : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_AMC_Infect");
		return ptr;
	}


	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgInventoryObject_Listen_AhMuzenCabBees
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_AhMuzenCabBees : public UTgInventoryObject_Listen
{
public:
	TArray<struct FBeeVictimInfo>                      m_BeeVictimList;                                          // 0x00D0(0x0010) (NeedCtorLink)
	float                                              m_fMaxBeesTime;                                           // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AhMuzenCabBees");
		return ptr;
	}

};


// Class TgGame.TgPawn_AhMuzenCab
// 0x007C (0x2634 - 0x25B8)
class ATgPawn_AhMuzenCab : public ATgPawn_Character
{
public:
	TArray<class ATgDeployable_AhMuzenCab_Hive*>       m_Hives;                                                  // 0x25B8(0x0010) (NeedCtorLink)
	class ATgAhMuzenCabSwarmInstance*                  m_Num2Strain;                                             // 0x25C8(0x0008)
	unsigned long                                      r_bHoneySprayEffectsActive : 1;                           // 0x25D0(0x0004) (Net)
	unsigned long                                      r_bIsHoneyDeviceActive : 1;                               // 0x25D0(0x0004) (Net)
	unsigned long                                      m_bPendingBeeBuff : 1;                                    // 0x25D0(0x0004)
	unsigned long                                      m_bKilledByUltStinger : 1;                                // 0x25D0(0x0004)
	int                                                c_Num3PostureIndex;                                       // 0x25D4(0x0004)
	class UTgSpecialFx*                                m_HoneyBeamFx;                                            // 0x25D8(0x0008)
	class UTgSpecialFx*                                m_HoneySprayEndFx;                                        // 0x25E0(0x0008)
	struct FVector                                     r_vNum3HoneyEndLocation;                                  // 0x25E8(0x000C) (Net)
	TArray<class ATgDeployable_AhMuzenCab_HoneyPool*>  m_HoneyPools;                                             // 0x25F4(0x0010) (NeedCtorLink)
	class ATgAhMuzenCabSwarmInstance*                  m_Num3Strain;                                             // 0x2604(0x0008)
	TArray<class ATgAhMuzenCabSwarmInstance*>          m_SwarmStrains;                                           // 0x260C(0x0010) (NeedCtorLink)
	TArray<struct FHoneyVictimInfo>                    m_HoneyVictimList;                                        // 0x261C(0x0010) (NeedCtorLink)
	class ATgDeployable_AhMuzenCab_Stinger*            r_DeployedStinger;                                        // 0x262C(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_AhMuzenCab");
		return ptr;
	}


	void STATIC_SetDeployableStinger(class ATgDeployable_AhMuzenCab_Stinger* DeployedStinger);
	void STATIC_StopNum3EquipEffects();
	void STATIC_PlayNum3EquipEffects();
	void STATIC_ServerTargetingDeviceSet(class ATgDevice* Dev);
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_OnRespawn();
	void UnRegisterHoneyPool(class ATgDeployable_AhMuzenCab_HoneyPool* HoneyPoolToRemove);
	void STATIC_RegisterHoneyPool(class ATgDeployable_AhMuzenCab_HoneyPool* NewHoneyPool);
	void UnRegisterHive(class ATgDeployable_AhMuzenCab_Hive* HiveToRemove);
	void STATIC_RegisterHive(class ATgDeployable_AhMuzenCab_Hive* NewHive);
	void EnableHoneySprayEffects(bool bActive);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PawnOnHealed(struct FOnHealedParams* Params);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_DropStinger(const struct FImpactInfo& Impact);
	float STATIC_GetSmoothEnergy();
	float AdjustRespawnTime(float InRespawnTime);
	void KillSelfFromFailedStinger();
	float ApplySwarmToTarget(class ATgPawn* Target, float SwarmTime, class ATgAhMuzenCabSwarmInstance* SwarmInstance, bool bBasicAttack);
	void STATIC_ReapplyLoadoutEffects();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_AhMuzenCab_BeeFlock
// 0x0010 (0x2474 - 0x2464)
class ATgPawn_AhMuzenCab_BeeFlock : public ATgPawn_Familiar
{
public:
	class ATgDeployable_AhMuzenCab_Hive*               m_TargetHive;                                             // 0x2464(0x0008)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x246C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_AhMuzenCab_BeeFlock");
		return ptr;
	}


	void STATIC_JumpOffPawn();
	void BaseChange();
	void Destroyed();
};


// Class TgGame.TgAnimBlendByNuWaWariness
// 0x0008 (0x017C - 0x0174)
class UTgAnimBlendByNuWaWariness : public UTgAnimNodeBlendByCombatWariness
{
public:
	float                                              fSnakeTransitionToNormalTime;                             // 0x0174(0x0004) (Edit)
	unsigned long                                      bInSnakeForm : 1;                                         // 0x0178(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByNuWaWariness");
		return ptr;
	}


	void ToggleSnakeForm(bool bEnable);
};


// Class TgGame.TgAnimNodeBlendNuWa
// 0x0000 (0x0124 - 0x0124)
class UTgAnimNodeBlendNuWa : public UAnimNodeBlend
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendNuWa");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_PlayParticleEffect_NuWaBasicAttack
// 0x0030 (0x00E4 - 0x00B4)
class UTgAnimNotify_PlayParticleEffect_NuWaBasicAttack : public UTgAnimNotify_PlayParticleEffect_Skinned
{
public:
	class UParticleSystem*                             m_DefaultAOETemplate;                                     // 0x00B4(0x0008) (Edit)
	TArray<struct FPPE_Skin>                           m_AOESkinOverrideList;                                    // 0x00BC(0x0010) (Edit, NeedCtorLink)
	class UParticleSystem*                             m_DefaultSnakeTemplate;                                   // 0x00CC(0x0008) (Edit)
	TArray<struct FPPE_Skin>                           m_SnakeSkinOverrideList;                                  // 0x00D4(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_PlayParticleEffect_NuWaBasicAttack");
		return ptr;
	}


	class UParticleSystem* STATIC_GetParticleSystemToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgDeployable_NuWa_Pillars
// 0x0020 (0x0460 - 0x0440)
class ATgDeployable_NuWa_Pillars : public ATgDeploy_SandPillar
{
public:
	class UMeshComponent*                              s_HitMesh;                                                // 0x0440(0x0008) (ExportObject, Component, EditInline)
	int                                                s_nHitMeshId;                                             // 0x0448(0x0004)
	int                                                s_nDamageEffectGroupId;                                   // 0x044C(0x0004)
	TArray<struct FCannotTouchInfo>                    s_CannotTouchList;                                        // 0x0450(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_NuWa_Pillars");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	float TimeUntilActorCanBeReTouched(class AActor* Target);
};


// Class TgGame.TgDevice_NuWa_Passive
// 0x02EC (0x0810 - 0x0524)
class ATgDevice_NuWa_Passive : public ATgDevice_PassiveAura
{
public:
	struct FCrystalInfo                                m_Crystals[0x1F];                                         // 0x0524(0x0018)
	float                                              m_fCrystalDefaultLifeTime;                                // 0x080C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NuWa_Passive");
		return ptr;
	}


	void EndAura();
	void BeginAura();
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
	int STATIC_NumCrystalsActive();
	void AdjustAllActiveCrystals(float fNewLifetime);
	void STATIC_ReactivateCrystals();
	void STATIC_DeactivateAllCrystals(bool bWillReapply);
	void STATIC_DeactivateCrystal(TEnumAsByte<ETG_EQUIP_POINT> eqp, bool bWillReapply);
	void ActivateCrystal(TEnumAsByte<ETG_EQUIP_POINT> eqp, float fLifeTime);
	void STATIC_SetCrystalFireMode(TEnumAsByte<ETG_EQUIP_POINT> eqp, class UTgDeviceFire* DeviceMode);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_NuWa_StealthAura
// 0x000C (0x0530 - 0x0524)
class ATgDevice_NuWa_StealthAura : public ATgDevice_PassiveAura
{
public:
	class ATgCollisionProxy_PawnListener*              s_StealthCancelProxy;                                     // 0x0524(0x0008)
	unsigned long                                      bRemoveStealth : 1;                                       // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NuWa_StealthAura");
		return ptr;
	}


	void Destroyed();
	void EndAura();
	void BeginAura();
	void STATIC_OnPawnDeviceStartFire(class ATgPawn* Other, class ATgDevice* OtherDevice);
	void Tick(float DeltaTime);
	void ApplyHitAura(class AActor* Other);
	bool STATIC_CanApplyAura(class AActor* Other);
};


// Class TgGame.TgDevice_NuWa_GlobalUltimate
// 0x0044 (0x0540 - 0x04FC)
class ATgDevice_NuWa_GlobalUltimate : public ATgDevice_Deployable
{
public:
	class ATgPawn_NuWaV2*                              s_CachedNuWa;                                             // 0x04FC(0x0008)
	float                                              m_fChargeRange;                                           // 0x0504(0x0004)
	TEnumAsByte<EChargeState>                          m_eChargeType;                                            // 0x0508(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0509(0x0003) MISSED OFFSET
	unsigned long                                      m_bCharging : 1;                                          // 0x050C(0x0004)
	TArray<class ATgDeployable*>                       s_ActiveDeployables;                                      // 0x0510(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_ExemptActors;                                           // 0x0520(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_WarnedActors;                                           // 0x0530(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NuWa_GlobalUltimate");
		return ptr;
	}


	void RemoveWarningEffects(bool bInterrupted);
	void ApplyWarningEffects();
	void STATIC_CustomFire();
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	class ATgRepInfo_TaskForce* STATIC_GetEnemyTaskForce(int* nIndex);
	bool CanBeCanceled();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool UsesCachedAim();
};


// Class TgGame.TgDevice_NuWa_FogSpawn
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_NuWa_FogSpawn : public ATgDevice
{
public:
	class ATgPawn*                                     DeployableBase;                                           // 0x04F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NuWa_FogSpawn");
		return ptr;
	}


	void STATIC_GetCachedAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_NuWa_MinionSpawn
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_NuWa_MinionSpawn : public ATgDevice
{
public:
	class UTgDeviceFire_NuWa_MinionSpawn*              m_CachedMode;                                             // 0x04F0(0x0008)
	struct FVector                                     c_vCurrentTargeting2Location;                             // 0x04F8(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NuWa_MinionSpawn");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void STATIC_SpawnNext();
	void STATIC_CalcSpecialTarget(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_NuWa_ShiningMetal
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_NuWa_ShiningMetal : public ATgDevice
{
public:
	TArray<class AActor*>                              m_TargetingExplosionActors;                               // 0x04F0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NuWa_ShiningMetal");
		return ptr;
	}


	void TickTargetingMode(float DeltaSeconds);
	bool STATIC_CanLockOnToTarget(class AActor* Target);
};


// Class TgGame.TgDevice_NuWa_Ultimate
// 0x0014 (0x053C - 0x0528)
class ATgDevice_NuWa_Ultimate : public ATgDevice_Staging
{
public:
	class ATgPawn_NuWaV2*                              s_CachedNuWa;                                             // 0x0528(0x0008)
	float                                              m_fChargeRange;                                           // 0x0530(0x0004)
	TEnumAsByte<EChargeState>                          m_eChargeType;                                            // 0x0534(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0535(0x0003) MISSED OFFSET
	unsigned long                                      m_bCharging : 1;                                          // 0x0538(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NuWa_Ultimate");
		return ptr;
	}


	void OnStageShooterStopFire(bool bInterrupted);
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	bool LockStageShooterFiring();
	bool CanJumpWhileFiring();
	bool CanBeCanceled();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_NuWa_UltimateShooter
// 0x0000 (0x0514 - 0x0514)
class ATgDevice_NuWa_UltimateShooter : public ATgDevice_Painting
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NuWa_UltimateShooter");
		return ptr;
	}


	bool ApplyGlobalOffhandCooldown();
	bool ShouldInterruptInhand();
	void RemoveEquipEffects();
	void ApplyEquipEffects();
};


// Class TgGame.TgDeviceFire_NuWa_FlameStrike
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_NuWa_FlameStrike : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NuWa_FlameStrike");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_NuWa_FogSpawn
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_NuWa_FogSpawn : public UTgDeviceFire
{
public:
	struct FPointer                                    m_pBotSetup;                                              // 0x01C0(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NuWa_FogSpawn");
		return ptr;
	}


	class ATgPawn* STATIC_SpawnPet(bool bPet);
	void STATIC_CustomFire();
};


// Class TgGame.TgDeviceFire_NuWa_InHand
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_NuWa_InHand : public UTgDeviceFire
{
public:
	class UTgDeviceFire*                               m_AoeMode;                                                // 0x01C0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NuWa_InHand");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_NuWa_MinionSpawn
// 0x0018 (0x01D8 - 0x01C0)
class UTgDeviceFire_NuWa_MinionSpawn : public UTgDeviceFire
{
public:
	int                                                m_nNextSpawnIndex;                                        // 0x01C0(0x0004)
	unsigned long                                      m_bCachedPet : 1;                                         // 0x01C4(0x0004)
	int                                                m_nCachedLaneId;                                          // 0x01C8(0x0004)
	class UTgAISquad*                                  m_CachedSquad;                                            // 0x01CC(0x0008)
	float                                              m_fCachedStaggerTime;                                     // 0x01D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NuWa_MinionSpawn");
		return ptr;
	}


	int STATIC_GetSpawnCount();
	void STATIC_ForceRemainderToSpawn();
	class ATgPawn* STATIC_SpawnNext(bool bSetTimer);
	class ATgPawn* STATIC_SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_NuWa_MinionSpawn_PVE
// 0x0000 (0x01D8 - 0x01D8)
class UTgDeviceFire_NuWa_MinionSpawn_PVE : public UTgDeviceFire_NuWa_MinionSpawn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NuWa_MinionSpawn_PVE");
		return ptr;
	}


	int STATIC_GetSpawnCount();
};


// Class TgGame.TgDeviceFire_NuWa_StealthFog
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_NuWa_StealthFog : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NuWa_StealthFog");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_NuWa_ShiningMetal
// 0x0004 (0x01D4 - 0x01D0)
class UTgDeviceFire_NuWa_ShiningMetal : public UTgDeviceFire_WithExemptList
{
public:
	unsigned long                                      m_bClaySoldierExplosion : 1;                              // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NuWa_ShiningMetal");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceForm_NuWa_ClaySoldiers
// 0x002C (0x0264 - 0x0238)
class UTgDeviceForm_NuWa_ClaySoldiers : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicator2;                            // 0x0238(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFx2;                                       // 0x0240(0x0008)
	struct FVector                                     c_TargetingModeFx2Location;                               // 0x0248(0x000C)
	int                                                c_nTargetingModeFx2Id;                                    // 0x0254(0x0004)
	class UTgSpecialFx*                                c_SuccessfulTargetFx;                                     // 0x0258(0x0008)
	int                                                c_nSuccessfulTargetFxID;                                  // 0x0260(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_NuWa_ClaySoldiers");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void UpdateTargetingMode2Location(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_NuWa_Fireball
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_NuWa_Fireball : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_NuWa_Fireball");
		return ptr;
	}


	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgInventoryObject_Listen_NuWaPassiveV2
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_NuWaPassiveV2 : public UTgInventoryObject_Listen_InHand
{
public:
	int                                                m_nSuccessfulHitCount;                                    // 0x00D0(0x0004)
	int                                                m_nActiveEffectSituationalType;                           // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NuWaPassiveV2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NuWa_StealthAura
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_NuWa_StealthAura : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NuWa_StealthAura");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NuWaPassive
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_NuWaPassive : public UTgInventoryObject_Listen
{
public:
	int                                                m_nInHandSwapCategoryCode;                                // 0x00D0(0x0004) (Const)
	int                                                m_nInHandBoostCategoryCode;                               // 0x00D4(0x0004) (Const)
	unsigned long                                      m_bInHandSwapActive : 1;                                  // 0x00D8(0x0004)
	unsigned long                                      m_bInHandExtraActive : 1;                                 // 0x00D8(0x0004)
	unsigned long                                      m_bSnakeFormActive : 1;                                   // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NuWaPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_NuWa
// 0x03E8 (0x29A0 - 0x25B8)
class ATgPawn_NuWa : public ATgPawn_Character
{
public:
	int                                                r_nCrystalFlashEventIndex;                                // 0x25B8(0x0004) (Net)
	int                                                c_nCrystalFlashEventIndex;                                // 0x25BC(0x0004)
	int                                                r_nCrystalFlashEvents[0x10];                              // 0x25C0(0x0004) (Net)
	float                                              r_fCrystalFlashLifetimes[0x10];                           // 0x2600(0x0004) (Net)
	struct FNuWaCrystalInfo                            c_LocalCrystals[0x1F];                                    // 0x2640(0x0018)
	float                                              m_fCrystalActivateTime;                                   // 0x2928(0x0004)
	float                                              m_fCrystalDeactivateTime;                                 // 0x292C(0x0004)
	int                                                m_nCurrentInHandMode;                                     // 0x2930(0x0004)
	int                                                m_nSnakeTailMeshId;                                       // 0x2934(0x0004)
	TEnumAsByte<ENUWA_FORM>                            r_eCurrentNuWaForm;                                       // 0x2938(0x0001) (Net)
	TEnumAsByte<ENUWA_FORM>                            c_eLocalNuWaForm;                                         // 0x2939(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x293A(0x0002) MISSED OFFSET
	unsigned long                                      m_bFormTransitionInProgress : 1;                          // 0x293C(0x0004)
	float                                              m_fNuWaFormTimeToGo;                                      // 0x2940(0x0004)
	float                                              m_fNuWaFormBlend;                                         // 0x2944(0x0004)
	float                                              m_fNuWaFormBlendTarget;                                   // 0x2948(0x0004)
	float                                              m_fNuWaFormTransitionTimes[0x2];                          // 0x294C(0x0004) (Const)
	TArray<class UAnimNodeBlend*>                      c_NuWaFormBlendNodes;                                     // 0x2954(0x0010) (NeedCtorLink)
	TArray<struct FNuWaFormControl>                    c_NuWaFormControls;                                       // 0x2964(0x0010) (NeedCtorLink)
	class UTgSkeletalMeshComponent*                    c_SnakeMeshComponent;                                     // 0x2974(0x0008) (ExportObject, Transient, Component, EditInline)
	class AActor*                                      r_ClaySoldierTarget;                                      // 0x297C(0x0008) (Net)
	class UTgSpecialFx*                                c_ClaySoldierTargetFx;                                    // 0x2984(0x0008)
	int                                                c_nClaySoldierTargetFxID;                                 // 0x298C(0x0004) (Const)
	TArray<int>                                        m_nNoMinionRagdollSkinList;                               // 0x2990(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_NuWa");
		return ptr;
	}


	void AdjustPawnMeshVisibility();
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	void STATIC_PrepareIntro();
	void STATIC_OnRespawn();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void OnDeactivateCrystal(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void OnActivateCrystal(TEnumAsByte<ETG_EQUIP_POINT> eqp, float fLifeTime);
	void EndFormTransition();
	void STATIC_FixInHandProgressionAnims(int nNewMode, float NewDesiredDuration);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_ReflashActiveCrystals();
	void SetClaySoldierTarget(class AActor* Target);
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void ReplicatedEvent(const struct FName& VarName);
	bool AllowMinionRagdoll();
	void STATIC_PawnOnSpecialCleanup();
	void STATIC_InitClaySoldierTargetFx();
	bool STATIC_ShouldShowSnakeTailThisTick();
	void STATIC_ChangeForm(TEnumAsByte<ENUWA_FORM> NewForm, bool bSkipTransition, bool bIntroOrDeath);
	void UpdateCrystalEvents();
	void STATIC_FlashDeactivateCrystal(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void STATIC_FlashActivateCrystal(TEnumAsByte<ETG_EQUIP_POINT> eqp, float fLifeTime);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_SetMeshVisibility(bool bVisible);
	void STATIC_OnMeshSwapped();
	float STATIC_GetSmoothEnergy();
};


// Class TgGame.TgPawn_NuWaV2
// 0x0028 (0x29C8 - 0x29A0)
class ATgPawn_NuWaV2 : public ATgPawn_NuWa
{
public:
	TEnumAsByte<ENuWaUltState>                         r_eUltimateState;                                         // 0x29A0(0x0001) (Net)
	TEnumAsByte<ENuWaUltState>                         m_eLocalUltState;                                         // 0x29A1(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x29A2(0x0002) MISSED OFFSET
	float                                              s_fUltimateTakeDownTime;                                  // 0x29A4(0x0004)
	class UClass*                                      c_UltimateCameraModuleClass;                              // 0x29A8(0x0008)
	class UClass*                                      c_PreviousCameraModuleClass;                              // 0x29B0(0x0008)
	class UTgCameraModule*                             c_UltimateCameraMod;                                      // 0x29B8(0x0008)
	unsigned long                                      r_bUltimateVision : 1;                                    // 0x29C0(0x0004) (Net)
	float                                              m_fCollisionOffTime;                                      // 0x29C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_NuWaV2");
		return ptr;
	}


	bool CannotJumpNow();
	void STATIC_OnRespawn();
	void STATIC_EndSnakeForm();
	void ToggleUltimateCameraMod(bool bOn);
	void STATIC_DelayedCameraPull();
	void STATIC_EndUltimateTakeDown();
	void UltimateCollisionTimer();
	void UpdateUltimateState(TEnumAsByte<ENuWaUltState> NewState);
	void Stun(bool bStunController, TEnumAsByte<EStunType> eType);
	void STATIC_PrepareIntro();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_EndSkinLevelUp();
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void STATIC_PawnOnRevive();
	bool STATIC_OverrideDistanceFadeRange();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
};


// Class TgGame.TgPawn_NuWa_Fog
// 0x0000 (0x2464 - 0x2464)
class ATgPawn_NuWa_Fog : public ATgPawn_Familiar
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_NuWa_Fog");
		return ptr;
	}


	bool CanApplyEffects();
	void STATIC_OnMeshSwapped();
	void STATIC_PostPawnSetupServer();
	void STATIC_OnOwnerGroundSpeedChange();
	bool IsNonCombat();
};


// Class TgGame.TgPawn_NuWa_FogV2
// 0x0000 (0x2464 - 0x2464)
class ATgPawn_NuWa_FogV2 : public ATgPawn_NuWa_Fog
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_NuWa_FogV2");
		return ptr;
	}


	void STATIC_PostPawnSetupServer();
	void STATIC_OnOwnerGroundSpeedChange();
};


// Class TgGame.TgDevice_Chaac_Num2
// 0x0004 (0x0520 - 0x051C)
class ATgDevice_Chaac_Num2 : public ATgDevice_RadialSweep
{
public:
	unsigned long                                      m_bTeleporting : 1;                                       // 0x051C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chaac_Num2");
		return ptr;
	}


	bool CanBeCanceled();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
	bool STATIC_CanBeCrippled();
	float GetBuildupTime(int nMode);
};


// Class TgGame.TgDeviceForm_Chaac_Num2
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Chaac_Num2 : public UTgDeviceForm_RadialSweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Chaac_Num2");
		return ptr;
	}


	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgPawn_Chaac
// 0x00A4 (0x265C - 0x25B8)
class ATgPawn_Chaac : public ATgPawn_Character
{
public:
	int                                                r_nPassiveCount;                                          // 0x25B8(0x0004) (Net)
	int                                                m_nCachedPassiveCount;                                    // 0x25BC(0x0004)
	TArray<struct FChaacPassiveTracker>                s_RefundedList;                                           // 0x25C0(0x0010) (NeedCtorLink)
	int                                                r_nPassiveMaxCount;                                       // 0x25D0(0x0004) (Net)
	class ATgDevice*                                   m_BasicAttackDevice;                                      // 0x25D4(0x0008)
	class ATgDevice*                                   m_Num1SeekingProjectileDevice;                            // 0x25DC(0x0008)
	class ATgDeployable*                               r_Num1AxeDeployable;                                      // 0x25E4(0x0008) (Net)
	class ATgDeployable*                               m_Num1WarningDeployable;                                  // 0x25EC(0x0008)
	class ATgCollisionProxy_Cylinder*                  m_Num2TweenCylinder;                                      // 0x25F4(0x0008)
	TArray<class ATgPawn*>                             m_Num2TweenHitPawns;                                      // 0x25FC(0x0010) (NeedCtorLink)
	struct FVector                                     m_Num2TweenDestination;                                   // 0x260C(0x000C)
	TArray<struct FLevitateVictimInfo>                 m_UltLevitateVictims;                                     // 0x2618(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_UltStunnedVictims;                                      // 0x2628(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_UltEffectsPawn;                                         // 0x2638(0x0008)
	unsigned long                                      r_bIsUltBuffed : 1;                                       // 0x2640(0x0004) (Net)
	unsigned char                                      r_nRunningKillCount;                                      // 0x2644(0x0001) (Net)
	unsigned char                                      c_nLocalRunningKillCount;                                 // 0x2645(0x0001)
	unsigned char                                      m_nRunningKillCountMax;                                   // 0x2646(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x2647(0x0001) MISSED OFFSET
	TArray<struct FKillMaterialInfo>                   m_KillMaterialInfos;                                      // 0x2648(0x0010) (NeedCtorLink)
	float                                              m_fKillCountDecrementTime;                                // 0x2658(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Chaac");
		return ptr;
	}


	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void STATIC_DecrementKillCount();
	void UpdateRunningKillCount(unsigned char NewCount);
	void STATIC_ResetRunningKillCount();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void STATIC_OnRespawn();
	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	void PostDemoRewind();
	void CheckPassiveEffects();
	void STATIC_PlayDyingEffects();
	void StopUltBuffedEffects();
	void PlayUltBuffedEffects();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void OnNum2CollisionProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UpdateNum2Targeter();
	void STATIC_RegisterNum1AxeDeployable(class ATgDeployable* NewAxeDeployable);
	int STATIC_GetNum1SeekingProjectileFireModeId();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void SetTargetingDevice(class ATgDevice* Dev);
	bool STATIC_IgnoreFaceRotationWithInterp();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void ReplicatedEvent(const struct FName& VarName);
	bool PostPawnSetup();
	void STATIC_ClearTrackedInst(class ATgDevice* Dev);
	bool STATIC_ShouldClearTrackedInst(class ATgDevice* Dev);
	bool IsDeviceFireInstRefunded(class ATgDevice* Dev);
	void TrackRefundedDevice(class ATgDevice* Dev);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void UpdateKillMaterial(float DeltaTime, bool bForce, struct FKillMaterialInfo* KillMatInfo);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	bool STATIC_DeviceOverrideManaUseVitals(class ATgDevice* Dev, class ATgPlayerController* PC);
	void UltRemoveHitSpecialStun();
	bool STATIC_ShouldPawnMeshBeHiddenThisTick();
	float STATIC_GetSmoothEnergy();
	bool STATIC_DeviceHasEnoughPowerPool(class ATgDevice* Dev, unsigned char FireModeNum);
	void STATIC_DeviceOnStartCooldown(class ATgDevice* Dev, float CooldownTime);
	void STATIC_ConsumePowerPool(class ATgDevice* Dev, int nPacingType, float fAmount);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_ChaacSkin
// 0x0078 (0x26D4 - 0x265C)
class ATgPawn_ChaacSkin : public ATgPawn_Chaac
{
public:
	TEnumAsByte<EChaacSkinStates>                      r_eSkinState;                                             // 0x265C(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eEquipSlotSkinChangeTrigger;                            // 0x265D(0x0001)
	TEnumAsByte<EChaacKillAssistEvolutionStates>       r_eCurrentEvolution;                                      // 0x265E(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x265F(0x0001) MISSED OFFSET
	struct FString                                     m_strStateSuffixes[0x4];                                  // 0x2660(0x0010) (Const, NeedCtorLink)
	int                                                s_nCurrentKillAssists;                                    // 0x26A0(0x0004)
	int                                                m_nEvolutionKillAssistThreshold[0x4];                     // 0x26A4(0x0004) (Const)
	struct FName                                       m_nmEvolutionFxGroups[0x4];                               // 0x26B4(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ChaacSkin");
		return ptr;
	}


	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PawnOnAssisted(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnRevive();
	void STATIC_OnMeshSwapped();
	void STATIC_OnSkinLevelChanged();
	void STATIC_DeactivateStages();
	void STATIC_SetStageMIC(TArray<struct FName> nmStageParameters, bool bActivate);
	void ActivateStage(TEnumAsByte<EChaacKillAssistEvolutionStates> evolutionState);
	void AddKillAssist(int nNumToAdd);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_IncrementSkinState();
	void STATIC_ServerSetSkinLevel(unsigned char nSkinLevel);
};


// Class TgGame.TgAchievement_Geb_IllProtectYou
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_Geb_IllProtectYou : public UTgAchievement
{
public:
	int                                                m_HealthPercent;                                          // 0x0084(0x0004)
	unsigned long                                      m_Successful : 1;                                         // 0x0088(0x0004)
	class ATgPawn*                                     m_HitPawn;                                                // 0x008C(0x0008)
	int                                                m_nDeviceId;                                              // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Geb_IllProtectYou");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Geb_ShockWave
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Geb_ShockWave : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Geb_ShockWave");
		return ptr;
	}


	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgInventoryObject_Listen_GebUltimate
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_GebUltimate : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GebUltimate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_GebPassive
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_GebPassive : public UTgInventoryObject_Listen_Kill_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_GebPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Geb
// 0x0074 (0x262C - 0x25B8)
class ATgPawn_Geb : public ATgPawn_Character
{
public:
	TEnumAsByte<EGebBoulderState>                      r_eBoulderState;                                          // 0x25B8(0x0001) (Net)
	TEnumAsByte<EGebBoulderState>                      m_eLocalBoulderState;                                     // 0x25B9(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x25BA(0x0002) MISSED OFFSET
	struct FName                                       c_BoulderOutroAnimNames[0x3];                             // 0x25BC(0x0008)
	class UAnimNodeSequence*                           m_BoulderIntroSequenceNode;                               // 0x25D4(0x0008)
	unsigned long                                      m_bTriggerBoulderMeshChange : 1;                          // 0x25DC(0x0004)
	unsigned long                                      m_bTransformInProgress : 1;                               // 0x25DC(0x0004)
	int                                                m_BoulderMeshAssemblyIds[0x3];                            // 0x25E0(0x0004)
	struct FPointer                                    m_BoulderBodyMeshAssemblies[0x3];                         // 0x25EC(0x0008) (Native)
	struct FPointer                                    m_BoulderDestroyedMeshAssemblies[0x3];                    // 0x2604(0x0008) (Native)
	int                                                m_BoulderDesiredAssemblyId;                               // 0x261C(0x0004)
	int                                                m_BoulderDesiredDestroyedAssemblyId;                      // 0x2620(0x0004)
	float                                              m_fLastBoulderSpeed;                                      // 0x2624(0x0004)
	float                                              r_fRootlessGroundSpeed;                                   // 0x2628(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Geb");
		return ptr;
	}


	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void TriggerBoulderMeshChange();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void PostDemoRewind();
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	bool IsValidBoulderOutroName(const struct FName& AnimName);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void ClientPlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_CancelEmote(bool bVerifyNoRelevantEmotes, class UTgAnimNodeEmoteSequence* Exclude);
	void KillEmoteParticles();
	void STATIC_StartTransform(TEnumAsByte<EGebBoulderState> NewState, bool bSkipTransition);
	void STATIC_SwapTransformMesh();
	void STATIC_SwapToDestroyedMesh();
	void STATIC_SwapToLiveMesh();
	void STATIC_SetSpawnEnergy();
	void STATIC_PostPawnSetupServer();
	void STATIC_OnPostureChange();
	float STATIC_GetUIGroundSpeed();
};


// Class TgGame.TgPawn_Geb_PVE
// 0x0004 (0x2630 - 0x262C)
class ATgPawn_Geb_PVE : public ATgPawn_Geb
{
public:
	float                                              r_fTurnRateOverride;                                      // 0x262C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Geb_PVE");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	float STATIC_GetChargeTurnRate();
	void STATIC_SpawnOffspring();
};


// Class TgGame.TgAchievement_Nemesis_Prots
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Nemesis_Prots : public UTgAchievement
{
public:
	int                                                m_FiringInstance;                                         // 0x0084(0x0004)
	int                                                m_ProtectionStolen;                                       // 0x0088(0x0004)
	int                                                m_GoalAmount;                                             // 0x008C(0x0004)
	int                                                m_DeviceId;                                               // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Nemesis_Prots");
		return ptr;
	}


	float GetProtectionsStolen(class ATgPawn_Nemesis* Nemesis);
};


// Class TgGame.TgDevice_Nemesis_Num1
// 0x0004 (0x0540 - 0x053C)
class ATgDevice_Nemesis_Num1 : public ATgDevice_Charge
{
public:
	unsigned long                                      r_bHasDashed : 1;                                         // 0x053C(0x0004) (Net)
	unsigned long                                      r_bLastDash : 1;                                          // 0x053C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nemesis_Num1");
		return ptr;
	}


	void STATIC_ChargeTimeout();
	bool ShouldCooldownAfterFire();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	void UpdateDashState();
	bool STATIC_ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool ShouldTriggerCastReactionItems();
	void ReplicatedEvent(const struct FName& VarName);
	unsigned char STATIC_IncrementFiringInstance();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_Nemesis_Dev3
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Nemesis_Dev3 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nemesis_Dev3");
		return ptr;
	}


	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
};


// Class TgGame.TgDevice_Nemesis_Num3
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Nemesis_Num3 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nemesis_Num3");
		return ptr;
	}


	void RestartFiringWithParry();
};


// Class TgGame.TgDeviceForm_Nemesis_Num2
// 0x0014 (0x024C - 0x0238)
class UTgDeviceForm_Nemesis_Num2 : public UTgDeviceForm
{
public:
	TArray<class UTgSpecialFx*>                        c_Num2TargetFx;                                           // 0x0238(0x0010) (NeedCtorLink)
	int                                                c_Num2TargetFxId;                                         // 0x0248(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Nemesis_Num2");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingList(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgPawn_Nemesis
// 0x001C (0x25D4 - 0x25B8)
class ATgPawn_Nemesis : public ATgPawn_Character
{
public:
	int                                                r_nCurrentPassiveMeterEnergy;                             // 0x25B8(0x0004) (Net)
	int                                                r_nMaxPassiveMeterEnergy;                                 // 0x25BC(0x0004) (Net)
	int                                                m_nHealingInTakeDamage;                                   // 0x25C0(0x0004)
	class UTgSkeletalMeshComponent*                    m_Num2EffectsMeshComponent;                               // 0x25C4(0x0008) (ExportObject, Component, EditInline)
	class ATgDevice*                                   m_Num4SubDevice;                                          // 0x25CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Nemesis");
		return ptr;
	}


	void AdjustDamage(class AController* InstigatedBy, const struct FVector& HitLocation, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser, int* InDamage, struct FVector* Momentum);
	void ModifyHealthProp(int nDamage);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_Num2EffectDetachTimer();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	float STATIC_GetSmoothEnergy();
	bool STATIC_PawnCanDisplayImmuneMessage();
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	bool STATIC_DeviceOverrideManaUseVitals(class ATgDevice* Dev, class ATgPlayerController* PC);
};


// Class TgGame.TgProj_Nemesis_Num4ProtectionsSteal
// 0x0000 (0x03D0 - 0x03D0)
class ATgProj_Nemesis_Num4ProtectionsSteal : public ATgProj_SimulatedReturnStroke
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Nemesis_Num4ProtectionsSteal");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UpdateSeekingDirection(float fDeltaTime);
};


// Class TgGame.TgAchievement_Scylla_YesImAMonster
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_Scylla_YesImAMonster : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                               // 0x0084(0x0004)
	int                                                m_GoalAmount;                                             // 0x0088(0x0004)
	int                                                m_nNumResets;                                             // 0x008C(0x0004)
	int                                                m_nLastKillInstance;                                      // 0x0090(0x0004)
	float                                              m_fLastKillTime;                                          // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Scylla_YesImAMonster");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Scylla_Ultimate
// 0x0000 (0x047C - 0x047C)
class ATgDeploy_Scylla_Ultimate : public ATgDeploy_MovingEffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Scylla_Ultimate");
		return ptr;
	}


	void HandleTouch(class AActor* Other);
	bool KnockbackRangeCheck(class AActor* Other);
	bool STATIC_CanPerformKnockback(class AActor* Other);
	void STATIC_PerformKnockback(class AActor* Other);
};


// Class TgGame.TgDeployable_ScyllaWard
// 0x0010 (0x0420 - 0x0410)
class ATgDeployable_ScyllaWard : public ATgDeployable_Ward
{
public:
	class UMeshComponent*                              m_OverlayMesh;                                            // 0x0410(0x0008) (ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   m_OverlayMIC;                                             // 0x0418(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_ScyllaWard");
		return ptr;
	}

};


// Class TgGame.TgDevice_Scylla_Num3
// 0x0044 (0x0540 - 0x04FC)
class ATgDevice_Scylla_Num3 : public ATgDevice_Deployable
{
public:
	float                                              m_fTargetTime;                                            // 0x04FC(0x0004)
	unsigned long                                      m_bDeductCooldownTime : 1;                                // 0x0500(0x0004) (Const)
	unsigned long                                      m_bCanFireWithoutTarget : 1;                              // 0x0500(0x0004)
	float                                              m_fStopFireTimeStamp;                                     // 0x0504(0x0004)
	float                                              m_fCachedCooldownTime;                                    // 0x0508(0x0004)
	float                                              m_fCachedTweenTime;                                       // 0x050C(0x0004)
	class UTgDeviceFire*                               m_CachedFireMode;                                         // 0x0510(0x0008)
	TEnumAsByte<EScyllaSentinelState>                  m_eLocalState;                                            // 0x0518(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0519(0x0003) MISSED OFFSET
	class ATgCollisionProxy_Cylinder*                  m_HitProxy;                                               // 0x051C(0x0008)
	struct FVector                                     m_TweenStartLocation;                                     // 0x0524(0x000C)
	TArray<class AActor*>                              s_HitActors;                                              // 0x0530(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scylla_Num3");
		return ptr;
	}


	void TweenTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void InterruptFiring();
	void STATIC_OnPreTeleport();
	void STATIC_ClientSetState(TEnumAsByte<EScyllaSentinelState> NewState);
	void SetState(TEnumAsByte<EScyllaSentinelState> NewState, bool bStartCooldown);
	void STATIC_FireAmmunition();
	void ExpireTarget();
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void STATIC_EndToggledAction();
	bool ToggledAction(float* fPreHitDelay);
	bool STATIC_ServerDoToggledAction(class AActor* Target);
	bool STATIC_DoToggledAction();
	bool Use();
	bool ShouldCooldownAfterFire();
	bool CanUseToggle();
	unsigned char STATIC_IncrementFiringInstance();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetBuildupTime(int nMode);
	bool STATIC_CanBeCrippled();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_Scylla_Dev1
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Scylla_Dev1 : public ATgDevice_Range
{
public:
	unsigned long                                      m_bShowTargeter : 1;                                      // 0x04F0(0x0004)
	struct FVector                                     m_vHitLocation;                                           // 0x04F4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scylla_Dev1");
		return ptr;
	}


	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Scylla_Ultimate
// 0x0018 (0x0544 - 0x052C)
class ATgDevice_Scylla_Ultimate : public ATgDevice_StagingRefresh
{
public:
	class ATgPawn_Scylla*                              s_CachedScylla;                                           // 0x052C(0x0008)
	int                                                m_nShooterFireCount;                                      // 0x0534(0x0004)
	int                                                m_nCachedFireCountMax;                                    // 0x0538(0x0004)
	int                                                m_nShooterFireCountMax;                                   // 0x053C(0x0004)
	unsigned long                                      s_bFirstCast : 1;                                         // 0x0540(0x0004)
	unsigned long                                      s_bGodKilled : 1;                                         // 0x0540(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scylla_Ultimate");
		return ptr;
	}


	void OnStageShooterStopFire(bool bInterrupted);
	bool STATIC_CanRefreshPostHitDelay();
	bool CanJumpWhileFiring();
	bool CanBeCanceled();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Scylla_UltimateShooter
// 0x0006 (0x04FC - 0x04F6)
class ATgDevice_Scylla_UltimateShooter : public ATgDevice_TimerFromParent
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x04F6(0x0002) MISSED OFFSET
	float                                              m_fCachedDistanceScale;                                   // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scylla_UltimateShooter");
		return ptr;
	}


	bool ApplyGlobalOffhandCooldown();
	bool ShouldInterruptInhand();
};


// Class TgGame.TgEffectForm_Scylla_TentacleRoot
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_Scylla_TentacleRoot : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Scylla_TentacleRoot");
		return ptr;
	}


	void STATIC_DetachMeshes();
};


// Class TgGame.TgInventoryObject_Listen_ScyllaUltimate
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_ScyllaUltimate : public UTgInventoryObject_Listen_Staging
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ScyllaUltimate");
		return ptr;
	}

};


// Class TgGame.TgPawn_Scylla
// 0x0098 (0x2650 - 0x25B8)
class ATgPawn_Scylla : public ATgPawn_Character
{
public:
	unsigned char                                      m_bAbilityAtMaxRank[0x4];                                 // 0x25B8(0x0001)
	TEnumAsByte<EScyllaUltimateState>                  r_eUltimateState;                                         // 0x25BC(0x0001) (Net)
	TEnumAsByte<EScyllaUltimateState>                  m_eLocalUltState;                                         // 0x25BD(0x0001)
	TEnumAsByte<ETG_POSTURE>                           c_eUltimatePosture;                                       // 0x25BE(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x25BF(0x0001) MISSED OFFSET
	class UTgSkeletalMeshComponent*                    c_TentacleBuddy;                                          // 0x25C0(0x0008) (ExportObject, Component, EditInline)
	class UTgAnimNodeSlot*                             c_TentacleAnimSlot;                                       // 0x25C8(0x0008)
	int                                                r_nTentacleBuddyTicker;                                   // 0x25D0(0x0004) (Net)
	unsigned long                                      r_bPreTeleportFxActive : 1;                               // 0x25D4(0x0004) (Net)
	unsigned long                                      c_bPreTeleportFxActive : 1;                               // 0x25D4(0x0004)
	unsigned long                                      c_bTentaclesWereActive : 1;                               // 0x25D4(0x0004)
	unsigned long                                      c_bTentacleOverlaysWereActive : 1;                        // 0x25D4(0x0004)
	unsigned long                                      c_bFlamesWereActive : 1;                                  // 0x25D4(0x0004)
	int                                                c_nUltimatePostureId;                                     // 0x25D8(0x0004)
	struct FName                                       c_UltimateEndAnimName;                                    // 0x25DC(0x0008)
	struct FName                                       c_UltimateDeathAnimName;                                  // 0x25E4(0x0008)
	float                                              s_fUltimateTakeDownTime;                                  // 0x25EC(0x0004)
	int                                                r_nUltGodKillTrigger;                                     // 0x25F0(0x0004) (Net)
	float                                              s_fUltGodKillMinDelay;                                    // 0x25F4(0x0004)
	class UTgSpecialFx*                                c_GodKillFx;                                              // 0x25F8(0x0008) (Transient)
	struct FName                                       c_GodKillAnimName;                                        // 0x2600(0x0008)
	TArray<class UTgAnimNodeSlot*>                     c_GodKillAnimSlots;                                       // 0x2608(0x0010) (NeedCtorLink)
	TArray<class UAnimNodeSequence*>                   c_TentaclesActive;                                        // 0x2618(0x0010) (NeedCtorLink)
	TArray<class UAnimNodeSequence*>                   c_TentacleOverlaysActive;                                 // 0x2628(0x0010) (NeedCtorLink)
	TArray<class UAnimNodeSequence*>                   c_TentacleFlamesActive;                                   // 0x2638(0x0010) (NeedCtorLink)
	class UTgSkeletalMeshComponent*                    c_TentacleMeshComponent;                                  // 0x2648(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Scylla");
		return ptr;
	}


	void AdjustPawnMeshVisibility();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void STATIC_OnUltKillGod();
	void UltKillGodDelay();
	bool STATIC_IgnoreFaceRotationWithInterp();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void TriggerCobraStrike(const struct FVector& EndTrace);
	float BeginOffhand3Tween(const struct FVector& TweenLocation, int MovementType);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_TentacleTeleplort(float fRate);
	void ToggleSentinelFx(bool bEnable);
	bool CannotJumpNow();
	void STATIC_EndUltimateTakeDown();
	void UpdateUltimateState(TEnumAsByte<EScyllaUltimateState> NewState);
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_OnRespawn();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayTime, float ExcessTime);
	bool STATIC_PreTeleport(class ATeleporter* InTeleporter);
	void PreDemoRewind();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetMeshVectorValue(const struct FName& ScalarParam, struct FLinearColor* ColorValue);
	void STATIC_SetMeshScalarValue(const struct FName& ScalarParam, float ScalarValue);
	void STATIC_TentacleBuddyOn();
	bool STATIC_InitializeTentacleBuddy();
	void STATIC_FlashStartFire(int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target);
	void STATIC_FlashStopFire(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashBuildUp(int nDeviceInstanceId, int nFireModeNum, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void STATIC_OnPostureChange();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_SetSpawnEnergy();
	void STATIC_PostPawnSetupServer();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	bool STATIC_CalcOffhand3TweenLocation(class ATgPawn* Target, bool bFindValidLocation, struct FVector* TweenLocation);
	void STATIC_RemoveTentaclesWeights(class UAnimNodeSequence* SeqNode);
	void AddTentaclesWeights(class UAnimNodeSequence* SeqNode, bool bActive, bool bOverlayActive, bool bFlamesActive);
	bool STATIC_ShouldShowTentaclesThisTick();
	void STATIC_SetMeshVisibility(bool bVisible);
	void STATIC_OnMeshSwapped();
};


// Class TgGame.TgProj_Scylla_Num1
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Scylla_Num1 : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Scylla_Num1");
		return ptr;
	}


	void STATIC_SpawnClientEffects();
};


// Class TgGame.TgAnimNodeBlendByUllrStance
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByUllrStance : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Ullr*                                m_TgUllrPawn;                                             // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByUllrStance");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ullr_Arrow
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Ullr_Arrow : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ullr_Arrow");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Ullr_Num4
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Ullr_Num4 : public ATgDevice
{
public:
	float                                              m_TimeSinceLastManaCostApplied;                           // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ullr_Num4");
		return ptr;
	}


	void STATIC_ServerEndStance();
	void Tick(float DeltaTime);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool STATIC_ShouldApplyModeEquipEffects();
	bool STATIC_HasBeenTrained();
};


// Class TgGame.TgPawn_Ullr
// 0x0109 (0x26C1 - 0x25B8)
class ATgPawn_Ullr : public ATgPawn_Character
{
public:
	class UTgSpecialFx*                                m_ReloadArrowFX;                                          // 0x25B8(0x0008) (Transient)
	class ATgDevice*                                   m_UllrNum1Ranged;                                         // 0x25C0(0x0008) (Net)
	class ATgDevice*                                   m_UllrNum2Ranged;                                         // 0x25C8(0x0008) (Net)
	class ATgDevice*                                   m_UllrNum3Ranged;                                         // 0x25D0(0x0008) (Net)
	class ATgDevice*                                   m_UllrNum4Ranged;                                         // 0x25D8(0x0008) (Net)
	class ATgDevice*                                   m_UllrPassRanged;                                         // 0x25E0(0x0008)
	class ATgDevice*                                   m_UllrNum1Melee;                                          // 0x25E8(0x0008) (Net)
	class ATgDevice*                                   m_UllrNum2Melee;                                          // 0x25F0(0x0008) (Net)
	class ATgDevice*                                   m_UllrNum3Melee;                                          // 0x25F8(0x0008) (Net)
	class ATgDevice*                                   m_UllrNum4Melee;                                          // 0x2600(0x0008) (Net)
	class ATgDevice*                                   m_UllrPassMelee;                                          // 0x2608(0x0008)
	TArray<class UAnimSet*>                            m_MeleeAnimsets;                                          // 0x2610(0x0010) (NeedCtorLink)
	unsigned long                                      r_bIsUllrInMeleeStance : 1;                               // 0x2620(0x0004) (Net)
	unsigned long                                      c_bIsLocalUllrInMeleeStance : 1;                          // 0x2620(0x0004)
	unsigned long                                      s_bInHandSwapOnHold : 1;                                  // 0x2620(0x0004) (Transient)
	int                                                c_NumPostureId[0x4];                                      // 0x2624(0x0004)
	float                                              m_fPassiveStacks;                                         // 0x2634(0x0004)
	TArray<class UTgAnimNodeBlendList*>                c_GodMeleeAnimLists;                                      // 0x2638(0x0010) (NeedCtorLink)
	class ATgDevice*                                   r_CachedRangedDev1;                                       // 0x2648(0x0008) (Net)
	class ATgDevice*                                   r_CachedRangedDev2;                                       // 0x2650(0x0008) (Net)
	class ATgDevice*                                   r_CachedRangedDev3;                                       // 0x2658(0x0008) (Net)
	class ATgDevice*                                   r_CachedMeleeDev1;                                        // 0x2660(0x0008) (Net)
	class ATgDevice*                                   r_CachedMeleeDev2;                                        // 0x2668(0x0008) (Net)
	class ATgDevice*                                   r_CachedMeleeDev3;                                        // 0x2670(0x0008) (Net)
	class ATgDevice*                                   s_InHandMelee;                                            // 0x2678(0x0008)
	class ATgDevice*                                   s_InHandRanged;                                           // 0x2680(0x0008)
	struct FName                                       m_StanceAimOffsetProfileNames[0x4];                       // 0x2688(0x0008)
	TArray<class UAnimNodeAimOffset*>                  c_AimOffsets;                                             // 0x26A8(0x0010) (NeedCtorLink)
	class UTgSkeletalMeshComponent*                    c_BowStimMesh;                                            // 0x26B8(0x0008) (ExportObject, Component, EditInline)
	unsigned char                                      r_nShowBowStimMesh;                                       // 0x26C0(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ullr");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	struct FVector STATIC_GetFireLocationOffset(class ATgDevice* Dev);
	void UpdateBowMesh(unsigned char NewShowBowStim);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void ActivateArrowFX();
	void DeactivateArrowFX();
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void PlaySwapStanceEffects(bool bForce);
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void STATIC_OnRespawn();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveBool(int* bResult);
	void STATIC_ReduceRangedCooldown(float TimeReduced);
	void STATIC_ReduceMeleeCooldown(float TimeReduced);
	bool STATIC_InitializeReloadArrowFX();
	void LoadBowStimMesh();
	void STATIC_OnMeshSwapped();
	void STATIC_SwapToLiveMesh();
	void STATIC_SwapStance(bool bIsChangingToMelee);
	void STATIC_ChangeInhand(TEnumAsByte<EUllrInhandWeapon> NewInhand);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceOnStartCooldown(class ATgDevice* Device, float Cooldown);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_UllrSkin
// 0x002B (0x26EC - 0x26C1)
class ATgPawn_UllrSkin : public ATgPawn_Ullr
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x26C1(0x0003) MISSED OFFSET
	float                                              c_fCapeTransition;                                        // 0x26C4(0x0004)
	float                                              m_fCapeTransitionDuration;                                // 0x26C8(0x0004)
	float                                              c_fInitialCapeValue;                                      // 0x26CC(0x0004)
	float                                              r_fTargetCapeValue;                                       // 0x26D0(0x0004) (Net)
	int                                                c_nCurrentBowStimMeshId;                                  // 0x26D4(0x0004)
	class UMaterialInterface*                          m_MeleeMIC;                                               // 0x26D8(0x0008)
	class UMaterialInterface*                          m_RangedMIC;                                              // 0x26E0(0x0008)
	unsigned long                                      r_bBowBuffVis : 1;                                        // 0x26E8(0x0004) (Net)
	unsigned long                                      r_bMeleeBuffVis : 1;                                      // 0x26E8(0x0004) (Net)
	unsigned long                                      s_bBowBuffActive : 1;                                     // 0x26E8(0x0004)
	unsigned long                                      s_bMeleeBuffActive : 1;                                   // 0x26E8(0x0004)
	unsigned long                                      r_bT5WillWieldBow : 1;                                    // 0x26E8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_UllrSkin");
		return ptr;
	}


	void PlaySwapStanceEffects(bool bForce);
	int GetEvolvingItemSkinLevel();
	void SetHiddenInDeath(bool bHiddenDueToDeath);
	void UpdateBowMesh(unsigned char NewShowBowStim);
	void ActivateArrowFX();
	void Tick(float DeltaSeconds);
	void UpdateBuffVisibility();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void ResetCapeTransition();
	void UpdateSkinMIC();
	void STATIC_OnSkinLevelChanged();
	void UpdateT5AnimStance();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	class UClass* STATIC_DeviceOnOverrideDamageType(class ATgDevice* Dev, class UTgEffectGroup* EffectGroup);
	int STATIC_GetCurrentReloadFxId();
	int STATIC_GetCurrentBowStimMeshId();
	void STATIC_SwapStance(bool bIsChangingToMelee);
};


// Class TgGame.TgProj_Ullr_Num4
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Ullr_Num4 : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ullr_Num4");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgAchievement_Kumbhakarna_DownSetGut
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Kumbhakarna_DownSetGut : public UTgAchievement
{
public:
	int                                                m_nSuccessCount;                                          // 0x0084(0x0004)
	int                                                m_nTargetGoal;                                            // 0x0088(0x0004)
	int                                                m_nDeviceId;                                              // 0x008C(0x0004)
	unsigned long                                      m_bValidThrow : 1;                                        // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Kumbhakarna_DownSetGut");
		return ptr;
	}

};


// Class TgGame.TgDevice_Kumbhakarna_Num1
// 0x0020 (0x055C - 0x053C)
class ATgDevice_Kumbhakarna_Num1 : public ATgDevice_Charge
{
public:
	class ATgCollisionProxy*                           m_CollisionProxy;                                         // 0x053C(0x0008) (Transient)
	class ATgPawn*                                     m_ThrownPawn;                                             // 0x0544(0x0008)
	TArray<class AActor*>                              m_VictimList;                                             // 0x054C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kumbhakarna_Num1");
		return ptr;
	}


	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TweenEndTimer();
	void STATIC_ClientForcePostFire();
};


// Class TgGame.TgDevice_Kumbhakarna_Num2
// 0x0004 (0x052C - 0x0528)
class ATgDevice_Kumbhakarna_Num2 : public ATgDevice_Staging
{
public:
	unsigned long                                      m_bIsToggle : 1;                                          // 0x0528(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kumbhakarna_Num2");
		return ptr;
	}


	bool STATIC_ShouldInterruptReload();
	bool IsToggleDevice();
	bool StartFire();
	bool ShouldCooldownAfterFire();
	bool STATIC_CanDeviceFireInTargetingMode();
	bool CanBeCanceled();
	bool IsToggledOn();
	void UpdateUIToggleState();
};


// Class TgGame.TgDeviceFire_Kumbhakarna_Num2
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Kumbhakarna_Num2 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Kumbhakarna_Num2");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Kumbhakarna_Num3
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Kumbhakarna_Num3 : public UTgDeviceFire
{
public:
	unsigned long                                      m_bHitEnemyGod : 1;                                       // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Kumbhakarna_Num3");
		return ptr;
	}


	float GetCooldownTime();
	float STATIC_GetShotPowerCost(int nPacingType, bool bBaseOnly);
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceForm_Kumbhakarna_Num3
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Kumbhakarna_Num3 : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Kumbhakarna_Num3");
		return ptr;
	}


	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgPawn_Kumbhakarna
// 0x0188 (0x2740 - 0x25B8)
class ATgPawn_Kumbhakarna : public ATgPawn_Character
{
public:
	struct FPointer                                    VfTable_ITgExecuteVictimInterface;                        // 0x25B8(0x0008) (Const, Native, NoExport)
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                                       // 0x25C0(0x0140) (NeedCtorLink)
	unsigned long                                      r_bIsAsleep : 1;                                          // 0x2700(0x0004) (Net)
	unsigned long                                      r_bIsSleepPostureActive : 1;                              // 0x2700(0x0004) (Net)
	float                                              m_fFellAsleepTimeStamp;                                   // 0x2704(0x0004)
	float                                              m_fRespawnDeductionAmount;                                // 0x2708(0x0004)
	int                                                r_nNumHitsReceivedWhileSleeping;                          // 0x270C(0x0004) (Net)
	int                                                r_nMaxNumHitsWhileSleeping;                               // 0x2710(0x0004) (Net)
	int                                                m_nSleepingPostureID;                                     // 0x2714(0x0004)
	class ATgDeployable*                               s_UltWarningDeployable;                                   // 0x2718(0x0008)
	TArray<class ATgPawn_Apollo*>                      m_ApolloPawns;                                            // 0x2720(0x0010) (NeedCtorLink)
	TArray<struct FVictimCollisionData>                m_KnockedUpVictims;                                       // 0x2730(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Kumbhakarna");
		return ptr;
	}


	bool IsInClassSpecificChannel();
	bool CanApplyShield();
	void STATIC_PopSleepPostureTimer();
	void RemoveSleepEffect();
	void STATIC_RemoveSleepPosture();
	void UpdateSleepingEffects();
	void UpdateNum3Targeter();
	bool IsInputLocked();
	void CancelWarningDeployable();
	bool CanPlayHitReaction();
	bool STATIC_IgnoreFaceRotationWithInterp();
	bool ShouldRecharge();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void SetIsAsleep(bool bIsAsleep);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool STATIC_CanPreventDeathFrom(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_CanBeExecuted();
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_PawnCanDisplayImmuneMessage();
	void STATIC_SetSpawnEnergy();
	int STATIC_GetMaxHitsWhileSleeping();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_PawnOnPreDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	float AdjustRespawnTime(float InRespawnTime);
	bool STATIC_IsInvisible();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool STATIC_DeviceIsTargetingModeReady(class ATgDevice* Dev, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_Kumbhakarna_PVE
// 0x0000 (0x2740 - 0x2740)
class ATgPawn_Kumbhakarna_PVE : public ATgPawn_Kumbhakarna
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Kumbhakarna_PVE");
		return ptr;
	}


	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Osiris_AuraReformation
// 0x0004 (0x0528 - 0x0524)
class ATgDevice_Osiris_AuraReformation : public ATgDevice_Aura
{
public:
	int                                                m_PartsStackCount;                                        // 0x0524(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Osiris_AuraReformation");
		return ptr;
	}


	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void EndAura();
	void STATIC_FireAmmunition();
	void RemoveExtraBuff(class AActor* Other);
	bool StartFire();
	void ApplyExtraBuff(class AActor* Other);
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
	bool IsAuraActive();
};


// Class TgGame.TgDevice_Osiris_MummyWrap
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_Osiris_MummyWrap : public ATgDevice
{
public:
	unsigned long                                      c_bOverrideToggleOn : 1;                                  // 0x04F0(0x0004)
	TArray<struct FImpactInfo>                         ImpactsOnFireStart;                                       // 0x04F4(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Osiris_MummyWrap");
		return ptr;
	}


	void Remove(class ATgPawn* Pawn);
	bool CanJumpWhileFiring();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanBeInterrupted();
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void UpdateUIToggleState();
	bool IsToggledOn();
};


// Class TgGame.TgPawn_Osiris
// 0x0158 (0x2710 - 0x25B8)
class ATgPawn_Osiris : public ATgPawn_Character
{
public:
	TArray<class ATgPawn*>                             m_TetheredPawns;                                          // 0x25B8(0x0010) (NeedCtorLink)
	unsigned long                                      r_CanAttackDuringTether : 1;                              // 0x25C8(0x0004) (Net)
	unsigned long                                      m_bTetherFiring : 1;                                      // 0x25C8(0x0004)
	unsigned long                                      s_nPassiveInhandHasHit : 1;                               // 0x25C8(0x0004)
	unsigned long                                      m_bIsInSpectralState : 1;                                 // 0x25C8(0x0004)
	unsigned long                                      r_bUltActive : 1;                                         // 0x25C8(0x0004) (Net)
	class ATgPawn*                                     r_TetheredPawns[0x5];                                     // 0x25CC(0x0008) (Net)
	class ATgPawn*                                     c_TetheredPawns[0x5];                                     // 0x25F4(0x0008)
	class UTgStaticMeshComponent*                      c_TetherMeshComponents[0x5];                              // 0x261C(0x0008) (ExportObject, Component, EditInline)
	class UTgStaticMeshComponent*                      c_BreakingTetherMeshComponents[0x5];                      // 0x2644(0x0008) (ExportObject, Component, EditInline)
	float                                              c_TetherDestroyProgressPercentage[0x5];                   // 0x266C(0x0004)
	class USoundCue*                                   c_TetherSoundCue;                                         // 0x2680(0x0008)
	TEnumAsByte<EOsirisBodypartsMissing>               r_eCurrentPassiveState;                                   // 0x2688(0x0001) (Net)
	TEnumAsByte<EOsirisBodypartsMissing>               c_eLocalPassiveState;                                     // 0x2689(0x0001) (Transient)
	TEnumAsByte<ESoulTearState>                        r_UltState;                                               // 0x268A(0x0001) (Net, Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x268B(0x0001) MISSED OFFSET
	class UTgSpecialFx*                                c_PartsLostFx[0x9];                                       // 0x268C(0x0008) (Transient)
	int                                                r_nPassiveAttacksLeft;                                    // 0x26D4(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    m_PassiveMeshComponent;                                   // 0x26D8(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMaterialInstanceConstant*                   c_PassiveMIC;                                             // 0x26E0(0x0008)
	float                                              c_fBodyTransitionState;                                   // 0x26E8(0x0004)
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                                   // 0x26EC(0x0008)
	TArray<struct FChargeHitInfo>                      m_ChargeHitInfos;                                         // 0x26F4(0x0010) (NeedCtorLink)
	struct FVector                                     m_fChargeStartLocation;                                   // 0x2704(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Osiris");
		return ptr;
	}


	void STATIC_SetMeshDepthPriority(TEnumAsByte<ESceneDepthPriorityGroup> NewDepth);
	void UpdateIgnoreBlockingFlags();
	void STATIC_SetSpectralState(bool ShouldBeOn);
	void ResetPassiveStacks();
	void SetPassiveStacks(TEnumAsByte<EOsirisBodypartsMissing> eDesiredPart, unsigned char bForceInstant);
	void SetUltState(TEnumAsByte<ESoulTearState> NewState);
	void STATIC_SetUltimateInactive();
	void PlayUltimateHitAnim(bool HitGod);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void ApplyPassiveStacks();
	void UpdatePassiveState();
	void AllowAttacksDuringTether();
	void STATIC_RemoveTetherEffectGroups(class ATgPawn* TargetPawn);
	void UpdateTetherChainComponents(float DeltaSeconds);
	int GetTetheredPawnCount();
	void UpdateTetheredPawns();
	void AdjustPolymorphVisibilityClient();
	void SetBodyVisibility(TEnumAsByte<EOsirisBodypartsMissing> eDesiredPart);
	void UpdateVisibleMesh(float DeltaSeconds);
	void PopulateTetherList();
	void SetTargetingDevice(class ATgDevice* Dev);
	void Tick(float DeltaSeconds);
	bool loadfx();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void PreDemoRewind();
	bool STATIC_GetPassiveAuxMax(float* nResult);
	bool STATIC_GetPassiveAux(float* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_OnAttackDamagePropertyChange();
	class UTgSpecialFx* STATIC_CreateTetherSpecialFX();
	class UTgStaticMeshComponent* STATIC_CreateTetherMeshComponent();
	bool STATIC_InitializePartLossSpecialFX();
	bool STATIC_InitializePassiveMeshComponent();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void StartCharge(class ATgDevice* Dev);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgProj_Osiris_SoulRipDummy
// 0x0004 (0x03D0 - 0x03CC)
class ATgProj_Osiris_SoulRipDummy : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      bReturnFlight : 1;                                        // 0x03CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Osiris_SoulRipDummy");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool IsValidTarget(class AActor* A);
	bool STATIC_CheckTeamPassThrough(class AActor* Other);
	void UpdateSeekingDirection(float fDeltaTime);
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void Tick(float fDeltaTime);
	void STATIC_CreateSoulMesh(class ATgPawn* Target);
};


// Class TgGame.TgDeployable_Janus_WallPortal
// 0x0000 (0x04AC - 0x04AC)
class ATgDeployable_Janus_WallPortal : public ATgDeploy_AutoPortal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Janus_WallPortal");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Janus_FloorPortal
// 0x0000 (0x0414 - 0x0414)
class ATgDeployable_Janus_FloorPortal : public ATgDeployable_FloorPortal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Janus_FloorPortal");
		return ptr;
	}

};


// Class TgGame.TgDevice_Janus_Ultimate
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Janus_Ultimate : public ATgDevice_Range
{
public:
	class UTgInventoryObject_Listen_JanusPassive*      s_invObjPassive;                                          // 0x04F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Janus_Ultimate");
		return ptr;
	}


	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void STATIC_EnablePassive();
};


// Class TgGame.TgDevice_Janus_DeathGate
// 0x001C (0x0514 - 0x04F8)
class ATgDevice_Janus_DeathGate : public ATgDevice_Spline
{
public:
	float                                              m_fSamplesPerPeriod;                                      // 0x04F8(0x0004) (Const)
	class UTgInventoryObject_Listen_JanusPassive*      s_invObjPassive;                                          // 0x04FC(0x0008)
	TArray<struct FDeathGateHitInfo>                   s_ActiveTargets;                                          // 0x0504(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Janus_DeathGate");
		return ptr;
	}


	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void STATIC_EnablePassive();
	bool STATIC_CalculateFlightPath(int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Janus_A02_V2
// 0x001C (0x0530 - 0x0514)
class ATgDevice_Janus_A02_V2 : public ATgDevice_Janus_DeathGate
{
public:
	int                                                m_nMiddleProjectileId;                                    // 0x0514(0x0004) (Const)
	int                                                m_nMiddleProjectileIndex;                                 // 0x0518(0x0004) (Const)
	struct FDeathGateFiringInstanceTargetHits          s_firingInstanceTargetHits;                               // 0x051C(0x0014) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Janus_A02_V2");
		return ptr;
	}


	void TrackNewProjectileHit(class AActor* ATarget, TEnumAsByte<EDeathGateProjectileType> eProjType);
	void STATIC_ResetFiringInstanceTargetHits(unsigned char nFiringInstance);
	bool TrackProjectileHit(class AActor* ATarget, unsigned char nFiringInstance, TEnumAsByte<EDeathGateProjectileType> eProjType);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Janus_Ultimate
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Janus_Ultimate : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Janus_Ultimate");
		return ptr;
	}


	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceFire_Janus_DeathGate
// 0x0000 (0x01D4 - 0x01D4)
class UTgDeviceFire_Janus_DeathGate : public UTgDeviceFire_Spline_GapFill
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Janus_DeathGate");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgInventoryObject_Listen_JanusPortalPassThrough
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_JanusPortalPassThrough : public UTgInventoryObject_Listen
{
public:
	int                                                m_nSituationalType;                                       // 0x00D0(0x0004)
	unsigned long                                      m_bUseCooldown : 1;                                       // 0x00D4(0x0004)
	unsigned long                                      m_bSelfOnly : 1;                                          // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_JanusPortalPassThrough");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_JanusPassive
// 0x00AF (0x0187 - 0x00D8)
class UTgInventoryObject_Listen_JanusPassive : public UTgInventoryObject_Listen_JanusPortalPassThrough
{
public:
	unsigned long                                      m_bPassiveMagicPowerActive : 1;                           // 0x00D8(0x0004)
	int                                                m_nPowerScalingIndex;                                     // 0x00DC(0x0004)
	struct FJanusPowerScaledAbility                    m_PowerScalingAbilties[0xA];                              // 0x00E0(0x000C)
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               m_DeactivatePassiveOn;                                    // 0x0158(0x0010) (Transient, NeedCtorLink)
	unsigned char                                      m_PassiveActivatedDuring[0x1F];                           // 0x0168(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_JanusPassive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_JanusTransitions
// 0x0010 (0x00E8 - 0x00D8)
class UTgInventoryObject_Listen_JanusTransitions : public UTgInventoryObject_Listen_JanusPortalPassThrough
{
public:
	TArray<struct FTransitionsEffectGroupInfo>         m_TransitionsInfos;                                       // 0x00D8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_JanusTransitions");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_JanusUltimate
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_JanusUltimate : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_JanusUltimate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_JanusUltimate_V2
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_JanusUltimate_V2 : public UTgInventoryObject_Listen_JanusUltimate
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_JanusUltimate_V2");
		return ptr;
	}

};


// Class TgGame.TgPawn_Janus
// 0x0014 (0x25CC - 0x25B8)
class ATgPawn_Janus : public ATgPawn_Character
{
public:
	unsigned long                                      r_bPassiveActive : 1;                                     // 0x25B8(0x0004) (Net)
	unsigned long                                      c_bLocalPassiveActive : 1;                                // 0x25B8(0x0004)
	class UTgAnimNodeBlendList*                        c_PortalBlendList;                                        // 0x25BC(0x0008)
	struct FName                                       c_PortalBlendListName;                                    // 0x25C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Janus");
		return ptr;
	}


	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void UpdateJanusPassive(bool bActive);
	void STATIC_OnRespawn();
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void ResetInvisibleWalls();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgProj_Janus_PortalGenerator
// 0x0018 (0x03C4 - 0x03AC)
class ATgProj_Janus_PortalGenerator : public ATgProj_SimulatedPassThrough
{
public:
	struct FVector                                     m_LastLocation;                                           // 0x03AC(0x000C)
	float                                              m_fMinPortalDistance;                                     // 0x03B8(0x0004)
	float                                              m_fMaxPortalGenerationRange;                              // 0x03BC(0x0004)
	float                                              m_fEdgeOfWorldOffsetScaler;                               // 0x03C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Janus_PortalGenerator");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Rama_Ouch
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Rama_Ouch : public UTgAchievement
{
public:
	TArray<class ATgPawn*>                             m_CrippledEnemies;                                        // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Rama_Ouch");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Rama_Pro
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Rama_Pro : public UTgAchievement
{
public:
	int                                                m_nKillsDuringUlt;                                        // 0x0084(0x0004)
	unsigned long                                      m_bUltActive : 1;                                         // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Rama_Pro");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Ram_PickupArrow
// 0x0014 (0x03E8 - 0x03D4)
class ATgDeployable_Ram_PickupArrow : public ATgDeployable
{
public:
	unsigned long                                      m_Triggered : 1;                                          // 0x03D4(0x0004)
	float                                              r_InitialMeshOffset;                                      // 0x03D8(0x0004) (Net)
	struct FVector                                     m_TargetMeshOffset;                                       // 0x03DC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ram_PickupArrow");
		return ptr;
	}


	void TriggerDeployable(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_Rama_Psv
// 0x0010 (0x050C - 0x04FC)
class ATgDevice_Rama_Psv : public ATgDevice_Deployable
{
public:
	float                                              m_fBaseArrowDropChance;                                   // 0x04FC(0x0004) (Const)
	float                                              m_fDropChancePerLevel;                                    // 0x0500(0x0004) (Const)
	class ATgPawn_Ram*                                 m_rama;                                                   // 0x0504(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Rama_Psv");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void AttemptArrowDrop(const struct FImpactInfo& Impact);
	float STATIC_GetDropChance();
};


// Class TgGame.TgDevice_Ram_AimTowardsMovement
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Ram_AimTowardsMovement : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ram_AimTowardsMovement");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
	bool CanBeInterrupted();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Ram_AstralArrow
// 0x0018 (0x0540 - 0x0528)
class ATgDevice_Ram_AstralArrow : public ATgDevice_Staging
{
public:
	class ATgPawn_Ram*                                 s_CachedRam;                                              // 0x0528(0x0008)
	float                                              m_fReduceCooldownTimePerArrow;                            // 0x0530(0x0004) (Const)
	struct FName                                       m_nmCustomFireLockout;                                    // 0x0534(0x0008) (Const)
	float                                              s_fFireLockoutTime;                                       // 0x053C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ram_AstralArrow");
		return ptr;
	}


	void InterruptFiring();
	void OnStageShooterStopFire(bool bInterrupted);
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	bool CanJumpWhileFiring();
	bool CanBeCanceled();
	void STATIC_CustomFireLockout();
	bool LockStageShooterFiring();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Ram_AstralArrowShooter
// 0x001E (0x0514 - 0x04F6)
class ATgDevice_Ram_AstralArrowShooter : public ATgDevice_TimerFromParent
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x04F6(0x0002) MISSED OFFSET
	int                                                m_nAmmoCount;                                             // 0x04F8(0x0004)
	int                                                m_nMaxAmmoCount;                                          // 0x04FC(0x0004)
	int                                                m_nAmmoCountSituationalType;                              // 0x0500(0x0004)
	TArray<int>                                        m_nProjectileIds;                                         // 0x0504(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ram_AstralArrowShooter");
		return ptr;
	}


	void STATIC_ClientSetAmmoCount(int nAmmoCount);
	void SetAmmoCount(int nAmmoCount, bool bDoNotFowardToClient);
	void InterruptFiring();
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool ApplyGlobalOffhandCooldown();
	bool ShouldInterruptInhand();
	int STATIC_GetProjectileNum();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void RemoveEquipEffects();
	void ApplyEquipEffects();
	void TickTargetingMode(float DeltaSeconds);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Ram_Offhand1
// 0x0008 (0x04FC - 0x04F4)
class ATgDevice_Ram_Offhand1 : public ATgDevice_Toggle
{
public:
	float                                              m_ElapsedRechargeTime;                                    // 0x04F4(0x0004)
	float                                              m_LastTickCooldownUpdate;                                 // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ram_Offhand1");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	void Tick(float DeltaSeconds);
	bool CanBeCanceled();
	bool CanBeCanceledByRightMouse();
	bool IsActiveWhilefiring();
	bool ShouldTriggerCastReactionItems();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShowUICanFire();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDeviceFire_Ram_ArrowDeploy
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Ram_ArrowDeploy : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ram_ArrowDeploy");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_Ram_AstralArrow
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Ram_AstralArrow : public UTgDeviceFire
{
public:
	int                                                m_nProjectileHitOverride;                                 // 0x01C0(0x0004)
	int                                                m_nThirdHitSituationalType;                               // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ram_AstralArrow");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceForm_Ram_AstralArrow
// 0x0018 (0x0250 - 0x0238)
class UTgDeviceForm_Ram_AstralArrow : public UTgDeviceForm
{
public:
	unsigned long                                      c_bDoNotResetTargetingPulseIndex : 1;                     // 0x0238(0x0004) (Transient)
	int                                                c_nTargetingPulseIndex;                                   // 0x023C(0x0004)
	TArray<int>                                        c_TargetingFxIds;                                         // 0x0240(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Ram_AstralArrow");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingPulseIndex(int nIndex);
};


// Class TgGame.TgDeviceForm_Rama_Inhand
// 0x0020 (0x0258 - 0x0238)
class UTgDeviceForm_Rama_Inhand : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorB;                            // 0x0238(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFxB;                                       // 0x0240(0x0008)
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorC;                            // 0x0248(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFxC;                                       // 0x0250(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Rama_Inhand");
		return ptr;
	}


	void ExitTargetingMode();
	bool UsesTargetingMode();
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_Rama_A02
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_Rama_A02 : public UTgInventoryObject_Listen
{
public:
	int                                                m_nHitsForArrowRegen;                                     // 0x00D0(0x0004) (Const)
	class ATgPawn_Ram*                                 s_rama;                                                   // 0x00D4(0x0008)
	int                                                s_nCurrentHitCount;                                       // 0x00DC(0x0004)
	unsigned long                                      s_bA02BuffActive : 1;                                     // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Rama_A02");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RamaAstralStrike
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_RamaAstralStrike : public UTgInventoryObject_Listen_XbalanqueBranchingBola
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RamaAstralStrike");
		return ptr;
	}

};


// Class TgGame.TgPawn_Ram
// 0x00D8 (0x2690 - 0x25B8)
class ATgPawn_Ram : public ATgPawn_Character
{
public:
	class ATgDevice_ActiveMode*                        m_devAuto;                                                // 0x25B8(0x0008)
	class ATgDevice_Rama_Psv*                          m_devPsv;                                                 // 0x25C0(0x0008)
	class ATgDevice_Ram_Offhand1*                      m_devA01;                                                 // 0x25C8(0x0008)
	class ATgDevice*                                   m_devA02;                                                 // 0x25D0(0x0008)
	class ATgDevice_Ram_AimTowardsMovement*            m_devA03;                                                 // 0x25D8(0x0008)
	class ATgDevice_Ram_AstralArrow*                   m_devA04;                                                 // 0x25E0(0x0008)
	unsigned long                                      m_bDevicesCached : 1;                                     // 0x25E8(0x0004) (Const)
	unsigned long                                      s_bNum1HasHit : 1;                                        // 0x25E8(0x0004)
	unsigned long                                      r_bNum3BonusEffect : 1;                                   // 0x25E8(0x0004) (Net)
	unsigned long                                      s_bNum3ArrowConsumed : 1;                                 // 0x25E8(0x0004)
	unsigned long                                      m_bHasAdjustedCamera : 1;                                 // 0x25E8(0x0004)
	TEnumAsByte<ERamProjectile>                        m_eCurrentInhandActiveMode;                               // 0x25EC(0x0001)
	TEnumAsByte<ERamUltState>                          r_eUltimateState;                                         // 0x25ED(0x0001) (Net)
	TEnumAsByte<ERamUltState>                          m_eLocalUltState;                                         // 0x25EE(0x0001)
	TEnumAsByte<ETG_POSTURE>                           c_eUltimatePosture;                                       // 0x25EF(0x0001)
	struct FVector                                     s_ArrowLocation;                                          // 0x25F0(0x000C)
	struct FRotator                                    s_ArrowRotation;                                          // 0x25FC(0x000C)
	int                                                r_nUltimateAimPitch;                                      // 0x2608(0x0004) (Net)
	int                                                c_nUltimatePostureId;                                     // 0x260C(0x0004)
	struct FName                                       c_UltimateEndAnimName;                                    // 0x2610(0x0008)
	struct FName                                       c_UltimateDeathAnimName;                                  // 0x2618(0x0008)
	float                                              s_fUltimateTakeDownTime;                                  // 0x2620(0x0004)
	TArray<class UTgAnimBlendByFire*>                  c_UltimateFireNodes;                                      // 0x2624(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeAimOffset*>                c_UltimateAimOffsets;                                     // 0x2634(0x0010) (NeedCtorLink)
	struct FName                                       c_UltimateFireNodeName;                                   // 0x2644(0x0008)
	class UTgSkeletalMeshComponent*                    m_UltPropMesh;                                            // 0x264C(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fSmoothEnergy;                                          // 0x2654(0x0004)
	float                                              m_fSmoothEnergySpeed;                                     // 0x2658(0x0004)
	int                                                r_nQuiverAmmunitionCount;                                 // 0x265C(0x0004) (Net)
	class USkelControlBase*                            m_ArrowSkelControl[0x5];                                  // 0x2660(0x0008)
	float                                              c_fRemainingAmmoReplenishTime;                            // 0x2688(0x0004)
	float                                              s_fRamaHeightOnFire;                                      // 0x268C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ram");
		return ptr;
	}


	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
	bool IsInClassSpecificMovement();
	void ActivatePickupArrowFX();
	void STATIC_DeactivatePickupArrowFX();
	void ActivateArrowBones(int desiredArrow);
	void EndNum3BonusEffect();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	bool CannotJumpNow();
	void STATIC_OnRespawn();
	bool IsInForcedConsoleRestrictedPitch();
	float ApplyPitchLimit(float fPitch);
	void STATIC_EndUltimateTakeDown();
	void UpdateUltimateState(TEnumAsByte<ERamUltState> NewState);
	bool STATIC_IgnoreFaceRotationWithInterp();
	void ChangeInhandActiveMode(TEnumAsByte<ERamProjectile> newActiveMode);
	void UpdateQuiverAmmoReplenishTime(float NewTime);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void Tick(float DeltaSeconds);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateClientDevices(bool bForce);
	void STATIC_OnPostureChange();
	void STATIC_RamBasicAttackFiring(class ATgDevice* Dev);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void UpdateQuiverStatus();
	void STATIC_RecoverArrow();
	bool STATIC_OverrideDistanceFadeRange();
	void STATIC_CalcSmoothEnergy(float fDelta);
	void STATIC_SetSmoothEnergy(float Delta);
	void STATIC_SetSpawnEnergy();
	float STATIC_GetSmoothEnergy();
	void STATIC_RegainEnergyPool(float fDelta);
	void STATIC_PawnOnSpecialReset();
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnStopFire(class ATgDevice* Dev, bool bWasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool STATIC_DeviceOnCanDeviceCriticalStrike(class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgProj_Rama_Inhand_A03
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Rama_Inhand_A03 : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Rama_Inhand_A03");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Ram_AstralArrow
// 0x0004 (0x03C8 - 0x03C4)
class ATgProj_Ram_AstralArrow : public ATgProj_SimulatedGroundTarget_FixedTime_NoLob
{
public:
	int                                                m_nProjectileIndex;                                       // 0x03C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ram_AstralArrow");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Rama_Offhand1_Toggle
// 0x0004 (0x03B0 - 0x03AC)
class ATgProj_Rama_Offhand1_Toggle : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      m_bA03Buffed : 1;                                         // 0x03AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Rama_Offhand1_Toggle");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAchievement_Serqet_Critalicious
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Serqet_Critalicious : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nFiringInstance;                                        // 0x0088(0x0004)
	int                                                m_nStrikesWithCrits;                                      // 0x008C(0x0004)
	int                                                m_nTrackedStrike;                                         // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Serqet_Critalicious");
		return ptr;
	}


	int GetDeathbaneChargeNum(class ATgDevice* Dev);
};


// Class TgGame.TgAchievement_Serqet_ItsSpreading
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Serqet_ItsSpreading : public UTgAchievement
{
public:
	int                                                m_nSpreadCount;                                           // 0x0084(0x0004)
	int                                                m_nTargetGoal;                                            // 0x0088(0x0004)
	int                                                m_nDeviceId;                                              // 0x008C(0x0004)
	unsigned long                                      m_nValidSpread : 1;                                       // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Serqet_ItsSpreading");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendBySerqetUltimate
// 0x0004 (0x016C - 0x0168)
class UTgAnimBlendBySerqetUltimate : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bWasInterrupted : 1;                                    // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySerqetUltimate");
		return ptr;
	}


	void LosingFocus();
	void UltimateInterrupted();
	void BeginBackflip();
	void BeginGrab();
	bool STATIC_EndLeap();
	void BeginLeap();
};


// Class TgGame.TgCharmComponent_Serqet
// 0x0000 (0x00D8 - 0x00D8)
class UTgCharmComponent_Serqet : public UTgCharmComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCharmComponent_Serqet");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Serqet_Catalyst
// 0x0000 (0x0498 - 0x0498)
class ATgDeployable_Serqet_Catalyst : public ATgDeploy_ExplodingCylinder
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Serqet_Catalyst");
		return ptr;
	}


	float STATIC_GetExplosionTime();
};


// Class TgGame.TgDevice_Serqet_Passive
// 0x001C (0x0540 - 0x0524)
class ATgDevice_Serqet_Passive : public ATgDevice_PassiveAura
{
public:
	float                                              s_fTimeUntilStealth;                                      // 0x0524(0x0004)
	unsigned long                                      r_bPassiveActive : 1;                                     // 0x0528(0x0004) (Net)
	unsigned long                                      s_bStealthOn : 1;                                         // 0x0528(0x0004)
	unsigned long                                      s_bDeviceSwapped : 1;                                     // 0x0528(0x0004)
	int                                                m_nJumpDeviceId;                                          // 0x052C(0x0004)
	class ATgDevice*                                   r_JumpDevice;                                             // 0x0530(0x0008) (Net)
	class ATgDevice*                                   s_CachedInHand;                                           // 0x0538(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Serqet_Passive");
		return ptr;
	}


	void Tick(float DeltaTime);
	void STATIC_EquipJumpDevice(bool bEquip, bool bForce);
	void STATIC_SetStealth(bool bOn);
	void UpdatePassiveState(float DeltaSeconds, bool bForceOff, bool bJumpStartFire);
	void RemoveFromAllHitAura();
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
	void InterruptFiring();
	bool CanBeInterrupted();
	void ApplyEquipEffects();
};


// Class TgGame.TgDevice_Serqet_Deathbane
// 0x0064 (0x05A0 - 0x053C)
class ATgDevice_Serqet_Deathbane : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgSplineDeviceInterface;                         // 0x053C(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bStartDashRight : 1;                                    // 0x0544(0x0004)
	unsigned long                                      m_bDoNotUseTargetingRangeConstraint : 1;                  // 0x0544(0x0004)
	struct FVector2D                                   m_fTargetPointOffsetFromCenter;                           // 0x0548(0x0008)
	TArray<struct FVector>                             m_CachedTargetPoints;                                     // 0x0550(0x0010) (NeedCtorLink)
	int                                                m_nCurrentCacheAimIndex;                                  // 0x0560(0x0004)
	int                                                m_nNumTargetPoints;                                       // 0x0564(0x0004)
	float                                              m_fCachedSpeed;                                           // 0x0568(0x0004)
	class UClass*                                      m_FiringCameraModuleClass;                                // 0x056C(0x0008)
	class UClass*                                      m_PreviousCameraModuleClass;                              // 0x0574(0x0008)
	class UTgCameraModule*                             m_CachedCameraModule;                                     // 0x057C(0x0008)
	float                                              m_fCameraTweenInTime;                                     // 0x0584(0x0004)
	float                                              m_fCameraTweenOutTime;                                    // 0x0588(0x0004)
	struct FInterpCurveVector                          c_TargetingSpline;                                        // 0x058C(0x0014) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Serqet_Deathbane");
		return ptr;
	}


	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	bool PredictChargeHit(const struct FVector& ChargeDir, const struct FVector& ChargeStart, float fChargeRange, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	void TurnOffSpecialCamera();
	void TurnOnSpecialCamera();
	void InstantFire();
	void STATIC_ProcessChargeNumber(int nChargeNumber);
	unsigned char STATIC_GetMaxChargeValue();
	unsigned char STATIC_GetCurrentChargeValue();
	void GetAdjustedAimSpline(int nShotIndex, struct FAimData* Aim);
	float GetRefireTime(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	void TickTargetingMode(float DeltaSeconds);
	bool STATIC_CalculateFlightPath(int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim);
	void STATIC_GetCachedAim(struct FAimData* Aim);
	struct FAimData STATIC_CacheAim();
	bool UsesCachedAim();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_Serqet_LastBreath
// 0x0064 (0x0558 - 0x04F4)
class ATgDevice_Serqet_LastBreath : public ATgDevice_GroundTarget_LockOn
{
public:
	TEnumAsByte<ETweenState>                           m_eLeapTweenState;                                        // 0x04F4(0x0001)
	TEnumAsByte<EGrabState>                            m_eStingerGrabState;                                      // 0x04F5(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x04F6(0x0002) MISSED OFFSET
	int                                                m_nStunSituationalType;                                   // 0x04F8(0x0004)
	unsigned long                                      s_bStunApplied : 1;                                       // 0x04FC(0x0004)
	class ATgDevice*                                   r_BackflipDevice;                                         // 0x0500(0x0008) (Net)
	float                                              m_fTimeToSting;                                           // 0x0508(0x0004)
	class UTgDeviceFire*                               s_StingFireMode;                                          // 0x050C(0x0008)
	struct FAimData                                    s_StingAim;                                               // 0x0514(0x0030)
	float                                              m_fExplosionDeplayTime;                                   // 0x0544(0x0004)
	TArray<struct FLastBreathExplosionInfo>            m_ExplosionQueue;                                         // 0x0548(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Serqet_LastBreath");
		return ptr;
	}


	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
	void STATIC_FireAmmunition();
	void STATIC_DoSting();
	void STATIC_OnEndTween(bool bInterrupted);
	bool STATIC_ClientDoBackflip();
	bool STATIC_DoBackflip();
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	void Tick(float DeltaTime);
	bool IsAttackValid(struct FAimData* Aim);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_QueueLastBreathExplosion(const struct FVector& ExplosionLocation, class UTgDeviceFire* DeviceMode);
	bool STATIC_DoKnockBack(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
	float GetRefireTime(int nMode);
};


// Class TgGame.TgDevice_Serqet_Catalyst
// 0x0028 (0x0524 - 0x04FC)
class ATgDevice_Serqet_Catalyst : public ATgDevice_HitPulse
{
public:
	int                                                m_nCharmedMeleeDeviceId;                                  // 0x04FC(0x0004)
	int                                                m_nCharmedProjectileDeviceId;                             // 0x0500(0x0004)
	TArray<class UTgDeviceFire*>                       m_CharmedMeleeFireMode;                                   // 0x0504(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_CharmedProjectileFireMode;                              // 0x0514(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Serqet_Catalyst");
		return ptr;
	}


	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	class UTgDeviceFire* STATIC_GetCharmedProjectileMode(int nMode);
	class UTgDeviceFire* STATIC_GetCurrentCharmedProjectileMode();
	class UTgDeviceFire* STATIC_GetCharmedMeleeMode(int nMode);
	class UTgDeviceFire* STATIC_GetCurrentCharmedMeleeMode();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Serqet_Ambush
// 0x001E (0x0546 - 0x0528)
class ATgDevice_Serqet_Ambush : public ATgDevice_Staging
{
public:
	unsigned long                                      s_bStealthActive : 1;                                     // 0x0528(0x0004)
	unsigned long                                      r_bCanCancel : 1;                                         // 0x0528(0x0004) (Net)
	class ATgCollisionProxy*                           m_HitProxy;                                               // 0x052C(0x0008)
	TArray<class AActor*>                              s_PreventStealthList;                                     // 0x0534(0x0010) (NeedCtorLink)
	TEnumAsByte<ETG_TELEPORT_STATE>                    m_eStealthOnState;                                        // 0x0544(0x0001)
	TEnumAsByte<ETG_TELEPORT_STATE>                    m_eStealthOffState;                                       // 0x0545(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Serqet_Ambush");
		return ptr;
	}


	void AuraUnTouch(class AActor* Other);
	void AuraTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ToggleStealth(bool bOn);
	bool ShouldCancelStealth();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_ShouldRevealFromStealth();
};


// Class TgGame.TgDeviceFire_Serqet_LastBreath
// 0x0010 (0x01D4 - 0x01C4)
class UTgDeviceFire_Serqet_LastBreath : public UTgDeviceFire_GroundTarget_LockOn
{
public:
	TArray<float>                                      m_fDamageRadiusStack;                                     // 0x01C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Serqet_LastBreath");
		return ptr;
	}


	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceForm_Serqet_Deathbane
// 0x0004 (0x02A0 - 0x029C)
class UTgDeviceForm_Serqet_Deathbane : public UTgDeviceForm_SplineTarget
{
public:
	int                                                m_nSecondarySplineId;                                     // 0x029C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Serqet_Deathbane");
		return ptr;
	}


	class UStaticMesh* STATIC_GetDeformMesh(int nSplineId);
	void STATIC_CreateSplines();
};


// Class TgGame.TgInventoryObject_Listen_SerqetCatalyst
// 0x002C (0x00FC - 0x00D0)
class UTgInventoryObject_Listen_SerqetCatalyst : public UTgInventoryObject_Listen
{
public:
	int                                                m_nExtraEffectSituationalTypes[0x6];                      // 0x00D0(0x0004)
	TArray<int>                                        m_ConsumePoisonsOnHitFrom;                                // 0x00E8(0x0010) (NeedCtorLink)
	unsigned long                                      m_bRemovePoisonEffectGroups : 1;                          // 0x00F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SerqetCatalyst");
		return ptr;
	}


	void STATIC_ConsumePoisons(struct FImpactInfo* Impact);
};


// Class TgGame.TgInventoryObject_Listen_SerqetCharm
// 0x0000 (0x00FC - 0x00FC)
class UTgInventoryObject_Listen_SerqetCharm : public UTgInventoryObject_Listen_SerqetCatalyst
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SerqetCharm");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SerqetLastBreath
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_SerqetLastBreath : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SerqetLastBreath");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SerqetPassive
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_SerqetPassive : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SerqetPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Serqet
// 0x007C (0x2634 - 0x25B8)
class ATgPawn_Serqet : public ATgPawn_Character
{
public:
	TEnumAsByte<ETG_POSTURE>                           m_ePassivePosture;                                        // 0x25B8(0x0001)
	TEnumAsByte<ENewChargeState>                       r_eDeathBaneCharge;                                       // 0x25B9(0x0001) (Net)
	unsigned char                                      r_nTriggerEndUltimateAnimFailSafe;                        // 0x25BA(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x25BB(0x0001) MISSED OFFSET
	struct FName                                       m_PassiveLeapNodeName;                                    // 0x25BC(0x0008)
	TArray<class UTgAnimBlendByFire*>                  m_LeapFireNodes;                                          // 0x25C4(0x0010) (NeedCtorLink)
	TArray<class UTgAnimSequenceChain*>                m_DeathBaneChainNodes;                                    // 0x25D4(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeFitToDuration*>            m_DeathBaneRateNodes;                                     // 0x25E4(0x0010) (NeedCtorLink)
	int                                                m_nDeathBaneFireIndex;                                    // 0x25F4(0x0004)
	struct FName                                       m_DeathBaneChainNodeName;                                 // 0x25F8(0x0008)
	struct FName                                       m_DeathBaneRateNodeName;                                  // 0x2600(0x0008)
	int                                                r_nDeathBaneForwardYaw;                                   // 0x2608(0x0004) (Net)
	int                                                m_nDeathBaneChargeYaw;                                    // 0x260C(0x0004)
	float                                              r_fDeathBaneChargeRange;                                  // 0x2610(0x0004) (Net)
	float                                              r_fDeathBaneChargeSpeed;                                  // 0x2614(0x0004) (Net)
	struct FVector                                     r_vDeathBaneChargeStartLocation;                          // 0x2618(0x000C) (Net)
	TArray<class UTgAnimBlendBySerqetUltimate*>        m_UltimateBlendNodes;                                     // 0x2624(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Serqet");
		return ptr;
	}


	float STATIC_GetChargeInitialYaw();
	bool STATIC_ShouldOverrideChargeAccel();
	bool STATIC_ShouldCacheAndResetChargeValues();
	void STATIC_ResetChargeValues(unsigned char ChargeState, float fChargeInitialYaw, const struct FVector& vChargeInitialPosition, float fChargeSpeed, float fChargeRange, bool bChargeIngoreHumanoidBlocking, bool bWantsCharge, class ATgPawn* ChargeTarget);
	void STATIC_CacheChargeValues(unsigned char* ChargeState, float* fChargeInitialYaw, struct FVector* vChargeInitialPosition, float* fChargeSpeed, float* fChargeRange, int* bChargeIngoreHumanoidBlocking, int* bWantsCharge, class ATgPawn** ChargeTarget);
	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other, bool bAllowHitFromBehind);
	void EndPhysNewCharge(bool bInterrupted);
	void StartPhysNewCharge(TEnumAsByte<ENewChargeState> newChargeType, const struct FRotator& InitialDirection, const struct FVector& InitialLocation, float fChargeSpeed, float fChargeRange, bool bIngoreHumanoidBlocking, int NewMoveState);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_EndUltimateAnimFailSafe();
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void LastBreathGrabEnd();
	void STATIC_EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_EffectGroupCanBeHardCleared(class UTgEffectGroup* EffectGroup);
	struct FRotator TweenRelRotation(float fDeltaSeconds, const struct FRotator& currRel, const struct FRotator& targetRel);
	bool STATIC_DeviceOnCanDeviceCriticalStrike(class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
};


// Class TgGame.TgAchievement_Cabrakan_Tremors
// 0x0018 (0x009C - 0x0084)
class UTgAchievement_Cabrakan_Tremors : public UTgAchievement
{
public:
	TArray<struct FTremorsData>                        m_TrackedData;                                            // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nTargetTime;                                            // 0x0094(0x0004)
	int                                                m_nDeviceId;                                              // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Cabrakan_Tremors");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Vortex_Cabrakan_Dev3
// 0x0000 (0x02E0 - 0x02E0)
class ATgCollisionProxy_Vortex_Cabrakan_Dev3 : public ATgCollisionProxy_Vortex
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Vortex_Cabrakan_Dev3");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Cabrakan_Dev4_Wall
// 0x0008 (0x0414 - 0x040C)
class ATgDeployable_Cabrakan_Dev4_Wall : public ATgDeploy_Wall_Destructible
{
public:
	class ATgPawn_Cabrakan*                            m_OwningCabrakan;                                         // 0x040C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Cabrakan_Dev4_Wall");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool STATIC_IsInvisible(class AActor* TestActor);
	struct FVector STATIC_GetHudOverlayLocation();
};


// Class TgGame.TgDeployable_Cabrakan_Dev4_Ultimate
// 0x0008 (0x03DC - 0x03D4)
class ATgDeployable_Cabrakan_Dev4_Ultimate : public ATgDeployable
{
public:
	class ATgPawn_Cabrakan*                            m_OwningCabrakan;                                         // 0x03D4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Cabrakan_Dev4_Ultimate");
		return ptr;
	}


	void STATIC_InstantFireDeployable();
};


// Class TgGame.TgDevice_Cabrakan_Basic
// 0x0000 (0x0538 - 0x0538)
class ATgDevice_Cabrakan_Basic : public ATgDevice_ChainedMelee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cabrakan_Basic");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Cabrakan_Dev3
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Cabrakan_Dev3 : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cabrakan_Dev3");
		return ptr;
	}


	void InterruptFiring();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool CanBeCanceled();
	bool StartFire();
	bool IsToggledOn();
	void UpdateUIToggleState();
};


// Class TgGame.TgDeviceFire_Cabrakan_Dev4
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Cabrakan_Dev4 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cabrakan_Dev4");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcChargeTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float fRange, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Cabrakan_Dev4_UltimateShooter
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Cabrakan_Dev4_UltimateShooter : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cabrakan_Dev4_UltimateShooter");
		return ptr;
	}


	void STATIC_DeployWall(const struct FVector& vLocation, class AActor* FiringActor, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgMarkComponent_Cabrakan_Dev2
// 0x0000 (0x00BC - 0x00BC)
class UTgMarkComponent_Cabrakan_Dev2 : public UTgMarkComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_Cabrakan_Dev2");
		return ptr;
	}


	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgPawn_Cabrakan
// 0x0048 (0x2600 - 0x25B8)
class ATgPawn_Cabrakan : public ATgPawn_Character
{
public:
	TArray<class AActor*>                              m_Dev2TargetsHit;                                         // 0x25B8(0x0010) (NeedCtorLink)
	struct FVector                                     r_vDev2Location;                                          // 0x25C8(0x000C) (Net)
	struct FRotator                                    r_rDev2Rotation;                                          // 0x25D4(0x000C) (Net)
	int                                                r_nDev2Ticker;                                            // 0x25E0(0x0004) (Net)
	int                                                r_nDev2Stacks;                                            // 0x25E4(0x0004) (Net)
	float                                              r_fDev2Duration;                                          // 0x25E8(0x0004) (Net)
	unsigned long                                      c_bRefractionShieldFXActive : 1;                          // 0x25EC(0x0004)
	class UTgMarkComponent_Cabrakan_Dev2*              m_RefractionShieldMark;                                   // 0x25F0(0x0008) (ExportObject, Transient, Component, EditInline)
	class ATgCollisionProxy_Vortex_Cabrakan_Dev3*      m_Vortex;                                                 // 0x25F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Cabrakan");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_SpawnVortex(class ATgDevice* Dev);
	void LoadAndPlayDev2Mesh(const struct FVector& vLocation, const struct FRotator& rRotation);
	void UpdateDev2Stacks();
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_ReapplyLoadoutEffects();
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
};


// Class TgGame.TgProj_Cabrakan_Dev4_Ult
// 0x0014 (0x03AC - 0x0398)
class ATgProj_Cabrakan_Dev4_Ult : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x0398(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x039C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Cabrakan_Dev4_Ult");
		return ptr;
	}


	void ShutDown();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeployable_Sylvanus_Dev1
// 0x000C (0x03E0 - 0x03D4)
class ATgDeployable_Sylvanus_Dev1 : public ATgDeployable
{
public:
	unsigned long                                      m_bHasHit : 1;                                            // 0x03D4(0x0004)
	class ATgPawn*                                     m_OwningPawn;                                             // 0x03D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Sylvanus_Dev1");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable_Sylvanus_Sub1
// 0x0040 (0x0414 - 0x03D4)
class ATgDeployable_Sylvanus_Sub1 : public ATgDeployable
{
public:
	class ATgPawn*                                     m_OwningPawn;                                             // 0x03D4(0x0008)
	class UMaterialInstanceConstant*                   c_MIC;                                                    // 0x03DC(0x0008)
	float                                              m_SecondsSinceDeployed;                                   // 0x03E4(0x0004)
	unsigned long                                      m_bFullyDeployed : 1;                                     // 0x03E8(0x0004)
	TArray<class AActor*>                              s_ApplyList;                                              // 0x03EC(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03FC(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x040C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Sylvanus_Sub1");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void ProxyUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
	void Tick(float DeltaSeconds);
	void InitializeMIC();
	void STATIC_FindTouchingActorsWrapper(class AActor* Actor);
	bool STATIC_IsInvisible(class AActor* TestActor);
};


// Class TgGame.TgDevice_Sylvanus_NaturesGrasp
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Sylvanus_NaturesGrasp : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sylvanus_NaturesGrasp");
		return ptr;
	}


	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Sylvanus_HealingWisp
// 0x0048 (0x0538 - 0x04F0)
class ATgDevice_Sylvanus_HealingWisp : public ATgDevice
{
public:
	TArray<class AActor*>                              m_CurrentTargets;                                         // 0x04F0(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_EnemyProjectileFireModes;                               // 0x0500(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_FriendlyProjectileFireModes;                            // 0x0510(0x0010) (NeedCtorLink)
	int                                                m_nEnemyProjectileId;                                     // 0x0520(0x0004)
	int                                                m_nFriendlyProjectileId;                                  // 0x0524(0x0004)
	struct FPointer                                    m_pProjSetupEnemy;                                        // 0x0528(0x0008) (Native)
	struct FPointer                                    m_pProjSetupFriendly;                                     // 0x0530(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sylvanus_HealingWisp");
		return ptr;
	}


	class AProjectile* STATIC_FireWisp(class AActor* Target, const struct FAimData& Aim);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void UpdateTargetList(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Sylvanus_Auto
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Sylvanus_Auto : public UTgDeviceFire
{
public:
	int                                                m_nImpactCount;                                           // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Sylvanus_Auto");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	float STATIC_GetRange();
};


// Class TgGame.TgDeviceForm_Sylvanus_Auto
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Sylvanus_Auto : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Sylvanus_Auto");
		return ptr;
	}


	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgEffectForm_Sylvanus_Wisp
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_Sylvanus_Wisp : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Sylvanus_Wisp");
		return ptr;
	}

};


// Class TgGame.TgPawn_Sylvanus
// 0x0024 (0x25DC - 0x25B8)
class ATgPawn_Sylvanus : public ATgPawn_Character
{
public:
	TArray<class ATgDeployable_Sylvanus_Sub1*>         m_Blooms;                                                 // 0x25B8(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                c_PullBeamFx;                                             // 0x25C8(0x0008) (Transient)
	class UTgSkeletalMeshComponent*                    c_PullMissMeshComponent;                                  // 0x25D0(0x0008) (ExportObject, Transient, Component, EditInline)
	unsigned long                                      m_bCancelPull : 1;                                        // 0x25D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Sylvanus");
		return ptr;
	}


	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	void STATIC_PlayPullRetrieve();
	void KillPullBeam();
	void SetPullBeamTarget(class AActor* Target);
	void UnRegisterBloom(class ATgDeployable_Sylvanus_Sub1* BloomToRemove);
	void RegisterBloom(class ATgDeployable_Sylvanus_Sub1* NewBloom);
	void STATIC_PlayDyingEffects();
	void DetachDev3Mesh();
	void AttachDev3Mesh();
	void PassiveFire(class AActor* Target);
	bool PostPawnSetup();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	void STATIC_InitializePullBeamFx();
	void STATIC_ResetDev3MeshComponent();
	bool STATIC_InitializeDev3MeshComponent();
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_Sylvanus_NGM
// 0x0004 (0x25E0 - 0x25DC)
class ATgPawn_Sylvanus_NGM : public ATgPawn_Sylvanus
{
public:
	unsigned long                                      m_bIsGodFollowerBot : 1;                                  // 0x25DC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Sylvanus_NGM");
		return ptr;
	}


	void STATIC_OwnerJumpedTimer();
	void STATIC_SetInitialLevel();
	void STATIC_PostPawnSetupServer();
	void STATIC_OnOwnerJumped();
};


// Class TgGame.TgProj_Sylvanus_Dev3
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Sylvanus_Dev3 : public ATgProj_SimulatedPassThroughUntilGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Sylvanus_Dev3");
		return ptr;
	}


	void ShutDown();
	void ClientExplode(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SpawnFlightEffects();
};


// Class TgGame.TgAchievement_Nox_EmbraceTheDarkness
// 0x0028 (0x00AC - 0x0084)
class UTgAchievement_Nox_EmbraceTheDarkness : public UTgAchievement
{
public:
	int                                                m_nSiphonDarkDeviceId;                                    // 0x0084(0x0004)
	int                                                m_nShadowLockDeviceId;                                    // 0x0088(0x0004)
	int                                                m_nKillGoal;                                              // 0x008C(0x0004)
	int                                                m_nComboKills;                                            // 0x0090(0x0004)
	TArray<class ATgPawn*>                             m_SiphonTargets;                                          // 0x0094(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_ComboTarget;                                            // 0x00A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Nox_EmbraceTheDarkness");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_Nox_Candles
// 0x000C (0x0174 - 0x0168)
class UTgAnimNodeBlendList_Nox_Candles : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Nox*                                 OwningNoxPawn;                                            // 0x0168(0x0008) (Transient)
	int                                                CandleCount;                                              // 0x0170(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Nox_Candles");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Nox_NightTerror
// 0x0028 (0x03FC - 0x03D4)
class ATgDeployable_Nox_NightTerror : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_TouchingGods;                                           // 0x03D4(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_PreviouslyStunned;                                      // 0x03E4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03F4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Nox_NightTerror");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void Cleanup();
	void UntrackAllTracked();
	void UntrackActorAt(int Idx);
	void TrackActor(class AActor* tracked);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDeployable_Nox_Siphon
// 0x001C (0x03F0 - 0x03D4)
class ATgDeployable_Nox_Siphon : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03E4(0x0008)
	unsigned long                                      bCleaningUp : 1;                                          // 0x03EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Nox_Siphon");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void Cleanup();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_Nox_PassiveListener
// 0x000C (0x0530 - 0x0524)
class ATgDevice_Nox_PassiveListener : public ATgDevice_PassiveAura
{
public:
	class ATgCollisionProxy_PawnListener*              CollisionProxyListener;                                   // 0x0524(0x0008) (Transient)
	float                                              s_fSecondsBetweenAbilityProcs;                            // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nox_PassiveListener");
		return ptr;
	}


	void Destroyed();
	void STATIC_CollisionProxyDeviceOnStartFire(class ATgPawn* Other, class ATgDevice* OtherDevice);
	void UpdateCollisionProxyDelegates();
};


// Class TgGame.TgDevice_Nox_Dev3
// 0x0004 (0x0540 - 0x053C)
class ATgDevice_Nox_Dev3 : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bFirstFire : 1;                                         // 0x053C(0x0004)
	unsigned long                                      m_bInterruptOnCharge : 1;                                 // 0x053C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nox_Dev3");
		return ptr;
	}


	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldAllowGrab(class ATgPawn_Nox* OwnerPawn, class ATgPawn* OtherPawn);
	bool STATIC_ShouldStopOnThisHit(class AActor* Other);
	bool ShouldCooldownAfterFire();
	void InterruptFiring();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Nox_Dev1
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_Nox_Dev1 : public ATgDevice
{
public:
	TArray<class ATgProjectile*>                       s_ActiveProjectiles;                                      // 0x04F0(0x0010) (NeedCtorLink)
	unsigned long                                      m_bLockOutFiring : 1;                                     // 0x0500(0x0004)
	unsigned long                                      c_bPreventLockOut : 1;                                    // 0x0500(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nox_Dev1");
		return ptr;
	}


	void STATIC_SetLinkActor(class AActor* Target);
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_ClientSetLockOutFiringFlag(bool bLockOut);
	void STATIC_SetLockOutFiringFlag(bool bLockOut);
	void STATIC_ClearLockOutFlag();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool ShouldCooldownAfterFire();
	void InterruptFiring();
	bool CanBeCanceled();
	bool LinkedToTarget();
};


// Class TgGame.TgDevice_Nox_InHand
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Nox_InHand : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nox_InHand");
		return ptr;
	}


	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Nox_Dev3
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Nox_Dev3 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Nox_Dev3");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgPawn_Nox
// 0x00F4 (0x26AC - 0x25B8)
class ATgPawn_Nox : public ATgPawn_Character
{
public:
	int                                                r_nPassiveAbilitiesUsed;                                  // 0x25B8(0x0004) (Net)
	int                                                r_nPassiveAbilityMax;                                     // 0x25BC(0x0004) (Net)
	class UTgSpecialFx*                                c_CandleFx[0x4];                                          // 0x25C0(0x0008) (Transient)
	unsigned long                                      c_bHideCandles : 1;                                       // 0x25E0(0x0004) (Transient)
	unsigned long                                      m_bTickCheckGrabEnd : 1;                                  // 0x25E0(0x0004)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x25E4(0x0008) (ExportObject, Component, EditInline)
	int                                                m_Dev1Category;                                           // 0x25EC(0x0004)
	int                                                r_fLinkRange;                                             // 0x25F0(0x0004) (Net)
	class ATgPawn*                                     r_LinkedTarget;                                           // 0x25F4(0x0008) (Net)
	struct FShadowLockInfo                             c_LinkedTargetInfo;                                       // 0x25FC(0x003C) (Transient)
	int                                                m_nLinkBeamHandFxId;                                      // 0x2638(0x0004)
	class UTgSpecialFx*                                c_LinkBeamHandFx;                                         // 0x263C(0x0008)
	float                                              m_fDeadLinkShrinkRate;                                    // 0x2644(0x0004)
	struct FVector                                     m_vSpineOffset;                                           // 0x2648(0x000C)
	class UTgDeviceFire*                               m_LinkedTargetFire;                                       // 0x2654(0x0008)
	int                                                m_LinkMICId;                                              // 0x265C(0x0004)
	int                                                m_nDev3FriendlyCategory;                                  // 0x2660(0x0004)
	class ATgPawn*                                     r_AttachedTarget;                                         // 0x2664(0x0008) (Net)
	class UTgDeviceFire*                               m_AttachedTargetFire;                                     // 0x266C(0x0008)
	int                                                m_nEjectionExplosionFxId;                                 // 0x2674(0x0004)
	class UTgSpecialFx*                                c_EjectionExplosionFx;                                    // 0x2678(0x0008)
	int                                                m_nAOETargeterFxId;                                       // 0x2680(0x0004)
	class UTgSpecialFx*                                c_InsideAOETargeter;                                      // 0x2684(0x0008)
	class ATgSkeletalMeshActor*                        c_InsideAOETargeterMesh;                                  // 0x268C(0x0008)
	struct FVector                                     m_LastValidShadowLocation;                                // 0x2694(0x000C)
	class UTgEffectGroup*                              m_AttachedGroup;                                          // 0x26A0(0x0008)
	float                                              r_fAOETargetPercent;                                      // 0x26A8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Nox");
		return ptr;
	}


	void CleanupPostTempSpawn();
	bool IsInClassSpecificChannel();
	void TriggerEjectionFX();
	void ApplyPawnShadows(bool bOn);
	void OnDetachFromTarget();
	void OnAttachedToTarget();
	void STATIC_StartDev3Cooldown();
	void VerifyGrabEffectRemoved();
	void NotifyGrabEndIgnored();
	bool STATIC_ShouldGrabEnd(bool bInterrupted);
	bool IsGrabSourceValid(class ATgPawn* Target, bool bAllowTurrets, bool bAllowStealthed);
	void NoxGrabEnd(bool bInterrupted);
	void STATIC_EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	void TriggerEjectionExplosion();
	bool UpdateLinkedTarget(float DeltaTime, struct FShadowLockInfo* LinkInfo);
	void SetLinkedActor(class AActor* LinkedTarget, bool bEnable);
	struct FShadowLockInfo STATIC_CreateShadowLockInfo(class AActor* LinkedTarget);
	void DeactivateLinkedTarget();
	void STATIC_CheckLinkBreakSources();
	void STATIC_CheckLinkTargetRange();
	void STATIC_CalcLinkedTargetLocation(class AActor* SoulMate, struct FVector* LinkLocation);
	class UTgSpecialFx* STATIC_GetLinkedTargetFX(class UMaterialInstanceConstant* MIC);
	bool DeviceOverrideLockedDown(class ATgDevice* Device);
	void TogglePassiveFX(bool bNewHideState);
	void UpdatePassiveFx(int NewPassiveCount);
	bool loadfx();
	void UpdatePassiveStacks();
	void IncrementPassiveCount();
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void Tick(float DeltaSeconds);
	bool STATIC_SelfIsDeadOrDying();
	bool STATIC_TargetIsDeadOrDying();
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void PostDemoRewind();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateDev3TargetingFX();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_InitializeDev3AOEFX();
	bool STATIC_InitializeEjectionExplosion();
	bool STATIC_InitializePassiveCandleFX();
	void STATIC_OnPawnDied();
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	bool IsStealthed(class ATgRepInfo_Player* Viewer);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	bool STATIC_DeviceHasEnoughPowerPool(class ATgDevice* Dev, unsigned char FireModeNum);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
};


// Class TgGame.TgAchievement_AoKuang_AMightySword
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_AoKuang_AMightySword : public UTgAchievement
{
public:
	int                                                m_nAoKuangUltDeviceId;                                    // 0x0084(0x0004)
	class AActor*                                      m_ExecutionCandidate;                                     // 0x0088(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AoKuang_AMightySword");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByAoKuangAttack
// 0x0008 (0x0170 - 0x0168)
class UTgAnimBlendByAoKuangAttack : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_AoKuang*                             m_CachedAoKuang;                                          // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByAoKuangAttack");
		return ptr;
	}


	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgAnimBlendByAoKuangDragon
// 0x0004 (0x016C - 0x0168)
class UTgAnimBlendByAoKuangDragon : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bKeepPlaying : 1;                                       // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByAoKuangDragon");
		return ptr;
	}


	void STATIC_ContinueToSky();
};


// Class TgGame.TgAnimBlendByAoKuangWariness
// 0x0000 (0x0174 - 0x0174)
class UTgAnimBlendByAoKuangWariness : public UTgAnimNodeBlendByCombatWariness
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByAoKuangWariness");
		return ptr;
	}


	bool STATIC_ShouldBeWary();
};


// Class TgGame.TgCameraModule_AoKuangUltimate
// 0x003C (0x00E4 - 0x00A8)
class UTgCameraModule_AoKuangUltimate : public UTgCameraModule_ThirdPerson
{
public:
	float                                              fStoredZoomFactor;                                        // 0x00A8(0x0004)
	float                                              fStoredZoomFactorInterp;                                  // 0x00AC(0x0004)
	unsigned long                                      m_bOutroCurveActive : 1;                                  // 0x00B0(0x0004)
	float                                              m_fIntroTime;                                             // 0x00B4(0x0004)
	float                                              m_fOutroTime;                                             // 0x00B8(0x0004)
	struct FInterpCurveFloat                           m_IntroCurve;                                             // 0x00BC(0x0014) (NeedCtorLink)
	struct FInterpCurveFloat                           m_OutroCurve;                                             // 0x00D0(0x0014) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_AoKuangUltimate");
		return ptr;
	}


	void UpdateOffsetFromCurves(float DeltaSeconds);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void ActivateOutroCurve();
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void STATIC_CalculateCurveTangents();
};


// Class TgGame.TgDeploy_AoKuang_Tornadoes
// 0x0020 (0x03F4 - 0x03D4)
class ATgDeploy_AoKuang_Tornadoes : public ATgDeployable
{
public:
	TArray<class ATgProj_Tornado*>                     m_Tornadoes;                                              // 0x03D4(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               m_TornadoSpawnFiremode;                                   // 0x03E4(0x0008)
	float                                              m_fTornadoBlend;                                          // 0x03EC(0x0004)
	float                                              m_fTornadoDuration;                                       // 0x03F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_AoKuang_Tornadoes");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	class ATgProj_Tornado* STATIC_GetTornadoFor(class AActor* Actor);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable_AoKuang_WaterIllusion
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_AoKuang_WaterIllusion : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_AoKuang_WaterIllusion");
		return ptr;
	}


	void SpawningDeviceToggledOff();
	void STATIC_FireAmmunitionDeployable();
	void STATIC_DeployComplete();
	void STATIC_DeviceFired();
};


// Class TgGame.TgDevice_AoKuang_NewUltimate
// 0x00B4 (0x05A4 - 0x04F0)
class ATgDevice_AoKuang_NewUltimate : public ATgDevice
{
public:
	int                                                m_nDelayedKnockupSituationalType;                         // 0x04F0(0x0004)
	int                                                m_nDelayedMegaKillSituationalType;                        // 0x04F4(0x0004)
	int                                                m_nDelayedMegaKillProtectionSitType;                      // 0x04F8(0x0004)
	float                                              m_fMegaKillStunDelay;                                     // 0x04FC(0x0004)
	TEnumAsByte<ETweenState>                           m_MegaKillTweenType;                                      // 0x0500(0x0001)
	TEnumAsByte<ETG_DEATH_REASON>                      m_MegaKillDeathReason;                                    // 0x0501(0x0001)
	TEnumAsByte<ETweenState>                           m_NormalKnockUpTween;                                     // 0x0502(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0503(0x0001) MISSED OFFSET
	struct FImpactInfo                                 s_DelayedActionImpact;                                    // 0x0504(0x0078) (Component)
	struct FVector                                     s_vFallBackLocation;                                      // 0x057C(0x000C)
	unsigned long                                      s_bPerformedMegaKill : 1;                                 // 0x0588(0x0004)
	unsigned long                                      s_bTargetLost : 1;                                        // 0x0588(0x0004)
	TArray<struct FValidTargetInfo>                    s_ValidTargets;                                           // 0x058C(0x0010) (NeedCtorLink)
	int                                                s_nTargetingSituationalType;                              // 0x059C(0x0004)
	float                                              s_fTargetingHighlightRange;                               // 0x05A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AoKuang_NewUltimate");
		return ptr;
	}


	void STATIC_DeviceShutDown(bool bDeactivateMode, bool bResetCooldowns);
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void DeliverQueuedPendingHits();
	void STATIC_FireAmmunition();
	void STATIC_ClientForceFireAmmunition();
	void STATIC_TargetLost();
	void STATIC_FreeAllDelayedActionTargets();
	void CancelDelayedAction();
	void STATIC_EndDelayedAction();
	void BeginDelayedKnockUpTween(const struct FImpactInfo& Impact, class UTgDeviceFire* FireMode, bool bEndDelayedAction);
	bool BeginDelayedKnockUp(const struct FImpactInfo& Impact, class UTgDeviceFire* FireMode);
	void STATIC_DoMegaKill();
	void BeginDelayedMegaKillTween(const struct FImpactInfo& Impact, class UTgDeviceFire* FireMode);
	void STATIC_StartDragon();
	void MegaKillTargetDied(float fTimeRemaining, class AActor* Target);
	bool BeginDelayedMegaKill(const struct FImpactInfo& Impact, class UTgDeviceFire* FireMode, int nMode);
	void InterruptFiring();
	bool CanBeInterrupted();
	void STATIC_ClientToggleOn(bool bOn);
	void ToggleOn(bool bOn);
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool ShouldCooldownAfterFire();
	bool CancelledByJumping();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_FixFailedMegaKillFallLocation(class ATgPawn* Target);
	bool STATIC_ShouldForceMegaKill(class AActor* Target);
	void STATIC_ClearValidTargets();
	void STATIC_SpawnDeployable(class UTgDeviceFire* DeviceMode);
	bool STATIC_CanMegaKill(class AActor* A, class UTgDeviceFire* DeviceMode, bool bPredicting);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
};


// Class TgGame.TgDevice_AoKuang_Ultimate
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_AoKuang_Ultimate : public ATgDevice
{
public:
	float                                              m_fKillDelay;                                             // 0x04F0(0x0004)
	unsigned long                                      s_bPerformedMegaKill : 1;                                 // 0x04F4(0x0004)
	unsigned long                                      m_bTransformOnStopFire : 1;                               // 0x04F4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AoKuang_Ultimate");
		return ptr;
	}


	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void DeliverQueuedPendingHits();
	bool IsDeadGod(class AActor* A);
	void STATIC_FireAmmunition();
	void STATIC_ClientForceFireAmmunition();
	bool STATIC_DoMegaKill(const struct FImpactInfo& Impact, class UTgDeviceFire* FireMode, int nMode);
	bool STATIC_CanMegaKill(class AActor* A);
	void STATIC_ClientTransformOnStopFire();
	void TransformOnStopFire();
	void STATIC_ClientToggleOn(bool bOn);
	void ToggleOn(bool bOn);
	bool ShouldCooldownAfterFire();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
};


// Class TgGame.TgDevice_AoKuang_WaterIllusion
// 0x0000 (0x0514 - 0x0514)
class ATgDevice_AoKuang_WaterIllusion : public ATgDevice_TogglableDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AoKuang_WaterIllusion");
		return ptr;
	}


	void STATIC_DeviceFormToggleOff();
	bool STATIC_ServerToggleOff();
	bool ToggleOff();
	void ToggleOffConsumePowerPool(class ATgDeployable* deployable);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	unsigned char STATIC_FindDeployableFireModeNum(class ATgDeployable* deployable);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_AoKuang_UltimateJumpDown
// 0x0000 (0x0508 - 0x0508)
class ATgDevice_AoKuang_UltimateJumpDown : public ATgDevice_AnvilSlamBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AoKuang_UltimateJumpDown");
		return ptr;
	}


	void InterruptFiring();
	void STATIC_SpawnWarningDeployable();
};


// Class TgGame.TgDevice_AoKuang_DragonCall
// 0x0048 (0x0550 - 0x0508)
class ATgDevice_AoKuang_DragonCall : public ATgDevice_TwoPhase
{
public:
	class UTgDeviceFire*                               m_BuffFireMode;                                           // 0x0508(0x0008)
	int                                                m_nMaxDragonDeploys;                                      // 0x0510(0x0004) (Const)
	int                                                m_nRemainingDragonDeploys;                                // 0x0514(0x0004)
	unsigned long                                      m_bUseMiniProjectile : 1;                                 // 0x0518(0x0004)
	int                                                m_nMiniProjectileId;                                      // 0x051C(0x0004)
	struct FAimData                                    m_MiniProjAim;                                            // 0x0520(0x0030)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AoKuang_DragonCall");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	bool ShouldCancelStealth();
	void STATIC_OnStateSet(TEnumAsByte<ETwoPhaseState> PrevState, TEnumAsByte<ETwoPhaseState> CurrentState);
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void STATIC_FireAmmunition();
	void ExpireTarget();
	void RemoveBuff();
	bool ApplyBuff();
	bool UsesTrackingTarget();
	void FireMiniProjectile(class AActor* Target, class UTgDeviceFire* FireMode);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	unsigned char STATIC_IncrementFiringInstance();
	void STATIC_GetCachedAim(struct FAimData* Aim);
	float STATIC_GetToggleMaxTime(int nMode);
};


// Class TgGame.TgDeviceFire_AoKuang_KingsSword
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_AoKuang_KingsSword : public UTgDeviceFire
{
public:
	int                                                m_nCombatSituationalType;                                 // 0x01C0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AoKuang_KingsSword");
		return ptr;
	}


	void RemoveEquipEffects();
	void ApplyEquipEffects();
	void STATIC_RemovePassive();
	void STATIC_ReapplyPassive(bool bSkipRemove);
};


// Class TgGame.TgDeviceFire_AoKuang_WaterIllusion
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_AoKuang_WaterIllusion : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AoKuang_WaterIllusion");
		return ptr;
	}


	void STATIC_TeleportFire();
	void STATIC_CustomFire();
};


// Class TgGame.TgDeviceForm_AoKuang_WaterIllusion
// 0x0014 (0x024C - 0x0238)
class UTgDeviceForm_AoKuang_WaterIllusion : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_ProximityMeshIndicator;                                 // 0x0238(0x0008)
	class UTgSpecialFx*                                c_ProximityFx;                                            // 0x0240(0x0008)
	int                                                c_nProximityFxId;                                         // 0x0248(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AoKuang_WaterIllusion");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_AoKuang_NewUltimate
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_AoKuang_NewUltimate : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AoKuang_NewUltimate");
		return ptr;
	}


	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgInventoryObject_Listen_AoKuangDragonCall
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AoKuangDragonCall : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AoKuangDragonCall");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AoKuangKingsSword
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_AoKuangKingsSword : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AoKuangKingsSword");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_AoKuangNewUltimate
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Listen_AoKuangNewUltimate : public UTgInventoryObject_Listen
{
public:
	class UTgEffectGroup*                              MegaKillEffectGroup;                                      // 0x00D0(0x0008)
	TArray<class UTgEffectGroup*>                      KnockupEffectGroups;                                      // 0x00D8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AoKuangNewUltimate");
		return ptr;
	}


	void STATIC_FreeAllDelayedActionTargets();
};


// Class TgGame.TgInventoryObject_Listen_AoKuangWaterIllusion
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_AoKuangWaterIllusion : public UTgInventoryObject_Listen
{
public:
	int                                                m_nRemovableCategoryCode;                                 // 0x00D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AoKuangWaterIllusion");
		return ptr;
	}

};


// Class TgGame.TgPawn_AoKuang
// 0x0190 (0x2748 - 0x25B8)
class ATgPawn_AoKuang : public ATgPawn_Character
{
public:
	unsigned long                                      r_bSwordInHand : 1;                                       // 0x25B8(0x0004) (Net)
	unsigned long                                      c_bLocalSwordInHand : 1;                                  // 0x25B8(0x0004)
	unsigned long                                      c_bGlowOff : 1;                                           // 0x25B8(0x0004)
	unsigned long                                      m_bTransformInProgress : 1;                               // 0x25B8(0x0004)
	unsigned long                                      m_bTriggerTransformMeshChange : 1;                        // 0x25B8(0x0004)
	unsigned long                                      m_bTriggerTransformToNormalMesh : 1;                      // 0x25B8(0x0004)
	unsigned long                                      m_bUseBestDashLocation : 1;                               // 0x25B8(0x0004)
	float                                              s_fSwordExpireTime;                                       // 0x25BC(0x0004) (Const)
	float                                              c_fSwordSwapInCooldown;                                   // 0x25C0(0x0004)
	int                                                c_nSwordEnergyLevel;                                      // 0x25C4(0x0004)
	float                                              m_fDelayedSwordGlowShutdownTime;                          // 0x25C8(0x0004)
	TArray<class UTgAnimNodeBlendList*>                c_WaterIllusionBlendNodes;                                // 0x25CC(0x0010) (NeedCtorLink)
	struct FName                                       c_WaterIllusionNodeName;                                  // 0x25DC(0x0008)
	TArray<class UTgAnimNodeBlendList*>                c_DragonCallBlendNodes;                                   // 0x25E4(0x0010) (NeedCtorLink)
	struct FName                                       c_DragonCallNodeName;                                     // 0x25F4(0x0008)
	TEnumAsByte<EDragonBushelState>                    r_DragonBushelState;                                      // 0x25FC(0x0001) (Net)
	TEnumAsByte<EDragonBushelState>                    c_LocalDragonBushelState;                                 // 0x25FD(0x0001)
	TEnumAsByte<EAoKuangUltimateState>                 r_eUltimateState;                                         // 0x25FE(0x0001) (Net)
	TEnumAsByte<EAoKuangUltimateState>                 m_eLocalUltState;                                         // 0x25FF(0x0001)
	TEnumAsByte<EAOKUANG_TRANSFORM>                    r_CurrentTransformState;                                  // 0x2600(0x0001) (Net)
	TEnumAsByte<EAOKUANG_TRANSFORM>                    c_PrevTransformState;                                     // 0x2601(0x0001)
	TEnumAsByte<EAOKUANG_TRANSFORM>                    c_LocalTransformState;                                    // 0x2602(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x2603(0x0001) MISSED OFFSET
	int                                                m_DragonBushelAssemblyId;                                 // 0x2604(0x0004)
	struct FPointer                                    m_DragonBushelAssembly;                                   // 0x2608(0x0008) (Native)
	class USkeletalMeshComponent*                      c_DragonBushelMesh;                                       // 0x2610(0x0008) (ExportObject, Component, EditInline)
	TArray<class USkelControlBase*>                    c_DragonBushelDragonScalers;                              // 0x2618(0x0010) (NeedCtorLink)
	TArray<class USkelControlBase*>                    c_DragonBushelDissipateControls;                          // 0x2628(0x0010) (NeedCtorLink)
	TArray<class USkelControlBase*>                    c_DragonBushelCombineControls;                            // 0x2638(0x0010) (NeedCtorLink)
	struct FName                                       c_DragonBushelDragonScalerBaseName;                       // 0x2648(0x0008)
	struct FName                                       c_DragonBushelDragonSocketBaseName;                       // 0x2650(0x0008)
	struct FName                                       c_DragonBushelDissipateName;                              // 0x2658(0x0008)
	struct FName                                       c_DragonBushelCombineName;                                // 0x2660(0x0008)
	float                                              c_DragonBushelDissipateTime;                              // 0x2668(0x0004)
	float                                              c_DragonBushelCombineTime;                                // 0x266C(0x0004)
	TArray<class UAnimNodeSequence*>                   m_TransformIntroSequenceNodes;                            // 0x2670(0x0010) (NeedCtorLink)
	TArray<class UTgAnimBlendByAoKuangDragon*>         m_DragonAttackNodes;                                      // 0x2680(0x0010) (NeedCtorLink)
	struct FName                                       c_DragonAttackAnimName;                                   // 0x2690(0x0008)
	struct FName                                       c_UltimateDashAnimName;                                   // 0x2698(0x0008)
	struct FName                                       c_UltimateStunAnimName;                                   // 0x26A0(0x0008)
	struct FName                                       c_UltimateStunKillAnimName;                               // 0x26A8(0x0008)
	struct FName                                       c_TransformIntroAnimName;                                 // 0x26B0(0x0008)
	struct FName                                       c_TransformOutroAnimName;                                 // 0x26B8(0x0008)
	class AActor*                                      r_UltimateDastTarget;                                     // 0x26C0(0x0008) (Net)
	float                                              m_fDashTargetBufferSpace;                                 // 0x26C8(0x0004)
	struct FVector                                     m_BestDashLocation;                                       // 0x26CC(0x000C)
	class UTgEffectGroup*                              s_InterimCCImmunity;                                      // 0x26D8(0x0008)
	float                                              s_fUltimateCancelTime;                                    // 0x26E0(0x0004)
	class UClass*                                      c_UltimateCameraModuleClass;                              // 0x26E4(0x0008)
	class UClass*                                      c_PreviousCameraModuleClass;                              // 0x26EC(0x0008)
	class UTgCameraModule*                             c_UltimateCameraMod;                                      // 0x26F4(0x0008)
	int                                                m_TransformMeshAssemblyIds[0x2];                          // 0x26FC(0x0004)
	struct FPointer                                    m_TransformBodyMeshAssemblies[0x2];                       // 0x2704(0x0008) (Native)
	struct FPointer                                    m_TransformDestroyedMeshAssemblies[0x2];                  // 0x2714(0x0008) (Native)
	int                                                m_TransformDesiredAssemblyId;                             // 0x2724(0x0004)
	int                                                m_TransformDesiredDestroyedAssemblyId;                    // 0x2728(0x0004)
	int                                                r_nPSVStacks;                                             // 0x272C(0x0004) (Net)
	int                                                m_nMaxPSVStacks;                                          // 0x2730(0x0004)
	float                                              r_fPSVTimer;                                              // 0x2734(0x0004) (Net)
	TArray<unsigned long>                              m_bPSVTracking;                                           // 0x2738(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_AoKuang");
		return ptr;
	}


	bool IsInClassSpecificMovement();
	void STATIC_OnRespawn();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	struct FVector GetPhysTweenTargetLocation();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_DragonTweenEnd(bool bInterrupted, bool EndTransform);
	void STATIC_DashTweenEnd(bool bInterrupted);
	void STATIC_DragonTweenStart(bool bRemoveRoots);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void ToggleUltimateCameraMod(bool bOn);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void Combat(bool bInCombat);
	void Tick(float DeltaSeconds);
	bool IsFullBodyUltAnimPlaying();
	void STATIC_ClientUpdateUltimateState(TEnumAsByte<EAoKuangUltimateState> NewState);
	void STATIC_EndUltimateCancel();
	bool IsInputLocked();
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	void STATIC_ClientSetBestDashLocation(float DashX, float DashY, float DashZ);
	void STATIC_SetBestDashLocation(const struct FVector& BestLocation);
	void LoseUltimateDashTarget();
	void STATIC_SetUltimateDashTarget(class AActor* Target);
	void UpdateUltimateState(TEnumAsByte<EAoKuangUltimateState> NewState);
	void STATIC_DelayedSwordGlowShutdown();
	void UpdateSwordEnergyLevel(int nOverride, bool bForce);
	void STATIC_PutAwaySword();
	void SetSwordInHand(bool bInHand);
	bool IsSwordInHand();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_EndDragonBuff();
	void BeginDragonBuffCombine();
	void BeginDragonBuffDissipate();
	void UpdateDragonBushelState(TEnumAsByte<EDragonBushelState> NewState);
	void ReceivedPropValues();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetSpawnEnergy();
	void ApplyPSVReduction(class ATgDevice* Dev);
	void ApplyPSVHeal();
	int STATIC_CheckPSVSlot(class ATgDevice* Dev);
	void STATIC_ChangePSVState(class ATgDevice* Dev, bool NewState);
	bool STATIC_CheckPSVState(class ATgDevice* Dev);
	void STATIC_ClearPassiveStacks();
	void STATIC_ConsumePassiveStack(int nStackCount);
	void TimedPassiveStack();
	void AwardPassiveStack(int nStackCount);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnStopCooldown(class ATgDevice* Dev);
	void STATIC_DeviceOnStartCooldown(class ATgDevice* Dev, float fCooldownTime);
	bool STATIC_OverrideDistanceFadeRange();
	void AdjustMeshTranslation();
	void STATIC_SetMeshVisibility(bool bVisible);
	void STATIC_SwapTransformMesh();
	void STATIC_SwapToDestroyedMesh();
	void STATIC_SwapToLiveMesh();
	void STATIC_OnPostureChange();
	void STATIC_OnTransformTransitionEnd();
	void STATIC_StartTransform(TEnumAsByte<EAOKUANG_TRANSFORM> NewStance, bool bSkipTransition);
	bool STATIC_CalcBestDashLocation(class AActor* Target, struct FVector* BestLocation);
	struct FVector UsedDragonFromBushel();
	void BeginDragonBuff(TEnumAsByte<EDragonBushelState> StartState);
	void STATIC_CacheDragonBushelControls(class UTgSkeletalMeshComponent* SkelComp);
	void STATIC_CreateDragonBushelMesh();
	bool STATIC_DeviceOverrideManaUseVitals(class ATgDevice* Dev, class ATgPlayerController* PC);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	bool STATIC_DeviceHasEnoughPowerPool(class ATgDevice* Dev, unsigned char FireModeNum);
};


// Class TgGame.TgProj_AoKuang_DragonCallMini
// 0x002C (0x040C - 0x03E0)
class ATgProj_AoKuang_DragonCallMini : public ATgProj_SimulatedSeekingPassThrough
{
public:
	float                                              m_fExplosionDelay;                                        // 0x03E0(0x0004)
	class AActor*                                      m_ExplodeTarget;                                          // 0x03E4(0x0008)
	struct FVector                                     m_vExplodeHitLocation;                                    // 0x03EC(0x000C)
	struct FVector                                     m_vExplodeHitNormal;                                      // 0x03F8(0x000C)
	unsigned long                                      m_bExplodeFlashed : 1;                                    // 0x0404(0x0004)
	float                                              m_fInitialLifeSpan;                                       // 0x0408(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AoKuang_DragonCallMini");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_ExplodeOnTargetTimer();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostProjectileInitialize();
};


// Class TgGame.TgAnimBlendByAwilixMount
// 0x000C (0x0174 - 0x0168)
class UTgAnimBlendByAwilixMount : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Awilix*                              m_TgPawn;                                                 // 0x0168(0x0008)
	unsigned long                                      m_bWasMounted : 1;                                        // 0x0170(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByAwilixMount");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByAwilixUlt
// 0x0004 (0x016C - 0x0168)
class UTgAnimBlendByAwilixUlt : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      bFirstInit : 1;                                           // 0x0168(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByAwilixUlt");
		return ptr;
	}


	void WithPull();
};


// Class TgGame.TgAnimNotify_Disappear_AwilixMount
// 0x0003 (0x0068 - 0x0065)
class UTgAnimNotify_Disappear_AwilixMount : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Disappear_AwilixMount");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Awilix_KittenCannon
// 0x0000 (0x047C - 0x047C)
class ATgDeploy_Awilix_KittenCannon : public ATgDeploy_MovingEffectVolume_CustomCollisionExtent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Awilix_KittenCannon");
		return ptr;
	}

};


// Class TgGame.TgDevice_Awilix_Moonlight
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Awilix_Moonlight : public ATgDevice
{
public:
	class ATgPawn_Awilix*                              m_AwilixPawn;                                             // 0x04F0(0x0008)
	class UTgDeviceFire*                               m_BuffFireMode;                                           // 0x04F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Awilix_Moonlight");
		return ptr;
	}


	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	struct FImpactInfo GetPullTarget();
	void ApplyMoonlightBuff();
	void TriggerDelayReset();
	void StartMoonlightBuff(bool bApplyImmediately);
};


// Class TgGame.TgDevice_Awilix_Reposition
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Awilix_Reposition : public ATgDevice
{
public:
	int                                                m_nPounceDistance;                                        // 0x04F0(0x0004)
	int                                                m_nMaxTargetDistance;                                     // 0x04F4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Awilix_Reposition");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	bool CanBeCanceled();
	bool STATIC_CanLockOnToTarget(class AActor* Target);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool IsLockedDown();
	bool UsesCachedAim();
};


// Class TgGame.TgDevice_Awilix_StarlightLance
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Awilix_StarlightLance : public ATgDevice
{
public:
	unsigned long                                      m_bApplyHitSpecial : 1;                                   // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Awilix_StarlightLance");
		return ptr;
	}


	bool ShouldApplyHitSpecial();
	bool IsFacingAway(class AActor* TargetActor);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Awilix_JungleMount
// 0x0004 (0x052C - 0x0528)
class ATgDevice_Awilix_JungleMount : public ATgDevice_Staging
{
public:
	unsigned long                                      m_bShouldShooterStartCooldown : 1;                        // 0x0528(0x0004) (Const)
	unsigned long                                      m_bInStageInterruption : 1;                               // 0x0528(0x0004)
	unsigned long                                      m_bWasInterrupted : 1;                                    // 0x0528(0x0004)
	unsigned long                                      m_bCanShooterStartCooldown : 1;                           // 0x0528(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Awilix_JungleMount");
		return ptr;
	}


	void STATIC_ResetDevice();
	void STATIC_CancelMount();
	void STATIC_StartMount();
	void OnStageShooterStopFire(bool bInterrupted);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool SimulateStartFire();
	void OnStageShooterStartFire();
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	void InterruptFiring();
	bool ShouldTriggerCastReactionItems();
	bool CanJumpWhileFiring();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_ShouldRevealFromStealth();
};


// Class TgGame.TgDeviceFire_Awilix_Moonlight
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Awilix_Moonlight : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Awilix_Moonlight");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgInventoryObject_Listen_Awilix_FirstStrike
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Awilix_FirstStrike : public UTgInventoryObject_Listen_OutOfCombat
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Awilix_FirstStrike");
		return ptr;
	}

};


// Class TgGame.TgPawn_Awilix
// 0x00BC (0x2674 - 0x25B8)
class ATgPawn_Awilix : public ATgPawn_Character
{
public:
	unsigned long                                      s_bInitiatedLastCombat : 1;                               // 0x25B8(0x0004)
	unsigned long                                      c_bOnJungleMount : 1;                                     // 0x25B8(0x0004)
	unsigned long                                      r_bTriggerAOEFX : 1;                                      // 0x25B8(0x0004) (Net)
	TEnumAsByte<EeMountState>                          r_eMountState;                                            // 0x25BC(0x0001) (Net)
	TEnumAsByte<EeStarlightLanceState>                 r_nStarlightState;                                        // 0x25BD(0x0001) (Net)
	TEnumAsByte<EeMoonlightState>                      r_nMoonlightState;                                        // 0x25BE(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x25BF(0x0001) MISSED OFFSET
	int                                                m_nJungleFriendMeshID;                                    // 0x25C0(0x0004)
	class UTgSkeletalMeshComponent*                    c_JungleFriendMesh;                                       // 0x25C4(0x0008) (ExportObject, Component, EditInline)
	class ATgPawn*                                     r_RepositionTarget;                                       // 0x25CC(0x0008) (Net)
	float                                              m_fStartingYaw;                                           // 0x25D4(0x0004)
	float                                              m_fDiffYaw;                                               // 0x25D8(0x0004)
	int                                                r_nRepositionInHandMode;                                  // 0x25DC(0x0004) (Net)
	float                                              m_fCurrentTweenTime;                                      // 0x25E0(0x0004)
	int                                                m_nCurrentFSMode;                                         // 0x25E4(0x0004)
	int                                                m_nRepositionFXID;                                        // 0x25E8(0x0004)
	int                                                m_nRepositionTargeterID;                                  // 0x25EC(0x0004)
	int                                                m_nRepositionAOETargeterID;                               // 0x25F0(0x0004)
	int                                                m_nRepositionBeamID;                                      // 0x25F4(0x0004)
	class UTgSpecialFx*                                c_RepositionAOEFX;                                        // 0x25F8(0x0008)
	class UTgSpecialFx*                                c_RepositionTargeter;                                     // 0x2600(0x0008)
	class ATgSkeletalMeshActor*                        c_RepositionTargeterMesh;                                 // 0x2608(0x0008)
	class UTgSpecialFx*                                c_RepositionAOETargeter;                                  // 0x2610(0x0008)
	class ATgSkeletalMeshActor*                        c_RepositionAOETargeterMesh;                              // 0x2618(0x0008)
	class UTgSpecialFx*                                c_RepositionBeam;                                         // 0x2620(0x0008)
	class UMaterialInstanceConstant*                   c_UltGlowMIC;                                             // 0x2628(0x0008) (Transient)
	int                                                m_nMoonlightBeamFXID;                                     // 0x2630(0x0004)
	int                                                m_nMoonlightBubbleFXID;                                   // 0x2634(0x0004)
	class UTgSpecialFx*                                c_MoonlightBeamFX;                                        // 0x2638(0x0008)
	class UTgSpecialFx*                                c_MoonlightBubbleFX;                                      // 0x2640(0x0008)
	class ATgPawn*                                     r_PullTarget;                                             // 0x2648(0x0008) (Net)
	class ATgPawn*                                     r_BestPullTarget;                                         // 0x2650(0x0008) (Net)
	int                                                m_nMoonlightMarkID;                                       // 0x2658(0x0004)
	class UTgSpecialFx*                                c_MoonlightMark;                                          // 0x265C(0x0008)
	TArray<class UTgAnimBlendByAwilixUlt*>             m_UltPullBlendNodes;                                      // 0x2664(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Awilix");
		return ptr;
	}


	void AdjustPawnMeshVisibility();
	void CleanupPostTempSpawn();
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void SetMoonlightMaterial();
	void UltWillPull();
	void PlayMoonlightFullbody(bool bGrabbedTarget);
	void SetMoonlightPullTimer(float DelayTime);
	void TriggerRepositionFX();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_InterruptInhand(class ATgDevice* InterruptingDevice);
	struct FName GetDeathAnimName();
	void STATIC_PlayStarlightLanceAnim(bool bKnockup);
	void SetJungleFriendMesh(bool bAttach);
	void STATIC_PlayJungleFriendAnim(bool bInterrupted);
	void UpdateMountState();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_ResetRepositionTarget();
	void SetRepositionTarget(class ATgPawn* NewTarget, float ResetTime);
	void STATIC_OnRespawn();
	void STATIC_InCombatTimer();
	void EnterCombat(class ATgDevice* Device, class AActor* aInstigator, class AActor* ATarget, float fLength);
	bool PostPawnSetup();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void TransmitTiDiServer();
	void STATIC_SetMeshVisibility(bool bVisible);
	void STATIC_EndMoonlightTidiGrab();
	void STATIC_StartMoonlightTidiGrab();
	void TriggerMoonlightPull();
	void UpdateMoonlightTarget();
	bool IsValidMoonlightTarget(class ATgPawn* TestPawn);
	void UpdateRepositionFX();
	bool IsInAOEHit();
	bool IsValidRepositionTarget();
	bool STATIC_InitializeMoonlightFX();
	bool STATIC_InitializeRepositionFX();
	bool STATIC_InitializeJungleFriendMesh();
	void STATIC_FlashResetChainAttack(int nDeviceInstanceId);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnStartCooldown(class ATgDevice* Dev, float fCooldownTime);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void STATIC_PawnOnDeliverHits(TArray<struct FImpactInfo>* PendingHits);
	void STATIC_SetSpawnEnergy();
};


// Class TgGame.TgAchievement_HouYi_Crow
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_HouYi_Crow : public UTgAchievement
{
public:
	class AActor*                                      m_CrowTarget;                                             // 0x0084(0x0008)
	float                                              m_fLastSlow;                                              // 0x008C(0x0004)
	float                                              m_fLastKnockUp;                                           // 0x0090(0x0004)
	float                                              m_fLastStun;                                              // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HouYi_Crow");
		return ptr;
	}

};


// Class TgGame.TgAchievement_HouYi_Trick
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_HouYi_Trick : public UTgAchievement
{
public:
	TArray<struct FHitsPerBounce>                      m_SegmentHits;                                            // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_HouYi_Trick");
		return ptr;
	}


	bool UniqueHitPerSegment();
};


// Class TgGame.TgAnimNodeBlendList_HouYiT5Pet
// 0x0011 (0x0179 - 0x0168)
class UTgAnimNodeBlendList_HouYiT5Pet : public UTgAnimNodeBlendList
{
public:
	TArray<TEnumAsByte<EHouYiPetAnimType>>             m_eAnimTypes;                                             // 0x0168(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<EHouYiPetEvolution>                    m_ePet;                                                   // 0x0178(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_HouYiT5Pet");
		return ptr;
	}


	void STATIC_PlaySecondaryAnim(int nSelection);
	void STATIC_RestorePrimaryAnim();
};


// Class TgGame.TgAnimNotify_HouYiT5_HidePetMesh
// 0x0010 (0x0075 - 0x0065)
class UTgAnimNotify_HouYiT5_HidePetMesh : public UAnimNotify
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	class ATgPawn_HouYiSkin*                           m_houyiT5;                                                // 0x0068(0x0008) (Transient)
	unsigned long                                      m_bPetHidden : 1;                                         // 0x0070(0x0004) (Transient)
	TEnumAsByte<EHouYiPetEvolution>                    m_ePetType;                                               // 0x0074(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_HouYiT5_HidePetMesh");
		return ptr;
	}


	void ShowPet();
	void HidePet();
	void OnAnimNodeSequenceCeaseRelevant(class UAnimNodeSequence* OwningNode);
};


// Class TgGame.TgDevice_HouYi_Dev3
// 0x0040 (0x057C - 0x053C)
class ATgDevice_HouYi_Dev3 : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bSentTriggerFunction : 1;                               // 0x053C(0x0004)
	unsigned long                                      m_bDoNotTurnCollisionBackOn : 1;                          // 0x053C(0x0004)
	unsigned long                                      m_bLeapingOnStopFire : 1;                                 // 0x053C(0x0004)
	TEnumAsByte<ETweenState>                           m_eLeapTweenState;                                        // 0x0540(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0541(0x0003) MISSED OFFSET
	class UTgDeviceFire*                               m_ExplosionMode;                                          // 0x0544(0x0008)
	struct FAimData                                    m_ExplosionAim;                                           // 0x054C(0x0030)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HouYi_Dev3");
		return ptr;
	}


	void STATIC_CancelExplosion();
	void TriggerExplosion();
	void STATIC_ClientLeapTriggerSuccess();
	void STATIC_ClientLeapTriggerFailed();
	void STATIC_ServerTriggerLeap(const struct FAimData& ClientAim, float EndTraceX, float EndTraceY, int nCompressedRot);
	bool TriggerLeap();
	void STATIC_EndSecondaryTargeting();
	void BeginSecondaryTargeting();
	void STATIC_RestoreCollision();
	void STATIC_DisableCollision();
	bool Use();
	bool CanTriggerLeap();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_HouYi_Dev1_Shooter
// 0x0004 (0x04FC - 0x04F8)
class ATgDevice_HouYi_Dev1_Shooter : public ATgDevice_Spline
{
public:
	int                                                m_nMaxTargetingBounces;                                   // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HouYi_Dev1_Shooter");
		return ptr;
	}


	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	bool CanBeCanceled();
	bool STATIC_CalculateFlightPath(int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim);
};


// Class TgGame.TgDevice_HouYi_DivebombShooter
// 0x0008 (0x0510 - 0x0508)
class ATgDevice_HouYi_DivebombShooter : public ATgDevice_AnvilSlamBase
{
public:
	TEnumAsByte<ETweenState>                           m_eDiveBombTweenState;                                    // 0x0508(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0509(0x0003) MISSED OFFSET
	unsigned long                                      s_bDisableOnTweenEnd : 1;                                 // 0x050C(0x0004)
	unsigned long                                      m_bFixedTweenTime : 1;                                    // 0x050C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HouYi_DivebombShooter");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void STATIC_OnTweenEnd(bool bInterrupted);
	struct FVector GetTweenLocation(struct FAimData* Aim);
	float STATIC_GetTweenTime();
	void STATIC_ClientInterrupt();
	void Destroyed();
};


// Class TgGame.TgDeviceFire_HouYi_MarkHandling
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_HouYi_MarkHandling : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HouYi_MarkHandling");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceFire_HouYi_ChargedShot
// 0x000C (0x01CC - 0x01C0)
class UTgDeviceFire_HouYi_ChargedShot : public UTgDeviceFire_HouYi_MarkHandling
{
public:
	struct FPointer                                    VfTable_ITgSplineDeviceModeInterface;                     // 0x01C0(0x0008) (Const, Native, NoExport)
	int                                                m_nNumSections;                                           // 0x01C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HouYi_ChargedShot");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	struct FImpactInfo STATIC_CalcSplineFire(class AActor* DamageInstigator, bool bUseProximityDistance, bool bPredicting, struct FInterpCurveVector* Spline, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_HouYi_DiveBomb
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_HouYi_DiveBomb : public UTgDeviceFire_HouYi_MarkHandling
{
public:
	unsigned long                                      m_bUseSecondaryTargetingValues : 1;                       // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HouYi_DiveBomb");
		return ptr;
	}


	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	float STATIC_GetDamageRadius();
	float STATIC_GetRange();
};


// Class TgGame.TgInventoryObject_Listen_HouYiGoldenCrow
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_HouYiGoldenCrow : public UTgInventoryObject_Listen
{
public:
	TArray<class AActor*>                              m_CurrentMarkedTargets;                                   // 0x00D0(0x0010) (NeedCtorLink)
	int                                                m_MaxMarkedTargets;                                       // 0x00E0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HouYiGoldenCrow");
		return ptr;
	}

};


// Class TgGame.TgPawn_HouYi
// 0x0018 (0x25D0 - 0x25B8)
class ATgPawn_HouYi : public ATgPawn_Character
{
public:
	float                                              r_fPassiveDuration;                                       // 0x25B8(0x0004) (Net)
	TEnumAsByte<EHouYiDivebombState>                   r_CurrentDivebombState;                                   // 0x25BC(0x0001) (Net)
	TEnumAsByte<EHouYiDivebombState>                   c_LocalDivebombState;                                     // 0x25BD(0x0001)
	TEnumAsByte<ETG_POSTURE>                           m_eDiveBombPosture;                                       // 0x25BE(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x25BF(0x0001) MISSED OFFSET
	int                                                m_nDiveBombPostureId;                                     // 0x25C0(0x0004)
	unsigned long                                      s_bAppliedNotGrabSource : 1;                              // 0x25C4(0x0004)
	unsigned long                                      m_bIgnoreEndTweenLogic : 1;                               // 0x25C4(0x0004)
	class ATgDevice_HouYi_DivebombShooter*             s_DivebombShooter;                                        // 0x25C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_HouYi");
		return ptr;
	}


	bool IsLeaping();
	void STATIC_CancelDivebombAnim();
	void UpdatePassiveMIC();
	void STATIC_OnRespawn();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void UpdateDivebombState(TEnumAsByte<EHouYiDivebombState> NewState);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	float STATIC_GetPercPenetration(int nProtectionType, class AActor* Target);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
};


// Class TgGame.TgPawn_HouYiSkin
// 0x01A0 (0x2770 - 0x25D0)
class ATgPawn_HouYiSkin : public ATgPawn_HouYi
{
public:
	struct FHouYiPetAnimMetaData                       s_petAnimMetaData;                                        // 0x25D0(0x0030)
	struct FHouYiPetInfo                               m_petInfos[0x4];                                          // 0x2600(0x001C) (Const)
	struct FName                                       m_nmTimedShowA01Pet;                                      // 0x2670(0x0008) (Const)
	struct FName                                       m_nmTimedShowA02Pet;                                      // 0x2678(0x0008) (Const)
	unsigned char                                      m_nAbilityRankThreshold;                                  // 0x2680(0x0001) (Const)
	TEnumAsByte<EHouYiSkinState>                       r_eHouYiSkinState;                                        // 0x2681(0x0001) (Net)
	TEnumAsByte<EHouYiSkinState>                       c_eHouYiSkinState;                                        // 0x2682(0x0001)
	unsigned char                                      r_nSpawnedPetMask;                                        // 0x2683(0x0001) (Net)
	unsigned char                                      r_nVisiblePetMask;                                        // 0x2684(0x0001) (Net)
	unsigned char                                      r_nEvolvedPetMask;                                        // 0x2685(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x2686(0x0002) MISSED OFFSET
	class ATgPawn_Courier_FollowOwner*                 r_followerPets[0x4];                                      // 0x2688(0x0008) (Net)
	class ATgPawn*                                     r_secondaryPet;                                           // 0x26A8(0x0008) (Net)
	class ATgPawn_Courier_FollowOwner*                 r_recurrentAnimPet;                                       // 0x26B0(0x0008) (Net)
	int                                                r_nRecurrentAnimIndex;                                    // 0x26B8(0x0004) (Net)
	class ATgPawn_Courier_FollowOwner*                 c_recurrentAnimPet;                                       // 0x26BC(0x0008)
	class ATgPawn_Courier_FollowOwner*                 m_previousRecurrentPet;                                   // 0x26C4(0x0008)
	struct FName                                       m_nmStartRecurrentPetAnim;                                // 0x26CC(0x0008) (Const)
	struct FName                                       m_nmEndRecurrentPetAnim;                                  // 0x26D4(0x0008) (Const)
	float                                              m_fRecurrentAnimDelay;                                    // 0x26DC(0x0004) (Const)
	float                                              m_fRecurrentAnimDuration;                                 // 0x26E0(0x0004) (Const)
	int                                                c_nVxgRandomAnimationIndex;                               // 0x26E4(0x0004)
	int                                                s_nActiveVgxIndex;                                        // 0x26E8(0x0004)
	unsigned long                                      m_bUseRandomizedPetSelection : 1;                         // 0x26EC(0x0004) (Const)
	class UTgSkeletalMeshComponent*                    c_meshPets[0x4];                                          // 0x26F0(0x0008) (ExportObject, Component, EditInline)
	int                                                c_nVisibilityChangeFxIds[0x4];                            // 0x2710(0x0004) (Const)
	int                                                c_nVisibilityChangeOutFxIds[0x4];                         // 0x2720(0x0004) (Const)
	class UTgSpecialFx*                                c_visibilityChangeFx[0x4];                                // 0x2730(0x0008)
	class UTgSpecialFx*                                c_visibilityChangeOutFx[0x4];                             // 0x2750(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_HouYiSkin");
		return ptr;
	}


	void STATIC_ServerHouYiT5UpdatePetVisibility(TEnumAsByte<EHouYiPetEvolution> ePet, bool bVisible);
	void STATIC_ServerHouYiT5CancelVxg();
	void STATIC_ServerHouYiT5SetAnimationTypes(const struct FHouYiPetAnimMetaData& animData);
	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	void SendVxgCancelToServer();
	void ClientPlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	void PlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	bool PostPawnSetup();
	void RegisterPetAnimNodeReferences(class UTgSkeletalMeshComponent* meshPet);
	void ReplicatedEvent(const struct FName& VarName);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void STATIC_CancelEmote(bool bVerifyNoRelevantEmotes, class UTgAnimNodeEmoteSequence* Exclude);
	void STATIC_FlashPlayEmote(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	void STATIC_ClientGetAnimMetaData(struct FHouYiPetAnimMetaData* animData);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	bool STATIC_PlayFullBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, bool bBlendOutIfVelocityIsGreaterThanZero, bool bHideInHandDevice);
	void STATIC_ClientEndRecurrentPetAnim();
	void STATIC_ClientStartRecurrentPetAnim(class ATgPawn_Courier_FollowOwner* Pet);
	void STATIC_EndRecurrentPetAnim();
	void STATIC_StartRecurrentPetAnim();
	void STATIC_PawnOnExitCombat();
	void STATIC_PawnOnEnterCombat();
	void STATIC_ClientUpdateEvolvedPets();
	void STATIC_ClientUpdateVisiblePets();
	void STATIC_ClientUpdateSpawnedPets();
	void STATIC_OnSkinLevelChanged();
	void LevelUpSkin(unsigned char NewSkinLevel);
	void HidePet(TEnumAsByte<EHouYiPetEvolution> ePetEvolution);
	void ShowPet(TEnumAsByte<EHouYiPetEvolution> ePetEvolution);
	void STATIC_DespawnPet(TEnumAsByte<EHouYiPetEvolution> ePetEvolution);
	void STATIC_SpawnPet(TEnumAsByte<EHouYiPetEvolution> ePetEvolution);
	void TimedShowA02Pet();
	void TimedShowA01Pet();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_PawnOnRevive();
	void STATIC_PawnOnDied(class AController* pKiller);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_HouYiSkin_BasePet
// 0x0003 (0x24F8 - 0x24F5)
class ATgPawn_HouYiSkin_BasePet : public ATgPawn_Courier_FollowOwner
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x24F5(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_HouYiSkin_BasePet");
		return ptr;
	}


	bool ForceHideOnMinimap();
	void STATIC_OnOwnerPostTeleport();
};


// Class TgGame.TgPawn_HouYiSkin_PetA01
// 0x000C (0x2504 - 0x24F8)
class ATgPawn_HouYiSkin_PetA01 : public ATgPawn_HouYiSkin_BasePet
{
public:
	float                                              m_fHideTime;                                              // 0x24F8(0x0004) (Const)
	float                                              m_fZTranslateDistance;                                    // 0x24FC(0x0004) (Const)
	unsigned long                                      r_bIsUnderground : 1;                                     // 0x2500(0x0004) (Net)
	unsigned long                                      m_bCachedWorldCollide : 1;                                // 0x2500(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_HouYiSkin_PetA01");
		return ptr;
	}


	void STATIC_SetUndergroundStatus(bool bShouldForceUnderground);
	void STATIC_HidePetTimer();
};


// Class TgGame.TgProj_HouYi_Dev1
// 0x0038 (0x03E4 - 0x03AC)
class ATgProj_HouYi_Dev1 : public ATgProj_SimulatedPassThrough
{
public:
	int                                                m_nMaxHitsPerTarget;                                      // 0x03AC(0x0004) (Const)
	struct FVector                                     m_LastBounceLocation;                                     // 0x03B0(0x000C)
	int                                                m_nBounceCount;                                           // 0x03BC(0x0004)
	int                                                m_nMaxBounceCount;                                        // 0x03C0(0x0004)
	unsigned long                                      m_bApplyBounceVelocity : 1;                               // 0x03C4(0x0004)
	struct FVector                                     m_vBounceVelocity;                                        // 0x03C8(0x000C)
	TArray<class AActor*>                              m_TotalHitTargets;                                        // 0x03D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HouYi_Dev1");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
};


// Class TgGame.TgProj_HouYi_GoldenCrow
// 0x0030 (0x03FC - 0x03CC)
class ATgProj_HouYi_GoldenCrow : public ATgProj_SimulatedSeeking
{
public:
	struct FVector                                     m_TranslationFrequency;                                   // 0x03CC(0x000C)
	struct FVector                                     m_TranslationAmplitude;                                   // 0x03D8(0x000C)
	struct FVector                                     m_TranslationPhase;                                       // 0x03E4(0x000C)
	struct FVector                                     m_TranslationOffset;                                      // 0x03F0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_HouYi_GoldenCrow");
		return ptr;
	}


	bool UseAOE();
};


// Class TgGame.TgAchievement_Bellona_Master
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Bellona_Master : public UTgAchievement
{
public:
	TArray<struct FTrackedHits>                        m_HitInCombat;                                            // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Bellona_Master");
		return ptr;
	}


	bool IsShieldDevice(class ATgDevice* Dev);
	bool IsScourgeDevice(class ATgDevice* Dev);
	bool IsHammerDevice(class ATgDevice* Dev);
	bool IsDefaultDevice(class ATgDevice* Dev);
};


// Class TgGame.TgAchievement_Bellona_Rally
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Bellona_Rally : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Bellona_Rally");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_BellonaFlagMesh
// 0x0014 (0x0074 - 0x0060)
class UTgAnimMetaData_BellonaFlagMesh : public UAnimMetaData
{
public:
	unsigned long                                      bAllowOverlayMesh : 1;                                    // 0x0060(0x0004) (Edit)
	TArray<struct FFlagMeshParameterKeyFrame>          KeyFrames;                                                // 0x0064(0x0010) (Edit, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_BellonaFlagMesh");
		return ptr;
	}

};


// Class TgGame.TgAnimMetaData_BellonaWeaponSetOverride
// 0x0014 (0x0074 - 0x0060)
class UTgAnimMetaData_BellonaWeaponSetOverride : public UAnimMetaData
{
public:
	TEnumAsByte<EBellonaWeaponSet>                     WeaponSetOverride;                                        // 0x0060(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<struct FWeaponSetParameterKeyFrame>         KeyFrames;                                                // 0x0064(0x0010) (Edit, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_BellonaWeaponSetOverride");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByBellonaWeaponSetIdle
// 0x0006 (0x016E - 0x0168)
class UTgAnimBlendByBellonaWeaponSetIdle : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bCurrentlyBlockingWeaponSwap : 1;                       // 0x0168(0x0004)
	TEnumAsByte<EBellonaWeaponSet>                     m_PendingWeaponSet;                                       // 0x016C(0x0001)
	TEnumAsByte<EBellonaWeaponSet>                     m_ActiveWeaponSet;                                        // 0x016D(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByBellonaWeaponSetIdle");
		return ptr;
	}


	void STATIC_StartChangeWeaponSet(TEnumAsByte<EBellonaWeaponSet> NewSet, bool bInstant);
};


// Class TgGame.TgAnimNodeSequenceBellonaBlocker
// 0x0000 (0x01B4 - 0x01B4)
class UTgAnimNodeSequenceBellonaBlocker : public UTgAnimNodeSequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequenceBellonaBlocker");
		return ptr;
	}

};


// Class TgGame.TgDevice_Bellona_Inhand
// 0x0000 (0x0538 - 0x0538)
class ATgDevice_Bellona_Inhand : public ATgDevice_ChainedMelee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bellona_Inhand");
		return ptr;
	}


	unsigned char STATIC_GetCurrentFiringInstance();
};


// Class TgGame.TgDevice_Bellona_ShieldBash
// 0x0044 (0x0580 - 0x053C)
class ATgDevice_Bellona_ShieldBash : public ATgDevice_Charge
{
public:
	int                                                m_nCachedStackCount;                                      // 0x053C(0x0004) (Transient)
	TEnumAsByte<EBellonaWeaponSet>                     m_eSwitchToSet;                                           // 0x0540(0x0001)
	TEnumAsByte<EShieldBashState>                      m_eDoingConeAttack;                                       // 0x0541(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0542(0x0002) MISSED OFFSET
	struct FAimData                                    m_ConeAttackCachedAim;                                    // 0x0544(0x0030)
	class AActor*                                      s_FirstActorHit;                                          // 0x0574(0x0008)
	unsigned long                                      m_bRemoveHitActorFromConeDamage : 1;                      // 0x057C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bellona_ShieldBash");
		return ptr;
	}


	bool PredictChargeHit(const struct FVector& ChargeDir, const struct FVector& ChargeStart, float fChargeRange, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void ApplyConeAttack();
	void STATIC_DoConeAttack();
	void InterruptFiring();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void STATIC_ClientStartConeAttack();
	void STATIC_StartConeAttack();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetRefireTime(int nMode);
};


// Class TgGame.TgDevice_Bellona_SpinToStrike
// 0x000C (0x0528 - 0x051C)
class ATgDevice_Bellona_SpinToStrike : public ATgDevice_RadialSweep
{
public:
	TEnumAsByte<ESpinToStrikeState>                    m_eDoingStrikeAttack;                                     // 0x051C(0x0001)
	TEnumAsByte<EBellonaWeaponSet>                     m_eSwitchToSet;                                           // 0x051D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x051E(0x0002) MISSED OFFSET
	int                                                m_nHitGodCount;                                           // 0x0520(0x0004)
	unsigned long                                      m_bDoingStrikeTargeting : 1;                              // 0x0524(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bellona_SpinToStrike");
		return ptr;
	}


	void STATIC_EndSecondaryTargeting();
	void BeginSecondaryTargeting();
	void STATIC_OnApplyHitFromTouch(class UTgDeviceFire* firmode, struct FImpactInfo* Impact);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_CanRadialSweep();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void STATIC_DoStrikeAttack();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void InterruptFiring();
	bool CanBeInterrupted();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetRefireTime(int nMode);
	void UpdateAimWhileFiring(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Bellona_VeniVidiVici
// 0x0004 (0x04FC - 0x04F8)
class ATgDevice_Bellona_VeniVidiVici : public ATgDevice_TweenBase
{
public:
	float                                              m_fFlagOffsetX;                                           // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bellona_VeniVidiVici");
		return ptr;
	}


	struct FVector GetTweenLocation(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Bellona_ShieldBash
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Bellona_ShieldBash : public UTgDeviceFire
{
public:
	unsigned long                                      m_bDoingBlockAOE : 1;                                     // 0x01C0(0x0004)
	unsigned long                                      m_bForceConeRadius : 1;                                   // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Bellona_ShieldBash");
		return ptr;
	}


	void RemoveEquipEffects();
	void ApplyEquipEffects();
	int STATIC_RemoveLastModesBlockGroups();
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceFire_Bellona_SpinToStrike
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Bellona_SpinToStrike : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Bellona_SpinToStrike");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	float STATIC_GetRange();
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgInventoryObject_Listen_BellonaPassive
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_BellonaPassive : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bHitAppliedThisTick : 1;                                // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BellonaPassive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BellonaScourge
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_BellonaScourge : public UTgInventoryObject_Listen
{
public:
	TArray<struct FHealAdder>                          m_CanHealDevices;                                         // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BellonaScourge");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BellonaShieldBash
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_BellonaShieldBash : public UTgInventoryObject_Listen
{
public:
	TArray<struct FBlockStackAdder>                    m_CanAddBlockStacks;                                      // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BellonaShieldBash");
		return ptr;
	}

};


// Class TgGame.TgPawn_Bellona
// 0x0150 (0x2708 - 0x25B8)
class ATgPawn_Bellona : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_devPsv;                                                 // 0x25B8(0x0008)
	class ATgDevice*                                   m_devA01;                                                 // 0x25C0(0x0008)
	class ATgDevice*                                   m_devA02;                                                 // 0x25C8(0x0008)
	class ATgDevice*                                   m_devA03;                                                 // 0x25D0(0x0008)
	class ATgDevice*                                   m_devA04;                                                 // 0x25D8(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x25E0(0x0004) (Const)
	unsigned long                                      m_bWaitingForAnimationToSwap : 1;                         // 0x25E0(0x0004)
	unsigned long                                      m_bWaitingForInhandToSwap : 1;                            // 0x25E0(0x0004)
	unsigned long                                      m_bHideVisibleWeaponSet : 1;                              // 0x25E0(0x0004)
	float                                              m_fLocalPassiveLifeMax;                                   // 0x25E4(0x0004) (Transient)
	struct FWeaponSetInfo                              r_CurrentWeaponSetInfo;                                   // 0x25E8(0x0004) (Net)
	TEnumAsByte<EBellonaWeaponSet>                     s_ePreviousWeaponSet;                                     // 0x25EC(0x0001)
	TEnumAsByte<EBellonaWeaponSet>                     m_eLocalWeaponSet;                                        // 0x25ED(0x0001)
	TEnumAsByte<EBellonaWeaponSet>                     m_VisibleWeaponSet;                                       // 0x25EE(0x0001) (Transient)
	unsigned char                                      r_nShieldBashAOETicker;                                   // 0x25EF(0x0001) (Net)
	float                                              m_fWeaponSetLifetime;                                     // 0x25F0(0x0004)
	TArray<class UTgAnimBlendByBellonaWeaponSetIdle*>  m_WeaponSetStanceNodes;                                   // 0x25F4(0x0010) (NeedCtorLink)
	TArray<class UAnimNode*>                           m_WeaponSwapBlockers;                                     // 0x2604(0x0010) (NeedCtorLink)
	TArray<struct FVisibleWeaponOverrides>             m_WeaponSwapOverrides;                                    // 0x2614(0x0010) (NeedCtorLink)
	int                                                m_WeaponSetMeshAssemblyIds[0x5];                          // 0x2624(0x0004)
	struct FPointer                                    m_WeaponSetMeshAssembly;                                  // 0x2638(0x0008) (Native)
	TArray<class UAnimSet*>                            m_ActiveWeaponSetAnimSets;                                // 0x2640(0x0010) (NeedCtorLink)
	struct FPointer                                    m_VisibleWeaponSetAssembly;                               // 0x2650(0x0008) (Native, Transient)
	float                                              m_VisibleWeaponSetMaterialFlare;                          // 0x2658(0x0004) (Transient)
	struct FName                                       m_VisibleWaponsSetMaterialParamName;                      // 0x265C(0x0008) (Transient)
	class UTgSkeletalMeshComponent*                    m_VisibleWeaponSetMesh;                                   // 0x2664(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              m_fDesiredWeaponWeighting[0x5];                           // 0x266C(0x0004)
	float                                              m_fCachedWeaponWeighting[0x5];                            // 0x2680(0x0004) (Transient)
	int                                                m_WeaponSetDeviceIds[0x5];                                // 0x2694(0x0004) (Const)
	class ATgDevice*                                   r_BaseWeaponSet;                                          // 0x26A8(0x0008) (Net)
	class ATgDevice*                                   r_WeaponSets[0x5];                                        // 0x26B0(0x0008) (Net)
	struct FShieldBashRepInfo                          r_ShieldBashRepInfo;                                      // 0x26D8(0x0014) (Net)
	int                                                m_FlagMeshAssemblyId;                                     // 0x26EC(0x0004)
	class UTgSkeletalMeshComponent*                    m_FlagMesh;                                               // 0x26F0(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<struct FVisibleFlagMesh>                    m_VisibleFlagMeshInfos;                                   // 0x26F8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Bellona");
		return ptr;
	}


	void AdjustPawnMeshVisibility();
	void STATIC_ClientForceToWeaponSet(TEnumAsByte<EBellonaWeaponSet> NewSet);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void STATIC_FlashHammerStrikeFxs(const struct FVector& StrikeLocation, const struct FVector& ForwardVector);
	void STATIC_PlayShieldBashAOEFx();
	void FlashShieldBashAOEFx();
	void STATIC_PlayShieldBashConeFx();
	void STATIC_FlashShieldBashFxs(const struct FVector& BashLocation, const struct FVector& ForwardVector);
	void AttemptResetToSword();
	void RefreshWeaponSetTimer();
	void EnterCombat(class ATgDevice* Device, class AActor* aInstigator, class AActor* ATarget, float fLength);
	void STATIC_OnRespawn();
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void ReplicatedEvent(const struct FName& VarName);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_SetSpawnEnergy();
	void STATIC_SetMeshVisibility(bool bVisible);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_SwapToLiveMesh();
	void STATIC_CalcAndApplyWeaponSetWeightings(float DeltaSeconds, bool bForceToDesired);
	void STATIC_RemoveFlagMeshSequenceNode(class UAnimNodeSequence* RequestingNode);
	void AddFlagMeshSequenceNode(class UAnimNodeSequence* RequestingNode, bool bUseOverlay);
	void STATIC_RemoveWeaponVisualOverride(class UAnimNodeSequence* RequestingNode);
	void AddWeaponVisualOverride(TEnumAsByte<EBellonaWeaponSet> DesiredWeaponSet, float fSetWeight, class UAnimNodeSequence* RequestingNode);
	void STATIC_RemoveWeaponSetSwapBlocker(class UAnimNode* Blocker);
	void AddWeaponSetSwapBlocker(class UAnimNode* Blocker);
	void STATIC_ResetToSword();
	void UpdateLocalWeaponSet(const struct FWeaponSetInfo& WeaponSet, bool bRespawning);
	void STATIC_EndChangeWeaponSet(TEnumAsByte<EBellonaWeaponSet> NewSet, bool bSuccess);
	void STATIC_PerformDeviceSwap(TEnumAsByte<EBellonaWeaponSet> NewSet);
	void STATIC_StartChangeWeaponSet(TEnumAsByte<EBellonaWeaponSet> NewSet, bool bForce);
	void UpdateClientDevices(bool bForce);
};


// Class TgGame.TgAchievement_Medusa_LookAtMe
// 0x0000 (0x0094 - 0x0094)
class UTgAchievement_Medusa_LookAtMe : public UTgAchievement_DeviceXHitsWithEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Medusa_LookAtMe");
		return ptr;
	}

};


// Class TgGame.TgDamageType_MedusaUlt
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_MedusaUlt : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_MedusaUlt");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Medusa_Statue
// 0x0008 (0x043C - 0x0434)
class ATgDeployable_Medusa_Statue : public ATgDeployable_Statue
{
public:
	class ATgPawn_Medusa*                              m_OwningMedusa;                                           // 0x0434(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Medusa_Statue");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
};


// Class TgGame.TgDevice_Medusa_Dev4
// 0x0008 (0x0504 - 0x04FC)
class ATgDevice_Medusa_Dev4 : public ATgDevice_HitPulse
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                                       // 0x04FC(0x0004) (Net)
	float                                              m_FacingTowardCos;                                        // 0x0500(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Medusa_Dev4");
		return ptr;
	}


	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool StartFire();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanBeCanceled();
	void ReplicatedEvent(const struct FName& VarName);
	bool IsToggledOn();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Medusa_Dev1
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Medusa_Dev1 : public ATgDevice
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                                       // 0x04F0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Medusa_Dev1");
		return ptr;
	}


	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void InterruptFiring();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
	void ReplicatedEvent(const struct FName& VarName);
	bool IsToggledOn();
};


// Class TgGame.TgDevice_Medusa_Dev2
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Medusa_Dev2 : public ATgDevice_Range
{
public:
	unsigned long                                      c_bWillExplode : 1;                                       // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Medusa_Dev2");
		return ptr;
	}


	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Medusa_Dev2
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Medusa_Dev2 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Medusa_Dev2");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	struct FImpactInfo STATIC_GetTraceImpact(const struct FVector& StartTrace, const struct FVector& EndTrace, const struct FVector& Extent, bool bIgnoreWorld, bool bCheckLockOn, bool MapVisionAssist);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceForm_Medusa_Inhand
// 0x0014 (0x024C - 0x0238)
class UTgDeviceForm_Medusa_Inhand : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorB;                            // 0x0238(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFxB;                                       // 0x0240(0x0008)
	int                                                m_TargetingModeFxIdB;                                     // 0x0248(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Medusa_Inhand");
		return ptr;
	}


	void ExitTargetingMode();
	bool UsesTargetingMode();
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_MedusaDev1
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_MedusaDev1 : public UTgInventoryObject_Listen
{
public:
	int                                                m_nStacksRemaining;                                       // 0x00D0(0x0004)
	int                                                m_nFiringInstance;                                        // 0x00D4(0x0004)
	unsigned long                                      m_bStimShot : 1;                                          // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MedusaDev1");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_MedusaStealth
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_MedusaStealth : public UTgInventoryObject_Listen
{
public:
	int                                                m_nRemovableCategoryCode;                                 // 0x00D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_MedusaStealth");
		return ptr;
	}

};


// Class TgGame.TgPawn_Medusa
// 0x0060 (0x2618 - 0x25B8)
class ATgPawn_Medusa : public ATgPawn_Character
{
public:
	int                                                r_nNum1Stacks;                                            // 0x25B8(0x0004) (Net)
	class UTgSpecialFx*                                c_PheremonesFX;                                           // 0x25BC(0x0008)
	int                                                m_nPheremonesFXID;                                        // 0x25C4(0x0004)
	class UTgSpecialFx*                                c_PheremonesStacksFX[0x4];                                // 0x25C8(0x0008)
	int                                                m_nPheremonesStacksFXID[0x4];                             // 0x25E8(0x0004)
	class UTgDeviceFire*                               m_Num3FireMode;                                           // 0x25F8(0x0008)
	class ATgPawn*                                     m_MaulTarget;                                             // 0x2600(0x0008)
	class UMaterialInstanceConstant*                   c_StoneMat;                                               // 0x2608(0x0008)
	int                                                m_nStatueDeployID;                                        // 0x2610(0x0004)
	int                                                m_nMaxStatueCount;                                        // 0x2614(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Medusa");
		return ptr;
	}


	bool PostPawnSetup();
	void UpdatePheremonesFX(bool bReset);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SpawnStatue(class ATgPawn_Character* StatuePawn);
	bool STATIC_InitializePheremonesFX();
	bool STATIC_ShouldApplyExtraUltEffects(float MinimumAngle, class ATgPawn* TargetPawn);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool STATIC_GetPassiveInt1(int* nResult);
	float STATIC_GetStrafePercent();
	float STATIC_GetBackpedalPercent();
};


// Class TgGame.TgProj_Medusa_Dev2
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Medusa_Dev2 : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Medusa_Dev2");
		return ptr;
	}


	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_SpawnTheDeployableSpecial(const struct FVector& HitLocation, class AActor* TargetActor, const struct FVector& HitNormal);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool STATIC_ProximityReached(class AActor* A, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool IsValidTarget(class AActor* A);
	class ATgDeployable* STATIC_SpawnDeployable(const struct FVector& vLocation, class AActor* TargetActor, const struct FVector& vNormal);
};


// Class TgGame.TgAchievement_AhPuch_CorpsesAkaLandmines
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_AhPuch_CorpsesAkaLandmines : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nCorpseGoal;                                            // 0x0088(0x0004)
	int                                                m_nCorpseExplosionCount;                                  // 0x008C(0x0004)
	unsigned long                                      m_bHitGod : 1;                                            // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AhPuch_CorpsesAkaLandmines");
		return ptr;
	}

};


// Class TgGame.TgAchievement_AhPuch_RiseMyPretties
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_AhPuch_RiseMyPretties : public UTgAchievement
{
public:
	int                                                m_nDevice1Id;                                             // 0x0084(0x0004)
	int                                                m_nDevice3Id;                                             // 0x0088(0x0004)
	int                                                m_nZombieGoal;                                            // 0x008C(0x0004)
	int                                                m_nNumZombies;                                            // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AhPuch_RiseMyPretties");
		return ptr;
	}

};


// Class TgGame.TgDeployable_AhPuch_Dev1
// 0x0028 (0x03FC - 0x03D4)
class ATgDeployable_AhPuch_Dev1 : public ATgDeployable
{
public:
	unsigned long                                      s_bEffectApplied : 1;                                     // 0x03D4(0x0004)
	unsigned long                                      m_bForceDestroy : 1;                                      // 0x03D4(0x0004)
	unsigned long                                      m_bTimerDestroy : 1;                                      // 0x03D4(0x0004)
	unsigned long                                      m_Triggered : 1;                                          // 0x03D4(0x0004)
	unsigned long                                      m_bDestroyCorpseOnHit : 1;                                // 0x03D4(0x0004)
	unsigned long                                      m_bSkipFxOnDestroyCorpse : 1;                             // 0x03D4(0x0004)
	unsigned long                                      r_IsExploding : 1;                                        // 0x03D4(0x0004) (Net)
	unsigned long                                      m_bSpawnedByDev3 : 1;                                     // 0x03D4(0x0004)
	class UTgDeviceFire*                               s_EffectModeApplied;                                      // 0x03D8(0x0008)
	int                                                m_nExplodeFxId;                                           // 0x03E0(0x0004)
	class UTgSpecialFx*                                m_ExplodeFX;                                              // 0x03E4(0x0008)
	float                                              r_InitialMeshOffset;                                      // 0x03EC(0x0004) (Net)
	struct FVector                                     m_TargetMeshOffset;                                       // 0x03F0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_AhPuch_Dev1");
		return ptr;
	}


	void ExplodeFX();
	bool StopsProjectile(class AProjectile* P);
	void DestroyIt(bool bSkipFx);
	void SpecialDestroyIt(bool bSkipFx);
	void TriggerDeployable(class AActor* Other);
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_IsInvisible(class AActor* TestActor);
	void STATIC_SetSelected(bool bIsSelected);
	void STATIC_Detonate();
	void STATIC_DetonateNearbyCorpses(float Radius);
};


// Class TgGame.TgDeployable_AhPuch_Dev2
// 0x0008 (0x03DC - 0x03D4)
class ATgDeployable_AhPuch_Dev2 : public ATgDeployable
{
public:
	class ATgPawn_AhPuch*                              r_PawnOwner;                                              // 0x03D4(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_AhPuch_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDevice_AhPuch_Dev1
// 0x0010 (0x0518 - 0x0508)
class ATgDevice_AhPuch_Dev1 : public ATgDevice_TwoPhase
{
public:
	TArray<class ATgProjectile*>                       s_ActiveProjectiles;                                      // 0x0508(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AhPuch_Dev1");
		return ptr;
	}


	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void STATIC_FireAmmunition();
	void STATIC_OnStateSet(TEnumAsByte<ETwoPhaseState> PrevState, TEnumAsByte<ETwoPhaseState> CurrentState);
	void STATIC_SetAltFireReady();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_AhPuch_EmptyTheCrypts
// 0x0028 (0x0530 - 0x0508)
class ATgDevice_AhPuch_EmptyTheCrypts : public ATgDevice_TwoPhase
{
public:
	TArray<int>                                        m_StunsPerRank;                                           // 0x0508(0x0010) (NeedCtorLink)
	TArray<int>                                        m_CorpsesPerRank;                                         // 0x0518(0x0010) (NeedCtorLink)
	int                                                m_nStunsLeft;                                             // 0x0528(0x0004)
	float                                              m_fCorpseOffset;                                          // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AhPuch_EmptyTheCrypts");
		return ptr;
	}


	bool STATIC_ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	void STATIC_SelectStopFiringState();
	void STATIC_OnStateSet(TEnumAsByte<ETwoPhaseState> PrevState, TEnumAsByte<ETwoPhaseState> CurrentState);
	void STATIC_ClientFixStunsLeft(int nStunsLeft);
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_FireAmmunition();
	bool CanUseToggle();
	void STATIC_SpawnZombieCorpses(int nNumCorpses, const struct FVector& vLocation, const struct FVector& vForward);
	float STATIC_GetToggleMaxTime(int nMode);
};


// Class TgGame.TgDeviceFire_AhPuch_Dev2_CorpseFire
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_AhPuch_Dev2_CorpseFire : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AhPuch_Dev2_CorpseFire");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_AhPuch_Dev2_Sub
// 0x0014 (0x01D4 - 0x01C0)
class UTgDeviceFire_AhPuch_Dev2_Sub : public UTgDeviceFire
{
public:
	class ATgPawn_AhPuch*                              m_OwningAhPuch;                                           // 0x01C0(0x0008)
	class UTgDeviceFire*                               m_CorpseFireMode;                                         // 0x01C8(0x0008)
	unsigned long                                      m_bDestroyCorpseOnHit : 1;                                // 0x01D0(0x0004)
	unsigned long                                      m_bSkipFxOnDestroyCorpse : 1;                             // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AhPuch_Dev2_Sub");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool IsValidCorpseUser();
	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	class UTgDeviceFire* STATIC_GetCorpseFire();
	void AddCorpseEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
	bool STATIC_CheckTeamPassThrough(class AActor* HitActor);
	bool IsOwnersCorpse(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_AhPuch_Dev2
// 0x0010 (0x01D0 - 0x01C0)
class UTgDeviceFire_AhPuch_Dev2 : public UTgDeviceFire_Deploy
{
public:
	class UTgDeviceFire*                               m_CorpseFireMode;                                         // 0x01C0(0x0008)
	class ATgPawn_AhPuch*                              m_OwningAhPuch;                                           // 0x01C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AhPuch_Dev2");
		return ptr;
	}


	void ApplyCorpseHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	float GetCorpseAbsorbRadius();
	bool IsCorpseModeAOE();
	bool IsOwnersCorpse(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
	struct FImpactInfo STATIC_CalcCorpseWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcCorpseWeaponTargettingAim(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_AhPuch_Passive
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_AhPuch_Passive : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AhPuch_Passive");
		return ptr;
	}


	void STATIC_DeployAt(const struct FVector& vLocation, class AActor* FiringActor, class AActor* TargetActor, const struct FVector& vNormal, const struct FVector& vInitialLocation, bool bFromDev3);
};


// Class TgGame.TgDeviceForm_AhPuch_Dev2
// 0x0030 (0x0268 - 0x0238)
class UTgDeviceForm_AhPuch_Dev2 : public UTgDeviceForm
{
public:
	TArray<class AActor*>                              c_SelectedCorpses;                                        // 0x0238(0x0010) (NeedCtorLink)
	TArray<class UTgSpecialFx*>                        c_CorpseRangeFxList;                                      // 0x0248(0x0010) (NeedCtorLink)
	struct FName                                       c_nmRangeFxSocketName;                                    // 0x0258(0x0008)
	unsigned long                                      c_bUseCorpseRangeFx : 1;                                  // 0x0260(0x0004)
	int                                                c_nCorpseRangeFxID;                                       // 0x0264(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AhPuch_Dev2");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingList(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceForm_AhPuch_Dev1
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_AhPuch_Dev1 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AhPuch_Dev1");
		return ptr;
	}


	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_AhPuch_Dev3
// 0x0010 (0x00E4 - 0x00D4)
class UTgInventoryObject_Listen_AhPuch_Dev3 : public UTgInventoryObject_Listen_Apply_On_Healed
{
public:
	class AActor*                                      OwningActor;                                              // 0x00D4(0x0008)
	float                                              m_fHealInterval;                                          // 0x00DC(0x0004)
	float                                              m_fSecondsUntilReProc;                                    // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_AhPuch_Dev3");
		return ptr;
	}

};


// Class TgGame.TgMarkComponent_AhPuch_Dev3
// 0x0020 (0x00DC - 0x00BC)
class UTgMarkComponent_AhPuch_Dev3 : public UTgMarkComponent
{
public:
	unsigned long                                      m_bUseOwningDeviceEffectGroup : 1;                        // 0x00BC(0x0004)
	unsigned long                                      m_bReapplyOnDeviceModeChange : 1;                         // 0x00BC(0x0004)
	class UTgDeviceFire*                               m_OwningDeviceMode;                                       // 0x00C0(0x0008)
	int                                                m_nDamageBuffDeviceId;                                    // 0x00C8(0x0004)
	TArray<class UTgInventoryObject*>                  s_DamageBuffInvObj;                                       // 0x00CC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_AhPuch_Dev3");
		return ptr;
	}


	void STATIC_DeviceOnSetFireMode(class UTgDeviceFire* DeviceMode);
	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgPawn_AhPuch
// 0x0090 (0x2648 - 0x25B8)
class ATgPawn_AhPuch : public ATgPawn_Character
{
public:
	int                                                r_nCurrentCorpses;                                        // 0x25B8(0x0004) (Net)
	unsigned long                                      c_bCorpsePickupDisplayGroupActive : 1;                    // 0x25BC(0x0004)
	unsigned long                                      s_bIsAhPuchFireHeightSet : 1;                             // 0x25BC(0x0004)
	float                                              s_fAhPuchFireHeight;                                      // 0x25C0(0x0004)
	int                                                r_nCorpseExplosionsThisFire;                              // 0x25C4(0x0004) (Net)
	struct FVector                                     r_vWarmupLoc[0x6];                                        // 0x25C8(0x000C) (Net)
	TArray<struct FDev3Victim>                         m_Dev3VictimPawns;                                        // 0x2610(0x0010) (NeedCtorLink)
	class UTgMarkComponent_AhPuch_Dev3*                m_Dev3DotMark;                                            // 0x2620(0x0008) (ExportObject, Component, EditInline)
	TArray<class UTgDeviceFire*>                       m_Dev3Modes;                                              // 0x2628(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_Dev4SubModes;                                           // 0x2638(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_AhPuch");
		return ptr;
	}


	void ResetCorpseWarmupLocations();
	int GetCorpseWarmupCount();
	void SpawnZombie(const struct FVector& vLocation, const struct FVector& vNormal, const struct FVector& vInitialLocation, bool bFromDev3);
	void ReplicatedEvent(const struct FName& VarName);
	int STATIC_GetDev3VictimIndex(class AActor* Target);
	void STATIC_EndHealListening(bool bWasInterrupted);
	void STATIC_StartHealListening(class AActor* Target);
	void UltAOEHitSpecial();
	void STATIC_ConsumeCorpse();
	bool STATIC_GetPassiveAux(float* fResult);
	void STATIC_OnPawnDied();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
};


// Class TgGame.TgProj_AhPuch_Dev1
// 0x000C (0x03A4 - 0x0398)
class ATgProj_AhPuch_Dev1 : public ATgProj_Simulated
{
public:
	struct FVector                                     m_vMeshTranslationOffset;                                 // 0x0398(0x000C) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AhPuch_Dev1");
		return ptr;
	}


	void Destroyed();
	void ShutDown();
	void STATIC_CalcAoeFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void NativeCalcAoeFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void ArrangeDeployables(const struct FVector& HitLocation);
};


// Class TgGame.TgProj_AhPuch_EmptyTheCrypts
// 0x0024 (0x03D0 - 0x03AC)
class ATgProj_AhPuch_EmptyTheCrypts : public ATgProj_SimulatedPassThrough
{
public:
	TArray<int>                                        m_NormalMeshAssemblyIds;                                  // 0x03AC(0x0010) (NeedCtorLink)
	TArray<int>                                        m_HighSettingsMeshAssemblyIds;                            // 0x03BC(0x0010) (NeedCtorLink)
	int                                                m_nHighSettingsMode;                                      // 0x03CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AhPuch_EmptyTheCrypts");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool UseAOE();
	bool STATIC_ProximityDistanceOverridesCollision();
};


// Class TgGame.TgAnimBlendByFireRatatoskr
// 0x0014 (0x0200 - 0x01EC)
class UTgAnimBlendByFireRatatoskr : public UTgAnimBlendByFire
{
public:
	struct FDeviceParameters                           m_PassiveDeviceParameters;                                // 0x01EC(0x0014) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFireRatatoskr");
		return ptr;
	}

};


// Class TgGame.TgDevice_Ratatoskr_Dart
// 0x0034 (0x0570 - 0x053C)
class ATgDevice_Ratatoskr_Dart : public ATgDevice_Charge
{
public:
	TArray<class AActor*>                              s_AllHitActors;                                           // 0x053C(0x0010) (NeedCtorLink)
	TArray<struct FPreviousChargeInfo>                 s_PreviousChargeInfos;                                    // 0x054C(0x0010) (NeedCtorLink)
	float                                              m_fPreviousHitTimeout;                                    // 0x055C(0x0004)
	unsigned long                                      s_bNoCooldownThisFire : 1;                                // 0x0560(0x0004)
	int                                                s_nMaxDashCount;                                          // 0x0564(0x0004) (Const)
	unsigned char                                      m_nLocalDashCounter;                                      // 0x0568(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0569(0x0003) MISSED OFFSET
	float                                              m_fLocalIndividualOffhandCooldown;                        // 0x056C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_Dart");
		return ptr;
	}


	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	void AttemptToNotGoOnCooldown(class AActor* Other);
	void STATIC_CustomFire();
	void InterruptFiring();
	void STATIC_ClientRecoverDashCounter(unsigned char nDashCounter);
	void STATIC_ClientResetDashCounter();
	void STATIC_ResetDashCounter();
	unsigned char STATIC_GetMaxChargeValue();
	unsigned char STATIC_GetCurrentChargeValue();
	unsigned char STATIC_GetNextChargeNumber();
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	void STATIC_CalcOpalLightningImpactList(class UTgDeviceFire* DeviceMode, class ATgPawn* DamageInstigator, const struct FAimData& Aim, float Range, float Radius, int nMaxCount, bool bPredicting, const struct FVector& InstigatorLocation, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_HasBeenPreviouslyHit(class AActor* HitTarget);
	bool UpdatePreviousHitTargets(bool bDoNotSave, TArray<class AActor*>* HitActors);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Ratatoskr_DartV2
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Ratatoskr_DartV2 : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_DartV2");
		return ptr;
	}


	void STATIC_ReduceCooldown();
};


// Class TgGame.TgDevice_Ratatoskr_DartV3
// 0x0008 (0x0544 - 0x053C)
class ATgDevice_Ratatoskr_DartV3 : public ATgDevice_Ratatoskr_DartV2
{
public:
	unsigned long                                      r_bCurrentlyEnhanced : 1;                                 // 0x053C(0x0004) (Net)
	float                                              m_fInhandBuffMod;                                         // 0x0540(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_DartV3");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_CanCrit();
	void STATIC_SetEnhancedState(bool bEnhanced);
};


// Class TgGame.TgDevice_Ratatoskr_FlurryV2
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Ratatoskr_FlurryV2 : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_FlurryV2");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanJumpWhileFiring();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Ratatoskr_FlurryV3
// 0x0030 (0x052C - 0x04FC)
class ATgDevice_Ratatoskr_FlurryV3 : public ATgDevice_Ratatoskr_FlurryV2
{
public:
	class ATgPawn_RatatoskrV3*                         m_pawnRatatoskr;                                          // 0x04FC(0x0008) (Const)
	unsigned long                                      r_bCurrentlyEnhanced : 1;                                 // 0x0504(0x0004) (Net)
	int                                                r_nAmmoCount;                                             // 0x0508(0x0004) (Net)
	int                                                r_nMaxAmmoCount;                                          // 0x050C(0x0004) (Net)
	int                                                r_nBaseMaxAmmo;                                           // 0x0510(0x0004) (Const, Net)
	int                                                r_nEnhancedMaxAmmo;                                       // 0x0514(0x0004) (Const, Net)
	float                                              r_fMaxReplenishTime;                                      // 0x0518(0x0004) (Net)
	struct FName                                       m_nmGrantAmmoName;                                        // 0x051C(0x0008) (Const)
	struct FName                                       m_nmClientAmmoTimerEndName;                               // 0x0524(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_FlurryV3");
		return ptr;
	}


	void STATIC_CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void ConsumeAllAmmo();
	void ReplenishAllAmmo();
	void ConsumeAmmo();
	float GetClientAmmoTimerEndTime();
	void STATIC_ClientGrantAmmo();
	void STATIC_ClientSetCurrentAmmoTimer(float fTime);
	void SetGrantAmmoTimer();
	void GrantAmmo();
	void SetAmmoCount(int nAmmoCount, bool bDoNotFowardToClient);
	void STATIC_SetEnhancedState(bool bEnhanced);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Ratatoskr_TailSpin
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Ratatoskr_TailSpin : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_TailSpin");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	bool CanBeInterrupted();
	bool UsesCachedAim();
	void UpdateAimWhileFiring(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Ratatoskr_AcornThrow
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_Ratatoskr_AcornThrow : public ATgDevice
{
public:
	int                                                m_nProjectileOverridesSapphire[0x5];                      // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_AcornThrow");
		return ptr;
	}


	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Ratatoskr_AcornThrowV3
// 0x000C (0x0510 - 0x0504)
class ATgDevice_Ratatoskr_AcornThrowV3 : public ATgDevice_Ratatoskr_AcornThrow
{
public:
	unsigned long                                      r_bCurrentlyEnhanced : 1;                                 // 0x0504(0x0004) (Net)
	class UTgDeviceFire_Ratatoskr_AcornThrowV3*        m_fireCurrentAsAcornThrow;                                // 0x0508(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_AcornThrowV3");
		return ptr;
	}


	void UpdateFormEnhancedState();
	void STATIC_SetEnhancedState(bool bEnhanced);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_Ratatoskr_UltimateStaging
// 0x0004 (0x0530 - 0x052C)
class ATgDevice_Ratatoskr_UltimateStaging : public ATgDevice_StagingRefresh
{
public:
	unsigned long                                      s_bForceStraightDown : 1;                                 // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_UltimateStaging");
		return ptr;
	}


	void InterruptFiring();
	bool STATIC_FireEndStageDevice();
	void OnStageShooterStopFire(bool bInterrupted);
	void STATIC_FireAmmunition();
	bool LockStageShooterFiring();
	bool STATIC_CanRefreshPostHitDelay();
	bool STATIC_ShouldSwapInHandOnShooterStopFire();
	bool STATIC_ShouldSetStageShooterFired();
	void STATIC_ServerOnRightMousePressed();
	void STATIC_OnRightMousePressed();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Ratatoskr_UltimateShooter
// 0x0054 (0x055C - 0x0508)
class ATgDevice_Ratatoskr_UltimateShooter : public ATgDevice_TwoPhase
{
public:
	class ATgDeployable*                               s_ActiveTreeDeployable;                                   // 0x0508(0x0008)
	struct FVector                                     s_vTreeDeloyOffset;                                       // 0x0510(0x000C)
	int                                                m_nLeapCount;                                             // 0x051C(0x0004)
	TEnumAsByte<ETweenState>                           m_eLeapTweenState;                                        // 0x0520(0x0001)
	TEnumAsByte<ETweenState>                           m_eSlamTweenType;                                         // 0x0521(0x0001)
	TEnumAsByte<ETargetingTimerCheckpointType>         m_eStartTimerCheckpoint;                                  // 0x0522(0x0001)
	TEnumAsByte<ETargetingTimerCheckpointType>         m_eStopTimerCheckpoint;                                   // 0x0523(0x0001)
	unsigned long                                      m_bFixedTweenTime : 1;                                    // 0x0524(0x0004)
	unsigned long                                      m_bForceCast : 1;                                         // 0x0524(0x0004)
	unsigned long                                      s_bForceStraightDown : 1;                                 // 0x0524(0x0004)
	unsigned long                                      s_bDisableOnTweenEnd : 1;                                 // 0x0524(0x0004)
	float                                              m_fCachedDistanceScale;                                   // 0x0528(0x0004)
	struct FAimData                                    s_LastValidAim;                                           // 0x052C(0x0030)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_UltimateShooter");
		return ptr;
	}


	void STATIC_OnTweenEnd(bool bInterrupted);
	void InstantFire();
	struct FVector GetTweenLocation(struct FAimData* Aim);
	float STATIC_GetTweenTime();
	void STATIC_FireAmmunition();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_ClientForceFireCharge(float EndX, float EndY);
	bool STATIC_ForceFireCharge(bool bForceStraightDown);
	void STATIC_ClientFixRatatoskrUltState(int bRecoverLeapCount);
	void STATIC_HandleFiringRejection();
	void InterruptFiring();
	void STATIC_OnStateSet(TEnumAsByte<ETwoPhaseState> PrevState, TEnumAsByte<ETwoPhaseState> CurrentState);
	void STATIC_DestroyTree();
	void NextTree(const struct FAimData& Aim);
	bool CanUseToggle();
	void STATIC_DestroyTreeEarly(class ATgDeployable* Tree);
	class ATgDeployable* STATIC_SpawnTreeDeployable(const struct FAimData& Aim, class UTgDeviceFire* DeviceMode);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Ratatoskr_AcornThrowV2
// 0x0014 (0x01D4 - 0x01C0)
class UTgDeviceFire_Ratatoskr_AcornThrowV2 : public UTgDeviceFire
{
public:
	int                                                m_currentFiringInstance;                                  // 0x01C0(0x0004)
	TArray<struct FAcornThrowHitData>                  m_HitData;                                                // 0x01C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ratatoskr_AcornThrowV2");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
};


// Class TgGame.TgDeviceFire_Ratatoskr_AcornThrowV3
// 0x0010 (0x01E4 - 0x01D4)
class UTgDeviceFire_Ratatoskr_AcornThrowV3 : public UTgDeviceFire_Ratatoskr_AcornThrowV2
{
public:
	class ATgDevice_Ratatoskr_AcornThrowV3*            m_devOwner;                                               // 0x01D4(0x0008)
	float                                              m_fLossIntervalPercent;                                   // 0x01DC(0x0004) (Const)
	float                                              m_fMaxTotalDamageLossPercent;                             // 0x01E0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ratatoskr_AcornThrowV3");
		return ptr;
	}


	void ClearTrackingData(int nFiringInstance);
	int STATIC_GetTrackedIndex(class AActor* HitActor);
	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	float STATIC_GetPawnDamageLossPercent(class ATgPawn* HitPawn);
	int STATIC_GetShotsPerFire();
};


// Class TgGame.TgDeviceFire_Ratatoskr_Base
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Ratatoskr_Base : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ratatoskr_Base");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	bool AllowAcornBasedHits(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool STATIC_HasAcornHitSpecialGroup(int nSituationalType);
};


// Class TgGame.TgDeviceFire_Ratatoskr_AcornThrow
// 0x000C (0x01CC - 0x01C0)
class UTgDeviceFire_Ratatoskr_AcornThrow : public UTgDeviceFire_Ratatoskr_Base
{
public:
	int                                                s_nActiveFiringInstance;                                  // 0x01C0(0x0004)
	int                                                s_nHealStackCount;                                        // 0x01C4(0x0004)
	int                                                s_nMaxHealStackCount;                                     // 0x01C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ratatoskr_AcornThrow");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
	bool AllowAcornBasedHits(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceForm_Ratatoskr_AcornBlastV3
// 0x0004 (0x025C - 0x0258)
class UTgDeviceForm_Ratatoskr_AcornBlastV3 : public UTgDeviceForm_MultiTargeters
{
public:
	unsigned long                                      m_bOwnerIsEnhanced : 1;                                   // 0x0258(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Ratatoskr_AcornBlastV3");
		return ptr;
	}


	bool ShouldInitializeFx(int nFxTargeterIndex);
};


// Class TgGame.TgInventoryManager_Ratatoskr
// 0x0020 (0x0784 - 0x0764)
class ATgInventoryManager_Ratatoskr : public ATgInventoryManager
{
public:
	struct FAcornPurchaseInfo                          r_PendingAcornPurchase;                                   // 0x0764(0x0010) (Net)
	TArray<TScriptInterface<class UTgRatatoskrAcorn>>  s_Acorns;                                                 // 0x0774(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryManager_Ratatoskr");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
	bool STATIC_DoesPassGodEnabledItemCheck(int nItemId);
	bool STATIC_PerformPendingAcornPurchase();
	bool STATIC_CancelPendingAcornPurchase(bool bNoDeviceInterrupt);
	bool STATIC_HasAcorn(TEnumAsByte<EAcornType> AcornType);
	void STATIC_OnCanPurchaseFlagSet(bool bCanPurchase);
};


// Class TgGame.TgInventoryObject_Ratatoskr_EvergreenAcorn
// 0x0009 (0x00FD - 0x00F4)
class UTgInventoryObject_Ratatoskr_EvergreenAcorn : public UTgInventoryObject_Listen_OffhandOnceTotalPerCast
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00F4(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00FC(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Ratatoskr_EvergreenAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_Ratatoskr_LivelyAcorn
// 0x0009 (0x00FD - 0x00F4)
class UTgInventoryObject_Ratatoskr_LivelyAcorn : public UTgInventoryObject_Listen_OffhandOnceTotalPerCast
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00F4(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00FC(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Ratatoskr_LivelyAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_Ratatoskr_ThickbarkAcorn
// 0x0009 (0x00FD - 0x00F4)
class UTgInventoryObject_Ratatoskr_ThickbarkAcorn : public UTgInventoryObject_Listen_OffhandOnceTotalPerCast
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00F4(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00FC(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Ratatoskr_ThickbarkAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_Listen_RatatoskrAcornThrow
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_RatatoskrAcornThrow : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RatatoskrAcornThrow");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RatatoskrTailSpin
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_RatatoskrTailSpin : public UTgInventoryObject_Listen
{
public:
	TEnumAsByte<ETweenState>                           m_eYellowAcornTween;                                      // 0x00D0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D1(0x0003) MISSED OFFSET
	float                                              m_fTweenSpeed;                                            // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RatatoskrTailSpin");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Ratatoskr_BristlebushAcorn
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Ratatoskr_BristlebushAcorn : public UTgInventoryObject_Listen
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00D0(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00D8(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D9(0x0003) MISSED OFFSET
	class ATgDevice_Ratatoskr_DartV3*                  m_devDart;                                                // 0x00DC(0x0008)
	float                                              m_fDamageBuffPercent;                                     // 0x00E4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Ratatoskr_BristlebushAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_Ratatoskr_NettleAcorn
// 0x0009 (0x00D9 - 0x00D0)
class UTgInventoryObject_Ratatoskr_NettleAcorn : public UTgInventoryObject_Listen
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00D0(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00D8(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Ratatoskr_NettleAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_Ratatoskr_ThistlethornAcorn
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Ratatoskr_ThistlethornAcorn : public UTgInventoryObject_Listen
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00D0(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00D8(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D9(0x0003) MISSED OFFSET
	class ATgDevice_Ratatoskr_AcornThrowV3*            m_devAcornThrow;                                          // 0x00DC(0x0008)
	float                                              m_fDamageBuffPercent;                                     // 0x00E4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Ratatoskr_ThistlethornAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_RatatoskrBlueAcorn
// 0x0011 (0x00E1 - 0x00D0)
class UTgInventoryObject_RatatoskrBlueAcorn : public UTgInventoryObject_Listen
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00D0(0x0008) (Const, Native, NoExport)
	int                                                m_LastHealedDevId;                                        // 0x00D8(0x0004)
	int                                                m_LastHealedInstance;                                     // 0x00DC(0x0004)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00E0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_RatatoskrBlueAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_RatatoskrAcorn
// 0x0009 (0x00D5 - 0x00CC)
class UTgInventoryObject_RatatoskrAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00CC(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00D4(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_RatatoskrAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_RatatoskrEmeraldAcorn
// 0x0009 (0x00D5 - 0x00CC)
class UTgInventoryObject_RatatoskrEmeraldAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00CC(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00D4(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_RatatoskrEmeraldAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_RatatoskrOpalAcorn
// 0x0009 (0x00D5 - 0x00CC)
class UTgInventoryObject_RatatoskrOpalAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00CC(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00D4(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_RatatoskrOpalAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_RatatoskrSapphireAcorn
// 0x0009 (0x00D5 - 0x00CC)
class UTgInventoryObject_RatatoskrSapphireAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00CC(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00D4(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_RatatoskrSapphireAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_RatatoskrTopazAcorn
// 0x0009 (0x00D5 - 0x00CC)
class UTgInventoryObject_RatatoskrTopazAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00CC(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00D4(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_RatatoskrTopazAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgInventoryObject_RatatoskrYellowAcorn
// 0x0009 (0x00D5 - 0x00CC)
class UTgInventoryObject_RatatoskrYellowAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                                // 0x00CC(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EAcornType>                            m_eAcornType;                                             // 0x00D4(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_RatatoskrYellowAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgPawn_Ratatoskr
// 0x0850 (0x2E08 - 0x25B8)
class ATgPawn_Ratatoskr : public ATgPawn_Character
{
public:
	TEnumAsByte<EAcornType>                            r_eCurrentAcorn;                                          // 0x25B8(0x0001) (Net)
	unsigned char                                      r_nHasAcorn[0xE];                                         // 0x25B9(0x0001) (Net)
	unsigned char                                      r_nDartNoCooldownTicker;                                  // 0x25C7(0x0001) (Net)
	TEnumAsByte<ERatatoskrUltimateState>               r_CurrentUltimateState;                                   // 0x25C8(0x0001) (Net)
	TEnumAsByte<ERatatoskrUltimateState>               c_LocalUltimateState;                                     // 0x25C9(0x0001) (Transient)
	TEnumAsByte<ETG_POSTURE>                           m_eUltTargetingPosture;                                   // 0x25CA(0x0001) (Const)
	TEnumAsByte<ETG_POSTURE>                           m_eUltFlyingPosture;                                      // 0x25CB(0x0001) (Const)
	struct FLinearColor                                m_EmissiveBodyColors[0xE];                                // 0x25CC(0x0010)
	struct FLinearColor                                s_colorDefault;                                           // 0x26AC(0x0010) (Const, Config)
	struct FRatatoskrSkinTailBaseColor                 s_skinTailBaseColors[0x20];                               // 0x26BC(0x0014) (Const, Config)
	struct FLinearColor                                s_colorAcornTail[0xE];                                    // 0x293C(0x0010) (Const, Config)
	struct FLinearColor                                r_colorDefault;                                           // 0x2A1C(0x0010) (Const, Net)
	struct FRatatoskrSkinTailBaseColor                 r_skinTailBaseColors[0x20];                               // 0x2A2C(0x0014) (Const, Net)
	struct FLinearColor                                r_colorAcornTail[0xE];                                    // 0x2CAC(0x0010) (Const, Net)
	unsigned long                                      r_bCachedColors : 1;                                      // 0x2D8C(0x0004) (Const, Net)
	unsigned long                                      s_bAppliedNotGrabSource : 1;                              // 0x2D8C(0x0004)
	unsigned long                                      m_bIgnoreEndTweenLogic : 1;                               // 0x2D8C(0x0004)
	class UTgDeviceFire*                               s_UltDamagingDeviceMode;                                  // 0x2D90(0x0008)
	int                                                m_nUltTargetingPostureId;                                 // 0x2D98(0x0004)
	class UClass*                                      m_UltTargetingControlModuleClass;                         // 0x2D9C(0x0008) (Const)
	class UClass*                                      m_PreviousControlModuleClass;                             // 0x2DA4(0x0008)
	class UTgControlModule*                            m_UltTargetingControlModule;                              // 0x2DAC(0x0008)
	class UClass*                                      m_UltTargetingCameraModuleClass;                          // 0x2DB4(0x0008) (Const)
	class UClass*                                      m_PreviousCameraModuleClass;                              // 0x2DBC(0x0008)
	class UTgCameraModule*                             m_UltTargetingCameraModule;                               // 0x2DC4(0x0008)
	class UClass*                                      m_UltTreeHoppingControlModuleClass;                       // 0x2DCC(0x0008) (Const)
	class UClass*                                      m_PreviousTreeHoppingControlModuleClass;                  // 0x2DD4(0x0008)
	class UTgControlModule*                            m_UltTreeHoppingControlModule;                            // 0x2DDC(0x0008)
	int                                                m_nUltFlyngPostureId;                                     // 0x2DE4(0x0004)
	TArray<class UTgAnimBlendByFire*>                  m_UltFlyingFireNodes;                                     // 0x2DE8(0x0010) (NeedCtorLink)
	struct FName                                       m_UltFlyingFireNodeName;                                  // 0x2DF8(0x0008)
	class ATgDevice_Ratatoskr_UltimateShooter*         s_UltShooter;                                             // 0x2E00(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ratatoskr");
		return ptr;
	}


	bool IsInClassSpecificMovement();
	void STATIC_OnRespawn();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void UltimateTweenEnd(bool bInterrupted);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void UpdateUltimateState(TEnumAsByte<ERatatoskrUltimateState> NewState);
	void STATIC_ClientFixUltimateState(TEnumAsByte<ERatatoskrUltimateState> NewState);
	void ExitUltTargeting();
	void EnterUltTargeting();
	void STATIC_OnRightMousePressed();
	void InterruptRecallFromDamage();
	void InterruptAcornPurchase();
	void Tick(float DeltaSeconds);
	void STATIC_OnDartNoCooldown();
	void PostDemoRewind();
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	float ApplyPitchLimit(float fPitch);
	void STATIC_OnAcornHealOver();
	void OnAcornItemProcced();
	void ReplicatedEvent(const struct FName& VarName);
	TEnumAsByte<ESpecialItemPurchaseException> STATIC_HasSpecialPurchaseException(int nItemId);
	void STATIC_SetStripeAcornColorSkinOverride(int nSkinId);
	void STATIC_InitialzeStripeAcornColors();
	void STATIC_SetStripeColor(TEnumAsByte<EAcornType> AcornType);
	TEnumAsByte<EAcornType> STATIC_GetCurrentAcornType();
	void STATIC_OnAcornChanged(bool bNoRecalc);
	bool STATIC_HasYellowAcorn();
	bool STATIC_HasBlueAcorn();
	bool STATIC_HasWhiteAcorn();
	bool STATIC_HasAcorn(TEnumAsByte<EAcornType> AcornType);
	float STATIC_GetSmoothEnergy();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	int STATIC_GetCustomParticleSystemFilter();
	void STATIC_CacheConfigValues();
};


// Class TgGame.TgPawn_RatatoskrV2
// 0x0000 (0x2E08 - 0x2E08)
class ATgPawn_RatatoskrV2 : public ATgPawn_Ratatoskr
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_RatatoskrV2");
		return ptr;
	}


	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
};


// Class TgGame.TgPawn_RatatoskrV3
// 0x0108 (0x2F10 - 0x2E08)
class ATgPawn_RatatoskrV3 : public ATgPawn_RatatoskrV2
{
public:
	class ATgDevice*                                   m_deviceInhand;                                           // 0x2E08(0x0008)
	class ATgDevice*                                   m_devicePsv;                                              // 0x2E10(0x0008)
	class ATgDevice_Ratatoskr_DartV3*                  m_deviceA01;                                              // 0x2E18(0x0008)
	class ATgDevice_Ratatoskr_FlurryV3*                m_deviceA02;                                              // 0x2E20(0x0008)
	class ATgDevice_Ratatoskr_AcornThrowV3*            m_deviceA03;                                              // 0x2E28(0x0008)
	class ATgDevice_Ratatoskr_UltimateStaging*         m_deviceA04;                                              // 0x2E30(0x0008)
	class ATgDevice_Ratatoskr_UltimateShooter*         m_deviceA04Shooter;                                       // 0x2E38(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x2E40(0x0004) (Const)
	class UTgSkeletalMeshComponent*                    c_skelMeshComponentAcorn;                                 // 0x2E44(0x0008) (Const, ExportObject, Component, EditInline)
	int                                                m_nAcornFilterByType[0xE];                                // 0x2E4C(0x0004) (Const)
	int                                                m_nBaseAcornMeshId;                                       // 0x2E84(0x0004) (Const)
	int                                                m_nAcornMeshId;                                           // 0x2E88(0x0004) (Const)
	struct FName                                       m_nmAcornAttachSocketName;                                // 0x2E8C(0x0008) (Const)
	struct FName                                       m_nmAcornSoundDisplayGroups[0xE];                         // 0x2E94(0x0008) (Const)
	struct FName                                       m_nmAcornAuraDisplayGroup;                                // 0x2F04(0x0008) (Const)
	float                                              r_fDartInhandBuffMod;                                     // 0x2F0C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_RatatoskrV3");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_InitializeAcornMesh();
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_OnAttackDamagePropertyChange();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_PawnOnRevive();
	void STATIC_OnPawnDied();
	int STATIC_GetCustomParticleSystemFilter();
	void STATIC_OnAcornChanged(bool bNoRecalc);
	void UpdateDeviceEnhancedStates();
	void UpdateClientDevices(bool bForce);
	bool ApplyPawnSetup();
};


// Class TgGame.TgProj_Ratatoskr_AcornThrow
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Ratatoskr_AcornThrow : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ratatoskr_AcornThrow");
		return ptr;
	}

};


// Class TgGame.TgProj_Ratatoskr_AcornThrowSapphire
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Ratatoskr_AcornThrowSapphire : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ratatoskr_AcornThrowSapphire");
		return ptr;
	}


	void ShutDown();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_CheckTeamPassThrough(class AActor* Other);
	bool AlreadyHasDeployable(class AActor* HitActor);
	bool ValidDeployableId(int nDeployableId);
	void STATIC_SpawnTheDeployableSpecial(const struct FVector& HitLocation, const struct FVector& HitNormal, class AActor* BaseActor);
};


// Class TgGame.TgProj_Ratatoskr_TailSpinSapphire
// 0x000C (0x03C4 - 0x03B8)
class ATgProj_Ratatoskr_TailSpinSapphire : public ATgProj_SimulatedBoomerang
{
public:
	float                                              m_fWaitInPlaceTime;                                       // 0x03B8(0x0004)
	struct FName                                       m_BlendListName;                                          // 0x03BC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ratatoskr_TailSpinSapphire");
		return ptr;
	}


	void STATIC_SetAnimBlendListActiveChild(int nActiveChild);
	void WaitInPlace();
	void STATIC_RangeReached();
};


// Class TgGame.TgRatatoskrAcorn
// 0x0000 (0x0060 - 0x0060)
class UTgRatatoskrAcorn : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRatatoskrAcorn");
		return ptr;
	}


	TEnumAsByte<EAcornType> GetAcornType();
};


// Class TgGame.TgDevice_Ravana_Dev4
// 0x0009 (0x04F9 - 0x04F0)
class ATgDevice_Ravana_Dev4 : public ATgDevice
{
public:
	class ATgCollisionProxy_Cylinder*                  m_DashCollision;                                          // 0x04F0(0x0008)
	TEnumAsByte<ETweenState>                           m_eDashTweenType;                                         // 0x04F8(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ravana_Dev4");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	bool CanBeCanceled();
	bool CanBeInterrupted();
	void ProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TurnOffDashCollision();
	void TurnOnDashCollision();
};


// Class TgGame.TgEffectForm_Ravana_Root
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_Ravana_Root : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Ravana_Root");
		return ptr;
	}


	void STATIC_DetachMeshes();
};


// Class TgGame.TgInventoryObject_Listen_Ravana_Passive
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_Ravana_Passive : public UTgInventoryObject_Listen
{
public:
	int                                                m_nPassiveEffectGroupId;                                  // 0x00D0(0x0004)
	TArray<unsigned long>                              DeviceAlreadyHit;                                         // 0x00D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Ravana_Passive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Ravana
// 0x0048 (0x2600 - 0x25B8)
class ATgPawn_Ravana : public ATgPawn_Character
{
public:
	int                                                m_nPassiveCategory;                                       // 0x25B8(0x0004)
	int                                                r_nPassiveCombo;                                          // 0x25BC(0x0004) (Net)
	int                                                m_nPassiveCombosMax;                                      // 0x25C0(0x0004) (Const)
	int                                                r_nPassiveStacks;                                         // 0x25C4(0x0004) (Net)
	int                                                m_nPassiveStacksMax;                                      // 0x25C8(0x0004)
	float                                              r_fPassiveDuration;                                       // 0x25CC(0x0004) (Net)
	float                                              m_fPassiveDurationMax;                                    // 0x25D0(0x0004)
	unsigned long                                      m_bPassiveMaxsUpdated : 1;                                // 0x25D4(0x0004)
	unsigned long                                      r_bDodgeIsActive : 1;                                     // 0x25D4(0x0004) (Net)
	unsigned long                                      m_bActivatedPunch : 1;                                    // 0x25D4(0x0004)
	int                                                m_nMaxMinionHeals;                                        // 0x25D8(0x0004)
	int                                                m_nMaxPlayerHeals;                                        // 0x25DC(0x0004)
	int                                                m_nUltCategoryEnemy;                                      // 0x25E0(0x0004)
	int                                                m_nUltCategorySelf;                                       // 0x25E4(0x0004)
	float                                              m_fPunchWindupTime;                                       // 0x25E8(0x0004) (Const)
	int                                                m_nTweenTimerFxId;                                        // 0x25EC(0x0004) (Const)
	class UTgSpecialFx*                                c_TweenTimerFx;                                           // 0x25F0(0x0008)
	class ATgSkeletalMeshActor*                        c_TweenTimerMesh;                                         // 0x25F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ravana");
		return ptr;
	}


	float ShadowFistHealingScaling(bool isPlayer);
	void ResetShadowFistHeals(int minionHeals, int playerHeals);
	void ActivatePunch();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void Tick(float DeltaSeconds);
	bool PostPawnSetup();
	bool STATIC_InitializeUltFx();
	void STATIC_OnPostureChange();
	void STATIC_OnAttackDamagePropertyChange();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_PawnCanDisplayImmuneMessage();
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgProj_Ravana_Dev4
// 0x0014 (0x03AC - 0x0398)
class ATgProj_Ravana_Dev4 : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x0398(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x039C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ravana_Dev4");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_PerformWallKnockback(class ATgPawn* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAchievement_KhepriSaveThemAll
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_KhepriSaveThemAll : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	TArray<class ATgPawn*>                             m_TrackedSaved;                                           // 0x0088(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_KhepriSaveThemAll");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByKhepriCrawlBack
// 0x0004 (0x016C - 0x0168)
class UTgAnimBlendByKhepriCrawlBack : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bCrawlBackActive : 1;                                   // 0x0168(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByKhepriCrawlBack");
		return ptr;
	}


	void STATIC_EndCrawlBack();
	void STATIC_ReplayAnim();
	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
};


// Class TgGame.TgDeployable_Khepri_Scarab
// 0x0058 (0x042C - 0x03D4)
class ATgDeployable_Khepri_Scarab : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_PotentialPassengers;                                    // 0x03D4(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_InnerOccupants;                                         // 0x03E4(0x0010) (NeedCtorLink)
	TArray<float>                                      s_PotentialTimers;                                        // 0x03F4(0x0010) (NeedCtorLink)
	float                                              m_fTotalLife;                                             // 0x0404(0x0004)
	class UTgSpecialFx*                                m_ChargingFx;                                             // 0x0408(0x0008)
	int                                                m_nChargingFxId;                                          // 0x0410(0x0004)
	class ATgPawn*                                     r_NewestChargingActor;                                    // 0x0414(0x0008) (Net)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x041C(0x0008)
	class ATgCollisionProxy*                           s_AcceptProxy;                                            // 0x0424(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Khepri_Scarab");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void Cleanup();
	void UntrackAllTracked();
	void UntrackActorAt(int Idx);
	void TrackActor(class AActor* tracked);
	bool IsTrackingAny();
	void STATIC_SetChargingFx(bool isCharging);
	void Tick(float DeltaSeconds);
	void ProxyScarabUnTouch(class AActor* Other);
	void ProxyScarabTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void AddChargingFxToActor(class ATgPawn* newTrackedPawn);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_Khepri_Abduct
// 0x0008 (0x0544 - 0x053C)
class ATgDevice_Khepri_Abduct : public ATgDevice_Charge
{
public:
	TEnumAsByte<EGrabState>                            m_TargetGrabState;                                        // 0x053C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x053D(0x0003) MISSED OFFSET
	unsigned long                                      m_bInterruptingGrab : 1;                                  // 0x0540(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Khepri_Abduct");
		return ptr;
	}


	void STATIC_OnStoppedChargeOnHit(class AActor* Other);
	void STATIC_OnAbductionGrabDetach(class ATgPawn* pawnOther, bool bInterrupted);
	void ForceEarlyGrabDetach(class AActor* Other);
	void STATIC_ClientForceStopFire(TEnumAsByte<EChargeEndState> EndState);
	void Destroyed();
	void InterruptFiring();
};


// Class TgGame.TgDevice_Khepri_ScarabsFlight
// 0x0024 (0x0520 - 0x04FC)
class ATgDevice_Khepri_ScarabsFlight : public ATgDevice_Deployable
{
public:
	class ATgDeployable*                               r_KhepriBasedScarab;                                      // 0x04FC(0x0008) (Net)
	TArray<class AActor*>                              alreadyTaken;                                             // 0x0504(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                m_RangedChargingFx;                                       // 0x0514(0x0008)
	unsigned long                                      r_bRangedScarabCharging : 1;                              // 0x051C(0x0004) (Net)
	unsigned long                                      r_bBasedScarabCharging : 1;                               // 0x051C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Khepri_ScarabsFlight");
		return ptr;
	}


	void Tick(float DeltaTime);
	bool UseFlight(class AActor* passenger);
	bool STATIC_CanUseFlight(class AActor* passenger);
	struct FVector STATIC_GetFlightLocationFrom(class ATgDeployable* launchPad);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void UpdateBasedFx();
	void UpdateRangedFx();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SpawnKhepriBasedScarab();
};


// Class TgGame.TgDevice_Khepri_ScarabBlessing
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Khepri_ScarabBlessing : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Khepri_ScarabBlessing");
		return ptr;
	}


	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
};


// Class TgGame.TgDevice_Khepri_KheprisFortitude
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Khepri_KheprisFortitude : public ATgDevice
{
public:
	float                                              r_fPassiveTimer;                                          // 0x04F0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Khepri_KheprisFortitude");
		return ptr;
	}


	bool ShouldInterruptInhand();
	bool ApplyGlobalOffhandCooldown();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_CanFireWhileFalling();
	void DeliverQueuedPendingHits();
	void Tick(float DeltaSeconds);
	float GetCurrentTickFrequency();
};


// Class TgGame.TgDevice_Khepri_Sun
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Khepri_Sun : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Khepri_Sun");
		return ptr;
	}


	bool UsesCachedAim();
};


// Class TgGame.TgDeviceFire_Khepri_Dev4
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_Khepri_Dev4 : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Khepri_Dev4");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Khepri_Sun
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Khepri_Sun : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Khepri_Sun");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgInventoryObject_Listen_KhepriAbduct
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_KhepriAbduct : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_KhepriAbduct");
		return ptr;
	}

};


// Class TgGame.TgPawn_Khepri
// 0x007C (0x2634 - 0x25B8)
class ATgPawn_Khepri : public ATgPawn_Character
{
public:
	class ATgDevice_Khepri_Abduct*                     s_AbductDevice;                                           // 0x25B8(0x0008)
	class UClass*                                      m_CrawlBackControlModuleClass;                            // 0x25C0(0x0008) (Const)
	class UClass*                                      m_PreviousControlModuleClass;                             // 0x25C8(0x0008)
	class UTgControlModule*                            m_CrawlBackControlModule;                                 // 0x25D0(0x0008)
	TArray<int>                                        m_CanFireDuringCrawlBack;                                 // 0x25D8(0x0010) (NeedCtorLink)
	unsigned long                                      m_bAllowCrawlBackCancelOnRightMousePressed : 1;           // 0x25E8(0x0004) (Const)
	unsigned long                                      m_bApplyBigHeal : 1;                                      // 0x25E8(0x0004)
	unsigned char                                      r_bEndCrawlBackTrigger;                                   // 0x25EC(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x25ED(0x0003) MISSED OFFSET
	TArray<class UTgAnimBlendByKhepriCrawlBack*>       m_CrawlBackNodes;                                         // 0x25F0(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                m_ReviveFX;                                               // 0x2600(0x0008)
	class AActor*                                      r_RevivedActor;                                           // 0x2608(0x0008) (Net)
	class AActor*                                      c_OldRevivedActor;                                        // 0x2610(0x0008)
	class UTgSkeletalMeshComponent*                    m_ReviveMesh;                                             // 0x2618(0x0008) (ExportObject, Component, EditInline)
	class ATgPawn*                                     m_ReviveTarget;                                           // 0x2620(0x0008)
	struct FVector                                     m_vReviveLocation;                                        // 0x2628(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Khepri");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void HookTargetOnKhepri();
	void SendTargetToKhepri();
	bool WillOverrideTakeDamage(class APawn* Victim, int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	bool STATIC_DeviceCausesWariness(int nEquipSlot);
	void STATIC_ServerEndCrawlBack();
	void STATIC_EndCrawlBackAnim();
	void STATIC_ClientEndCrawlBack();
	void STATIC_EndCrawlBack(bool bInterrupted, bool bSkipClient);
	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void STATIC_ClientBeginCrawlBack(float fDuration, int nYaw);
	bool BeginCrawlBack(float fDuration, const struct FRotator& ForwardRotation);
	void DestroyReviveFx();
	void PlayReviveFxAt(class AActor* RevivedTarget);
	bool PostPawnSetup();
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_InitializeReviveFX();
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
};


// Class TgGame.TgAnimNodeBlendList_XingTian_Spin
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendList_XingTian_Spin : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_XingTian_Spin");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
	void SetActiveAnimationIndex();
};


// Class TgGame.TgDevice_XingTian_HeroicCharge
// 0x0004 (0x0584 - 0x0580)
class ATgDevice_XingTian_HeroicCharge : public ATgDevice_Bellona_ShieldBash
{
public:
	unsigned long                                      m_bWillHit : 1;                                           // 0x0580(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_XingTian_HeroicCharge");
		return ptr;
	}


	bool PredictChargeHit(const struct FVector& ChargeDir, const struct FVector& ChargeStart, float fChargeRange, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_XingTian_HeroicChargeV2
// 0x0060 (0x05A8 - 0x0548)
class ATgDevice_XingTian_HeroicChargeV2 : public ATgDevice_DoubleCharge
{
public:
	struct FAimData                                    m_CachedSecondaryAim;                                     // 0x0548(0x0030)
	struct FAimData                                    c_SecondaryTargetingAim;                                  // 0x0578(0x0030)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_XingTian_HeroicChargeV2");
		return ptr;
	}


	bool STATIC_ShouldStopOnThisHit(class AActor* Other);
	float GetAimTime();
	void TickTargetingMode(float DeltaSeconds);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	void UpdateAimWhileFiring(struct FAimData* Aim);
	void STATIC_GetCachedAim(struct FAimData* Aim);
	struct FAimData STATIC_CacheAim();
	bool UsesCachedAim();
	void STATIC_GetSecondaryAim(struct FAimData* Aim, struct FAimData* primaryAim);
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetBuildupTime(int nMode);
};


// Class TgGame.TgDevice_XingTian_UltSweep
// 0x0024 (0x0540 - 0x051C)
class ATgDevice_XingTian_UltSweep : public ATgDevice_RadialSweep
{
public:
	unsigned long                                      m_bHasEjected : 1;                                        // 0x051C(0x0004)
	unsigned long                                      m_bAlreadyInPoxyTouch : 1;                                // 0x051C(0x0004)
	int                                                m_nHitsApplied;                                           // 0x0520(0x0004)
	float                                              m_fNumSpins;                                              // 0x0524(0x0004)
	float                                              m_fNextEjectPercent;                                      // 0x0528(0x0004)
	TEnumAsByte<EGrabState>                            m_eHitTargetGrabState;                                    // 0x052C(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x052D(0x0003) MISSED OFFSET
	TArray<class AActor*>                              m_SecondaryHits;                                          // 0x0530(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_XingTian_UltSweep");
		return ptr;
	}


	void STATIC_RehitAll();
	bool ShouldRehit(float currentPercent);
	bool ShouldEject();
	void TossAllHit();
	void ProxyEndSweep(bool bInterrupted);
	void Tick(float DeltaSeconds);
	void STATIC_OnGrabDetach(class ATgPawn* Target);
	void STATIC_OnApplyHitFromTouch(class UTgDeviceFire* FireMode, struct FImpactInfo* Impact);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void InterruptFiring();
	bool CanBeInterrupted();
	float STATIC_GetCurrentSweepPercent();
};


// Class TgGame.TgDevice_XingTian_SkyCuttingAxe
// 0x0004 (0x04FC - 0x04F8)
class ATgDevice_XingTian_SkyCuttingAxe : public ATgDevice_TweenBase
{
public:
	unsigned long                                      r_bHasLeaped : 1;                                         // 0x04F8(0x0004) (Net)
	unsigned long                                      r_bLastLeap : 1;                                          // 0x04F8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_XingTian_SkyCuttingAxe");
		return ptr;
	}


	void LeapTimeout();
	void STATIC_OnTweenEnd(bool bInterrupted);
	void STATIC_HandleTweenEnd();
	bool CanBeCanceled();
	bool ShouldCooldownAfterFire();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	void UpdateLeapState();
	bool STATIC_ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool ShouldTriggerCastReactionItems();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateManaUseVitals(class ATgPlayerController* PC);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	unsigned char STATIC_IncrementFiringInstance();
};


// Class TgGame.TgDevice_XingTian_HeroicLeap
// 0x0010 (0x0518 - 0x0508)
class ATgDevice_XingTian_HeroicLeap : public ATgDevice_TwoPhase
{
public:
	int                                                m_nLeapCount;                                             // 0x0508(0x0004)
	int                                                m_nMaxLeapCount;                                          // 0x050C(0x0004) (Const)
	TEnumAsByte<ETweenState>                           m_eLeapTweenState;                                        // 0x0510(0x0001)
	TEnumAsByte<ETweenState>                           m_eSlamTweenType;                                         // 0x0511(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0512(0x0002) MISSED OFFSET
	unsigned long                                      m_bFixedTweenTime : 1;                                    // 0x0514(0x0004)
	unsigned long                                      m_bForceToNormalState : 1;                                // 0x0514(0x0004)
	unsigned long                                      s_bDisableOnTweenEnd : 1;                                 // 0x0514(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_XingTian_HeroicLeap");
		return ptr;
	}


	void STATIC_SelectStopFiringState();
	void STATIC_OnTweenEnd(bool bInterrupted);
	struct FVector GetTweenLocation(struct FAimData* Aim);
	float STATIC_GetTweenTime();
	void STATIC_FireAmmunition();
	void STATIC_ClientFixLeapCount(int bRecoverLeapCount);
	void STATIC_HandleFiringRejection();
	void InterruptFiring();
	bool ShouldCooldownAfterFire();
	void ForceToNormalState();
	void STATIC_ServerForceToNormalState();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_OnStateSet(TEnumAsByte<ETwoPhaseState> PrevState, TEnumAsByte<ETwoPhaseState> CurrentState);
	bool STATIC_ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool ShouldTriggerCastReactionItems();
	float STATIC_GetToggleMaxTime(int nMode);
};


// Class TgGame.TgDevice_XingTian_AxeSweepShieldBash
// 0x0002 (0x04F2 - 0x04F0)
class ATgDevice_XingTian_AxeSweepShieldBash : public ATgDevice
{
public:
	TEnumAsByte<ETweenState>                           m_eBashTweenState;                                        // 0x04F0(0x0001)
	TEnumAsByte<EXingAttackState>                      m_eXingAttackState;                                       // 0x04F1(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_XingTian_AxeSweepShieldBash");
		return ptr;
	}


	void STATIC_EndSecondaryTargeting();
	void BeginSecondaryTargeting();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool CanBeInterrupted();
	void UpdateAimWhileFiring(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetRefireTime(int nMode);
};


// Class TgGame.TgDevice_XingTian_Battlecry
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_XingTian_Battlecry : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_XingTian_Battlecry");
		return ptr;
	}


	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_CalcLinearFire(const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_XingTian_AxeSweepShieldBash
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_XingTian_AxeSweepShieldBash : public UTgDeviceFire
{
public:
	unsigned long                                      m_bUseSecondaryTargetingMode : 1;                         // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_XingTian_AxeSweepShieldBash");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	float STATIC_GetDamageRadius();
	float STATIC_GetRange();
	bool UseSecondaryTargetingMode();
};


// Class TgGame.TgDeviceFire_XingTian_HeroicChargeV2
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_XingTian_HeroicChargeV2 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_XingTian_HeroicChargeV2");
		return ptr;
	}


	float GetRefireTime();
	float GetPostHitDelay();
	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	float STATIC_GetRange();
};


// Class TgGame.TgDeviceForm_XingTian_HeroicCharge
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_XingTian_HeroicCharge : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_XingTian_HeroicCharge");
		return ptr;
	}


	void UpdateConeTargetModeLocation(float TranslationX, float TranslationY);
};


// Class TgGame.TgInventoryObject_Listen_XingTianPassive
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_XingTianPassive : public UTgInventoryObject_Listen_SuccessfulHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_XingTianPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_XingTian
// 0x006A (0x2622 - 0x25B8)
class ATgPawn_XingTian : public ATgPawn_Character
{
public:
	int                                                c_nMaxRageStacks;                                         // 0x25B8(0x0004) (Transient)
	float                                              m_fOutOfCombatEnrageTimer;                                // 0x25BC(0x0004)
	float                                              m_fHealingTimer;                                          // 0x25C0(0x0004)
	int                                                m_nHealthPercentSituationalType;                          // 0x25C4(0x0004)
	struct FVector                                     m_vCachedPrimaryTarget;                                   // 0x25C8(0x000C)
	struct FAimData                                    m_aCachedShieldBashLocation;                              // 0x25D4(0x0030)
	unsigned long                                      c_bIsHittable : 1;                                        // 0x2604(0x0004)
	unsigned long                                      r_SkyCuttingAxeSetAsTargetingDevice : 1;                  // 0x2604(0x0004) (Net)
	TArray<class UTgAnimNodeBlendList*>                m_HeroicChargeNodes;                                      // 0x2608(0x0010) (NeedCtorLink)
	struct FName                                       m_HeroicChargeNodeName;                                   // 0x2618(0x0008)
	TEnumAsByte<EXingTianUltState>                     r_CurrentUltimateState;                                   // 0x2620(0x0001) (Net)
	TEnumAsByte<EXingTianUltState>                     c_LocalUltimateState;                                     // 0x2621(0x0001) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_XingTian");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void STATIC_ForceLeapTargetingIfNeeded();
	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	void STATIC_OnRightMousePressed();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void AddRageStack();
	bool PostPawnSetup();
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_OnRespawn();
	bool STATIC_ShowImmunityHighlight();
	void STATIC_InitializePassiveVars();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
};


// Class TgGame.TgAnimNodeBlendList_Sol_Dev2
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendList_Sol_Dev2 : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Sol*                                 OwningSolPawn;                                            // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Sol_Dev2");
		return ptr;
	}


	void STATIC_ReplayAnim();
};


// Class TgGame.TgDeploy_Sol_Diamond
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeploy_Sol_Diamond : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Sol_Diamond");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Sol_Trail
// 0x0004 (0x0408 - 0x0404)
class ATgDeployable_Sol_Trail : public ATgDeployable_GroundTrail
{
public:
	unsigned long                                      r_bIgnited : 1;                                           // 0x0404(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Sol_Trail");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
};


// Class TgGame.TgDeployable_Sol_Ult
// 0x0004 (0x03D8 - 0x03D4)
class ATgDeployable_Sol_Ult : public ATgDeployable
{
public:
	unsigned long                                      r_bPassiveStacked : 1;                                    // 0x03D4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Sol_Ult");
		return ptr;
	}


	void STATIC_DeployComplete();
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable_Sol_Whip
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_Sol_Whip : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Sol_Whip");
		return ptr;
	}


	void STATIC_InstantFireDeployable();
};


// Class TgGame.TgDevice_Sol_BasicAttack
// 0x0000 (0x054C - 0x054C)
class ATgDevice_Sol_BasicAttack : public ATgDevice_ActiveMode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sol_BasicAttack");
		return ptr;
	}


	void ToggleInstability(TEnumAsByte<ESolInstabilityState> NewState);
};


// Class TgGame.TgDevice_Sol_Dev1
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Sol_Dev1 : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sol_Dev1");
		return ptr;
	}


	bool CanBeCanceled();
	bool ShouldInterruptInhand();
};


// Class TgGame.TgDevice_Sol_Dev2
// 0x0004 (0x0500 - 0x04FC)
class ATgDevice_Sol_Dev2 : public ATgDevice_Deployable
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                                       // 0x04FC(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sol_Dev2");
		return ptr;
	}


	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void InterruptFiring();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_StartShockwaveAt(const struct FVector& SpawnLoc);
	bool IsToggledOn();
};


// Class TgGame.TgDevice_Sol_Trail
// 0x0004 (0x0500 - 0x04FC)
class ATgDevice_Sol_Trail : public ATgDevice_Deployable
{
public:
	unsigned long                                      r_bPassiveActive : 1;                                     // 0x04FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sol_Trail");
		return ptr;
	}


	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
	void Tick(float DeltaTime);
	bool STATIC_DeactivateTrail();
	bool ActivateTrail();
};


// Class TgGame.TgDevice_Sol_Ult
// 0x002C (0x0528 - 0x04FC)
class ATgDevice_Sol_Ult : public ATgDevice_Deployable
{
public:
	unsigned long                                      s_bSpecialFire : 1;                                       // 0x04FC(0x0004)
	int                                                m_nRemainingDeployables;                                  // 0x0500(0x0004)
	struct FVector                                     m_vLastDeployLocation;                                    // 0x0504(0x000C)
	float                                              m_fDistanceBetweenDeployables;                            // 0x0510(0x0004)
	float                                              m_fNextDeployableDelay;                                   // 0x0514(0x0004)
	TArray<class ATgPawn*>                             HitPawns;                                                 // 0x0518(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sol_Ult");
		return ptr;
	}


	void OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_CustomFire();
	void DropNext();
	bool StartFire();
};


// Class TgGame.TgDevice_Sol_2Basic
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Sol_2Basic : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sol_2Basic");
		return ptr;
	}


	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	bool STATIC_CanBeDisarmed();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Sol_Dev4_Staging
// 0x0000 (0x0528 - 0x0528)
class ATgDevice_Sol_Dev4_Staging : public ATgDevice_Staging
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sol_Dev4_Staging");
		return ptr;
	}


	bool STATIC_FireEndStageDevice();
	void STATIC_ClientInterrupt();
	bool CanBeInterrupted();
};


// Class TgGame.TgDevice_Sol_Dev4
// 0x0004 (0x050C - 0x0508)
class ATgDevice_Sol_Dev4 : public ATgDevice_AnvilSlamBase
{
public:
	unsigned long                                      s_bDisableOnTweenEnd : 1;                                 // 0x0508(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sol_Dev4");
		return ptr;
	}


	void STATIC_OnTweenEnd(bool bInterrupted);
	void STATIC_FireAmmunition();
	float STATIC_GetTweenTime();
	struct FVector GetTweenLocation(struct FAimData* Aim);
	void STATIC_ClientInterrupt();
};


// Class TgGame.TgDeviceFire_Sol_Dev2
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Sol_Dev2 : public UTgDeviceFire_Deploy
{
public:
	struct FPointer                                    m_pDepSetup;                                              // 0x01C0(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Sol_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Sol_TrailIgniter
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Sol_TrailIgniter : public UTgDeviceFire_OffsetCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Sol_TrailIgniter");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool IsOwnersTrail(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Sol_Dev1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Sol_Dev1 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Sol_Dev1");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgInventoryObject_Listen_SolDev2
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_SolDev2 : public UTgInventoryObject_Listen
{
public:
	int                                                m_nStacksRemaining;                                       // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SolDev2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SolUnstable
// 0x0018 (0x00E8 - 0x00D0)
class UTgInventoryObject_Listen_SolUnstable : public UTgInventoryObject_Listen
{
public:
	TArray<int>                                        m_nInstabilityIgnoreList;                                 // 0x00D0(0x0010) (NeedCtorLink)
	int                                                m_nInstabilityCategoryCode;                               // 0x00E0(0x0004) (Const)
	int                                                m_nInstabilitySituationalType;                            // 0x00E4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SolUnstable");
		return ptr;
	}


	void STATIC_ForceInstabilityToZero();
	bool STATIC_InstigatorIsPartiallyUnstable();
};


// Class TgGame.TgPawn_Sol
// 0x005C (0x2614 - 0x25B8)
class ATgPawn_Sol : public ATgPawn_Character
{
public:
	TEnumAsByte<ESolInstabilityState>                  r_eIsUnstable;                                            // 0x25B8(0x0001) (Net)
	TEnumAsByte<ESolInstabilityState>                  c_eLocalIsUnstable;                                       // 0x25B9(0x0001)
	TEnumAsByte<ESolUltState>                          r_eCurrentUltState;                                       // 0x25BA(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x25BB(0x0001) MISSED OFFSET
	TArray<int>                                        m_UnStableCannotBlockList;                                // 0x25BC(0x0010) (NeedCtorLink)
	unsigned long                                      r_bLeapingBack : 1;                                       // 0x25CC(0x0004) (Net)
	unsigned long                                      r_bDashLockingInput : 1;                                  // 0x25CC(0x0004) (Net)
	unsigned long                                      r_bIsDisapparated : 1;                                    // 0x25CC(0x0004) (Net)
	unsigned long                                      r_bNextPulse : 1;                                         // 0x25CC(0x0004) (Net)
	unsigned long                                      r_bInHandStimmed : 1;                                     // 0x25CC(0x0004) (Net)
	unsigned long                                      r_bIsAutoAttacking : 1;                                   // 0x25CC(0x0004) (Net)
	unsigned long                                      s_bDidTriggerPassiveAudio : 1;                            // 0x25CC(0x0004)
	unsigned long                                      r_bDev2InHand : 1;                                        // 0x25CC(0x0004) (Net)
	struct FVector                                     m_vLeapbackLocation;                                      // 0x25D0(0x000C)
	class UTgTrailComponent_Sol_Passive*               s_TrailComp;                                              // 0x25DC(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nUnstableGroupCategory;                                 // 0x25E4(0x0004)
	int                                                c_DisapparatedPostureId;                                  // 0x25E8(0x0004)
	class ATgDevice_Sol_Dev4*                          s_UltShooter;                                             // 0x25EC(0x0008)
	class ATgDevice_Sol_2Basic*                        s_Dev2InHand;                                             // 0x25F4(0x0008)
	class ATgDevice_Sol_BasicAttack*                   s_DefaultInHand;                                          // 0x25FC(0x0008)
	int                                                m_nDisapparateId;                                         // 0x2604(0x0004)
	float                                              r_fTrailDuration;                                         // 0x2608(0x0004) (Net)
	float                                              m_fRemainingTrail;                                        // 0x260C(0x0004)
	int                                                r_nPassiveAudioCueCount;                                  // 0x2610(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Sol");
		return ptr;
	}


	void STATIC_ServerOnRightMousePressed();
	void STATIC_OnRightMousePressed();
	void SetTargetingDevice(class ATgDevice* Dev);
	void UpdateIgnoreBlockingFlags(bool ShouldIgnore);
	bool FindTrailComponent();
	void IgniteTrail(class AActor* IgnitePoint);
	bool ShouldProjectilePulse();
	bool ShouldTrail();
	void STATIC_CleanUpOnDeath();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void Tick(float DeltaSeconds);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	void UpdateDashInputLock(bool IsLocked);
	void UpdateUltState(TEnumAsByte<ESolUltState> NewUltState);
	void ToggleInstability(TEnumAsByte<ESolInstabilityState> NewState);
	void ToggleAutoAttacking(bool AutoAttacking);
	void ToggleStimFx(bool IsStimmed);
	void UpdateTrailDuration(float Duration);
	void ReplicatedEvent(const struct FName& VarName);
	void TriggerInfrequentUnstableFX();
	void STATIC_ForceInstabilityToZero();
	bool IsPartiallyUnstable();
	void STATIC_ClearPersistantDamage();
	bool IsCoolingOff();
	void STATIC_SetInHandByPassive();
	void ActivateDev2Basic();
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_RegainEnergyPool(float fDelta);
	void STATIC_RegainPools(float fDelta);
	void STATIC_SetProperty(int nPropIndex, float fNewValue);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	bool STATIC_ShouldPawnMeshBeHiddenThisTick();
};


// Class TgGame.TgProj_Sol_SolarFlair
// 0x0018 (0x03E4 - 0x03CC)
class ATgProj_Sol_SolarFlair : public ATgProj_SimulatedSinusoid
{
public:
	struct FPointer                                    VfTable_ITgProjGroundTargetInterface;                     // 0x03CC(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bIsUnstable : 1;                                        // 0x03D4(0x0004) (Transient)
	struct FVector                                     m_GroundTargetLocation;                                   // 0x03D8(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Sol_SolarFlair");
		return ptr;
	}


	void ShutDown();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void SetGroundTarget(const struct FVector& GTLocation);
	void ClientTargetUpdate(class AActor* TargetActor, const struct FVector& TargetLocation);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	bool IsOutsideMinRange(const struct FVector& HitLocation);
	float STATIC_CalcFrequency(struct FVector* StartLocation, struct FVector* EndLocation);
};


// Class TgGame.TgTrailComponent_Sol_Passive
// 0x001C (0x00E4 - 0x00C8)
class UTgTrailComponent_Sol_Passive : public UTgTrailComponent_GroundTrail
{
public:
	TArray<class ATgDeployable*>                       s_DisconnectedCrumbs;                                     // 0x00C8(0x0010) (NeedCtorLink)
	struct FVector                                     s_vLastPoop;                                              // 0x00D8(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTrailComponent_Sol_Passive");
		return ptr;
	}


	struct FVector LastDroppedLoc();
	float TraveledDist();
	void STATIC_OnChildUnTouch(class AActor* Other, class ATgDeployable* Child);
	void STATIC_OnChildTouch(class AActor* Other, class ATgDeployable* Child);
	void IgniteTrailStartingAt(class ATgDeployable* TrailCrumb);
	void STATIC_RemoveGroundTrailByIndex(int I);
	bool STATIC_SpawnNewGroundTrail(const struct FVector& DeployLocation, const struct FRotator& DeployRotation);
	bool STATIC_SpawnNewGroundTrailAtOwner();
	void STATIC_PrepareForSelfDetach();
};


// Class TgGame.TgDeployable_Chiron_TrainingExercise
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_Chiron_TrainingExercise : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Chiron_TrainingExercise");
		return ptr;
	}


	void STATIC_FireAmmunitionDeployable();
};


// Class TgGame.TgDevice_Chiron_ChargeLong
// 0x0014 (0x0550 - 0x053C)
class ATgDevice_Chiron_ChargeLong : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bDoNotNotifyOthers : 1;                                 // 0x053C(0x0004) (Transient)
	unsigned long                                      m_bForceLockout : 1;                                      // 0x053C(0x0004)
	float                                              m_fForcedLockoutDuration;                                 // 0x0540(0x0004)
	float                                              m_fChargeBuffExtendedDuration;                            // 0x0544(0x0004)
	class UTgDeviceFire*                               m_CachedFireMode;                                         // 0x0548(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chiron_ChargeLong");
		return ptr;
	}


	void STATIC_EndChargeBuff();
	void STATIC_StartChargeBuff();
	void STATIC_EndForcedLockout();
	void STATIC_StartForcedLockout();
	void InstantFire();
	bool CanBeCanceled();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Chiron_Passive
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Chiron_Passive : public ATgDevice
{
public:
	class AActor*                                      r_CurrentTarget;                                          // 0x04F0(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chiron_Passive");
		return ptr;
	}


	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	class AActor* STATIC_GetTrackingTarget(int nFireIndex);
	bool UsesTrackingTarget();
	void UpdateTarget();
};


// Class TgGame.TgDevice_Chiron_SpreadShotShooter
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Chiron_SpreadShotShooter : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chiron_SpreadShotShooter");
		return ptr;
	}


	bool UsesTrackingTarget();
	class AActor* STATIC_GetTrackingTarget(int nFireIndex);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Chiron_UltimateShooter
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Chiron_UltimateShooter : public ATgDevice
{
public:
	unsigned long                                      r_IsFinalShot : 1;                                        // 0x04F0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chiron_UltimateShooter");
		return ptr;
	}


	float STATIC_GetFiringPostHitDelay(int nMode);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Chiron_TrainingExercise
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Chiron_TrainingExercise : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chiron_TrainingExercise");
		return ptr;
	}


	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_Chiron_Ultimate
// 0x0034 (0x055C - 0x0528)
class ATgDevice_Chiron_Ultimate : public ATgDevice_Staging
{
public:
	unsigned long                                      r_bShooterFired : 1;                                      // 0x0528(0x0004) (Net)
	unsigned long                                      m_bForcingPostFire : 1;                                   // 0x0528(0x0004)
	unsigned long                                      m_bInStaging : 1;                                         // 0x0528(0x0004)
	int                                                m_nAmmoRemaining;                                         // 0x052C(0x0004)
	int                                                m_nMaxAmmo;                                               // 0x0530(0x0004)
	float                                              m_fForcedPostFireDuration;                                // 0x0534(0x0004)
	class UClass*                                      m_DefaultCameraModuleClass;                               // 0x0538(0x0008)
	class UClass*                                      m_FiringCameraModuleClass;                                // 0x0540(0x0008)
	class UTgCameraModule*                             m_FiringCameraModule;                                     // 0x0548(0x0008)
	float                                              m_fCameraTweenInTime;                                     // 0x0550(0x0004)
	float                                              m_fCameraTweenOutTime;                                    // 0x0554(0x0004)
	float                                              m_fFiringCameraZOffset;                                   // 0x0558(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chiron_Ultimate");
		return ptr;
	}


	void TurnOffSpecialCamera();
	void TurnOnSpecialCamera();
	void STATIC_EndForcedPostFire();
	void OnStageShooterStopFire(bool bInterrupted);
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	bool LockStageShooterFiring();
	bool CanJumpWhileFiring();
	bool CanBeCanceled();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool ShouldTriggerCastReactionItems();
	bool ShouldInterruptInhand();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
};


// Class TgGame.TgDeviceFire_Chiron_Passive
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Chiron_Passive : public UTgDeviceFire
{
public:
	int                                                m_nTempChironLevel;                                       // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Chiron_Passive");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Chiron_SpreadShot
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Chiron_SpreadShot : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Chiron_SpreadShot");
		return ptr;
	}


	int STATIC_GetShotsPerFire();
};


// Class TgGame.TgDeviceFire_Chiron_UltimateShooter
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Chiron_UltimateShooter : public UTgDeviceFire
{
public:
	float                                              m_fCachedRangeTimestamp;                                  // 0x01C0(0x0004)
	float                                              m_fCachedRange;                                           // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Chiron_UltimateShooter");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	float STATIC_GetRange();
	class ATgPawn* STATIC_SpawnPet(bool bPet);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
};


// Class TgGame.TgDeviceFire_Chiron_TrainingExercise
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Chiron_TrainingExercise : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Chiron_TrainingExercise");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Chiron_UltimateShooter
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Chiron_UltimateShooter : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Chiron_UltimateShooter");
		return ptr;
	}


	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgMarkComponent_Chiron_Lockon
// 0x0000 (0x00BC - 0x00BC)
class UTgMarkComponent_Chiron_Lockon : public UTgMarkComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMarkComponent_Chiron_Lockon");
		return ptr;
	}


	void UpdateLockonState();
	void STATIC_RemoveMarkByIndex(int nIndex);
	void AddMark(class AActor* Target);
};


// Class TgGame.TgPawn_Chiron
// 0x00EC (0x26A4 - 0x25B8)
class ATgPawn_Chiron : public ATgPawn_Character
{
public:
	class ATgDevice*                                   r_dev_inhand;                                             // 0x25B8(0x0008) (Net)
	class ATgDevice_Chiron_ChargeLong*                 r_dev_chargelong;                                         // 0x25C0(0x0008) (Net)
	class ATgDevice_Chiron_Ultimate*                   r_dev_ultimate;                                           // 0x25C8(0x0008) (Net)
	class ATgDevice_Chiron_Passive*                    s_dev_passive;                                            // 0x25D0(0x0008)
	int                                                r_nLocksActive;                                           // 0x25D8(0x0004) (Net)
	class UTgMarkComponent_Chiron_Lockon*              s_TargetingMarks;                                         // 0x25DC(0x0008) (ExportObject, Component, EditInline)
	class UClass*                                      m_ChargeLongControlModuleClass;                           // 0x25E4(0x0008) (Const)
	class UClass*                                      m_PreviousControlModuleClass;                             // 0x25EC(0x0008)
	class UTgControlModule*                            m_ChargeLongControlModule;                                // 0x25F4(0x0008)
	class UTgAnimNodeSlot*                             c_KickAnimSlot;                                           // 0x25FC(0x0008)
	struct FName                                       c_KickAnimName;                                           // 0x2604(0x0008)
	float                                              m_fKickAnimRecoverTime;                                   // 0x260C(0x0004)
	unsigned long                                      m_bTransformInProgress : 1;                               // 0x2610(0x0004)
	unsigned long                                      m_bKicking : 1;                                           // 0x2610(0x0004)
	unsigned long                                      r_bUltIsBuildingUp : 1;                                   // 0x2610(0x0004) (Net)
	unsigned long                                      s_bKillOnStopFire : 1;                                    // 0x2610(0x0004)
	unsigned long                                      s_bTargetable : 1;                                        // 0x2610(0x0004)
	unsigned long                                      r_bReviveOccured : 1;                                     // 0x2610(0x0004) (Net)
	float                                              r_fChargeDecreaseSpeedMultiplier;                         // 0x2614(0x0004) (Net)
	float                                              m_fChargeIncreaseSpeedMultiplier;                         // 0x2618(0x0004)
	float                                              m_fTurnSlowPct;                                           // 0x261C(0x0004)
	float                                              m_fKickCheckCount;                                        // 0x2620(0x0004)
	float                                              m_fKickCheckDelta;                                        // 0x2624(0x0004)
	float                                              m_fKickCheckRange;                                        // 0x2628(0x0004)
	float                                              m_fTotalUltChargeUpTime;                                  // 0x262C(0x0004)
	float                                              m_fRemainingUltChargeUpTime;                              // 0x2630(0x0004)
	class APawn*                                       s_Killer;                                                 // 0x2634(0x0008)
	TArray<class AActor*>                              s_Damaged;                                                // 0x263C(0x0010) (NeedCtorLink)
	TArray<float>                                      s_AccumulatedDamage;                                      // 0x264C(0x0010) (NeedCtorLink)
	float                                              r_fTotalHealthStolen;                                     // 0x265C(0x0004) (Net)
	class UTgEffectGroup*                              s_UltimateCancelRoot;                                     // 0x2660(0x0008)
	class UTgSpecialFx*                                m_ReviveFX;                                               // 0x2668(0x0008)
	int                                                c_nMaxPassiveStacks;                                      // 0x2670(0x0004)
	int                                                r_nCurrentPassiveStacks;                                  // 0x2674(0x0004) (Net)
	float                                              r_fCurrentPassiveMeterEnergy;                             // 0x2678(0x0004) (Net)
	float                                              r_fMaxPassiveMeterEnergy;                                 // 0x267C(0x0004) (Net)
	float                                              r_fCurrentPassiveDistance;                                // 0x2680(0x0004) (Net)
	float                                              r_fMaxPassiveDistance;                                    // 0x2684(0x0004) (Net)
	float                                              m_fPassiveDistanceMultiplier;                             // 0x2688(0x0004)
	float                                              m_fRemainingPausePassiveDistanceTime;                     // 0x268C(0x0004)
	TArray<class UTgSpecialFx*>                        c_PassiveSpecialFX;                                       // 0x2690(0x0010) (Transient, NeedCtorLink)
	int                                                c_nPrevStacks;                                            // 0x26A0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Chiron");
		return ptr;
	}


	void STATIC_OnRespawn();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void PlayReviveFx();
	void ToggleUltimateRoot(bool bEnable);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_EndChargeKickAnim();
	void PlayChargeKickAnim();
	void DeathPreventedFrom(class APawn* attacker);
	struct FRotator STATIC_GetAdjustedAimFor(class AWeapon* W, const struct FVector& StartFireLoc);
	float STATIC_GetChargeTurnRate();
	void PassiveFire(class AActor* Target);
	int STATIC_GetNumPassiveStacks();
	void SetTargetingDevice(class ATgDevice* Dev);
	bool DeviceOverrideLockedDown(class ATgDevice* Dev);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SendKillingBlowMessage(class AActor* Source, class AActor* Target, float fDamage, float fMitigated);
	void STATIC_SetTargetable(bool targetable);
	void UpdatePassiveSpecialFX(int nStacks);
	bool STATIC_InitializePassiveSpecialFX();
	bool STATIC_InitializeReviveFX();
	bool STATIC_CanFirePassive(class ATgDevice* Dev);
	void STATIC_DecrementPassiveStacks();
	void STATIC_IncrementPassiveStacks();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	float STATIC_GetSmoothEnergy();
	void STATIC_PawnAdjustHeal(class ATgPawn* InstigatorPawn, int nPropertyId, int nSimplifiedPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnFire(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
};


// Class TgGame.TgPawn_Chiron_Arrow
// 0x0054 (0x24B8 - 0x2464)
class ATgPawn_Chiron_Arrow : public ATgPawn_Familiar
{
public:
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x2464(0x0008)
	class UTgDeviceFire*                               s_OwnerFireMode;                                          // 0x246C(0x0008)
	TArray<class AActor*>                              s_HitActors;                                              // 0x2474(0x0010) (NeedCtorLink)
	int                                                s_nFiringInstance;                                        // 0x2484(0x0004)
	struct FVector                                     s_vSpawnLocation;                                         // 0x2488(0x000C)
	float                                              s_fRange;                                                 // 0x2494(0x0004)
	float                                              s_fProximityDistance;                                     // 0x2498(0x0004)
	TArray<struct FVector>                             s_WallEntrances;                                          // 0x249C(0x0010) (NeedCtorLink)
	struct FVector                                     s_LastLocation;                                           // 0x24AC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Chiron_Arrow");
		return ptr;
	}


	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	bool IsNonCombat();
};


// Class TgGame.TgProj_Chiron_SpreadShotArrow
// 0x0008 (0x03D4 - 0x03CC)
class ATgProj_Chiron_SpreadShotArrow : public ATgProj_SimulatedSeeking
{
public:
	class UTgSpecialFx*                                m_WarningFx;                                              // 0x03CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Chiron_SpreadShotArrow");
		return ptr;
	}


	void ShutDown();
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void UpdateVisualsOnSetTarget();
};


// Class TgGame.TgAchievement_G72_Reflect
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_G72_Reflect : public UTgAchievement
{
public:
	float                                              m_fDuration;                                              // 0x0084(0x0004)
	int                                                m_nDeviceId;                                              // 0x0088(0x0004)
	float                                              s_fMaxWorldTime;                                          // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_G72_Reflect");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_G72_Ult
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendList_G72_Ult : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_G72_Ult");
		return ptr;
	}


	void STATIC_PlayAnim(bool bLoop, float Rate, float StartTime);
	void SetActiveAnimationIndex();
};


// Class TgGame.TgDevice_G72_Dev1
// 0x0001 (0x0525 - 0x0524)
class ATgDevice_G72_Dev1 : public ATgDevice_PassiveAura
{
public:
	TEnumAsByte<EG72_AuraType>                         r_eAuraType;                                              // 0x0524(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G72_Dev1");
		return ptr;
	}


	void BeginAura();
	void SwapAuraType();
	void STATIC_FireAmmunition();
	bool IsAuraActive();
	void STATIC_SetParticleFilter();
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_G72_Dev3
// 0x0000 (0x053C - 0x053C)
class ATgDevice_G72_Dev3 : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G72_Dev3");
		return ptr;
	}


	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
};


// Class TgGame.TgDevice_G72_Dev2Stage
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_G72_Dev2Stage : public ATgDevice
{
public:
	unsigned long                                      r_bWillSwapOnFire : 1;                                    // 0x04F0(0x0004) (Net)
	int                                                c_nChargingPostureId;                                     // 0x04F4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G72_Dev2Stage");
		return ptr;
	}


	bool ShouldInterruptInhand();
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void STATIC_ResetDevice();
	bool CanBeInterrupted();
	void ForceRefireOnTimeout();
	void STATIC_ResetRefireTargeter();
	void AttachRefireTargeting();
	void ShowRefireTargeter();
	void SetPosture();
	void STATIC_CustomFire();
	bool ApplyGlobalOffhandCooldown();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	void ReplicatedEvent(const struct FName& VarName);
	bool UsesTargetingMode();
	bool IsToggledOn();
	float GetRefireTime(int nMode);
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgDevice_G72_Passive
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_G72_Passive : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G72_Passive");
		return ptr;
	}


	void PassiveAuraProxyOnUnTouch(class AActor* Other);
	void PassiveAuraProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_G72_Dev4
// 0x0008 (0x0504 - 0x04FC)
class ATgDevice_G72_Dev4 : public ATgDevice_HitPulse
{
public:
	int                                                r_nUltSwing;                                              // 0x04FC(0x0004) (Net)
	int                                                s_nUltPulse;                                              // 0x0500(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G72_Dev4");
		return ptr;
	}


	bool CanBeInterrupted();
	void DeliverQueuedPendingHits();
	void UpdatePawnAnim(int SwingNum);
};


// Class TgGame.TgDeviceFire_G72_Dev1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_G72_Dev1 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_G72_Dev1");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	void RemoveEffectType(class AActor* Target, bool bForceRemove, int nEffectGroupType, int StackCount);
	void ApplyEffectType(class AActor* Target, int nEffectGroupType, const struct FImpactInfo& Impact, int StackCount);
};


// Class TgGame.TgDeviceFire_G72_Dev2Stage
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_G72_Dev2Stage : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_G72_Dev2Stage");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	float STATIC_GetShotPowerCost(int nPacingType, bool bBaseOnly);
	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_G72_Dev4
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_G72_Dev4 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_G72_Dev4");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceForm_G72_Dev2
// 0x0014 (0x024C - 0x0238)
class UTgDeviceForm_G72_Dev2 : public UTgDeviceForm
{
public:
	class UTgSpecialFx*                                c_RefireFx;                                               // 0x0238(0x0008)
	class ATgSkeletalMeshActor*                        c_RefireFxMesh;                                           // 0x0240(0x0008)
	int                                                m_nRefireFxId;                                            // 0x0248(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_G72_Dev2");
		return ptr;
	}


	void STATIC_DisableRefireFX();
	void ActivateRefireFX();
};


// Class TgGame.TgPawn_G72
// 0x0070 (0x2628 - 0x25B8)
class ATgPawn_G72 : public ATgPawn_Character
{
public:
	float                                              r_fStoredDamage;                                          // 0x25B8(0x0004) (Net)
	class ATgDevice*                                   s_dDefaultInHand;                                         // 0x25BC(0x0008)
	int                                                r_nUltAnim;                                               // 0x25C4(0x0004) (Net)
	float                                              m_fLastUltimateFire;                                      // 0x25C8(0x0004)
	int                                                r_nChargeEndTrigger;                                      // 0x25CC(0x0004) (Net)
	int                                                r_nStartStoredCharge;                                     // 0x25D0(0x0004) (Net)
	int                                                r_nMaxCharged;                                            // 0x25D4(0x0004) (Net)
	int                                                r_nResetCharge;                                           // 0x25D8(0x0004) (Net)
	class UTgSpecialFx*                                c_sfxChargeFx;                                            // 0x25DC(0x0008)
	class UTgAnimNodeSlot*                             c_MirrorSlot;                                             // 0x25E4(0x0008)
	unsigned long                                      r_bEnraged : 1;                                           // 0x25EC(0x0004) (Net)
	unsigned long                                      s_bServerRefireMirror : 1;                                // 0x25EC(0x0004)
	unsigned long                                      r_bMirrorOnlyAnim : 1;                                    // 0x25EC(0x0004) (Net)
	int                                                c_nEnragedPostureId;                                      // 0x25F0(0x0004)
	int                                                r_nParticleFilter;                                        // 0x25F4(0x0004) (Net)
	struct FG72PassiveTarget                           s_PassiveTargets[0x3];                                    // 0x25F8(0x0010)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_G72");
		return ptr;
	}


	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	bool OtherDeviceBlockingOffhand2Anim(class ATgDevice* FinishingDevice);
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void Tick(float DeltaSeconds);
	void TriggerChargeEndFx();
	void DeactivateChargeFx();
	void ActivateFullChargeFx();
	void ActivateChargingFx();
	void SetPosture();
	void ReplicatedEvent(const struct FName& VarName);
	void ToggleDev1AuraFX(int nAuraFilter);
	void STATIC_FlashStartFire(int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	bool STATIC_InitPassiveAuras();
	int STATIC_GetCustomParticleSystemFilter();
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgDevice_Raijin_Dev1
// 0x0009 (0x0505 - 0x04FC)
class ATgDevice_Raijin_Dev1 : public ATgDevice_HitPulse
{
public:
	float                                              m_fProjectileXOffset;                                     // 0x04FC(0x0004)
	float                                              m_fProjectileYOffset;                                     // 0x0500(0x0004)
	TEnumAsByte<EWeaponFireType>                       m_nCachedFireType;                                        // 0x0504(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Raijin_Dev1");
		return ptr;
	}


	bool CanBeCanceled();
	bool CanBeInterrupted();
	void STATIC_CustomFire();
	void STATIC_FireAmmunition();
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Raijin_Dev1_V2
// 0x0003 (0x0508 - 0x0505)
class ATgDevice_Raijin_Dev1_V2 : public ATgDevice_Raijin_Dev1
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0505(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Raijin_Dev1_V2");
		return ptr;
	}


	void STATIC_CustomFire();
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Raijin_Dev4
// 0x0048 (0x0544 - 0x04FC)
class ATgDevice_Raijin_Dev4 : public ATgDevice_HitPulse
{
public:
	TEnumAsByte<EBeatSelect>                           m_CachedBeatSelect;                                       // 0x04FC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04FD(0x0003) MISSED OFFSET
	TArray<class UTgDeviceFire*>                       m_Beat2FireModes;                                         // 0x0500(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_Beat3FireModes;                                         // 0x0510(0x0010) (NeedCtorLink)
	class UClass*                                      m_DefaultCameraModuleClass;                               // 0x0520(0x0008)
	class UClass*                                      m_FiringCameraModuleClass;                                // 0x0528(0x0008)
	class UTgCameraModule*                             m_FiringCameraModule;                                     // 0x0530(0x0008)
	float                                              m_fCameraTweenInTime;                                     // 0x0538(0x0004)
	float                                              m_fCameraTweenOutTime;                                    // 0x053C(0x0004)
	float                                              m_fFiringCameraZOffset;                                   // 0x0540(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Raijin_Dev4");
		return ptr;
	}


	void TurnOffSpecialCamera();
	void TurnOnSpecialCamera();
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void TickTargetingMode(float DeltaSeconds);
	void UpdateAimWhileFiring(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Raijin_Dev3
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Raijin_Dev3 : public ATgDevice
{
public:
	float                                              m_fMinTweenTime;                                          // 0x04F0(0x0004)
	float                                              m_fFixedVelocity;                                         // 0x04F4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Raijin_Dev3");
		return ptr;
	}


	void BeginThunder();
	void InstantFire();
	bool CanBeCanceled();
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgDevice_Raijin_KotoDrums
// 0x001C (0x050C - 0x04F0)
class ATgDevice_Raijin_KotoDrums : public ATgDevice
{
public:
	TEnumAsByte<EKotoBeat>                             m_CachedBeatSelect;                                       // 0x04F0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F1(0x0003) MISSED OFFSET
	class ATgDevice*                                   c_BeatDevice;                                             // 0x04F4(0x0008)
	unsigned long                                      m_bForcingPostFire : 1;                                   // 0x04FC(0x0004)
	unsigned long                                      m_bReadyToFire : 1;                                       // 0x04FC(0x0004)
	float                                              m_fForcedPostFireDuration;                                // 0x0500(0x0004)
	int                                                m_nMaxBeatFireCount;                                      // 0x0504(0x0004)
	int                                                r_nBeatFireCount;                                         // 0x0508(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Raijin_KotoDrums");
		return ptr;
	}


	void STATIC_EndForcedPostFire();
	void STATIC_StartForcedPostFire();
	void BeatStopFire();
	void BeatAmmunitionFired();
	bool CanBeCanceled();
	bool CanBeInterrupted();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
	void UpdateAimWhileFiring(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Raijin_KotoDrums_Beat
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Raijin_KotoDrums_Beat : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Raijin_KotoDrums_Beat");
		return ptr;
	}


	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	bool ApplyGlobalOffhandCooldown();
	bool STATIC_ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Raijin_RaijuuBouncing
// 0x0028 (0x051C - 0x04F4)
class ATgDevice_Raijin_RaijuuBouncing : public ATgDevice_ProjectileTeleport
{
public:
	class ATgProj_Raijin_RaijuuBouncing*               m_Raijuu;                                                 // 0x04F4(0x0008)
	class ATgPawn*                                     r_LastHitPawn;                                            // 0x04FC(0x0008) (Net)
	class ATgPawn*                                     c_FxPawn;                                                 // 0x0504(0x0008) (Transient)
	class UTgSpecialFx*                                c_TargetingDirectionFx;                                   // 0x050C(0x0008) (Transient)
	class UTgSpecialFx*                                c_TargetingPawnFx;                                        // 0x0514(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Raijin_RaijuuBouncing");
		return ptr;
	}


	void UpdateTargetFxs();
	void STATIC_ClearTargetingFxs();
	class ATgProjectile* GetProjectile();
	void PostDemoRewind();
	void PreDemoRewind();
	void Tick(float DeltaTime);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_Raijin_Dev2
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Raijin_Dev2 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Raijin_Dev2");
		return ptr;
	}


	bool CalcRaijuuTarget(const struct FAimData& Aim, class UTgDeviceFire* currentFire, class AActor** EnemyTarget);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
};


// Class TgGame.TgDeviceForm_Raijin_Ultimate
// 0x0000 (0x0260 - 0x0260)
class UTgDeviceForm_Raijin_Ultimate : public UTgDeviceForm_OverlaySelect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Raijin_Ultimate");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Raijin_A02
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Raijin_A02 : public UTgInventoryObject_Listen
{
public:
	float                                              m_fRemainingTime;                                         // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Raijin_A02");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_RaijinPSV
// 0x001C (0x00EC - 0x00D0)
class UTgInventoryObject_Listen_RaijinPSV : public UTgInventoryObject_Listen
{
public:
	int                                                m_nCurrentPassiveStacks;                                  // 0x00D0(0x0004)
	int                                                m_nMaxPassiveStacks;                                      // 0x00D4(0x0004)
	TArray<int>                                        m_RaijinDeviceIDs;                                        // 0x00D8(0x0010) (NeedCtorLink)
	int                                                m_nPendingCooldownDevId;                                  // 0x00E8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_RaijinPSV");
		return ptr;
	}


	void STATIC_ReduceAllDeviceCooldowns();
	void STATIC_IncrementPassiveStacks(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_Raijin
// 0x0110 (0x26C8 - 0x25B8)
class ATgPawn_Raijin : public ATgPawn_Character
{
public:
	int                                                m_nBotInhandId;                                           // 0x25B8(0x0004)
	int                                                m_nBotPassiveId;                                          // 0x25BC(0x0004)
	int                                                m_nBotOffhand1Id;                                         // 0x25C0(0x0004)
	int                                                m_nBotOffhand2Id;                                         // 0x25C4(0x0004)
	int                                                m_nBotOffhand2SubId;                                      // 0x25C8(0x0004)
	int                                                m_nBotOffhand3Id;                                         // 0x25CC(0x0004)
	int                                                m_nBotKotoDrumId;                                         // 0x25D0(0x0004)
	int                                                m_nBotBeat1Id;                                            // 0x25D4(0x0004)
	int                                                m_nBotBeat2Id;                                            // 0x25D8(0x0004)
	int                                                m_nBotBeat3Id;                                            // 0x25DC(0x0004)
	class ATgDevice*                                   r_dev_inhand;                                             // 0x25E0(0x0008) (Net)
	class ATgDevice*                                   s_dev_passive;                                            // 0x25E8(0x0008)
	class ATgDevice_Raijin_Dev1*                       r_dev_offhand1;                                           // 0x25F0(0x0008) (Net)
	class ATgDevice_Raijin_Dev2*                       r_dev_offhand2;                                           // 0x25F8(0x0008) (Net)
	class ATgDevice_Raijin_Dev3*                       r_dev_offhand3;                                           // 0x2600(0x0008) (Net)
	class ATgDevice_Raijin_Dev4*                       r_dev_offhand4;                                           // 0x2608(0x0008) (Net)
	class ATgDevice_Raijin_KotoDrums*                  r_dev_kotodrums;                                          // 0x2610(0x0008) (Net)
	class ATgDevice*                                   r_dev_beat1;                                              // 0x2618(0x0008) (Net)
	class ATgDevice*                                   r_dev_beat2;                                              // 0x2620(0x0008) (Net)
	class ATgDevice*                                   r_dev_beat3;                                              // 0x2628(0x0008) (Net)
	unsigned long                                      r_bPassiveBuffActive : 1;                                 // 0x2630(0x0004)
	unsigned long                                      r_bRaijuuBouncing : 1;                                    // 0x2630(0x0004) (Net)
	unsigned long                                      r_bRaijuuVisible : 1;                                     // 0x2630(0x0004) (Net)
	unsigned long                                      s_bProccingRaijuu : 1;                                    // 0x2630(0x0004)
	unsigned long                                      s_bTargetable : 1;                                        // 0x2630(0x0004)
	class UObject*                                     s_CachedPassiveDeviceModeReference;                       // 0x2634(0x0008)
	int                                                s_nCachedPassiveFiringInstance;                           // 0x263C(0x0004)
	int                                                c_nPrevPassiveStacks;                                     // 0x2640(0x0004) (Transient)
	int                                                r_nCurrentPassiveStacks;                                  // 0x2644(0x0004) (Net)
	int                                                m_nMaxPassiveStacks;                                      // 0x2648(0x0004)
	TArray<class UTgSpecialFx*>                        c_PassiveSpecialFX;                                       // 0x264C(0x0010) (Transient, NeedCtorLink)
	class UTgSpecialFx*                                c_ThunderCrashFX;                                         // 0x265C(0x0008)
	class USkeletalMeshComponent*                      c_Raijuu;                                                 // 0x2664(0x0008) (ExportObject, Component, EditInline)
	class UTgSpecialFx*                                c_RaijuuBellybuttonFX;                                    // 0x266C(0x0008)
	class UTgAnimNodeSlot*                             m_RaijuuFullBodyNode;                                     // 0x2674(0x0008)
	float                                              m_fDesiredRaijuuScale;                                    // 0x267C(0x0004) (Transient)
	class AActor*                                      r_RaijuuBellyButtonTarget;                                // 0x2680(0x0008) (Net)
	float                                              r_fRemainingRaijuuBellyButtonTime;                        // 0x2688(0x0004) (Net)
	float                                              m_fMaxRaijuuBellyButtonTime;                              // 0x268C(0x0004)
	TArray<class UTgDeviceFire*>                       m_RaijuuBounceModes;                                      // 0x2690(0x0010) (AlwaysInit, NeedCtorLink)
	class AActor*                                      m_RaijuuBounceTarget;                                     // 0x26A0(0x0008)
	int                                                m_nMaxRaijuuBounceCount;                                  // 0x26A8(0x0004)
	class UTgDeviceFire*                               s_RaijuuFiremode;                                         // 0x26AC(0x0008)
	class ATgDeployable*                               m_Num3WarningDeployable;                                  // 0x26B4(0x0008)
	TEnumAsByte<EBeatSelect>                           r_BeatSelect;                                             // 0x26BC(0x0001) (Net)
	TEnumAsByte<EBeatSelect>                           m_LastBeatSelect;                                         // 0x26BD(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x26BE(0x0002) MISSED OFFSET
	class ATgDevice_Raijin_KotoDrums_Beat*             m_BeatDevice;                                             // 0x26C0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Raijin");
		return ptr;
	}


	void STATIC_OnRespawn();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void StopRaijuuBellybuttonFx();
	void PlayRaijuuBellybuttonFx();
	class AProjectile* SpawnRaijuuBouncingProjectile();
	void RaijuuEndBouncing();
	void RaijuuStartBouncing();
	void SetRaijuuVisibility(bool bVisible);
	void ResetRaijuuTimers();
	void SetRaijuuBellyButtonTarget(class AActor* Target);
	void STATIC_SetBeatDevice(class ATgDevice* Dev);
	void STATIC_ServerSetBeatSelect(TEnumAsByte<EBeatSelect> beatType);
	void SetTargetingDevice(class ATgDevice* Dev);
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	bool DeviceOverrideLockedDown(class ATgDevice* Dev);
	void Tick(float fDeltaSeconds);
	void STATIC_StopFullBodyAnimation(float BlendOutTime);
	bool PostPawnSetup();
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ReplicatedEvent(const struct FName& VarName);
	void TryAutoSkillUp();
	bool STATIC_ShouldAllowSkillUp(bool bIsAutoSkillUp);
	bool STATIC_FindTeleportSpot(const struct FVector& Extent, struct FVector* TeleportLocation);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void UpdateRaijuuVisibility();
	void STATIC_SetTargetable(bool targetable);
	void STATIC_SetDeviceFlashing(class ATgDevice* Dev, bool bFlashing);
	void UpdatePassiveSpecialFX(int nStacks);
	void STATIC_ClearPassiveStacks();
	void STATIC_IncrementPassiveStacks();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void ApplyPassiveBonusDamage(const struct FImpactInfo& Impact);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DeviceOnHitSpecial(class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	bool STATIC_PlayFullBodyAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, bool bBlendOutIfVelocityIsGreaterThanZero, bool bHideInHandDevice);
	void AdjustMeshTranslation();
	void STATIC_SwapToLiveMesh();
	void STATIC_InitRaijuuMesh();
	bool STATIC_InitializePassiveSpecialFX();
	bool STATIC_InitializeRaijuuBellybuttonFX();
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_Raijin_PVE
// 0x0000 (0x26C8 - 0x26C8)
class ATgPawn_Raijin_PVE : public ATgPawn_Raijin
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Raijin_PVE");
		return ptr;
	}

};


// Class TgGame.TgPawn_RaijinV2
// 0x0010 (0x26D8 - 0x26C8)
class ATgPawn_RaijinV2 : public ATgPawn_Raijin
{
public:
	TArray<class ATgDevice*>                           m_RaijinDevices;                                          // 0x26C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_RaijinV2");
		return ptr;
	}


	void STATIC_IncrementPassiveStacks();
	void SetPassiveStacks(int StackCount);
	void ApplyPassiveBonusDamage(const struct FImpactInfo& Impact);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgProj_Raijin_RaijuuSeeking
// 0x0048 (0x03E0 - 0x0398)
class ATgProj_Raijin_RaijuuSeeking : public ATgProj_Simulated
{
public:
	struct FPointer                                    VfTable_ITgProjGroundTargetInterface;                     // 0x0398(0x0008) (Const, Native, NoExport)
	float                                              m_fTurnStrength;                                          // 0x03A0(0x0004)
	float                                              m_fVertTurnStrength;                                      // 0x03A4(0x0004)
	struct FRotator                                    m_SeekingRotation;                                        // 0x03A8(0x000C)
	class UTgAnimNodeBlendList*                        m_AttackBlendList;                                        // 0x03B4(0x0008)
	class ATgSkeletalMeshActor*                        m_WarningFxMesh;                                          // 0x03BC(0x0008)
	unsigned long                                      m_bGroundTargetReached : 1;                               // 0x03C4(0x0004)
	unsigned long                                      m_bRaijuuTargetFound : 1;                                 // 0x03C4(0x0004)
	unsigned long                                      m_bDeployedOnActorTarget : 1;                             // 0x03C4(0x0004)
	unsigned long                                      m_bInitialHit : 1;                                        // 0x03C4(0x0004)
	struct FVector                                     m_GroundTargetLocation;                                   // 0x03C8(0x000C)
	class AActor*                                      m_actorTarget;                                            // 0x03D4(0x0008)
	float                                              m_fLastHitTime;                                           // 0x03DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Raijin_RaijuuSeeking");
		return ptr;
	}


	void ShutDown();
	void STATIC_PlayFizzleFX(const struct FVector& HitLocation, const struct FVector& HitNormal, bool bIsExplosionFizzle);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployRaijuu(class AActor* ActorTarget);
	void STATIC_SetActorTarget(class AActor* ActorTarget);
	void SetGroundTarget(const struct FVector& GTLocation);
	void ClientTargetUpdate(class AActor* TargetActor, const struct FVector& TargetLocation);
	bool STATIC_CalcRaijuuAoe(const struct FAimData& Aim, class AActor** EnemyTarget);
	struct FVector GetActorSeekLocation(class AActor* ActorTarget);
	void UpdateActorTargetSeekingDirection(float fDeltaTime);
	void UpdateGroundTargetSeekingDirection(float fDeltaTime);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	bool STATIC_CheckProjectileRangeSpecial(const struct FVector& vLocOverride);
	bool STATIC_CheckActorTargetDistance(const struct FVector& vLocOverride);
	bool STATIC_CheckGroundTargetDistance(const struct FVector& vLocOverride);
	void ActorTargetReached();
	void STATIC_GroundTargetReached();
	void Tick(float fDeltaTime);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_PlayAttackAnim();
	void UpdateVisualsOnSetGroundTarget();
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_Raijin_Dev1
// 0x0010 (0x03BC - 0x03AC)
class ATgProj_Raijin_Dev1 : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_fStartRadius;                                           // 0x03AC(0x0004)
	float                                              m_fEndRadius;                                             // 0x03B0(0x0004)
	float                                              m_fCurrentRadius;                                         // 0x03B4(0x0004)
	float                                              m_fDeltaRadiusPerSec;                                     // 0x03B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Raijin_Dev1");
		return ptr;
	}


	void Tick(float DeltaSeconds);
};


// Class TgGame.TgProj_Raijin_RaijuuBouncing
// 0x0024 (0x0430 - 0x040C)
class ATgProj_Raijin_RaijuuBouncing : public ATgProj_SimulatedArcing
{
public:
	class UTgAnimNodeBlendList*                        m_AttackBlendList;                                        // 0x040C(0x0008)
	float                                              m_fTweenTime;                                             // 0x0414(0x0004)
	float                                              m_fTween;                                                 // 0x0418(0x0004)
	struct FVector                                     m_vTweenSource;                                           // 0x041C(0x000C)
	class AActor*                                      m_LastHitTarget;                                          // 0x0428(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Raijin_RaijuuBouncing");
		return ptr;
	}


	void ShutDown();
	void SetSeekingTarget(class AActor* LockedTarget);
	struct FVector GetSeekLocation();
	void UpdateSeekingDirection(float fDeltaTime);
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void PostBeginPlay();
	void STATIC_StopAttackAnim();
	void STATIC_PlayAttackAnim();
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgDevice_Skadi_Dev4
// 0x0014 (0x0538 - 0x0524)
class ATgDevice_Skadi_Dev4 : public ATgDevice_ActiveAura
{
public:
	class ATgPawn_Skadi*                               r_Skadi;                                                  // 0x0524(0x0008) (Const, Net)
	class ATgDevice_Kaldr_Dev4*                        s_Kaldr_Dev4;                                             // 0x052C(0x0008)
	unsigned long                                      r_bUpdateMIC : 1;                                         // 0x0534(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Skadi_Dev4");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	bool CanBeInterrupted();
	void EndAura();
	void BeginAura();
	void STATIC_FireAmmunition();
	void UpdateSkadiMIC(bool bOn);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_CacheKaldrUltDev();
};


// Class TgGame.TgDevice_Skadi_Dev1
// 0x0010 (0x050C - 0x04FC)
class ATgDevice_Skadi_Dev1 : public ATgDevice_Deployable
{
public:
	TArray<class AActor*>                              m_ValidAOETargets;                                        // 0x04FC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Skadi_Dev1");
		return ptr;
	}


	void TickTargetingMode(float DeltaSeconds);
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_Skadi_Dev3
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Skadi_Dev3 : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Skadi_Dev3");
		return ptr;
	}

};


// Class TgGame.TgDevice_Skadi_Dev2
// 0x0008 (0x04FC - 0x04F4)
class ATgDevice_Skadi_Dev2 : public ATgDevice_GroundTarget_LockOn
{
public:
	class ATgDevice*                                   s_MatchedDevice;                                          // 0x04F4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Skadi_Dev2");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	bool GetMatchedDevice();
	int MatchedKaldrDeviceEQPoint();
	void STATIC_FireAmmunition();
	bool STATIC_CanLockOnToTarget(class AActor* Target);
	bool IsToggledOn();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool UsesTargetingMode();
	bool STATIC_HasBeenTrained();
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_Skadi_Passive
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Skadi_Passive : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Skadi_Passive");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Skadi_Ice
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Skadi_Ice : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Skadi_Ice");
		return ptr;
	}


	void ApplyHitSpecial(class AActor* Target, const struct FImpactInfo& Impact, int nHitSpecialSituationalType, int StackCount);
};


// Class TgGame.TgDeviceFire_Skadi_Dev1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Skadi_Dev1 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Skadi_Dev1");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceForm_Skadi_Dev3
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Skadi_Dev3 : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Skadi_Dev3");
		return ptr;
	}


	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_Skadi_Dev4
// 0x0014 (0x0260 - 0x024C)
class UTgDeviceForm_Skadi_Dev4 : public UTgDeviceForm_TargetIndicator
{
public:
	class AActor*                                      c_aKaldrTarget;                                           // 0x024C(0x0008) (Const)
	int                                                c_nSkadiTargeterFxId;                                     // 0x0254(0x0004) (Const)
	class UTgSpecialFx*                                c_SkadiTargeterFX;                                        // 0x0258(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Skadi_Dev4");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgPawn_Skadi
// 0x003C (0x25F4 - 0x25B8)
class ATgPawn_Skadi : public ATgPawn_Character
{
public:
	class ATgPawn_Kaldr*                               r_Kaldr;                                                  // 0x25B8(0x0008) (Const, Net)
	class ATgDevice_Range*                             m_Auto_Device;                                            // 0x25C0(0x0008)
	class ATgDevice_Skadi_Passive*                     m_PSV_Device;                                             // 0x25C8(0x0008)
	class ATgDevice_Skadi_Dev1*                        m_A01_Device;                                             // 0x25D0(0x0008)
	class ATgDevice_Skadi_Dev2*                        m_A02_Device;                                             // 0x25D8(0x0008)
	class ATgDevice_Skadi_Dev3*                        m_A03_Device;                                             // 0x25E0(0x0008)
	class ATgDevice_Skadi_Dev4*                        m_A04_Device;                                             // 0x25E8(0x0008)
	unsigned long                                      m_bDevices_Cached : 1;                                    // 0x25F0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Skadi");
		return ptr;
	}


	void SetTargetingDevice(class ATgDevice* Dev);
	bool DeviceOverrideLockedDown(class ATgDevice* Dev);
	void EnterCombat(class ATgDevice* Device, class AActor* aInstigator, class AActor* ATarget, float fLength);
	void STATIC_PlayDyingEffects();
	void STATIC_OnRespawn();
	bool STATIC_GetPassiveString(struct FString* sResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	void STATIC_DespawnPet();
	void STATIC_SpawnPet();
	void STATIC_OnPawnDied();
	void STATIC_PostPawnSetupServer();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
};


// Class TgGame.TgPawn_Kaldr
// 0x0290 (0x2720 - 0x2490)
class ATgPawn_Kaldr : public ATgPawn_Familiar_LongTerm
{
public:
	class ATgPawn_Skadi*                               r_SkadiOwner;                                             // 0x2490(0x0008) (Const, Net)
	class ATgDevice_Kaldr_Basic*                       m_Auto_Device;                                            // 0x2498(0x0008)
	class ATgDevice_Kaldr_Passive*                     m_PSV_Device;                                             // 0x24A0(0x0008)
	class ATgDevice_Kaldr_Dev2*                        m_A02_Device;                                             // 0x24A8(0x0008)
	class ATgDevice_Kaldr_Dev3*                        m_A03_Device;                                             // 0x24B0(0x0008)
	class ATgDevice_Kaldr_Dev4*                        m_A04_Device;                                             // 0x24B8(0x0008)
	unsigned long                                      m_bDevices_Cached : 1;                                    // 0x24C0(0x0004) (Const)
	unsigned long                                      s_bRecallingToBase : 1;                                   // 0x24C0(0x0004)
	unsigned long                                      r_bIsDefensive : 1;                                       // 0x24C0(0x0004) (Net)
	unsigned long                                      r_bDefensiveTransition : 1;                               // 0x24C0(0x0004) (Net)
	unsigned long                                      r_bIsUlting : 1;                                          // 0x24C0(0x0004) (Net)
	unsigned long                                      s_bSelfTargetRemoval : 1;                                 // 0x24C0(0x0004)
	unsigned long                                      m_bAllowedToJump : 1;                                     // 0x24C0(0x0004)
	unsigned long                                      m_UseKaldrFallingCheck : 1;                               // 0x24C0(0x0004)
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                                       // 0x24C4(0x0140) (NeedCtorLink)
	class ATgPawn*                                     r_GuardTarget;                                            // 0x2604(0x0008) (Net)
	float                                              r_fRespawnTime;                                           // 0x260C(0x0004) (Net)
	float                                              s_fLeashRange;                                            // 0x2610(0x0004)
	int                                                r_nCurrentHealth;                                         // 0x2614(0x0004) (Net)
	int                                                c_nPreviousHealth;                                        // 0x2618(0x0004)
	int                                                r_nMaxHealth;                                             // 0x261C(0x0004) (Net)
	float                                              c_fNextHealth;                                            // 0x2620(0x0004)
	float                                              r_nHUDHealthFractional;                                   // 0x2624(0x0004) (Net)
	struct FVector                                     s_vRespawnLoc;                                            // 0x2628(0x000C)
	int                                                m_nTeleportEnterFXId;                                     // 0x2634(0x0004)
	int                                                m_nTeleportExitFXId;                                      // 0x2638(0x0004)
	int                                                c_nCurrentPostureId;                                      // 0x263C(0x0004)
	float                                              r_fComboRadius;                                           // 0x2640(0x0004) (Net)
	float                                              r_fUltRadius;                                             // 0x2644(0x0004) (Net)
	float                                              m_fBasicAttackGroundSpeedPct;                             // 0x2648(0x0004)
	struct FKaldrDamageInstance                        s_DamageHistory[0x10];                                    // 0x264C(0x000C)
	int                                                s_nCurrentDamageIndex;                                    // 0x270C(0x0004)
	int                                                s_nKaldrDamagePerHit;                                     // 0x2710(0x0004)
	int                                                s_nKaldrDamageFromMinions;                                // 0x2714(0x0004)
	int                                                s_nKaldrHealthPerTick;                                    // 0x2718(0x0004)
	int                                                s_nLastTargetBotRank;                                     // 0x271C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Kaldr");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	struct FString AIDebugString();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void KilledBy(class APawn* EventInstigator);
	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	void STATIC_OnTeleportToBaseNotify(class AActor* TeleportingActor);
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Tick(float DeltaSeconds);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_PlaySpawnFx();
	void STATIC_PrepareIntro();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void MoveToDesiredRelativePosition();
	void STATIC_TeleportToOwner();
	struct FVector STATIC_GetDesiredRelativePosition();
	void UpdateVisualState();
	void STATIC_OnOwnerAddPercentVitals(float pctHealth);
	void STATIC_OnOwnerGivenPercentVitals(float pctHealth);
	void STATIC_OnOwnerGivenFullVitals();
	void STATIC_OnOwnerPostTeleport();
	void STATIC_OnOwnerJumped();
	void STATIC_SetTargetActor(class AActor* Target);
	void TrackGuardedTarget(class AActor* Target);
	void TrackDamageFrom(class ATgDevice* owningDevice, int nFiringInstance);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool IsJumpDisabled();
	bool IsNonCombat();
	void RecallKaldr(bool bViaDevice);
	void SetAsAggressive();
	void SetAsDefensive();
	int GetOffhandDRDamage(class ATgDevice* Dev, int nGroupFiringInstance);
	int CalculateDamageFrom(class ATgDevice* damagingDevice, int nGroupFiringInstance);
	bool CanGiveNewTarget();
	bool CanCombo();
	void ClearGuardTarget(bool bLookForNext);
	void TriggerCombo();
	void PrepKaldrImmunity();
	void IncrementHealthBy(int nHealth);
	void STATIC_OwnerJumpedTimer();
	void STATIC_ResetKaldr();
	void STATIC_PreformKaldrFallingCheck();
	void UpdateSkadiBuff();
};


// Class TgGame.TgAchievement_JingWei_HeadsUp
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_JingWei_HeadsUp : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                               // 0x0084(0x0004)
	float                                              m_TimeLimit;                                              // 0x0088(0x0004)
	float                                              m_PassiveStopTime;                                        // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_JingWei_HeadsUp");
		return ptr;
	}

};


// Class TgGame.TgAchievement_JingWei_WaveDash
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_JingWei_WaveDash : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                               // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_JingWei_WaveDash");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_JingWei_KnockupSource
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendList_JingWei_KnockupSource : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_JingWei_KnockupSource");
		return ptr;
	}


	void SetActiveAnimationIndex(int ChildIndex);
};


// Class TgGame.TgCollisionProxy_JingWei_Dev4
// 0x0000 (0x02B4 - 0x02B4)
class ATgCollisionProxy_JingWei_Dev4 : public ATgCollisionProxy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_JingWei_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDeployable_JingWei_Dev1
// 0x0030 (0x0428 - 0x03F8)
class ATgDeployable_JingWei_Dev1 : public ATgDeploy_EffectVolume
{
public:
	TArray<class AActor*>                              s_TouchingActors;                                         // 0x03F8(0x0010) (NeedCtorLink)
	TArray<float>                                      s_fTouchingTime;                                          // 0x0408(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_ToApplyKnockupActors;                                   // 0x0418(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_JingWei_Dev1");
		return ptr;
	}


	void Tick(float fDeltaSeconds);
	void HandleUnTouch(class AActor* Other);
	bool STATIC_ShouldHitOnlyOnce(class AActor* Other);
	void HandleTouch(class AActor* Other);
};


// Class TgGame.TgDevice_JingWei_Dev4_AirCharge
// 0x0000 (0x053C - 0x053C)
class ATgDevice_JingWei_Dev4_AirCharge : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JingWei_Dev4_AirCharge");
		return ptr;
	}


	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_OnChargeEnd();
	void STATIC_OnChargeStart();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool AdjustCollisionProxyFX();
};


// Class TgGame.TgDevice_JingWei_Dev1
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_JingWei_Dev1 : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JingWei_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDevice_JingWei_Dev2
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_JingWei_Dev2 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JingWei_Dev2");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_JingWei_Dev3
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_JingWei_Dev3 : public ATgDevice
{
public:
	unsigned long                                      m_bIsAirDash : 1;                                         // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JingWei_Dev3");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void ApplyLeapBuff();
	void ToggleSecondaryTargeting(bool bEnable);
	bool STATIC_CanFireWhileFalling();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_CalculateLob();
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_JingWei_Dev4_Landing
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_JingWei_Dev4_Landing : public ATgDevice
{
public:
	unsigned long                                      m_IsTimedOut : 1;                                         // 0x04F0(0x0004)
	struct FVector                                     m_BackupLandingLocation;                                  // 0x04F4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JingWei_Dev4_Landing");
		return ptr;
	}


	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void Tick(float DeltaTime);
	bool ApplyGlobalOffhandCooldown();
	bool ShouldInterruptInhand();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool TriggerTimeOutJump();
	void UpdateBackupLocation();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	bool IsValidLandingLocation(const struct FVector& landLocation);
};


// Class TgGame.TgDevice_JingWei_Passive
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_JingWei_Passive : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JingWei_Passive");
		return ptr;
	}


	void InterruptFiring();
	bool CanJumpWhileFiring();
	bool STATIC_CanFireWhileFalling();
	bool CanBeCanceled();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_JingWei_SkyJumpAuto
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_JingWei_SkyJumpAuto : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JingWei_SkyJumpAuto");
		return ptr;
	}


	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_JingWei_Dev4_Staging
// 0x0008 (0x0554 - 0x054C)
class ATgDevice_JingWei_Dev4_Staging : public ATgDevice_Staging_MultiBase
{
public:
	float                                              m_ForceLandingTime;                                       // 0x054C(0x0004)
	unsigned long                                      r_bWillCooldown : 1;                                      // 0x0550(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JingWei_Dev4_Staging");
		return ptr;
	}


	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void SetActiveAnimChild(int nChild);
	void ForceLanding();
	void OnShooterStopFire(bool bInterrupted);
	void STATIC_ForceClientCooldown(int nMode);
	void OnShooterStartFire();
	void OnShooterStartBuildup();
	void ForceSelfCollisions(bool bEnable);
	void ForceSelfRoot(bool bEnable);
	bool IsFiring();
	bool CanStagingBeCanceled();
	bool ShouldCooldownAfterFire();
	bool ApplyGlobalOffhandCooldown();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_JingWei_Dev4
// 0x0028 (0x0530 - 0x0508)
class ATgDevice_JingWei_Dev4 : public ATgDevice_TwoPhase
{
public:
	int                                                m_nLeapCount;                                             // 0x0508(0x0004)
	int                                                m_nMaxLeapCount;                                          // 0x050C(0x0004) (Const)
	TEnumAsByte<ETweenState>                           m_ePrimaryTweenState;                                     // 0x0510(0x0001)
	TEnumAsByte<ETweenState>                           m_eSecondaryTweenState;                                   // 0x0511(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0512(0x0002) MISSED OFFSET
	unsigned long                                      m_bFixedTweenTime : 1;                                    // 0x0514(0x0004)
	unsigned long                                      m_bForceToNormalState : 1;                                // 0x0514(0x0004)
	unsigned long                                      s_bDisableOnTweenEnd : 1;                                 // 0x0514(0x0004)
	TArray<class AActor*>                              m_HitActors;                                              // 0x0518(0x0010) (NeedCtorLink)
	class ATgCollisionProxy_JingWei_Dev4*              m_CollisionProxy;                                         // 0x0528(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_JingWei_Dev4");
		return ptr;
	}


	void ForceSelfRoot(bool bEnable);
	void STATIC_SelectStopFiringState();
	struct FVector GetTweenLocation(struct FAimData* Aim);
	float STATIC_GetTweenTime();
	void STATIC_FireAmmunition();
	void STATIC_ClientFixLeapCount(int bRecoverLeapCount);
	void STATIC_HandleFiringRejection();
	void InterruptFiring();
	bool ShouldCooldownAfterFire();
	void ForceToNormalState();
	void STATIC_ServerForceToNormalState();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool CanJumpWhileFiring();
	void ExpireTarget();
	void STATIC_OnStateSet(TEnumAsByte<ETwoPhaseState> PrevState, TEnumAsByte<ETwoPhaseState> CurrentState);
	bool STATIC_ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool ShouldTriggerCastReactionItems();
	float STATIC_GetToggleMaxTime(int nMode);
};


// Class TgGame.TgDeviceFire_JingWei_Dev1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_JingWei_Dev1 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_JingWei_Dev1");
		return ptr;
	}


	bool IsValidTarget(class AActor* Target, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_JingWei_Dev4
// 0x0003 (0x01C4 - 0x01C1)
class UTgDeviceFire_JingWei_Dev4 : public UTgDeviceFire_TwoPhase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x01C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_JingWei_Dev4");
		return ptr;
	}


	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
};


// Class TgGame.TgDeviceForm_JingWei_Dev3
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_JingWei_Dev3 : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_JingWei_Dev3");
		return ptr;
	}


	void UpdateAerialTargetModeLocation(float TranslationZ);
};


// Class TgGame.TgInventoryObject_Listen_JingWei_Passive
// 0x0004 (0x00D8 - 0x00D4)
class UTgInventoryObject_Listen_JingWei_Passive : public UTgInventoryObject_Listen_OnExitStore
{
public:
	unsigned long                                      m_QueuedFire : 1;                                         // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_JingWei_Passive");
		return ptr;
	}


	void TryStartFire();
	bool STATIC_ShouldCancelPassive(class ATgPawn_JingWei* jingwei);
	bool OnExitStore();
};


// Class TgGame.TgPawn_JingWei
// 0x00EC (0x26A4 - 0x25B8)
class ATgPawn_JingWei : public ATgPawn_Character
{
public:
	class ATgDevice*                                   r_dev_inhand;                                             // 0x25B8(0x0008) (Net)
	class ATgDevice*                                   r_dev_super_inhand;                                       // 0x25C0(0x0008) (Net)
	class ATgDevice*                                   s_dev_passive;                                            // 0x25C8(0x0008)
	class ATgDevice_JingWei_Dev1*                      s_dev_offhand1;                                           // 0x25D0(0x0008)
	class ATgDevice*                                   r_dev_offhand2;                                           // 0x25D8(0x0008) (Net)
	class ATgDevice_JingWei_Dev3*                      s_dev_offhand3;                                           // 0x25E0(0x0008)
	class ATgDevice*                                   r_dev_offhand4;                                           // 0x25E8(0x0008) (Net)
	class ATgDevice*                                   r_dev_offhand4_landing;                                   // 0x25F0(0x0008) (Net)
	TArray<class UTgAnimNodeBlendList_JingWei_KnockupSource*> m_KnockupAnimNodes;                                       // 0x25F8(0x0010) (NeedCtorLink)
	int                                                r_nDesiredKnockupAnimChild;                               // 0x2608(0x0004) (Net)
	class ATgDevice*                                   r_SkyJumpInHandDevice;                                    // 0x260C(0x0008) (Net)
	unsigned long                                      m_bSkyJumpAtLocation : 1;                                 // 0x2614(0x0004)
	unsigned long                                      m_bSkyJumpHasFired : 1;                                   // 0x2614(0x0004)
	unsigned long                                      r_bIsInBase : 1;                                          // 0x2614(0x0004) (Net)
	unsigned long                                      m_bPassivePreventNextFiring : 1;                          // 0x2614(0x0004)
	unsigned long                                      r_bDev2InStimmedAnim : 1;                                 // 0x2614(0x0004) (Net)
	unsigned long                                      r_bIgnoreAllBlocking : 1;                                 // 0x2614(0x0004)
	unsigned long                                      m_bDoingBackupLandingCheck : 1;                           // 0x2614(0x0004)
	unsigned long                                      m_bLockFaceRotation : 1;                                  // 0x2614(0x0004)
	int                                                r_nSkyJumpCameraYaw;                                      // 0x2618(0x0004) (Net)
	float                                              m_fAimOffsetMax;                                          // 0x261C(0x0004)
	TEnumAsByte<ESkyJumpPhase>                         r_SkyJumpPhase;                                           // 0x2620(0x0001) (Net)
	unsigned char                                      r_nShowBowStimMesh;                                       // 0x2621(0x0001) (Net)
	TEnumAsByte<ETGJingWeiDev4Phase>                   r_Dev4Phase;                                              // 0x2622(0x0001) (Net)
	TEnumAsByte<ETGJingWeiDev4Phase>                   m_Dev4PhaseLocal;                                         // 0x2623(0x0001)
	struct FVector                                     r_SkyJumpStartLocation;                                   // 0x2624(0x000C) (Net)
	struct FVector                                     r_SkyJumpBackupLocation;                                  // 0x2630(0x000C) (Net)
	struct FName                                       c_PassiveLandingAnimName;                                 // 0x263C(0x0008)
	float                                              r_fPassiveFlightTimeProgress;                             // 0x2644(0x0004) (Net)
	float                                              r_fPassiveFlightTimeMax;                                  // 0x2648(0x0004) (Net)
	float                                              r_fPassiveCancelTimeProgress;                             // 0x264C(0x0004) (Net)
	float                                              r_fPassiveCancelTimeMax;                                  // 0x2650(0x0004) (Net)
	class UTgAnimNodeBlendList*                        c_BasicAttackBlendList;                                   // 0x2654(0x0008)
	struct FName                                       c_BasicAttackBlendListName;                               // 0x265C(0x0008)
	class UTgSkeletalMeshComponent*                    c_BowStimMesh;                                            // 0x2664(0x0008) (ExportObject, Component, EditInline)
	int                                                r_nDev2AmmoCount;                                         // 0x266C(0x0004) (Net)
	class UTgSpecialFx*                                m_CollisionProxyFX;                                       // 0x2670(0x0008)
	struct FVector                                     m_Dev4StartLocation;                                      // 0x2678(0x000C)
	float                                              m_Dev4PhaseTime;                                          // 0x2684(0x0004)
	float                                              m_Dev4ForceLandingTime;                                   // 0x2688(0x0004)
	TArray<class UTgAnimNodeBlendList_JingWei_Dev4*>   m_UltimateAnimNodes;                                      // 0x268C(0x0010) (NeedCtorLink)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x269C(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_JingWei");
		return ptr;
	}


	bool DoJump(bool bUpdating);
	void STATIC_CleanUpDyingEffects();
	void ManageDev2Anim();
	void STATIC_PlayDyingEffects();
	void PlayPassiveLandingAnimation();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_ServerOnRightMousePressed();
	void STATIC_OnRightMousePressed();
	bool IsInClassSpecificMovement();
	void SetTargetingDevice(class ATgDevice* Dev);
	bool STATIC_IgnoreFaceRotationWithInterp();
	float ApplyPitchLimit(float fPitch);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void Tick(float DeltaSeconds);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void UpdateSkyJumpPhase();
	void STATIC_DeactivateBuffedInhand();
	void ActivateBuffedInhand();
	void AdjustAmmo(int Delta);
	void UpdateBowMesh(unsigned char NewShowBowStim);
	void STATIC_OnRespawn();
	void ClearSkyJumpAfterDeath();
	void PostDemoRewind();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	bool PostPawnSetup();
	void DeactivateCollisionProxyFX();
	void ActivateCollisionProxyFX();
	void STATIC_OnDeviceFormInterruptCharge(int nEquipSlot);
	void STATIC_OnDeviceFormEndCharge(int nEquipSlot, bool bHit);
	void STATIC_OnDeviceFormBeginCharge(int nEquipSlot);
	void ToggleUltimateCameraModule(bool bOn);
	void ForceSelfCollisions(bool bEnable);
	void ForceSelfRoot(bool bEnable);
	void ForceDev4Landing();
	void UpdateDev4Phase();
	void STATIC_SetDev4Phase(TEnumAsByte<ETGJingWeiDev4Phase> Phase);
	void SetUltimateAnimationIndex(int nIndex);
	void SetKnockupAnimationIndex(int nIndex);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	bool IsAValidGrabTarget();
	bool IsFiringUltimate();
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_OnMeshSwapped();
	bool STATIC_InitializeCollisionProxyFX();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_FlashBeginCharge(int nDeviceInstanceId);
	void DeviceOnStopFire(class ATgDevice* Dev, bool bWasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceCriticalStrike(class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_OverrideDistanceFadeRange();
	void STATIC_EndSkyJump();
	void STATIC_StartSkyJump();
};


// Class TgGame.TgAchievement_Susano_WeatherTheStorm
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Susano_WeatherTheStorm : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Susano_WeatherTheStorm");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendBySusanoDev2Stage
// 0x000C (0x0174 - 0x0168)
class UTgAnimBlendBySusanoDev2Stage : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Susano*                              m_Susano;                                                 // 0x0168(0x0008)
	int                                                m_LastStage;                                              // 0x0170(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBySusanoDev2Stage");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Vortex_Susano
// 0x0000 (0x02E0 - 0x02E0)
class ATgCollisionProxy_Vortex_Susano : public ATgCollisionProxy_Vortex
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Vortex_Susano");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Susano_Dev1
// 0x0018 (0x04B0 - 0x0498)
class ATgDeployable_Susano_Dev1 : public ATgDeploy_ExplodingCylinder
{
public:
	float                                              m_MaxLobHeight;                                           // 0x0498(0x0004)
	int                                                m_LobCount;                                               // 0x049C(0x0004)
	TArray<class ATgPawn*>                             s_ToApplyKnockupActors;                                   // 0x04A0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Susano_Dev1");
		return ptr;
	}


	void Tick(float fDeltaSeconds);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_CanBeKnockedUp(class ATgPawn* Target);
	void LobPawn(class ATgPawn* Target);
};


// Class TgGame.TgDeployable_Susano_Dev4_Typhoon
// 0x0024 (0x041C - 0x03F8)
class ATgDeployable_Susano_Dev4_Typhoon : public ATgDeploy_EffectVolume
{
public:
	float                                              m_GrowthTime;                                             // 0x03F8(0x0004)
	float                                              r_StartRadius;                                            // 0x03FC(0x0004) (Net)
	float                                              r_MaxRadius;                                              // 0x0400(0x0004) (Net)
	float                                              r_MaxGrowthTime;                                          // 0x0404(0x0004) (Net)
	float                                              r_TravelTime;                                             // 0x0408(0x0004) (Net)
	float                                              r_TravelRange;                                            // 0x040C(0x0004) (Net)
	TEnumAsByte<ESusanoTyphoonState>                   r_CurrentState;                                           // 0x0410(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0411(0x0003) MISSED OFFSET
	class ATgCollisionProxy_Vortex_Susano*             m_Vortex;                                                 // 0x0414(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Susano_Dev4_Typhoon");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void TravelTimerDone();
	void STATIC_GrowthTimerDone();
	void SpawningDeviceToggledOff();
	void STATIC_InstantFireDeployable();
	void HandleTouch(class AActor* Other);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
	void STATIC_StartTraveling();
	void STATIC_StartGrowth();
	void ToggleOffConsumePowerPool(class ATgDeployable* deployable);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetParticleSystemScale(float Scale);
	void STATIC_SetupTravelingPhysics();
};


// Class TgGame.TgDevice_Susano_Dev2_Part1
// 0x0004 (0x0540 - 0x053C)
class ATgDevice_Susano_Dev2_Part1 : public ATgDevice_Charge
{
public:
	unsigned long                                      r_IsToggledOn : 1;                                        // 0x053C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Susano_Dev2_Part1");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	bool ShouldCooldownAfterFire();
	void ReplicatedEvent(const struct FName& VarName);
	bool IsToggledOn();
	void RemoveEquipEffects();
	void ApplyEquipEffects();
};


// Class TgGame.TgDevice_Susano_Dev2_Part3
// 0x0004 (0x0520 - 0x051C)
class ATgDevice_Susano_Dev2_Part3 : public ATgDevice_RadialSweep
{
public:
	unsigned long                                      r_IsToggledOn : 1;                                        // 0x051C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Susano_Dev2_Part3");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	bool ShouldCooldownAfterFire();
	void ReplicatedEvent(const struct FName& VarName);
	bool IsToggledOn();
	void RemoveEquipEffects();
	void ApplyEquipEffects();
};


// Class TgGame.TgDevice_Susano_Dev2_Part2
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Susano_Dev2_Part2 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Susano_Dev2_Part2");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	float STATIC_GetConePullbackDistance();
	void RemoveEquipEffects();
};


// Class TgGame.TgDevice_Susano_Dev3
// 0x0040 (0x0530 - 0x04F0)
class ATgDevice_Susano_Dev3 : public ATgDevice_Range
{
public:
	TEnumAsByte<ESusanoDev3State>                      r_CurrentState;                                           // 0x04F0(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F1(0x0003) MISSED OFFSET
	class AActor*                                      r_TeleportTarget;                                         // 0x04F4(0x0008) (Net)
	TArray<class ATgDeployable*>                       m_WindDeployables;                                        // 0x04FC(0x0010) (NeedCtorLink)
	class AProjectile*                                 m_LastFiredProjectile;                                    // 0x050C(0x0008) (Transient)
	class AActor*                                      m_FxTarget;                                               // 0x0514(0x0008) (Transient)
	class UTgSpecialFx*                                c_DirectionFx;                                            // 0x051C(0x0008) (Transient)
	class UTgSpecialFx*                                c_TimerFx;                                                // 0x0524(0x0008) (Transient)
	unsigned long                                      c_QueueTeleport : 1;                                      // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Susano_Dev3");
		return ptr;
	}


	void OnProjectileHit(class AProjectile* Proj, class AActor* HitActor);
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void STATIC_TeleportExpire();
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	bool STATIC_ExecuteTeleportToTarget(class ATgPawn* caster, const struct FVector& EndLocation, const struct FRotator& ToTarget);
	bool TryTeleportToDeployableTarget(class ATgPawn* caster);
	bool TryTeleportToPawnTarget(class ATgPawn* caster);
	bool STATIC_ServerTeleportToLastTarget();
	bool STATIC_TeleportToLastTarget();
	bool Use();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
	void PostDemoRewind();
	void PreDemoRewind();
	void Tick(float DeltaTime);
	void STATIC_ClearTargetingFX();
	void STATIC_CreateAndAttachFXToTarget(class ATgPawn_Susano* Susano, class AActor* Target, int FxId, class UTgSpecialFx** Fx);
	void UpdateTargetingFX();
	void UpdateCurrentState();
	void STATIC_SetCurrentTeleportTarget(class AActor* Target);
	void SetCurrentState(TEnumAsByte<ESusanoDev3State> State);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_CanBeCrippled();
	class ATgDeployable* STATIC_SpawnDeployable(class ATgProjectile* Projectile);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDeviceFire_Susano_Dev1_Part1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Susano_Dev1_Part1 : public UTgDeviceFire_OffsetCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Susano_Dev1_Part1");
		return ptr;
	}


	float STATIC_ConeOffset(float fMinRadius, float fMaxRadius);
};


// Class TgGame.TgInventoryObject_Listen_SusanoPassive
// 0x000C (0x012C - 0x0120)
class UTgInventoryObject_Listen_SusanoPassive : public UTgInventoryObject_Listen_Stack
{
public:
	class ATgPawn_Susano*                              m_Susano;                                                 // 0x0120(0x0008)
	int                                                m_PassiveValue;                                           // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SusanoPassive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SusanoPassiveV2
// 0x0048 (0x0118 - 0x00D0)
class UTgInventoryObject_Listen_SusanoPassiveV2 : public UTgInventoryObject_Listen
{
public:
	class ATgPawn_Susano*                              m_Susano;                                                 // 0x00D0(0x0008)
	TArray<unsigned long>                              DeviceAlreadyHit;                                         // 0x00D8(0x0010) (NeedCtorLink)
	TArray<int>                                        DeployableHitList;                                        // 0x00E8(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             PassiveHitList;                                           // 0x00F8(0x0010) (NeedCtorLink)
	int                                                m_PassiveValue;                                           // 0x0108(0x0004)
	unsigned long                                      r_bIsPassiveProc : 1;                                     // 0x010C(0x0004)
	int                                                r_nBonusDamageDeviceId;                                   // 0x0110(0x0004)
	int                                                r_nBonusDamageFireInstance;                               // 0x0114(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SusanoPassiveV2");
		return ptr;
	}


	void STATIC_ClearPassiveStacks();
	void ApplyPassiveStacks(class ATgDevice* Dev, struct FImpactInfo* Impact);
};


// Class TgGame.TgPawn_Susano
// 0x0050 (0x2608 - 0x25B8)
class ATgPawn_Susano : public ATgPawn_Character
{
public:
	class ATgDevice_Susano_Dev3*                       m_DevOffhand3;                                            // 0x25B8(0x0008)
	int                                                r_nPassiveStacks;                                         // 0x25C0(0x0004) (Net)
	TArray<class ATgDevice*>                           m_Dev1Sequence;                                           // 0x25C4(0x0010) (NeedCtorLink)
	int                                                m_Dev1LocalCurrent;                                       // 0x25D4(0x0004)
	int                                                r_Dev1ServerCurrent;                                      // 0x25D8(0x0004) (Net)
	int                                                m_Dev1CurrentlyFiringIndex;                               // 0x25DC(0x0004) (Net)
	unsigned long                                      m_Dev1AllowNextPart : 1;                                  // 0x25E0(0x0004)
	unsigned long                                      m_Dev1LockFiring : 1;                                     // 0x25E0(0x0004)
	unsigned long                                      m_IsDev1ComboSequenceActive : 1;                          // 0x25E0(0x0004)
	unsigned long                                      m_Dev1SetAsTargetingDevice : 1;                           // 0x25E0(0x0004)
	float                                              r_ComboTriggerTime;                                       // 0x25E4(0x0004) (Net)
	float                                              m_ComboCurrentTime;                                       // 0x25E8(0x0004)
	TArray<int>                                        m_nDev1ComboHitPawnIds;                                   // 0x25EC(0x0010) (NeedCtorLink)
	float                                              s_Dev4TyphoonGrowthPercent;                               // 0x25FC(0x0004)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x2600(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Susano");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void Tick(float DeltaSeconds);
	void STATIC_ForceComboTargetingIfNeeded();
	void STATIC_ClearPassiveStacks();
	void STATIC_OnRightMousePressed();
	void ProgressCombo();
	void STATIC_ComboTriggerTimerExpired();
	void UpdateDev1Current();
	bool DeviceOverrideLockedDown(class ATgDevice* Device);
	void ReplicatedEvent(const struct FName& VarName);
	bool InvObjCastTrackingException(struct FOnDamagedParams* Params);
	void STATIC_RemovePassiveBuff();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	bool IsComboDevice(class ATgDevice* Dev, int* Index);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_OnProjectileExploded(class ATgProjectile* ExplodedProjectile, class AActor* HitActor, struct FVector* vHitLocation, struct FVector* vHitNormal);
	void STATIC_DeviceAdjustPowerScaling(class ATgDevice* Dev, int nScalingType, struct FImpactInfo* Impact, float* fPhysicalPower, float* fMagicPower);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnStopFire(class ATgDevice* Dev, bool bWasInterrupted);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
};


// Class TgGame.TgProj_Susano_Dev3
// 0x000C (0x03A4 - 0x0398)
class ATgProj_Susano_Dev3 : public ATgProj_Simulated
{
public:
	struct FVector                                     m_LastValidLocation;                                      // 0x0398(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Susano_Dev3");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Fafnir_TakeThat
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_Fafnir_TakeThat : public UTgAchievement_MultiDeviceMultiHit_ByType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Fafnir_TakeThat");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Fafnir_GetToWork
// 0x0018 (0x009C - 0x0084)
class UTgAchievement_Fafnir_GetToWork : public UTgAchievement
{
public:
	int                                                m_nDeviceId1;                                             // 0x0084(0x0004)
	int                                                m_nDeviceId2;                                             // 0x0088(0x0004)
	TArray<class ATgPawn*>                             m_TrackedSaved;                                           // 0x008C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Fafnir_GetToWork");
		return ptr;
	}

};


// Class TgGame.TgDevice_Fafnir_Dev4
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Fafnir_Dev4 : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fafnir_Dev4");
		return ptr;
	}


	void OnDeployableDeployComplete(class ATgDeployable* deployable);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
};


// Class TgGame.TgDevice_Fafnir_Dev4_D
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Fafnir_Dev4_D : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fafnir_Dev4_D");
		return ptr;
	}


	void OnDeployableDeployComplete(class ATgDeployable* deployable);
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_Fafnir_Basic_D
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Fafnir_Basic_D : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fafnir_Basic_D");
		return ptr;
	}


	void DeliverQueuedPendingHits();
	bool STATIC_CanBeDisarmed();
	float GetRefireTime(int nMode);
};


// Class TgGame.TgDevice_Fafnir_Dev2
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Fafnir_Dev2 : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fafnir_Dev2");
		return ptr;
	}


	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool UsesTrackingTarget();
};


// Class TgGame.TgDevice_Fafnir_Dev2_D
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Fafnir_Dev2_D : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fafnir_Dev2_D");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SpawnWarningDeployable();
};


// Class TgGame.TgDevice_Fafnir_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Fafnir_Dev1 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fafnir_Dev1");
		return ptr;
	}


	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void STATIC_StartShockwaveAt(class UTgDeviceFire* DeviceFire, const struct FVector& SpawnLoc);
};


// Class TgGame.TgDevice_Fafnir_Dev3
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Fafnir_Dev3 : public ATgDevice_TweenBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fafnir_Dev3");
		return ptr;
	}


	bool CanBeCanceled();
	int STATIC_GetLeapMode(float fAimDist);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void STATIC_HandleDeviceFormBuildup(int nDeviceModeNum, float fBuildupTime);
	void DeliverQueuedPendingHits();
	float STATIC_GetTweenTime();
};


// Class TgGame.TgDeviceFire_Fafnir_Dev1
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Fafnir_Dev1 : public UTgDeviceFire_Deploy
{
public:
	struct FPointer                                    m_pDepSetup;                                              // 0x01C0(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Fafnir_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Fafnir_Basic_D
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Fafnir_Basic_D : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Fafnir_Basic_D");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Fafnir_Dev2
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_Fafnir_Dev2 : public UTgInventoryObject_Listen_Effect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Fafnir_Dev2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_FafnirPassive
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_FafnirPassive : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_FafnirPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Fafnir
// 0x0024 (0x2608 - 0x25E4)
class ATgPawn_Fafnir : public ATgPawn_MeshSwapper
{
public:
	int                                                r_nMaxGoldThreshold;                                      // 0x25E4(0x0004) (Net)
	float                                              r_fMaxProtections;                                        // 0x25E8(0x0004) (Net)
	class AController*                                 s_KillerOverride;                                         // 0x25EC(0x0008)
	float                                              r_fTotalDragonTime;                                       // 0x25F4(0x0004) (Net)
	float                                              c_fDragonStartTime;                                       // 0x25F8(0x0004)
	float                                              r_fTransformCameraZoom;                                   // 0x25FC(0x0004) (Net)
	float                                              r_fTransformCameraZoomTween;                              // 0x2600(0x0004) (Net)
	float                                              c_nActiveDisplayGroup_Passive;                            // 0x2604(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Fafnir");
		return ptr;
	}


	void STATIC_SetLeapFireMode(int nFireMode);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void AttemptDwarfTransform();
	bool DoJump(bool bUpdating);
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fTweenSpeed);
	bool IsDragon();
	void STATIC_SetPassiveDisplayGroup(int ActiveGroup);
	void Tick(float DeltaSeconds);
	float ApplyPitchLimit(float fPitch);
	bool STATIC_IgnoreFaceRotationWithInterp();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	class AController* OverrideKillInstigator();
	void ReplicatedEvent(const struct FName& VarName);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void STATIC_SwapToMesh(int nMeshId);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void STATIC_OnPawnDied();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	float STATIC_GetMagicalProtection();
	float STATIC_GetPhysicalProtection();
	float STATIC_GetGoldProtectionPct();
};


// Class TgGame.TgAchievement_ErlangShen_Undefeated
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_ErlangShen_Undefeated : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nTargetAmount;                                          // 0x0088(0x0004)
	unsigned long                                      m_nValidStart : 1;                                        // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_ErlangShen_Undefeated");
		return ptr;
	}

};


// Class TgGame.TgDevice_ErlangShen_Dog_Basic
// 0x0000 (0x054C - 0x054C)
class ATgDevice_ErlangShen_Dog_Basic : public ATgDevice_ActiveMode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ErlangShen_Dog_Basic");
		return ptr;
	}

};


// Class TgGame.TgDevice_ErlangShen_Dog_Dash
// 0x0000 (0x053C - 0x053C)
class ATgDevice_ErlangShen_Dog_Dash : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ErlangShen_Dog_Dash");
		return ptr;
	}

};


// Class TgGame.TgDevice_ErlangShen_Transform
// 0x0014 (0x0550 - 0x053C)
class ATgDevice_ErlangShen_Transform : public ATgDevice_Charge
{
public:
	TEnumAsByte<ERLANG_SHEN_TRANSFORM>                 r_eTransformType;                                         // 0x053C(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x053D(0x0003) MISSED OFFSET
	unsigned long                                      m_bDoNotNotifyOthers : 1;                                 // 0x0540(0x0004) (Transient)
	float                                              m_fTransformRanges[0x3];                                  // 0x0544(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ErlangShen_Transform");
		return ptr;
	}


	void InstantFire();
	void STATIC_ParentInterruptFiring();
	void InterruptFiring();
	void ResetCooldown(int nMode, float fCooldownTimeOverride);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void TransformBack();
	void TransformTo();
	bool CanBeCanceled();
	TEnumAsByte<ERLANG_SHEN_TRANSFORM> STATIC_GetBestTransform(const struct FAimData& Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_SetPointsAllocated(int nPoints);
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_ErlangShen_TransformMink
// 0x0004 (0x0554 - 0x0550)
class ATgDevice_ErlangShen_TransformMink : public ATgDevice_ErlangShen_Transform
{
public:
	unsigned long                                      m_bTriggerPounce : 1;                                     // 0x0550(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ErlangShen_TransformMink");
		return ptr;
	}


	void STATIC_ClientTriggerPounce();
	void TriggerPounce();
	void InterruptFiring();
	void TransformBack();
};


// Class TgGame.TgDevice_ErlangShen_TransformTurtle
// 0x0000 (0x0550 - 0x0550)
class ATgDevice_ErlangShen_TransformTurtle : public ATgDevice_ErlangShen_Transform
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ErlangShen_TransformTurtle");
		return ptr;
	}

};


// Class TgGame.TgDevice_ErlangShen_SeeWeakness
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_ErlangShen_SeeWeakness : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ErlangShen_SeeWeakness");
		return ptr;
	}


	bool ShouldInterruptInhand();
};


// Class TgGame.TgDevice_ErlangShen_NineTurnsBlessing
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_ErlangShen_NineTurnsBlessing : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ErlangShen_NineTurnsBlessing");
		return ptr;
	}


	float STATIC_GetConePullbackDistance();
};


// Class TgGame.TgDeviceFire_ErlangShen_Dog_Attack
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_ErlangShen_Dog_Attack : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ErlangShen_Dog_Attack");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceForm_ErlangShen_Transform
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_ErlangShen_Transform : public UTgDeviceForm_72Transformations
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ErlangShen_Transform");
		return ptr;
	}

};


// Class TgGame.TgPawn_ErlangShen
// 0x00E4 (0x26C8 - 0x25E4)
class ATgPawn_ErlangShen : public ATgPawn_MeshSwapper
{
public:
	class ATgDevice*                                   m_DevicePsv_GuardDog;                                     // 0x25E4(0x0008)
	class ATgDevice_ErlangShen_SeeWeakness*            m_DeviceA01_SeeWeakness;                                  // 0x25EC(0x0008)
	class ATgDevice*                                   m_DeviceA02_Pin;                                          // 0x25F4(0x0008)
	class ATgDevice_ErlangShen_TransformMink*          m_DeviceA03_72Transformations_Mink;                       // 0x25FC(0x0008)
	class ATgDevice_ErlangShen_TransformTurtle*        m_DeviceA03_72Transformations_Turtle;                     // 0x2604(0x0008)
	class ATgDevice_ErlangShen_NineTurnsBlessing*      m_DeviceA04_NineTurnsBlessing;                            // 0x260C(0x0008)
	class ATgPawn_ErlangShen_Dog*                      r_GuardDog;                                               // 0x2614(0x0008) (Net)
	unsigned long                                      m_bIsSpotWeaknessActive : 1;                              // 0x261C(0x0004)
	unsigned long                                      r_bSpotWeaknessFXEnabled : 1;                             // 0x261C(0x0004) (Net)
	unsigned long                                      m_bTransformInProgress : 1;                               // 0x261C(0x0004)
	unsigned long                                      m_bTriggerTransformMeshChange : 1;                        // 0x261C(0x0004)
	unsigned long                                      r_bTransformPouncing : 1;                                 // 0x261C(0x0004) (Net)
	unsigned long                                      r_bMinkBuffFXEnabled : 1;                                 // 0x261C(0x0004) (Net)
	unsigned long                                      m_bIsTurtleShieldActive : 1;                              // 0x261C(0x0004)
	unsigned long                                      m_bNineTurnsActive : 1;                                   // 0x261C(0x0004)
	int                                                m_nSpotWeaknessFiringInstance;                            // 0x2620(0x0004)
	TEnumAsByte<ERLANG_SHEN_TRANSFORM>                 r_CurrentTransformState;                                  // 0x2624(0x0001) (Net)
	TEnumAsByte<ERLANG_SHEN_TRANSFORM>                 c_PrevTransformState;                                     // 0x2625(0x0001)
	TEnumAsByte<ERLANG_SHEN_TRANSFORM>                 c_LocalTransformState;                                    // 0x2626(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x2627(0x0001) MISSED OFFSET
	class ATgDevice_ErlangShen_Transform*              r_TransformDevices[0x3];                                  // 0x2628(0x0008) (Net)
	TArray<class UTgAnimNodeAimOffset*>                c_TransformAimOffsets;                                    // 0x2640(0x0010) (NeedCtorLink)
	int                                                r_nTransformYawOffset;                                    // 0x2650(0x0004) (Net)
	float                                              m_fTransformAimOffsetMax;                                 // 0x2654(0x0004) (Const)
	class UAnimNodeSequence*                           m_TransformIntroSequenceNode;                             // 0x2658(0x0008)
	struct FName                                       c_TransformOutroAnimName;                                 // 0x2660(0x0008)
	struct FPointer                                    m_TransformBodyMeshAssemblies[0x3];                       // 0x2668(0x0008) (Native)
	struct FPointer                                    m_TransformDestroyedMeshAssemblies[0x3];                  // 0x2680(0x0008) (Native)
	int                                                m_TransformDesiredAssemblyId;                             // 0x2698(0x0004)
	int                                                m_TransformDesiredDestroyedAssemblyId;                    // 0x269C(0x0004)
	struct FName                                       c_MinkPounceAnimName;                                     // 0x26A0(0x0008)
	float                                              m_fTransformPounceRecoverTime;                            // 0x26A8(0x0004) (Const)
	class UTgEffectGroup*                              s_TransformPouceRoot;                                     // 0x26AC(0x0008)
	class UTgAnimNodeSlot*                             c_PounceSlot;                                             // 0x26B4(0x0008)
	int                                                r_nTurtleShieldEndCounter;                                // 0x26BC(0x0004) (Net)
	float                                              c_fNineTurnsApplyTime;                                    // 0x26C0(0x0004)
	float                                              r_fNineTurnsLifeTime;                                     // 0x26C4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ErlangShen");
		return ptr;
	}


	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void STATIC_EndMinkPounce();
	void BeginMinkPounce();
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void STATIC_SetPinFireMode(int nFireMode);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormHit(int nEquipSlot, class ATgPawn* TargetPawn);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	struct FVector STATIC_GetLookAtLocation();
	void STATIC_OnRespawn();
	void ReplicatedEvent(const struct FName& VarName);
	void TriggerTurtleShieldEndFX();
	void STATIC_EnableMinkBuffFX(bool bEnabled);
	void STATIC_EnableSpotWeaknessFX(bool bEnabled);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_EndTransform();
	void STATIC_StartTransform(TEnumAsByte<ERLANG_SHEN_TRANSFORM> NewStance, bool bSkipTransition);
	void STATIC_DespawnPet();
	void STATIC_SpawnPet();
	void STATIC_OnPawnDied();
	void STATIC_PostPawnSetupServer();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_SwapTransformMesh();
	void STATIC_SwapToDestroyedMesh();
	void STATIC_SwapToLiveMesh();
	void STATIC_OnPostureChange();
	void STATIC_OnTransformTransitionEnd(bool bTriggeredInAnimTick);
};


// Class TgGame.TgPawn_ErlangShen_Dog
// 0x0014 (0x24A4 - 0x2490)
class ATgPawn_ErlangShen_Dog : public ATgPawn_Familiar_LongTerm
{
public:
	float                                              m_fOwnerCriticalStrikePercent;                            // 0x2490(0x0004)
	float                                              r_fLeashRange;                                            // 0x2494(0x0004) (Net)
	float                                              r_fPhysPowerScaling;                                      // 0x2498(0x0004) (Net)
	class ATgPawn*                                     m_LastCombatTarget;                                       // 0x249C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ErlangShen_Dog");
		return ptr;
	}


	void STATIC_OwnerJumpedTimer();
	void Tick(float DeltaSeconds);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	struct FVector STATIC_GetDesiredRelativePosition();
	void STATIC_CatchUpToOwner(float Distance);
	void STATIC_TeleportToOwner();
	void STATIC_OnOwnerPostTeleport();
	void STATIC_OnOwnerJumped();
	void STATIC_DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	bool IsNonCombat();
	float STATIC_GetCriticalDamage();
	float STATIC_GetCriticalStrike();
};


// Class TgGame.TgAnimNodeBlendList_Terra_CrushingShaleState
// 0x000C (0x0174 - 0x0168)
class UTgAnimNodeBlendList_Terra_CrushingShaleState : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Terra*                               m_Terra;                                                  // 0x0168(0x0008)
	unsigned long                                      m_PlayCrush : 1;                                          // 0x0170(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Terra_CrushingShaleState");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_Terra_ShaleDestruction
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendList_Terra_ShaleDestruction : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Terra_ShaleDestruction");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Terra_Trap
// 0x0008 (0x0400 - 0x03F8)
class ATgDeployable_Terra_Trap : public ATgDeploy_EffectVolume
{
public:
	class ATgCollisionProxy_Box*                       s_CollisionProxy;                                         // 0x03F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Terra_Trap");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void InitializeCollisionProxy();
};


// Class TgGame.TgDeployable_Terra_StandingStone
// 0x0014 (0x0420 - 0x040C)
class ATgDeployable_Terra_StandingStone : public ATgDeploy_Wall_Destructible
{
public:
	class ATgPawn_Terra*                               m_OwningTerra;                                            // 0x040C(0x0008)
	unsigned long                                      r_WallCracking : 1;                                       // 0x0414(0x0004) (Net)
	float                                              m_WallCrackTime;                                          // 0x0418(0x0004)
	float                                              m_WallCrackDuration;                                      // 0x041C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Terra_StandingStone");
		return ptr;
	}


	void STATIC_StartWallCrack();
	void DestroyIt(bool bSkipFx);
	void MegaPunched(class ATgPawn_Terra* attacker, const struct FVector& HitLocation);
	void STATIC_OwningTerraShattered();
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetMICParameter(const struct FName& ScalarParam, float ScalarValue);
	bool STATIC_IsInvisible(class AActor* TestActor);
};


// Class TgGame.TgDeployable_Terra_CrushingShale
// 0x0039 (0x0459 - 0x0420)
class ATgDeployable_Terra_CrushingShale : public ATgDeployable_Terra_StandingStone
{
public:
	class ATgDeployable_Terra_CrushingShale*           r_SisterShale;                                            // 0x0420(0x0008) (Net)
	unsigned long                                      r_IsCrushing : 1;                                         // 0x0428(0x0004) (Net)
	unsigned long                                      r_CollisionReady : 1;                                     // 0x0428(0x0004) (Net)
	TArray<class ATgPawn*>                             s_HitActors;                                              // 0x042C(0x0010) (NeedCtorLink)
	struct FVector                                     m_TweenStart;                                             // 0x043C(0x000C)
	struct FVector                                     m_TweenEnd;                                               // 0x0448(0x000C)
	float                                              m_TweenTime;                                              // 0x0454(0x0004)
	TEnumAsByte<ETerraCrushingShaleDestructionState>   m_DestructionState;                                       // 0x0458(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Terra_CrushingShale");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_CrushTravelTimeExpired();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_OwningTerraShattered();
	void STATIC_ClientTriggerCrush();
	void TriggerCrush();
	bool STATIC_CanTriggerCrush(class ATgDeployable* Other);
	void STATIC_ClientCollisionReady();
	void STATIC_CollisionReady();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_StopCrushPhysics();
	void STATIC_StartCrushPhysics();
};


// Class TgGame.TgDeployable_Terra_Obelisk
// 0x0020 (0x0440 - 0x0420)
class ATgDeployable_Terra_Obelisk : public ATgDeployable_Terra_StandingStone
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x0420(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x0430(0x0008)
	class UCylinderComponent*                          m_CollisionCylinder;                                      // 0x0438(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Terra_Obelisk");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SetupCollisionProxy();
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_Terra_PillarOfEarth
// 0x0004 (0x0424 - 0x0420)
class ATgDeployable_Terra_PillarOfEarth : public ATgDeployable_Terra_StandingStone
{
public:
	unsigned long                                      m_FiredOnce : 1;                                          // 0x0420(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Terra_PillarOfEarth");
		return ptr;
	}


	void STATIC_ShatterOnBanishedTargets();
	void DestroyIt(bool bSkipFx);
};


// Class TgGame.TgDevice_Terra_MegaPunch
// 0x0008 (0x0544 - 0x053C)
class ATgDevice_Terra_MegaPunch : public ATgDevice_Charge
{
public:
	unsigned long                                      r_IsBonusCharge : 1;                                      // 0x053C(0x0004) (Net)
	unsigned long                                      r_HitWall : 1;                                            // 0x053C(0x0004) (Net)
	float                                              m_fBonusTime;                                             // 0x0540(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Terra_MegaPunch");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool IsNextUsageFree();
	unsigned char STATIC_IncrementFiringInstance();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void UpdateManaUseVitals(class ATgPlayerController* PC);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Terra_CrushingShale
// 0x0054 (0x0550 - 0x04FC)
class ATgDevice_Terra_CrushingShale : public ATgDevice_Deployable
{
public:
	TEnumAsByte<ETerraDev3State>                       r_CurrentState;                                           // 0x04FC(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04FD(0x0003) MISSED OFFSET
	TArray<class ATgDeployable*>                       s_ActiveDeployables;                                      // 0x0500(0x0010) (NeedCtorLink)
	class ATgDeployable_Terra_CrushingShale*           m_LastSpawned;                                            // 0x0510(0x0008)
	class ATgDeployable_Terra_Trap*                    m_Trap;                                                   // 0x0518(0x0008)
	struct FAimData                                    m_DeployAim;                                              // 0x0520(0x0030)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Terra_CrushingShale");
		return ptr;
	}


	bool STATIC_InDeployedState();
	bool STATIC_InDeployingState();
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableDeployComplete(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void TryTriggerCrush();
	void STATIC_RefireTimerExpire();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
	void UpdateCurrentState();
	void SetCurrentState(TEnumAsByte<ETerraDev3State> State);
	void STATIC_SetNextAnimState(bool IsDetonating);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void ReplicatedEvent(const struct FName& VarName);
	unsigned char STATIC_IncrementFiringInstance();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	void UpdateManaUseVitals(class ATgPlayerController* PC);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_Terra_MotherEarth
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Terra_MotherEarth : public ATgDevice
{
public:
	unsigned long                                      r_IsEffectActive : 1;                                     // 0x04F0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Terra_MotherEarth");
		return ptr;
	}


	class ATgRepInfo_TaskForce* STATIC_GetInstigatorTeam();
	void OnEffectEndOnSelf();
	void OnEffectPlacedOnSelf(float Duration);
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
	bool ShouldTriggerCastReactionItems();
	bool ShouldCooldownAfterFire();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_Terra_Shatter
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Terra_Shatter : public ATgDevice
{
public:
	class UTgDeviceFire*                               m_DeployableDeviceFire;                                   // 0x04F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Terra_Shatter");
		return ptr;
	}


	void STATIC_InitDeployableDeviceFire();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDeviceFire_Terra_CrushingShale
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Terra_CrushingShale : public UTgDeviceFire_Deploy
{
public:
	int                                                m_CenterDeployableId;                                     // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Terra_CrushingShale");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_SpawnBetweenDeployable();
	void STATIC_CustomFire();
};


// Class TgGame.TgDeviceFire_Terra_PillarOfEarth
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Terra_PillarOfEarth : public UTgDeviceFire_Deploy
{
public:
	int                                                m_LastHittingFiringInstance;                              // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Terra_PillarOfEarth");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool ValidateApplyHit(const struct FImpactInfo& Impact);
	void OnDeployableDeployComplete(class ATgDeployable* deployable);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Terra_BasicAttack
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Terra_BasicAttack : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Terra_BasicAttack");
		return ptr;
	}


	void STATIC_SwapAttackType(bool bPassiveActive);
};


// Class TgGame.TgDeviceFire_Terra_CrushingShale_Sub
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Terra_CrushingShale_Sub : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Terra_CrushingShale_Sub");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Terra_MegaPunch
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Terra_MegaPunch : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Terra_MegaPunch");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceForm_Terra_BasicAttack
// 0x0004 (0x023C - 0x0238)
class UTgDeviceForm_Terra_BasicAttack : public UTgDeviceForm
{
public:
	unsigned long                                      m_ShowSpecialTargeter : 1;                                // 0x0238(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Terra_BasicAttack");
		return ptr;
	}


	bool UsesTargetingMode();
};


// Class TgGame.TgDeviceForm_Terra_MegaPunch
// 0x0020 (0x0258 - 0x0238)
class UTgDeviceForm_Terra_MegaPunch : public UTgDeviceForm
{
public:
	class UTgSpecialFx*                                c_CrushingShaleShatterFx[0x2];                            // 0x0238(0x0008)
	class UTgSpecialFx*                                c_ObeliskShatterFx;                                       // 0x0248(0x0008)
	int                                                c_CrushingShaleShatterFxId;                               // 0x0250(0x0004)
	int                                                c_ObeliskShatterFxId;                                     // 0x0254(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Terra_MegaPunch");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingList(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_Terra_MotherEarth
// 0x0008 (0x00EC - 0x00E4)
class UTgInventoryObject_Listen_Terra_MotherEarth : public UTgInventoryObject_Listen_Effect
{
public:
	int                                                m_HitCount;                                               // 0x00E4(0x0004)
	unsigned long                                      m_Detonated : 1;                                          // 0x00E8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Terra_MotherEarth");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_TerraPassive
// 0x000C (0x012C - 0x0120)
class UTgInventoryObject_Listen_TerraPassive : public UTgInventoryObject_Listen_Stack
{
public:
	class ATgPawn_Terra*                               m_OwningTerra;                                            // 0x0120(0x0008)
	int                                                m_StandingStoneCount;                                     // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_TerraPassive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Terra
// 0x0170 (0x2728 - 0x25B8)
class ATgPawn_Terra : public ATgPawn_Character
{
public:
	class ATgDevice*                                   s_PassiveDevice;                                          // 0x25B8(0x0008)
	class ATgDevice_ChainedMelee*                      m_terraBasicAttack;                                       // 0x25C0(0x0008)
	class ATgDevice_Terra_Shatter*                     m_ShatterA02Device;                                       // 0x25C8(0x0008)
	class ATgDevice_Terra_Shatter*                     m_ShatterA03Device;                                       // 0x25D0(0x0008)
	class ATgDevice*                                   s_Dev4DetonateDevice;                                     // 0x25D8(0x0008)
	TArray<class ATgDeployable_Terra_StandingStone*>   s_StandingStones;                                         // 0x25E0(0x0010) (NeedCtorLink)
	int                                                r_PassiveCount;                                           // 0x25F0(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    c_SpikeArmor;                                             // 0x25F4(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      r_ShowSpikeArmor : 1;                                     // 0x25FC(0x0004) (Net)
	unsigned long                                      r_ExtendPassive : 1;                                      // 0x25FC(0x0004) (Net)
	unsigned long                                      r_Dev2NextCastIsDetonate : 1;                             // 0x25FC(0x0004) (Net)
	float                                              s_LastShatterTime;                                        // 0x2600(0x0004)
	class UTgAnimNodeSlot*                             m_Dev1ShatterNode;                                        // 0x2604(0x0008)
	int                                                r_Dev1BonusCharges;                                       // 0x260C(0x0004) (Net)
	TArray<class ATgPawn*>                             m_Dev2HitTracking;                                        // 0x2610(0x0010) (NeedCtorLink)
	TArray<int>                                        m_Dev3DeployableIds;                                      // 0x2620(0x0010) (NeedCtorLink)
	struct FTerraWardstoneFXData                       r_Dev4WardStoneStatus[0xA];                               // 0x2630(0x0010) (Net)
	class UMeshComponent*                              m_Dev4WardStoneFx[0xA];                                   // 0x26D0(0x0008) (ExportObject, Component, EditInline)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x2720(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Terra");
		return ptr;
	}


	void AdjustPawnMeshVisibility();
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	bool STATIC_HandleCrushingShaleHit(class ATgDeployable_Terra_CrushingShale* deployable, class ATgPawn* HitPawn, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void TriggerDev4DetonateOnTarget(class ATgPawn* Target);
	void PlayDev1HitAnimation();
	void TriggerShatter(class ATgDeployable_Terra_StandingStone* standingStone, const struct FVector& HitLocation);
	void STATIC_Dev1BonusTimeExpired();
	void UpdateDev1BonusCharges();
	void STATIC_ConsumeDev1BonusCharges();
	bool IsDev1BonusChargeAvailable();
	void AwardDev1BonusCharge();
	void Tick(float DeltaSeconds);
	void StandingStoneDestroyed(class ATgDeployable_Terra_StandingStone* standingStone);
	void StandingStoneCreated(class ATgDeployable_Terra_StandingStone* standingStone);
	void AnimateWardStonesOut();
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void UpdateWardStones();
	void SetWardStoneStatus(class ATgPawn* Target, bool IsActive, int ActiveStoneCount);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateClientDevices(bool bForce);
	bool IsMyStandingStone(class AActor* Target);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
	bool STATIC_GetPassiveInt1(int* nResult);
	void ToggleSpikeArmor(bool IsOn);
	void STATIC_InitializeSpikeArmor();
	class UMeshComponent* AttachWardStoneMesh(class ATgPawn* Target);
};


// Class TgGame.TgAchievement_Izanami_WhereYouGoing
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_Izanami_WhereYouGoing : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Izanami_WhereYouGoing");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Izanami_Dev4
// 0x0038 (0x0444 - 0x040C)
class ATgDeploy_Izanami_Dev4 : public ATgDeploy_Wall
{
public:
	class UMeshComponent*                              m_CollisionMesh;                                          // 0x040C(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nCollisionMeshId;                                       // 0x0414(0x0004)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x0418(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x0428(0x0008)
	class ATgPawn*                                     r_TargetPawn;                                             // 0x0430(0x0008) (Net)
	class UTgSpecialFx*                                c_SpawnEffect;                                            // 0x0438(0x0008)
	int                                                m_nSpawnEffectId;                                         // 0x0440(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Izanami_Dev4");
		return ptr;
	}


	bool AllowPassthrough(bool bFriendly);
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void Cleanup();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool IsPushable(class AActor* Other);
};


// Class TgGame.TgDevice_Izanami_Inhand
// 0x0008 (0x0554 - 0x054C)
class ATgDevice_Izanami_Inhand : public ATgDevice_ActiveMode
{
public:
	class ATgPawn_Izanami*                             IzanamiPawn;                                              // 0x054C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Izanami_Inhand");
		return ptr;
	}


	int CalculateNextMode(int CurrentMode);
};


// Class TgGame.TgDevice_Izanami_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Izanami_Dev1 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Izanami_Dev1");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool ShouldCancelStealth();
	bool StartFire();
	bool ShouldCooldownAfterFire();
};


// Class TgGame.TgDevice_Izanami_IcyGrasp
// 0x0060 (0x0550 - 0x04F0)
class ATgDevice_Izanami_IcyGrasp : public ATgDevice_Range
{
public:
	unsigned char                                      UnknownData00[0x48];                                      // 0x04F0(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgDevice_Izanami_IcyGrasp.m_HitTargets
	TArray<class ATgProj_Simulated*>                   m_ActiveContagions;                                       // 0x0538(0x0010) (NeedCtorLink)
	float                                              m_LastProjectileCheckTime;                                // 0x0548(0x0004)
	float                                              m_CheckProjectileTime;                                    // 0x054C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Izanami_IcyGrasp");
		return ptr;
	}


	bool CanFireWhileDead();
	void AddContagionProjectile(class ATgProj_Simulated* Contagion);
	void STATIC_RemoveContagionChain(int FiringInstance);
	void AddContagion(int FiringInstance, class ATgPawn* Victim);
};


// Class TgGame.TgDevice_Izanami_InvisibleEscape
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Izanami_InvisibleEscape : public ATgDevice_TweenBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Izanami_InvisibleEscape");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDeviceForm_Izanami_InvisibleEscape
// 0x0004 (0x023C - 0x0238)
class UTgDeviceForm_Izanami_InvisibleEscape : public UTgDeviceForm
{
public:
	float                                              c_fCurrBuildupTime;                                       // 0x0238(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Izanami_InvisibleEscape");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_IzanamiDev1
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_IzanamiDev1 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_IzanamiDev1");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_IzanamiDev2
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_IzanamiDev2 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_IzanamiDev2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_IzanamiDev3
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_IzanamiDev3 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_IzanamiDev3");
		return ptr;
	}

};


// Class TgGame.TgPawn_Izanami
// 0x0028 (0x25E0 - 0x25B8)
class ATgPawn_Izanami : public ATgPawn_Character
{
public:
	unsigned long                                      r_bIsBitingStrike : 1;                                    // 0x25B8(0x0004) (Net)
	unsigned long                                      m_bCanRemoveStealth : 1;                                  // 0x25B8(0x0004)
	class UTgSkeletalMeshComponent*                    c_BitingStrikePACMesh;                                    // 0x25BC(0x0008) (ExportObject, Component, EditInline)
	float                                              r_bInvisibleEscapeIsBuildingUp;                           // 0x25C4(0x0004) (Net)
	float                                              r_fInvisibleEscapeBuildupTime;                            // 0x25C8(0x0004) (Net)
	float                                              r_fDev2PassiveStack;                                      // 0x25CC(0x0004) (Net)
	TArray<class ATgPawn*>                             m_AppliedDev2StacksTick;                                  // 0x25D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Izanami");
		return ptr;
	}


	void STATIC_ServerOnRightMousePressed();
	void STATIC_OnRightMousePressed();
	void SetBitingStrikePACMesh(bool bTurnOn);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_OnAttackDamagePropertyChange();
	float STATIC_GetPercPenetration(int nProtectionType, class AActor* Target);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_DeviceAdjustHeal(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnPostHit(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	bool STATIC_InitializeBitingStrikeMesh();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
};


// Class TgGame.TgProj_Izanami_Dev2
// 0x0008 (0x03B4 - 0x03AC)
class ATgProj_Izanami_Dev2 : public ATgProj_SimulatedPassThrough
{
public:
	class UTgAnimNodeSlot*                             c_FullBodyAnimNode;                                       // 0x03AC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Izanami_Dev2");
		return ptr;
	}


	void STATIC_PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
};


// Class TgGame.TgProj_Izanami_Inhand
// 0x001C (0x03D4 - 0x03B8)
class ATgProj_Izanami_Inhand : public ATgProj_SimulatedBoomerang
{
public:
	class ATgPawn_Izanami*                             m_IzanamiPawn;                                            // 0x03B8(0x0008)
	unsigned long                                      m_bIsBitingStrike : 1;                                    // 0x03C0(0x0004)
	unsigned long                                      m_bRecallBitingSickle : 1;                                // 0x03C0(0x0004)
	unsigned long                                      m_bIsReturning : 1;                                       // 0x03C0(0x0004)
	TArray<class AActor*>                              m_AllHitTargets;                                          // 0x03C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Izanami_Inhand");
		return ptr;
	}


	void SetSyncParams(float fGeneric1, float fGeneric2);
	void GetSyncParams(float* fGeneric1, float* fGeneric2);
	bool STATIC_ProximityReached(class AActor* A, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void NativeReturnToOwner();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_RangeReached();
	void STATIC_ReturnToOwner();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Izanami_Dev4
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Izanami_Dev4 : public ATgProj_SimulatedPassThroughUntilGod_CollidesWorld
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Izanami_Dev4");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void MarkTarget(class AActor* Target);
};


// Class TgGame.TgAchievement_Camazotz_BatOutOfHell
// 0x0018 (0x00C4 - 0x00AC)
class UTgAchievement_Camazotz_BatOutOfHell : public UTgAchievement_DeviceMultiHit_ByType
{
public:
	struct FCamazotzTrackedTargets                     m_CurrentCamazotzTracked;                                 // 0x00AC(0x0018) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Camazotz_BatOutOfHell");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByCamazotzUltimate
// 0x0004 (0x016C - 0x0168)
class UTgAnimNodeBlendByCamazotzUltimate : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bOutroNextTick : 1;                                     // 0x0168(0x0004) (Transient)
	unsigned long                                      m_bFireNextTick : 1;                                      // 0x0168(0x0004) (Transient)
	unsigned long                                      m_bLastFireNextTick : 1;                                  // 0x0168(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByCamazotzUltimate");
		return ptr;
	}


	void STATIC_ResetChain();
	void STATIC_Outro();
	void LastFire();
	void Fire();
};


// Class TgGame.TgDeployable_Camazotz_Essence
// 0x003C (0x0434 - 0x03F8)
class ATgDeployable_Camazotz_Essence : public ATgDeploy_EffectVolume
{
public:
	unsigned long                                      s_bEffectApplied : 1;                                     // 0x03F8(0x0004)
	unsigned long                                      m_bForceDestroy : 1;                                      // 0x03F8(0x0004)
	unsigned long                                      m_bTimerDestroy : 1;                                      // 0x03F8(0x0004)
	unsigned long                                      m_bDestroyingSelf : 1;                                    // 0x03F8(0x0004)
	class UTgDeviceFire*                               s_EffectModeApplied;                                      // 0x03FC(0x0008)
	TEnumAsByte<ESceneDepthPriorityGroup>              c_CurrentNetOwnerDepthGroup;                              // 0x0404(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0405(0x0003) MISSED OFFSET
	int                                                m_nTotalDrinks;                                           // 0x0408(0x0004)
	int                                                m_nConsumedDrinks;                                        // 0x040C(0x0004)
	float                                              m_fFastTimeIncrement;                                     // 0x0410(0x0004)
	float                                              m_fSlowTimeIncrement;                                     // 0x0414(0x0004)
	class ATgPawn*                                     m_SpawnerPawn;                                            // 0x0418(0x0008)
	float                                              m_fSpawnTimeStamp;                                        // 0x0420(0x0004)
	TArray<struct FCamazotzTouchData>                  m_TrackedData;                                            // 0x0424(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Camazotz_Essence");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ReplicatedEvent(const struct FName& VarName);
	bool IsFriendlyWithLocalPawn();
	void STATIC_RemoveTouchData(class ATgPawn_Camazotz* removingCamazotz);
	void STATIC_CreateNewTouchData(class ATgPawn_Camazotz* touchingCamazotz);
	int STATIC_CheckTrackedDataForCamazotz(class ATgPawn_Camazotz* touchingCamazotz);
	void STATIC_EndConsuming();
};


// Class TgGame.TgDevice_Camazotz_Screech
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_Camazotz_Screech : public ATgDevice
{
public:
	unsigned long                                      m_bShouldUpgradeEcho : 1;                                 // 0x04F0(0x0004)
	TArray<class ATgProj_Camazotz_ScreechEcho*>        m_echoProjectiles;                                        // 0x04F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Camazotz_Screech");
		return ptr;
	}


	void DestroyAllEchoes();
	void STATIC_SetPointsAllocated(int nPoints);
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_Camazotz_Dev4Shooter
// 0x000C (0x0548 - 0x053C)
class ATgDevice_Camazotz_Dev4Shooter : public ATgDevice_Charge
{
public:
	int                                                m_nAmmoCount;                                             // 0x053C(0x0004)
	int                                                m_nMaxAmmoCount;                                          // 0x0540(0x0004)
	int                                                m_nAmmoCountSituationalType;                              // 0x0544(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Camazotz_Dev4Shooter");
		return ptr;
	}


	void STATIC_ClientSetAmmoCount(int nAmmoCount);
	void SetAmmoCount(int nAmmoCount, bool bDoNotFowardToClient);
	void InterruptFiring();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	int STATIC_GetProjectileNum();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void RemoveEquipEffects();
	void ApplyEquipEffects();
};


// Class TgGame.TgDevice_Camazotz_Essence
// 0x000C (0x0508 - 0x04FC)
class ATgDevice_Camazotz_Essence : public ATgDevice_Deployable
{
public:
	class ATgPawn*                                     s_SpawnerPawn;                                            // 0x04FC(0x0008)
	float                                              s_fSpawnTimeStamp;                                        // 0x0504(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Camazotz_Essence");
		return ptr;
	}


	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
};


// Class TgGame.TgDevice_Camazotz_VampireBats
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Camazotz_VampireBats : public ATgDevice_Range
{
public:
	unsigned long                                      m_bShouldUpgradeBatsHeal : 1;                             // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Camazotz_VampireBats");
		return ptr;
	}


	void STATIC_SetPointsAllocated(int nPoints);
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_Camazotz_Dev4Staging
// 0x0008 (0x0530 - 0x0528)
class ATgDevice_Camazotz_Dev4Staging : public ATgDevice_Staging
{
public:
	class ATgPawn_Camazotz*                            s_CachedCamazotz;                                         // 0x0528(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Camazotz_Dev4Staging");
		return ptr;
	}


	bool STATIC_ClientFireOnEndStage();
	void OnStageShooterStopFire(bool bInterrupted);
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	bool LockStageShooterFiring();
	bool CanJumpWhileFiring();
	bool CanBeCanceled();
};


// Class TgGame.TgPawn_Camazotz
// 0x009C (0x2654 - 0x25B8)
class ATgPawn_Camazotz : public ATgPawn_Character
{
public:
	class ATgDevice_Camazotz_Essence*                  m_DevicePsv_EssenceDrinker;                               // 0x25B8(0x0008)
	class ATgDevice_Camazotz_Screech*                  m_DeviceA01_Screech;                                      // 0x25C0(0x0008)
	class ATgDevice*                                   m_DeviceA01_ScreechEcho;                                  // 0x25C8(0x0008)
	class ATgDevice_Camazotz_VampireBats*              m_DeviceA02_VampireBats;                                  // 0x25D0(0x0008)
	class ATgDevice*                                   m_DeviceA02_VampireBatsBuff;                              // 0x25D8(0x0008)
	class ATgDevice*                                   m_DeviceA02_VampireBatsHeal;                              // 0x25E0(0x0008)
	class ATgDevice*                                   m_DeviceA03_ToothAndNail;                                 // 0x25E8(0x0008)
	class ATgDevice_Camazotz_Dev4Staging*              m_DeviceA04_Dev4Staging;                                  // 0x25F0(0x0008)
	int                                                r_nCurrentEssenceDrinksRemaining;                         // 0x25F8(0x0004) (Net)
	int                                                r_nTouchingEssences;                                      // 0x25FC(0x0004) (Net)
	struct FVector                                     m_PrevVelocity;                                           // 0x2600(0x000C)
	unsigned long                                      m_bScreechBuffActive : 1;                                 // 0x260C(0x0004)
	unsigned long                                      m_bFireLastShot : 1;                                      // 0x260C(0x0004)
	class ATgPawn*                                     m_ScreechHitPawn;                                         // 0x2610(0x0008)
	class ATgPawn*                                     m_ScreechRevealedPawn;                                    // 0x2618(0x0008)
	int                                                r_nNumJungleBuffStacks;                                   // 0x2620(0x0004) (Net)
	float                                              r_fJungleBuffTimeRemaining;                               // 0x2624(0x0004) (Net)
	float                                              r_fJungleBuffAlertThreshold;                              // 0x2628(0x0004) (Net)
	TEnumAsByte<ECamazotzUltState>                     r_eUltimateState;                                         // 0x262C(0x0001) (Net)
	TEnumAsByte<ECamazotzUltState>                     m_eLocalUltState;                                         // 0x262D(0x0001)
	TEnumAsByte<ETG_POSTURE>                           c_eUltimatePosture;                                       // 0x262E(0x0001)
	TEnumAsByte<ECamazotzWeaponType>                   r_EquippedInHand;                                         // 0x262F(0x0001) (Net)
	int                                                c_nUltimatePostureId;                                     // 0x2630(0x0004)
	float                                              s_fUltimateTakeDownTime;                                  // 0x2634(0x0004)
	class UTgAnimNodeBlendByCamazotzUltimate*          m_UltimateCycleBlendList;                                 // 0x2638(0x0008)
	int                                                m_nHitCountForSwoop;                                      // 0x2640(0x0004)
	int                                                m_nAmmoUsed;                                              // 0x2644(0x0004)
	int                                                m_nMaxAmmoCount;                                          // 0x2648(0x0004)
	float                                              r_fTransformCameraZoom;                                   // 0x264C(0x0004) (Net)
	float                                              r_fTransformCameraZoomTween;                              // 0x2650(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Camazotz");
		return ptr;
	}


	bool WantsLoopingEmote(TEnumAsByte<EEmote> Emote);
	void STATIC_OnDeviceFormInterruptFire(int nEquipSlot);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	bool CannotJumpNow();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_OnRespawn();
	void Tick(float DeltaSeconds);
	void STATIC_EndUltimateTakeDown();
	void STATIC_GetCameraZoomOverride(float* fZoom, float* fTweenSpeed);
	void SetCameraZoomOverride(float fZoom, float fTweenSpeed);
	void ToggleUltimateCameraModule(bool bOn);
	void UpdateUltimateState(TEnumAsByte<ECamazotzUltState> NewState);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ReturnVampireBatsHealth(const struct FVector& vLoc);
	void STATIC_EndVampireBatsLock(const struct FVector& vLoc);
	void STATIC_EndScreechBuff();
	void BeginScreechBuff();
	void STATIC_OnPawnDied();
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_CancelEssenceDrinkingEmote();
	void STATIC_PlayEssenceDrinkingEmote();
	void STATIC_HealSelfFromEssence();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveBool(int* bResult);
	void STATIC_PopulatePassiveMeterValues();
};


// Class TgGame.TgProj_Camazotz_Screech
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Camazotz_Screech : public ATgProj_SimulatedPassThroughUntilGod_CollidesWorld
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Camazotz_Screech");
		return ptr;
	}

};


// Class TgGame.TgProj_Camazotz_ScreechEcho
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Camazotz_ScreechEcho : public ATgProj_SimulatedPassThroughUntilGod_CollidesWorld
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Camazotz_ScreechEcho");
		return ptr;
	}


	void HitWall(const struct FVector& HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAchievement_Thoth_NarrowEscape
// 0x0000 (0x0098 - 0x0098)
class UTgAchievement_Thoth_NarrowEscape : public UTgAchievement_DeviceKillsSingleShot
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Thoth_NarrowEscape");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Thoth_WallOfDeath
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Thoth_WallOfDeath : public UTgAchievement
{
public:
	int                                                m_nWallDeployableId;                                      // 0x0084(0x0004)
	int                                                m_nHitObjectiveId;                                        // 0x0088(0x0004)
	int                                                m_nLastTeammateId;                                        // 0x008C(0x0004)
	int                                                m_nTeammateCount;                                         // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Thoth_WallOfDeath");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_Thoth_Inhand
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendList_Thoth_Inhand : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Thoth_Inhand");
		return ptr;
	}


	void STATIC_SetInhandState(TEnumAsByte<EThothInhandState> InhandState);
};


// Class TgGame.TgAnimNodeBlentList_Thoth_Dash
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlentList_Thoth_Dash : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlentList_Thoth_Dash");
		return ptr;
	}


	void STATIC_SetIsDashing(bool IsDashing);
};


// Class TgGame.TgDeployable_Thoth_DeathGlyph
// 0x0004 (0x03FC - 0x03F8)
class ATgDeployable_Thoth_DeathGlyph : public ATgDeploy_EffectVolume
{
public:
	unsigned long                                      m_DisplayWarning : 1;                                     // 0x03F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Thoth_DeathGlyph");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void STATIC_DashTriggered();
};


// Class TgGame.TgDeployable_Thoth_SpeedGlyph
// 0x0024 (0x041C - 0x03F8)
class ATgDeployable_Thoth_SpeedGlyph : public ATgDeploy_EffectVolume
{
public:
	class UStaticMeshComponent*                        m_CollisionBox;                                           // 0x03F8(0x0008) (ExportObject, Component, EditInline)
	class ATgProjectile*                               s_LastTracked;                                            // 0x0400(0x0008)
	struct FSpeedGlyphImpactFXData                     r_LastImpact;                                             // 0x0408(0x0014) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Thoth_SpeedGlyph");
		return ptr;
	}


	void HandleTouch(class AActor* Other);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PlayImpactFX();
};


// Class TgGame.TgDevice_Thoth_AutoCharge
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Thoth_AutoCharge : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thoth_AutoCharge");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Thoth_Dash
// 0x0004 (0x0540 - 0x053C)
class ATgDevice_Thoth_Dash : public ATgDevice_Charge
{
public:
	unsigned long                                      r_bIsActiveState : 1;                                     // 0x053C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thoth_Dash");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void ToggleActiveState(bool IsNowActive);
	void DeviceSetup();
	void DeviceCleanup();
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	float GetChargeRange();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldCooldownAfterFire();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Thoth_Dev1
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Thoth_Dev1 : public ATgDevice
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                                       // 0x04F0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thoth_Dev1");
		return ptr;
	}


	void StartCooldown(int nMode, float fCooldownTimeOverride);
	void STATIC_FireAmmunition();
	bool ShouldCooldownAfterFire();
	void ReplicatedEvent(const struct FName& VarName);
	bool IsToggledOn();
};


// Class TgGame.TgDevice_Thoth_RangeExtension
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Thoth_RangeExtension : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thoth_RangeExtension");
		return ptr;
	}

};


// Class TgGame.TgDevice_Thoth_Dev1_Shooter
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Thoth_Dev1_Shooter : public ATgDevice_Thoth_RangeExtension
{
public:
	TArray<int>                                        m_nFiringInstancesThatHitGod;                             // 0x04F0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thoth_Dev1_Shooter");
		return ptr;
	}


	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	bool STATIC_CanBeDisarmed();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	unsigned char STATIC_GetCurrentFiringInstance();
};


// Class TgGame.TgDevice_Thoth_Dev2Shooter
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Thoth_Dev2Shooter : public ATgDevice_Thoth_RangeExtension
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thoth_Dev2Shooter");
		return ptr;
	}


	bool STATIC_CanBeDisarmed();
};


// Class TgGame.TgDeviceFire_Thoth_Dash
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Thoth_Dash : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Thoth_Dash");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcChargeTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float fRange, TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_ShouldAddRangeExtension(const struct FVector& aimStart, const struct FVector& AimVector);
};


// Class TgGame.TgDeviceFire_Thoth_ExtendedRange
// 0x000C (0x01CC - 0x01C0)
class UTgDeviceFire_Thoth_ExtendedRange : public UTgDeviceFire
{
public:
	unsigned long                                      m_bAddGlyphRangeExtension : 1;                            // 0x01C0(0x0004)
	class ATgDevice_Deployable*                        m_devGlyph;                                               // 0x01C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Thoth_ExtendedRange");
		return ptr;
	}


	void STATIC_SubmitHitEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact, int nType);
	struct FImpactInfo STATIC_CalcLinearFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseProximityDistance, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Thoth_Dev1
// 0x0000 (0x01CC - 0x01CC)
class UTgDeviceFire_Thoth_Dev1 : public UTgDeviceFire_Thoth_ExtendedRange
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Thoth_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Thoth_Dash
// 0x0010 (0x0248 - 0x0238)
class UTgDeviceForm_Thoth_Dash : public UTgDeviceForm
{
public:
	TEnumAsByte<EThothDashTargetingMode>               m_TargetMode;                                             // 0x0238(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0239(0x0003) MISSED OFFSET
	int                                                m_NormalDashFxId;                                         // 0x023C(0x0004)
	int                                                m_BonusDashFxId;                                          // 0x0240(0x0004)
	int                                                m_NoDashFxId;                                             // 0x0244(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Thoth_Dash");
		return ptr;
	}


	void SetDashTargetMode(TEnumAsByte<EThothDashTargetingMode> Mode);
};


// Class TgGame.TgInventoryObject_Listen_Thoth_SpeedGlyph
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_Thoth_SpeedGlyph : public UTgInventoryObject_Listen_Effect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Thoth_SpeedGlyph");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_ThothPsv
// 0x0000 (0x0120 - 0x0120)
class UTgInventoryObject_Listen_ThothPsv : public UTgInventoryObject_Listen_Stack
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_ThothPsv");
		return ptr;
	}

};


// Class TgGame.TgPawn_Thoth
// 0x0274 (0x282C - 0x25B8)
class ATgPawn_Thoth : public ATgPawn_Character
{
public:
	TEnumAsByte<EThothInhandState>                     r_InhandState;                                            // 0x25B8(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x25B9(0x0003) MISSED OFFSET
	TArray<class UTgAnimNodeBlendList_Thoth_Inhand*>   m_InhandBlendListNodes;                                   // 0x25BC(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlentList_Thoth_Dash*>     m_DashBlendListNodes;                                     // 0x25CC(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<EThothInhandState>>             s_QueuedInhands;                                          // 0x25DC(0x0010) (NeedCtorLink)
	int                                                m_PsvStackLimitByLevel[0x14];                             // 0x25EC(0x0004)
	int                                                r_nCurrentPsvStacks;                                      // 0x263C(0x0004) (Net)
	int                                                r_nMaxPsvStacks;                                          // 0x2640(0x0004) (Net)
	int                                                r_nNumPsvEnemyKills;                                      // 0x2644(0x0004) (Net)
	int                                                r_nPsvEnemyKillThreshold;                                 // 0x2648(0x0004) (Net)
	class ATgDevice*                                   s_Dev1Shooter;                                            // 0x264C(0x0008)
	int                                                r_nDev1AmmoCount;                                         // 0x2654(0x0004) (Net)
	int                                                c_nDev1LocalAmmoCount;                                    // 0x2658(0x0004)
	struct FName                                       c_Dev1AmmoFxGroups[0x3];                                  // 0x265C(0x0008)
	int                                                c_Dev1AmmoFxCount;                                        // 0x2674(0x0004)
	TArray<struct FDev1GodHitBy>                       s_Dev1GodHitTracker;                                      // 0x2678(0x0010) (NeedCtorLink)
	class ATgDevice*                                   s_Dev2Shooter;                                            // 0x2688(0x0008)
	unsigned long                                      r_Dev2InhandShotFired : 1;                                // 0x2690(0x0004) (Net)
	unsigned long                                      r_Dev2ApplyRangeExtension : 1;                            // 0x2690(0x0004) (Net)
	unsigned long                                      r_bDev2CanFireShooter : 1;                                // 0x2690(0x0004) (Net)
	TArray<struct FSpeedGlyphProjTrackingData>         s_SpeedGlyphProjTracking;                                 // 0x2694(0x0010) (NeedCtorLink)
	struct FSpeedGlyphProjTrackingData                 s_LastSpeedGlyphAdjustedHit;                              // 0x26A4(0x000C)
	class ATgDevice_Deployable*                        r_Dev3Device;                                             // 0x26B0(0x0008) (Net)
	float                                              r_Dev3ProjSpeedMod;                                       // 0x26B8(0x0004) (Net)
	float                                              r_Dev3RangeBonus;                                         // 0x26BC(0x0004) (Net)
	struct FSpeedGlyphProjEventData                    r_Dev3ProjEvents[0x12];                                   // 0x26C0(0x000C) (Net)
	int                                                m_Dev3ProjUpdateStatus[0x12];                             // 0x2798(0x0004)
	int                                                m_Dev3EventIndex;                                         // 0x27E0(0x0004)
	class AController*                                 s_Dev3KillerOverride;                                     // 0x27E4(0x0008)
	TArray<int>                                        m_ModifiedProjectileIds;                                  // 0x27EC(0x0010) (NeedCtorLink)
	int                                                r_Dev4PagesCharged;                                       // 0x27FC(0x0004) (Net)
	int                                                m_Dev4MaxPages;                                           // 0x2800(0x0004)
	TArray<float>                                      m_Dev4PagePercents;                                       // 0x2804(0x0010) (NeedCtorLink)
	TArray<class UTgAnimNodeBlentList_IntroLoopOutro*> m_Dev4SequenceNodes;                                      // 0x2814(0x0010) (NeedCtorLink)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x2824(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Thoth");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void UpdateAnimNodeInhandState();
	void STATIC_ChargeDev4Page();
	class AController* OverrideKillInstigator();
	void STATIC_PlayDashFX();
	void UpdateDev3ProjectileEvents();
	bool TryTrackProjectile(class ATgProjectile* Proj, int* ShooterDevId);
	bool IsTrackableProjectile(class ATgDevice* shooterDevice);
	bool STATIC_DoesProjectilePathCrossSpeedGlyph(class ATgProjectile* Proj, class ATgPawn* shooter);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void Dev2InhandTimerExpired();
	void STATIC_DeactivateDev1AmmoFX();
	void ActivateDev1AmmoFX();
	void DeactivateDev1Inhand();
	void ActivateDev1Inhand();
	void AdjustAmmo(int Delta);
	void ReplicatedEvent(const struct FName& VarName);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_PopEquippedDevice(class ATgDevice* newDev, int nEqpSlot);
	void STATIC_PushEquippedDevice(class ATgDevice* newDev, int nEqpSlot);
	bool ApplyProjectileSpeedModifier(int ProjectileInstanceId, float SpeedModifier, float RangeBonus, int ShooterDevId);
	void STATIC_DeviceOnProjShutdown(class ATgDevice* Dev, class ATgProjectile* Proj);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
};


// Class TgGame.TgAchievement_Nike_PathToVictory
// 0x0014 (0x0098 - 0x0084)
class UTgAchievement_Nike_PathToVictory : public UTgAchievement
{
public:
	unsigned long                                      m_bFilledPassive : 1;                                     // 0x0084(0x0004)
	class ATgPawn_Nike*                                NikeOwner;                                                // 0x0088(0x0008)
	int                                                m_EffectGroupId;                                          // 0x0090(0x0004)
	int                                                m_nMinutes;                                               // 0x0094(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Nike_PathToVictory");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByNikeDivineValor
// 0x000C (0x0174 - 0x0168)
class UTgAnimBlendByNikeDivineValor : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Nike*                                m_TgPawn;                                                 // 0x0168(0x0008)
	unsigned long                                      m_bWasBuffed : 1;                                         // 0x0170(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByNikeDivineValor");
		return ptr;
	}

};


// Class TgGame.TgAnimNotify_Sound_NikeUltSounds
// 0x0020 (0x00C8 - 0x00A8)
class UTgAnimNotify_Sound_NikeUltSounds : public UTgAnimNotify_Sound
{
public:
	TArray<struct FPSE_Skin_Nike>                      m_NikeSkinOverrideList;                                   // 0x00A8(0x0010) (Edit, NeedCtorLink)
	TArray<class USoundCue*>                           m_NikeSoundCues;                                          // 0x00B8(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNotify_Sound_NikeUltSounds");
		return ptr;
	}


	class USoundCue* STATIC_GetSoundCueToPlay(class USkeletalMeshComponent* skel);
};


// Class TgGame.TgCollisionProxy_NikeShield
// 0x0028 (0x02E4 - 0x02BC)
class ATgCollisionProxy_NikeShield : public ATgCollisionProxy_Box
{
public:
	class ATgDevice_Nike_Dev2_V2*                      m_NikeDevice;                                             // 0x02BC(0x0008)
	TArray<class UClass*>                              m_HittableActors;                                         // 0x02C4(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_ProcessList;                                            // 0x02D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_NikeShield");
		return ptr;
	}


	void Tick(float DeltaTime);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_HandleHit(class AActor* HitActor);
	bool STATIC_RelevantActor(class AActor* HitActor);
	void STATIC_DisplayAbsorbedMsg(class ATgProj_Simulated* Projectile);
	void STATIC_ShieldTouchUpdate();
};


// Class TgGame.TgDevice_Nike_Dev4
// 0x0004 (0x0500 - 0x04FC)
class ATgDevice_Nike_Dev4 : public ATgDevice_Deployable
{
public:
	unsigned long                                      c_bWasDev2Active : 1;                                     // 0x04FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nike_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDevice_Nike_Dev1
// 0x0020 (0x051C - 0x04FC)
class ATgDevice_Nike_Dev1 : public ATgDevice_HitPulse
{
public:
	TArray<class ATgPawn*>                             m_SingleHitGods;                                          // 0x04FC(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_DoubleHitGods;                                          // 0x050C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nike_Dev1");
		return ptr;
	}


	void UpdateTargetingModeStatus(struct FAimData* Aim);
	float GetPersistTime(int nMode);
	bool CanBeCanceled();
	bool CanBeInterrupted();
};


// Class TgGame.TgDevice_Nike_Dev2
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Nike_Dev2 : public ATgDevice
{
public:
	unsigned long                                      r_bIsActiveState : 1;                                     // 0x04F0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nike_Dev2");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	void HandleActiveState();
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool ShouldCooldownAfterFire();
	void ReplicatedEvent(const struct FName& VarName);
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Nike_Dev2_V2
// 0x0044 (0x0534 - 0x04F0)
class ATgDevice_Nike_Dev2_V2 : public ATgDevice
{
public:
	class ATgPawn_Nike*                                r_NikePawn;                                               // 0x04F0(0x0008) (Const, Net)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x04F8(0x0008)
	TArray<struct FShieldTouchInfo>                    s_TouchedList;                                            // 0x0500(0x0010) (NeedCtorLink)
	float                                              m_fTouchAgainTime;                                        // 0x0510(0x0004) (Const)
	float                                              m_fRotationSpeed;                                         // 0x0514(0x0004) (Const)
	float                                              m_fKnockbackDist;                                         // 0x0518(0x0004) (Const)
	float                                              m_fShieldOffset;                                          // 0x051C(0x0004) (Const)
	float                                              m_fShieldDepth;                                           // 0x0520(0x0004) (Const)
	float                                              m_fShieldWidth;                                           // 0x0524(0x0004) (Const)
	float                                              m_fShieldIntroDelay;                                      // 0x0528(0x0004) (Const)
	unsigned long                                      m_bInShieldIntroDelay : 1;                                // 0x052C(0x0004)
	unsigned long                                      m_bShieldActive : 1;                                      // 0x052C(0x0004)
	unsigned long                                      r_bTriggerActive : 1;                                     // 0x052C(0x0004) (Net)
	int                                                r_nTriggerFireIncrement;                                  // 0x0530(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nike_Dev2_V2");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	void UseDevice();
	bool StartFire();
	void Destroyed();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_CanPerformKnockback(class AActor* Other);
	bool UsesControllerRotation();
	bool CanBeCanceled();
	void STATIC_PerformKnockback(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	bool STATIC_ForceDefaultCastMode();
	void STATIC_ShieldIntroDelay();
	void STATIC_CreateShieldProxy();
	void UpdateShieldTouches(float DeltaTime);
	void TriggerFireDevice();
};


// Class TgGame.TgDevice_Nike_Dev3
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Nike_Dev3 : public ATgDevice_TweenBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nike_Dev3");
		return ptr;
	}


	bool CanBeCanceled();
	float GetRefireTime(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgEffectForm_Nike_Armor
// 0x0010 (0x0120 - 0x0110)
class UTgEffectForm_Nike_Armor : public UTgEffectForm
{
public:
	TArray<int>                                        m_MaterialsToSwap;                                        // 0x0110(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Nike_Armor");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_NikePassive
// 0x0024 (0x0108 - 0x00E4)
class UTgInventoryObject_Listen_NikePassive : public UTgInventoryObject_Listen_Effect
{
public:
	int                                                s_nGoalsMet;                                              // 0x00E4(0x0004)
	unsigned long                                      s_bGoalGodsReached : 1;                                   // 0x00E8(0x0004)
	unsigned long                                      s_bGoalCreaturesReached : 1;                              // 0x00E8(0x0004)
	unsigned long                                      s_bGoalMaxLevelReached : 1;                               // 0x00E8(0x0004)
	unsigned long                                      s_bInitalized : 1;                                        // 0x00E8(0x0004)
	unsigned long                                      s_bOwnerWasKilled : 1;                                    // 0x00E8(0x0004)
	int                                                s_nGoalGodsKilled;                                        // 0x00EC(0x0004)
	int                                                s_nGoalCreaturesKilled;                                   // 0x00F0(0x0004)
	int                                                s_nGoalMaxLevelAllies;                                    // 0x00F4(0x0004)
	int                                                s_nOwnerTaskforce;                                        // 0x00F8(0x0004)
	int                                                s_nTotalGodsKilled;                                       // 0x00FC(0x0004)
	int                                                s_nTotalCreaturesKilled;                                  // 0x0100(0x0004)
	int                                                s_nTotalMaxLevelAllies;                                   // 0x0104(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_NikePassive");
		return ptr;
	}


	void STATIC_DebugPassive(bool bSetActive, int nIndex);
};


// Class TgGame.TgInventoryObject_Listen_Nike_Dev2_V2
// 0x0008 (0x00EC - 0x00E4)
class UTgInventoryObject_Listen_Nike_Dev2_V2 : public UTgInventoryObject_Listen_EffectGroupTrigger
{
public:
	class ATgDevice_Nike_Dev2_V2*                      s_Nike_A02;                                               // 0x00E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Nike_Dev2_V2");
		return ptr;
	}


	void TriggerRemoved(bool bRemovedEarly);
	void TriggerApplied();
};


// Class TgGame.TgInventoryObject_Listen_Nike_Dev2
// 0x001C (0x00EC - 0x00D0)
class UTgInventoryObject_Listen_Nike_Dev2 : public UTgInventoryObject_Listen_OffHand_Cast
{
public:
	class ATgDevice*                                   m_TrackedDevice;                                          // 0x00D0(0x0008)
	int                                                m_nTrackedFireInstance;                                   // 0x00D8(0x0004)
	TArray<int>                                        m_NikeDeviceIds;                                          // 0x00DC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Nike_Dev2");
		return ptr;
	}

};


// Class TgGame.TgPawn_Nike
// 0x008C (0x2644 - 0x25B8)
class ATgPawn_Nike : public ATgPawn_Character
{
public:
	class ATgDevice_ChainedMelee*                      m_Auto_Device;                                            // 0x25B8(0x0008)
	class ATgDevice*                                   m_devicePsv;                                              // 0x25C0(0x0008)
	class ATgDevice_Nike_Dev1*                         m_deviceA01;                                              // 0x25C8(0x0008)
	class ATgDevice_Nike_Dev2_V2*                      m_deviceA02;                                              // 0x25D0(0x0008)
	class ATgDevice_Nike_Dev3*                         m_deviceA03;                                              // 0x25D8(0x0008)
	class ATgDevice*                                   m_deviceA04;                                              // 0x25E0(0x0008)
	unsigned long                                      m_bDevices_Cached : 1;                                    // 0x25E8(0x0004) (Const)
	unsigned long                                      r_bMaxLevelAlliesReached : 1;                             // 0x25E8(0x0004) (Net)
	unsigned long                                      r_bIsDev2Active : 1;                                      // 0x25E8(0x0004) (Net)
	unsigned long                                      r_bIsArmorActive : 1;                                     // 0x25E8(0x0004) (Net)
	unsigned long                                      r_bIsArmorBroken : 1;                                     // 0x25E8(0x0004) (Net)
	unsigned long                                      r_bDisplayUltWings : 1;                                   // 0x25E8(0x0004) (Net)
	unsigned long                                      r_bManageUltWings : 1;                                    // 0x25E8(0x0004) (Net)
	int                                                r_nTotalCreaturesKilled;                                  // 0x25EC(0x0004) (Net)
	int                                                r_nTotalGodsKilled;                                       // 0x25F0(0x0004) (Net)
	TEnumAsByte<ENikeDev2AnimState>                    r_eDev2CurrentAnimState;                                  // 0x25F4(0x0001) (Net)
	TEnumAsByte<ENikeUltVisualsState>                  r_eUltVisualsState;                                       // 0x25F5(0x0001) (Net)
	TEnumAsByte<ENikeUltVisualsState>                  c_eLocalUltVisualsState;                                  // 0x25F6(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x25F7(0x0001) MISSED OFFSET
	TArray<class USkelControlBase*>                    c_UltVisualsStateSkelControls_Helmet;                     // 0x25F8(0x0010) (NeedCtorLink)
	TArray<class USkelControlBase*>                    c_UltVisualsStateSkelControls_Hair;                       // 0x2608(0x0010) (NeedCtorLink)
	struct FName                                       c_UltVisualsSkelControlName_Helmet;                       // 0x2618(0x0008)
	struct FName                                       c_UltVisualsSkelControlName_Hair;                         // 0x2620(0x0008)
	struct FName                                       c_UltVisualsSkelControlName_UltMic;                       // 0x2628(0x0008)
	class UTgSkeletalMeshComponent*                    c_UltWingsMesh;                                           // 0x2630(0x0008) (ExportObject, Component, EditInline)
	float                                              r_fUltWingBlend;                                          // 0x2638(0x0004) (Net)
	float                                              m_fUltWingBlendInSpeed;                                   // 0x263C(0x0004)
	float                                              m_fUltWingBlendOutSpeed;                                  // 0x2640(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Nike");
		return ptr;
	}


	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
	void UpdateHairState(bool SkelControlActive);
	void UpdateHelmetState(bool SkelControlActive);
	void UpdateUltVisualsState(TEnumAsByte<ENikeUltVisualsState> NewState);
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void ManageDev4ArmorBreakFx();
	void PlayDev4TransformationFx();
	void ToggleDev4Fx(bool Active);
	void ToggleDev2Fx();
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_OnRightMousePressed();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnRespawn();
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateClientDevices(bool bForce);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void STATIC_ForceUltWingsOff();
	bool STATIC_ShouldDisplayUltWings();
	void ToggleUltWings(bool ActiveWings);
	void STATIC_InitializeUltWings();
};


// Class TgGame.TgAchievement_G84_PetKill
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_G84_PetKill : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_G84_PetKill");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByG84MirrorImageState
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByG84MirrorImageState : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByG84MirrorImageState");
		return ptr;
	}


	void STATIC_SetImageState(TEnumAsByte<EMirrorImageStates> State);
};


// Class TgGame.TgDevice_G84_Inhand
// 0x0000 (0x0538 - 0x0538)
class ATgDevice_G84_Inhand : public ATgDevice_ChainedMelee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G84_Inhand");
		return ptr;
	}


	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDevice_G84_Dev4
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_G84_Dev4 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G84_Dev4");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_G84_Dev1Stage
// 0x0004 (0x052C - 0x0528)
class ATgDevice_G84_Dev1Stage : public ATgDevice_Staging
{
public:
	unsigned long                                      m_bFiredShooter : 1;                                      // 0x0528(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G84_Dev1Stage");
		return ptr;
	}


	bool ShouldInterruptInhand();
	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
	bool ShouldTriggerCastReactionItems();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	void OnStageShooterStopFire(bool bInterrupted);
	void OnStageShooterFire();
	void OnStageShooterStartFire();
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	void SwapOutShooter();
	void STATIC_SwapInShooter();
	void STATIC_SetShotAvailability(bool IsAvailable);
	bool CanBeCanceled();
	bool CanJumpWhileFiring();
	bool ShouldCancelStealth();
	unsigned char STATIC_IncrementFiringInstance();
	void STATIC_ConditionallyIncrementFiringInstance();
};


// Class TgGame.TgDeviceFire_G84_Dev3
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_G84_Dev3 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_G84_Dev3");
		return ptr;
	}


	class ATgPawn* STATIC_SpawnPet(bool bPet);
};


// Class TgGame.TgDeviceFire_G84_Dev4
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_G84_Dev4 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_G84_Dev4");
		return ptr;
	}


	void STATIC_CustomFire();
	class ATgPawn* STATIC_SpawnPet(bool bPet);
};


// Class TgGame.TgInventoryObject_Listen_G84Dev2Sub
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_G84Dev2Sub : public UTgInventoryObject_Listen_Effect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_G84Dev2Sub");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_G84_Dev2
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_G84_Dev2 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_G84_Dev2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_G84_Psv
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_G84_Psv : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_G84_Psv");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_G84Dev3
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_G84Dev3 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_G84Dev3");
		return ptr;
	}

};


// Class TgGame.TgPawn_G84
// 0x0050 (0x2608 - 0x25B8)
class ATgPawn_G84 : public ATgPawn_Character
{
public:
	unsigned long                                      r_bCloned : 1;                                            // 0x25B8(0x0004) (Net)
	unsigned long                                      c_IsMirrorImageActive : 1;                                // 0x25B8(0x0004)
	unsigned long                                      r_bDev1ShotAvailable : 1;                                 // 0x25B8(0x0004) (Net)
	unsigned long                                      m_bInPetUltLockout : 1;                                   // 0x25B8(0x0004)
	unsigned long                                      s_bCanHardCleansePet : 1;                                 // 0x25B8(0x0004)
	struct FMirrorImageData                            c_MirrorImages[0x2];                                      // 0x25BC(0x0010) (Component)
	TArray<int>                                        m_nEQPLockoutDespawn;                                     // 0x25DC(0x0010) (NeedCtorLink)
	struct FVector                                     s_vLastValidPetLoc;                                       // 0x25EC(0x000C)
	int                                                s_nOldPetId;                                              // 0x25F8(0x0004)
	class ATgPawn*                                     s_G84Decoy;                                               // 0x25FC(0x0008)
	float                                              s_fPreUltCachedMaxHealth;                                 // 0x2604(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_G84");
		return ptr;
	}


	bool ShouldHardCleanse(bool bPet);
	bool ForceHideOnMinimap();
	class AController* OverrideKillInstigator();
	void ForceControllerResetOnTransfer();
	bool IsGrabSourceValid(class ATgPawn* Target, bool bAllowTurrets, bool bAllowStealthed);
	void STATIC_EndGrab(TEnumAsByte<EGrabState> endingGrabState, bool bInterrupted);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	bool PetReadyForDespawn();
	void PawnOnBeginEndMission();
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void MirrorImageTimerExpired();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_SetMirrorImageAnim(TEnumAsByte<EMirrorImageStates> Anim, struct FMirrorImageData* Data);
	bool WillOverrideTakeDamage(class APawn* Victim, int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void TgPawnControllerSet();
	void Tick(float DeltaSeconds);
	bool PostPawnSetup();
	void IntervalPetInventoryRequest(bool bForce);
	void IntervalInventoryRequest(bool bForce);
	void ForceUIRefresh();
	void OnPlayerControllerDisconnect();
	void STATIC_CharacterPawnControllerSet();
	void STATIC_PlayNearDeathCleanup();
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void STATIC_ReleasePostCloneFireLock();
	void OnCloneDied();
	void OnCloned();
	void STATIC_SetMirrorImageState(bool IsOn);
	void ReplicatedEvent(const struct FName& VarName);
	void TransmitTiDiServer();
	int STATIC_GetDowngradeItemIdOverride(int nItemId);
	bool STATIC_FindPetLoc(struct FVector* Extent, struct FVector* FoundLocation);
	void STATIC_PawnOnAssisted(class AActor* Victim, int* xpGain, int* goldGain);
	void STATIC_PawnOnKilled(class AActor* Victim, int* xpGain, int* goldGain);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void UpdateClientDevices(bool bForce);
	void KillPet();
	bool IsNonCombat();
	void UpdateMirrorImages();
	void STATIC_InitializeMirrorImages();
	void STATIC_ResetGodTargeterState();
	void STATIC_PetExpired(bool bForce);
	void STATIC_SwapControlToPet(float fLifeTime);
};


// Class TgGame.TgPawn_G84_Decoy
// 0x0008 (0x25C0 - 0x25B8)
class ATgPawn_G84_Decoy : public ATgPawn_Character
{
public:
	float                                              c_fInheritedMana;                                         // 0x25B8(0x0004)
	float                                              c_fInheritedMaxMana;                                      // 0x25BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_G84_Decoy");
		return ptr;
	}


	struct FName GetDeathAnimName();
	void Tick(float DeltaTime);
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
};


// Class TgGame.TgProj_G84_BasicAttackBigProj
// 0x0000 (0x0398 - 0x0398)
class ATgProj_G84_BasicAttackBigProj : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_G84_BasicAttackBigProj");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAchievement_Kuzenbo_ShellReflect
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Kuzenbo_ShellReflect : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	float                                              m_fDamageGoal;                                            // 0x0088(0x0004)
	int                                                m_nCurFiringInst;                                         // 0x008C(0x0004)
	float                                              m_fDamageTotal;                                           // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Kuzenbo_ShellReflect");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Kuzenbo_TripleTreble
// 0x001C (0x00A0 - 0x0084)
class UTgAchievement_Kuzenbo_TripleTreble : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nKnockUpGoal;                                           // 0x0088(0x0004)
	unsigned long                                      m_bIsInWateryGrave : 1;                                   // 0x008C(0x0004)
	TArray<struct FKnockUpHitInfo>                     m_KnockUpTracker;                                         // 0x0090(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Kuzenbo_TripleTreble");
		return ptr;
	}

};


// Class TgGame.TgDevice_Kuzenbo_TurtleThrash
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_Kuzenbo_TurtleThrash : public ATgDevice_Aura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kuzenbo_TurtleThrash");
		return ptr;
	}


	bool CanJumpWhileFiring();
	bool CanBeInterrupted();
	void BeginAura();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool IsAuraActive();
	bool CanBeCanceled();
	void STATIC_ConfigureFireMode(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact);
};


// Class TgGame.TgDevice_Kuzenbo_WateryGrave_V2
// 0x0010 (0x0534 - 0x0524)
class ATgDevice_Kuzenbo_WateryGrave_V2 : public ATgDevice_Aura
{
public:
	TArray<class AActor*>                              s_InitialHitAppliedList;                                  // 0x0524(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kuzenbo_WateryGrave_V2");
		return ptr;
	}


	bool CanJumpWhileFiring();
	bool CanBeInterrupted();
	void EndAura();
	void BeginAura();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool IsAuraActive();
	bool CanBeCanceled();
	void STATIC_ConfigureFireMode(class UTgDeviceFire* FireMode, const struct FImpactInfo& Impact);
};


// Class TgGame.TgDevice_Kuzenbo_SumoPush
// 0x0028 (0x0564 - 0x053C)
class ATgDevice_Kuzenbo_SumoPush : public ATgDevice_Charge
{
public:
	float                                              m_fTurnSpeed;                                             // 0x053C(0x0004) (Const)
	TEnumAsByte<EGrabState>                            m_TargetGrabState;                                        // 0x0540(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0541(0x0003) MISSED OFFSET
	class ATgPawn*                                     m_GrabbedPawn;                                            // 0x0544(0x0008)
	TArray<class AActor*>                              m_HitAppliedList;                                         // 0x054C(0x0010) (Transient, NeedCtorLink)
	int                                                m_nGrabbedPawnHitCount;                                   // 0x055C(0x0004)
	unsigned long                                      m_bGrabbedPawnHasHitWall : 1;                             // 0x0560(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kuzenbo_SumoPush");
		return ptr;
	}


	void STATIC_ResetGrabbedPawnValues();
	void STATIC_OnGrabDetach(class ATgPawn* Target);
	void STATIC_ClientForceStopFire(TEnumAsByte<EChargeEndState> EndState);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Kuzenbo_ShellSpikes
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Kuzenbo_ShellSpikes : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kuzenbo_ShellSpikes");
		return ptr;
	}


	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool STATIC_CanFireWhileFalling();
};


// Class TgGame.TgDevice_Kuzenbo_TurtleThrash_V2
// 0x0000 (0x0548 - 0x0548)
class ATgDevice_Kuzenbo_TurtleThrash_V2 : public ATgDevice_RadialSweep_MultiHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kuzenbo_TurtleThrash_V2");
		return ptr;
	}

};


// Class TgGame.TgDevice_Kuzenbo_NeNeKappa
// 0x0004 (0x04FC - 0x04F8)
class ATgDevice_Kuzenbo_NeNeKappa : public ATgDevice_Spline
{
public:
	int                                                m_nMaxTargetingBounces;                                   // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kuzenbo_NeNeKappa");
		return ptr;
	}


	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	bool CanBeCanceled();
	void STATIC_StartShockwaveAt(class UTgDeviceFire* DeviceFire, const struct FVector& SpawnLoc);
	bool STATIC_CalculateFlightPath(int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Kuzenbo_NeNeKappa
// 0x0008 (0x01DC - 0x01D4)
class UTgDeviceFire_Kuzenbo_NeNeKappa : public UTgDeviceFire_Spline
{
public:
	struct FPointer                                    m_pBotSetup;                                              // 0x01D4(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Kuzenbo_NeNeKappa");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Kuzenbo_ShellSpikes
// 0x0000 (0x0240 - 0x0240)
class UTgDeviceForm_Kuzenbo_ShellSpikes : public UTgDeviceForm_ShieldOfTheUnderWorld
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Kuzenbo_ShellSpikes");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Kuzenbo_ShellSpikes
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Kuzenbo_ShellSpikes : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bShellSpikesActive : 1;                                 // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Kuzenbo_ShellSpikes");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Kuzenbo_WaterBowl
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Kuzenbo_WaterBowl : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Kuzenbo_WaterBowl");
		return ptr;
	}

};


// Class TgGame.TgPawn_Kuzenbo
// 0x004C (0x2604 - 0x25B8)
class ATgPawn_Kuzenbo : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_DevicePsv_WaterBowl;                                    // 0x25B8(0x0008)
	class ATgDevice_Kuzenbo_NeNeKappa*                 m_DeviceA01_NeNeKappa;                                    // 0x25C0(0x0008)
	class ATgDevice_Kuzenbo_ShellSpikes*               m_DeviceA02_ShellSpikes;                                  // 0x25C8(0x0008)
	class ATgDevice_Kuzenbo_SumoPush*                  m_DeviceA03_SumoPush;                                     // 0x25D0(0x0008)
	class ATgDevice_Kuzenbo_WateryGrave_V2*            m_DeviceA04_WateryGrave;                                  // 0x25D8(0x0008)
	unsigned long                                      m_bDevicesCached : 1;                                     // 0x25E0(0x0004) (Const)
	unsigned long                                      r_bShowShellSpikes : 1;                                   // 0x25E0(0x0004) (Net)
	class USkelControlBase*                            c_WaterBowlSkelController;                                // 0x25E4(0x0008)
	float                                              m_fTimeOfLastWaterSpilled;                                // 0x25EC(0x0004)
	float                                              r_fMaxProtections;                                        // 0x25F0(0x0004) (Net)
	float                                              r_fCurProtections;                                        // 0x25F4(0x0004) (Net)
	float                                              c_fPrevProtections;                                       // 0x25F8(0x0004)
	class UTgSkeletalMeshComponent*                    c_ShellSpikes;                                            // 0x25FC(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Kuzenbo");
		return ptr;
	}


	float STATIC_GetChargeTurnRate();
	void STATIC_ClientEndPushBack();
	void STATIC_EndPushBack(bool bInterrupted, bool bSkipClient);
	void STATIC_ClientBeginPushBack(float fDuration, int nYaw);
	void STATIC_OnGrabTargetDetach(TEnumAsByte<EGrabState> endingGrabState, class ATgPawn* Target, bool bInterrupted);
	bool BeginPushBack(float fDuration, const struct FRotator& ForwardRotation);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* SkelComp);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void BeginGrab(TEnumAsByte<EGrabState> newGrabState);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void ToggleShellSpikes(bool IsOn);
	void STATIC_InitializeShellSpikes();
	void STATIC_ReduceCooldown_NeNeKappa(float fTimeReduced);
	void UpdateFX_WaterBowl(float fProtections);
	void UpdateSkelController_WaterBowl();
	void STATIC_ReduceDmgReduction_WaterBowl();
	void STATIC_PawnOnEnterVortex(class ATgPawn* InstigatorPawn);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	void UpdateClientDevices(bool bForce);
};


// Class TgGame.TgProj_Kuzenbo_NeNeKappa
// 0x0038 (0x03E4 - 0x03AC)
class ATgProj_Kuzenbo_NeNeKappa : public ATgProj_SimulatedPassThroughUntilGod_CollidesWorld
{
public:
	int                                                m_nMaxHitsPerTarget;                                      // 0x03AC(0x0004) (Const)
	struct FVector                                     m_LastBounceLocation;                                     // 0x03B0(0x000C)
	int                                                m_nBounceCount;                                           // 0x03BC(0x0004)
	int                                                m_nMaxBounceCount;                                        // 0x03C0(0x0004)
	unsigned long                                      m_bApplyBounceVelocity : 1;                               // 0x03C4(0x0004)
	struct FVector                                     m_vBounceVelocity;                                        // 0x03C8(0x000C)
	TArray<class AActor*>                              m_TotalHitTargets;                                        // 0x03D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Kuzenbo_NeNeKappa");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
};


// Class TgGame.TgAchievement_Cernunnos_PiggingOut
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_Cernunnos_PiggingOut : public UTgAchievement
{
public:
	class ATgPawn*                                     m_KilledPolymorph;                                        // 0x0084(0x0008)
	float                                              m_fTimeOfDeath;                                           // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Cernunnos_PiggingOut");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Cernunnos_SeasonsShift
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_Cernunnos_SeasonsShift : public UTgAchievement
{
public:
	class ATgPawn*                                     m_KilledInAutumn;                                         // 0x0084(0x0008)
	float                                              m_fTimeOfDeath;                                           // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Cernunnos_SeasonsShift");
		return ptr;
	}

};


// Class TgGame.TgDeployable_G86_Dev1
// 0x0008 (0x0400 - 0x03F8)
class ATgDeployable_G86_Dev1 : public ATgDeploy_EffectVolume
{
public:
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                         // 0x03F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_G86_Dev1");
		return ptr;
	}


	void STATIC_PulseTimer();
	void STATIC_DeployComplete();
	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void InitializeCollisionProxy();
};


// Class TgGame.TgDevice_G86_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_G86_Dev1 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G86_Dev1");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_G86_Seasons
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_G86_Seasons : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G86_Seasons");
		return ptr;
	}


	bool ApplyGlobalOffhandCooldown();
	bool STATIC_CanFireIfLeftMouseDown();
	bool ShouldInterruptInhand();
	bool ShouldTriggerCastReactionItems();
	bool CanBeInterrupted();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgEffectForm_G86_Dev4
// 0x000C (0x011C - 0x0110)
class UTgEffectForm_G86_Dev4 : public UTgEffectForm
{
public:
	int                                                m_MeshId;                                                 // 0x0110(0x0004)
	class UMeshComponent*                              m_Mesh;                                                   // 0x0114(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_G86_Dev4");
		return ptr;
	}


	void STATIC_DetachMeshes();
	void AttachMeshes(class AActor* pOwner);
	void AdjustHidden();
	void Detach();
	void STATIC_Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgEffectForm_G86_Seasons
// 0x0000 (0x0114 - 0x0114)
class UTgEffectForm_G86_Seasons : public UTgEffectForm_Phoenix_Weakened
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_G86_Seasons");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_G86_Psv
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_G86_Psv : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_G86_Psv");
		return ptr;
	}

};


// Class TgGame.TgPawn_G86
// 0x0048 (0x2600 - 0x25B8)
class ATgPawn_G86 : public ATgPawn_Character
{
public:
	int                                                r_SeasonState;                                            // 0x25B8(0x0004) (Net)
	struct FSeasonInhandRecordData                     s_SeasonInhandRecord[0x8];                                // 0x25BC(0x0008)
	int                                                s_SeasonInhandIndex;                                      // 0x25FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_G86");
		return ptr;
	}


	void STATIC_RemoveDeathEffects();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void TriggerPassiveMeleeAttack();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ReapplySeasonEqpEffects();
	int STATIC_GetCustomParticleSystemFilter();
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceCriticalStrike(class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnFire(class ATgDevice* Dev);
	bool STATIC_GetPassiveString(struct FString* sResult);
	bool STATIC_GetPassiveInt1(int* nResult);
};


// Class TgGame.TgProj_G86_Dev1
// 0x0000 (0x0398 - 0x0398)
class ATgProj_G86_Dev1 : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_G86_Dev1");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool UseAOE();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_RangeReached();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	struct FVector STATIC_GetDeployablePlacement(const struct FVector& HitLoc);
};


// Class TgGame.TgAchievement_Ganesha_Pacifist
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Ganesha_Pacifist : public UTgAchievement
{
public:
	int                                                m_nPassedKills;                                           // 0x0084(0x0004)
	int                                                m_nTargetKills;                                           // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Ganesha_Pacifist");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Ganesha_Dev4_Tower
// 0x0000 (0x040C - 0x040C)
class ATgDeployable_Ganesha_Dev4_Tower : public ATgDeploy_Wall
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ganesha_Dev4_Tower");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Ganesha_Dev4
// 0x0050 (0x0424 - 0x03D4)
class ATgDeployable_Ganesha_Dev4 : public ATgDeployable
{
public:
	int                                                GANESHA_TOWER_DEPLOYABLE_ID;                              // 0x03D4(0x0004) (Const)
	TArray<class ATgDeployable_Ganesha_Dev4_Tower*>    m_Pillars;                                                // 0x03D8(0x0010) (NeedCtorLink)
	TArray<struct FDamageInfo>                         s_DamageInfoList;                                         // 0x03E8(0x0010) (NeedCtorLink)
	TArray<class ATgCollisionProxy_Box*>               s_CollisionProxies;                                       // 0x03F8(0x0010) (NeedCtorLink)
	float                                              m_damageLockoutTime;                                      // 0x0408(0x0004)
	struct FVector                                     m_forwardVector;                                          // 0x040C(0x000C)
	struct FVector                                     m_rightVector;                                            // 0x0418(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ganesha_Dev4");
		return ptr;
	}


	void STATIC_HandleDebuffUntouch(class AActor* Other);
	void STATIC_HandleDebuffOnTouch(class AActor* Other);
	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void LeftBarrierProxyUnTouch(class AActor* Other);
	void RightBarrierProxyUnTouch(class AActor* Other);
	void RearBarrierProxyUnTouch(class AActor* Other);
	void ForwardBarrierProxyUnTouch(class AActor* Other);
	bool STATIC_HasDamageInfoFor(class ATgPawn* OtherPawn);
	void BarrierProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void BuildProxies();
	void BuildCustomDeployable();
	void STATIC_DeployComplete();
	float STATIC_GetDamageLockoutTime();
	bool STATIC_CheckBarrierForTouching(class AActor* TargetActor, int proxyToSkip);
	void STATIC_SetTouchingState(class AActor* TargetActor, bool wantedState);
	bool STATIC_GetTouchingState(class AActor* TargetActor);
	void ManageTouchingState(class AActor* TargetActor, int proxyToSkip);
	bool STATIC_CanDamageTarget(class AActor* TargetActor);
	void BuildTowers(float lengthFromCenter, const struct FVector& centerPoint, const struct FRotator& baseRotation);
};


// Class TgGame.TgDevice_Ganesha_Dev2_V2
// 0x0010 (0x0534 - 0x0524)
class ATgDevice_Ganesha_Dev2_V2 : public ATgDevice_Aura
{
public:
	TArray<struct FAppliedEnemyInfo>                   s_AppliedEnemyList;                                       // 0x0524(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ganesha_Dev2_V2");
		return ptr;
	}


	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ProxyUnTouch(class AActor* Other);
	void CleanUpAllEnemyPawns();
	void CleanUpDevice();
	void InterruptFiring();
	bool CanBeInterrupted();
	bool CanJumpWhileFiring();
	bool CanBeCanceledByRightMouse();
	void UpdatePawnInEnemyList(class ATgPawn* TestPawn, bool InSlice);
	void STATIC_RemovePawnFromEnemyList(class ATgPawn* TestPawn);
	void AddPawnToEnemyList(class ATgPawn* TestPawn, bool InSlice);
	bool STATIC_CheckEnemyInSlice(class ATgPawn* EnemyPawn);
	void STATIC_CleanUpSilentPawn(class ATgPawn* SilentPawn);
	void ApplySilenceToPawn(class ATgPawn* SilentPawn, bool FirstApply);
};


// Class TgGame.TgDevice_Ganesha_Dev3
// 0x000C (0x0548 - 0x053C)
class ATgDevice_Ganesha_Dev3 : public ATgDevice_Charge
{
public:
	float                                              m_fMissedPostFire;                                        // 0x053C(0x0004)
	class ATgPawn*                                     r_HitGod;                                                 // 0x0540(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ganesha_Dev3");
		return ptr;
	}


	void LaunchHitGod();
	void AttackHitGod();
	void STATIC_CleanUpHitEnemyPawn();
	bool STATIC_CanEffectTarget(class ATgPawn* Target);
};


// Class TgGame.TgDevice_Ganesha_Dev2
// 0x0010 (0x0504 - 0x04F4)
class ATgDevice_Ganesha_Dev2 : public ATgDevice_GroundTarget_LockOn
{
public:
	TArray<class ATgPawn*>                             m_ProtectedGods;                                          // 0x04F4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ganesha_Dev2");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void InterruptFiring();
	bool CanBeCanceled();
};


// Class TgGame.TgDeviceFire_Ganesha_Dev4
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Ganesha_Dev4 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ganesha_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Ganesha_Dev2
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_Ganesha_Dev2 : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ganesha_Dev2");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgInventoryObject_Listen_Ganesha_Dev2
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Ganesha_Dev2 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Ganesha_Dev2");
		return ptr;
	}

};


// Class TgGame.TgPawn_Ganesha
// 0x007C (0x2634 - 0x25B8)
class ATgPawn_Ganesha : public ATgPawn_Character
{
public:
	class ATgDevice_PassiveAura*                       m_devicePsv;                                              // 0x25B8(0x0008)
	class ATgDevice*                                   m_deviceA01;                                              // 0x25C0(0x0008)
	class ATgDevice_Ganesha_Dev2_V2*                   m_deviceA02;                                              // 0x25C8(0x0008)
	class ATgDevice_Ganesha_Dev3*                      m_deviceA03;                                              // 0x25D0(0x0008)
	class ATgDevice*                                   m_deviceA04;                                              // 0x25D8(0x0008)
	TArray<class UTgAnimNodeBlentList_IntroLoopOutro*> m_Dev2SequenceNodes;                                      // 0x25E0(0x0010) (NeedCtorLink)
	class AController*                                 s_KillerOverride;                                         // 0x25F0(0x0008)
	float                                              m_fBackupAdditionalAssistTime;                            // 0x25F8(0x0004)
	int                                                r_nPassedKills;                                           // 0x25FC(0x0004) (Net)
	unsigned long                                      r_bHasKillerOverride : 1;                                 // 0x2600(0x0004) (Net)
	unsigned long                                      r_bInPose : 1;                                            // 0x2600(0x0004) (Net)
	unsigned long                                      r_bPlayingBeatupAnim : 1;                                 // 0x2600(0x0004) (Net)
	int                                                m_nA01BaseHitStackCount;                                  // 0x2604(0x0004)
	int                                                m_nA01GodHitStackCount;                                   // 0x2608(0x0004)
	float                                              m_fA01BuffRadius;                                         // 0x260C(0x0004)
	class UTgAnimNodeSlot*                             c_BeatupAnimSlot;                                         // 0x2610(0x0008)
	struct FName                                       c_BeatupAnimName;                                         // 0x2618(0x0008)
	float                                              m_fBeatupAnimLengthTime;                                  // 0x2620(0x0004)
	TArray<struct FDamageData>                         trackedDamage;                                            // 0x2624(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Ganesha");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_CacheMainMeshReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_StopBeatupAnim(float BlendTime);
	void STATIC_EndChargeBeatupAnim(float BlendTime);
	void PlayChargeBeatupAnim();
	void HandleBeatupAnim(bool Start);
	float GetAssistTime(class ATgPawn* VictimPawn);
	float GetAdditionalAssistDistance();
	void OverrideKillBonusLogic(class ATgPawn* VictimPawn, class AController* overrideController);
	class AController* OverrideKillInstigator();
	bool STATIC_CheckWillHaveOverride();
	void STATIC_FindValidAlternateKiller();
	void STATIC_SendGaneshaPSVMessage(class AController* overrideController);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveBool(int* bResult);
	void PlayDeathAnimation();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool STATIC_IgnoreFaceRotationWithInterp();
	void UpdatePoseState(bool ActivePose);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgProj_Ganesha_Dev2
// 0x008C (0x0458 - 0x03CC)
class ATgProj_Ganesha_Dev2 : public ATgProj_SimulatedSeeking
{
public:
	struct FImpactInfo                                 m_RedirectImpact;                                         // 0x03CC(0x0078) (Component)
	float                                              m_RedirectDamage;                                         // 0x0444(0x0004)
	class ATgPawn*                                     m_SourcePawn;                                             // 0x0448(0x0008)
	class UTgEffectGroup*                              m_SourceEffectGroup;                                      // 0x0450(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ganesha_Dev2");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgAnimNodeBlendList_DaJi_Ult
// 0x0000 (0x0168 - 0x0168)
class UTgAnimNodeBlendList_DaJi_Ult : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_DaJi_Ult");
		return ptr;
	}


	void STATIC_PlayFire();
	void SetState(TEnumAsByte<EDajiUltState> UltState);
};


// Class TgGame.TgDeployable_DaJi_Paolao
// 0x0004 (0x0410 - 0x040C)
class ATgDeployable_DaJi_Paolao : public ATgDeploy_Wall
{
public:
	unsigned long                                      m_bIntroAnimReady : 1;                                    // 0x040C(0x0004)
	unsigned long                                      r_bCollisionReady : 1;                                    // 0x040C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_DaJi_Paolao");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void activateCollision();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_DaJi_HorribleBurns
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_DaJi_HorribleBurns : public ATgDevice
{
public:
	unsigned long                                      r_bIsActiveState : 1;                                     // 0x04F0(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_HorribleBurns");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	void HandleActiveState();
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool ShouldCooldownAfterFire();
	void ReplicatedEvent(const struct FName& VarName);
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_DaJi_Passive
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_DaJi_Passive : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_Passive");
		return ptr;
	}

};


// Class TgGame.TgDevice_DaJi_SpiritLink
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_DaJi_SpiritLink : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_SpiritLink");
		return ptr;
	}


	bool CanBeCanceled();
	bool STATIC_CanLockOnToTarget(class AActor* Target);
};


// Class TgGame.TgDevice_DaJi_ThousandCuts
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_DaJi_ThousandCuts : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_ThousandCuts");
		return ptr;
	}


	void STATIC_ClientInterrupt();
	void InterruptFiring();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_DaJi_Paolao
// 0x0008 (0x0530 - 0x0528)
class ATgDevice_DaJi_Paolao : public ATgDevice_Staging
{
public:
	unsigned long                                      m_bIsRightClickCancel : 1;                                // 0x0528(0x0004)
	int                                                m_nShotsFired;                                            // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_Paolao");
		return ptr;
	}


	void STATIC_ClientInterrupt();
	void InterruptFiring();
	void OnStageShooterStopFire(bool bInterrupted);
	bool STATIC_ShouldSwapInHandOnShooterStopFire();
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	bool CanJumpWhileFiring();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_DaJi_Paolao_PVE
// 0x0030 (0x0560 - 0x0530)
class ATgDevice_DaJi_Paolao_PVE : public ATgDevice_DaJi_Paolao
{
public:
	class ATgPawn_DaJi*                                s_DaJi;                                                   // 0x0530(0x0008)
	int                                                m_nNumPresents;                                           // 0x0538(0x0004) (Const)
	float                                              m_fStartingAngle;                                         // 0x053C(0x0004) (Const)
	float                                              m_fDistFromCenterToPresent;                               // 0x0540(0x0004) (Const)
	float                                              m_fRandDistRange;                                         // 0x0544(0x0004) (Const)
	float                                              m_fRandAngleRange;                                        // 0x0548(0x0004) (Const)
	int                                                m_nPresentDeployableId;                                   // 0x054C(0x0004) (Const)
	TArray<class ATgDeployable*>                       s_Presents;                                               // 0x0550(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_Paolao_PVE");
		return ptr;
	}


	void Tick(float DeltaTime);
	void STATIC_DespawnPresents();
	void STATIC_SpawnPresents();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_DaJi_PaolaoTargetter
// 0x000E (0x0504 - 0x04F6)
class ATgDevice_DaJi_PaolaoTargetter : public ATgDevice_TimerFromParent
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x04F6(0x0002) MISSED OFFSET
	int                                                m_nAmmoCount;                                             // 0x04F8(0x0004)
	int                                                m_nMaxAmmoCount;                                          // 0x04FC(0x0004)
	int                                                m_nAmmoCountSituationalType;                              // 0x0500(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_PaolaoTargetter");
		return ptr;
	}


	void STATIC_ClientSetAmmoCount(int nAmmoCount);
	void SetAmmoCount(int nAmmoCount, bool bDoNotFowardToClient);
	void InterruptFiring();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool ApplyGlobalOffhandCooldown();
	bool ShouldInterruptInhand();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void RemoveEquipEffects();
	void ApplyEquipEffects();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_DaJi_Paolao
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_DaJi_Paolao : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DaJi_Paolao");
		return ptr;
	}


	void STATIC_Deploy();
};


// Class TgGame.TgDeviceFire_DaJi_SpiritLink
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_DaJi_SpiritLink : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_DaJi_SpiritLink");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_DaJi_HorribleBurns
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_DaJi_HorribleBurns : public UTgInventoryObject_Listen
{
public:
	class ATgDevice*                                   m_TrackedDevice;                                          // 0x00D0(0x0008)
	int                                                m_nTrackedFireInstance;                                   // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_DaJi_HorribleBurns");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Daji_RazorClaws
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Daji_RazorClaws : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Daji_RazorClaws");
		return ptr;
	}

};


// Class TgGame.TgPawn_DaJi
// 0x0138 (0x26F0 - 0x25B8)
class ATgPawn_DaJi : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_DevicePsv_RazorClaws;                                   // 0x25B8(0x0008)
	class ATgDevice_DaJi_HorribleBurns*                m_DeviceA01_HorribleBurns;                                // 0x25C0(0x0008)
	class ATgDevice*                                   m_DeviceA02_OneThousandCuts;                              // 0x25C8(0x0008)
	class ATgDevice_DaJi_SpiritLink*                   m_DeviceA03_SpiritLink;                                   // 0x25D0(0x0008)
	class ATgDevice_DaJi_Paolao*                       m_DeviceA04_Paolao;                                       // 0x25D8(0x0008)
	class ATgDevice_DaJi_PaolaoTargetter*              m_DeviceA04_PaolaoTargetter;                              // 0x25E0(0x0008)
	class UTgSkeletalMeshComponent*                    c_HorribleBurnsPAC;                                       // 0x25E8(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      r_bIsHorribleBurnsActive : 1;                             // 0x25F0(0x0004) (Net)
	unsigned long                                      m_bIsOneThousandCutsActive : 1;                           // 0x25F0(0x0004)
	unsigned long                                      m_bTargetHasTeleported : 1;                               // 0x25F0(0x0004)
	class ATgPawn*                                     r_SpiritLinkTarget;                                       // 0x25F4(0x0008) (Net)
	TArray<int>                                        m_nTeleportProjectilePitchSkinIds;                        // 0x25FC(0x0010) (Const, NeedCtorLink)
	TEnumAsByte<EDajiUltState>                         r_eUltimateState;                                         // 0x260C(0x0001) (Net)
	TEnumAsByte<EDajiUltState>                         m_eLocalUltState;                                         // 0x260D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x260E(0x0002) MISSED OFFSET
	class ATgDevice*                                   s_UltimateDismountDevice;                                 // 0x2610(0x0008)
	class ATgDeployable_DaJi_Paolao*                   r_UltimateDeployable;                                     // 0x2618(0x0008) (Net)
	class ATgDeployable_DaJi_Paolao*                   c_UltimateDeployable;                                     // 0x2620(0x0008)
	TArray<class ATgPawn*>                             m_ImmunePaolaoVictims;                                    // 0x2628(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_GrabbedPaolaoVictims;                                   // 0x2638(0x0010) (NeedCtorLink)
	class ATgPawn*                                     r_TetheredPawns[0x5];                                     // 0x2648(0x0008) (Net)
	class ATgPawn*                                     c_TetheredPawns[0x5];                                     // 0x2670(0x0008) (Transient)
	class UTgStaticMeshComponent*                      c_TetherMeshComponents[0x5];                              // 0x2698(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              c_TetherAttachProgressPercentage;                         // 0x26C0(0x0004) (Transient)
	struct FVector                                     m_ChainPaolaoOffset;                                      // 0x26C4(0x000C)
	struct FVector                                     r_PaolaoTeleportLocation;                                 // 0x26D0(0x000C) (Net)
	TArray<class UTgAnimNodeBlendList_DaJi_Ult*>       c_UltimateBlendList;                                      // 0x26DC(0x0010) (NeedCtorLink)
	int                                                m_nPaolaoTargeterId;                                      // 0x26EC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_DaJi");
		return ptr;
	}


	bool Teleport(const struct FVector& vDest, const struct FRotator& rDest, bool bPlayFx, int TeleportEnterState, int TeleportExitState, bool bMaintainControllerPitch);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_PlayUltimateFireAnimation();
	void STATIC_SetUltimateAnimationState(TEnumAsByte<EDajiUltState> UltState);
	void UpdateTetherChainComponents(float DeltaSeconds);
	void UpdateTetheredPawns();
	void Tick(float DeltaSeconds);
	bool CannotJumpNow();
	void STATIC_OnRespawn();
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void TriggerForceLandingAnimation();
	void ForceLanding();
	void ToggleUltimateEffectGroup(bool bOn);
	void ToggleForceLandingTimer(bool bOn);
	void ToggleUltimateDismountDevice(bool bOn);
	void STATIC_DismountDeviceTimer();
	void ActivateDismountDeviceTimer();
	void ToggleCollisionForUltimate(bool bOn);
	void STATIC_ServerOnRightMousePressed();
	void STATIC_OnUltimateAmmoExhausted();
	void STATIC_OnRightMousePressed();
	void STATIC_PaoLaoDestroyed(class ATgDeployable_DaJi_Paolao* deployable);
	void STATIC_EndUltimateState(TEnumAsByte<EDajiUltState> OldState);
	void STATIC_StartUltimateState(TEnumAsByte<EDajiUltState> NewState);
	void UpdateUltimateState(TEnumAsByte<EDajiUltState> NewState);
	bool IsInClassSpecificChannel();
	bool IsInClassSpecificMovement();
	void STATIC_OnTeleportNotify(class AActor* TeleportingActor);
	void ReplicatedEvent(const struct FName& VarName);
	int GetTetheredPawnCount();
	void STATIC_ClearGrabTargets();
	void STATIC_ClearGrabTarget(class ATgPawn* Target);
	void STATIC_PullGrabbedTargets();
	class UTgStaticMeshComponent* STATIC_CreateTetherMeshComponent();
	void ToggleHorribleBurnFx(bool bEnabled);
	void STATIC_InitializeHorribleBurnsPAC();
	struct FVector STATIC_FindNewTeleportPosition(const struct FVector& TeleportLocation, class AActor* TargetActor, const struct FVector& Extent, const struct FRotator& TeleportRotation);
	void STATIC_SpawnTeleportProjectile(const struct FVector& vTeleportOrigin);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vTeleportOrigin);
	void STATIC_PawnOnDamageMitigation(class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStopBuildup(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
};


// Class TgGame.TgProj_DaJi_PaolaoTortureChain
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_DaJi_PaolaoTortureChain : public ATgProj_SimulatedGroundTarget_FixedTime_NoLob
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_DaJi_PaolaoTortureChain");
		return ptr;
	}


	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAchievement_CuChulainn_Berserker
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_CuChulainn_Berserker : public UTgAchievement
{
public:
	class ATgPawn_CuChulainn*                          m_CachedOwner;                                            // 0x0084(0x0008)
	int                                                m_nHitCount;                                              // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_CuChulainn_Berserker");
		return ptr;
	}


	bool STATIC_HasCachedOwner();
};


// Class TgGame.TgDevice_CuChulainn_Dev3_Alt
// 0x0018 (0x0554 - 0x053C)
class ATgDevice_CuChulainn_Dev3_Alt : public ATgDevice_Charge
{
public:
	class ATgPawn_CuChulainn*                          m_CachedOwner;                                            // 0x053C(0x0008)
	TArray<struct FChargeHitInfo>                      m_ChargeHitInfos;                                         // 0x0544(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CuChulainn_Dev3_Alt");
		return ptr;
	}


	void STATIC_OnChargeEnd();
	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	bool ShouldTriggerCastReactionItems();
	float GetDevicePowerPoolToConsume();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_HasCachedPawnOwner();
};


// Class TgGame.TgDevice_CuChulainn_Dev3
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_CuChulainn_Dev3 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CuChulainn_Dev3");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	float GetDevicePowerPoolToConsume();
	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void STATIC_CustomUpdateTargetingModeLocation();
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_CuChulainn_Passive
// 0x001C (0x050C - 0x04F0)
class ATgDevice_CuChulainn_Passive : public ATgDevice
{
public:
	unsigned long                                      m_bNeedsDeathReset : 1;                                   // 0x04F0(0x0004)
	float                                              m_fManaMultiplier;                                        // 0x04F4(0x0004) (Const)
	float                                              m_fMP5Multiplier;                                         // 0x04F8(0x0004) (Const)
	class ATgPawn_CuChulainn*                          m_CachedOwner;                                            // 0x04FC(0x0008)
	class UTgDeviceFire_CuChulainn_Passive*            m_CachedFireMode;                                         // 0x0504(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CuChulainn_Passive");
		return ptr;
	}


	bool STATIC_HasCachedFiremode();
	bool STATIC_HasCachedPawnOwner();
};


// Class TgGame.TgDevice_CuChulainn_Dev2
// 0x001C (0x0518 - 0x04FC)
class ATgDevice_CuChulainn_Dev2 : public ATgDevice_HitPulse
{
public:
	class ATgPawn_CuChulainn*                          m_CachedOwner;                                            // 0x04FC(0x0008)
	TArray<struct FCuChulainnVentSteamHits>            m_HitCounts;                                              // 0x0504(0x0010) (NeedCtorLink)
	float                                              m_fTimeToNextHit;                                         // 0x0514(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CuChulainn_Dev2");
		return ptr;
	}


	void STATIC_CustomFireLockout();
	bool ShouldTriggerCastReactionItems();
	float GetDevicePowerPoolToConsume();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool IsActiveWhilefiring();
	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
	bool CanBeCanceledByRightMouse();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool StartFire();
	bool CanJumpWhileFiring();
	bool STATIC_HasCachedPawnOwner();
	void STATIC_ResetHitCounts();
	void UpdateHitCountsFor(class AActor* Target);
	bool STATIC_HasBeenTrained();
	bool UsesTargetingMode();
	void TickTargetingMode(float DeltaSeconds);
	bool IsToggledOn();
};


// Class TgGame.TgDevice_CuChulainn_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_CuChulainn_Dev1 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CuChulainn_Dev1");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	float GetDevicePowerPoolToConsume();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_CuChulainn_Dev1_Alt
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_CuChulainn_Dev1_Alt : public ATgDevice_Range
{
public:
	class ATgPawn_CuChulainn*                          m_CachedOwner;                                            // 0x04F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CuChulainn_Dev1_Alt");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	float GetDevicePowerPoolToConsume();
	bool STATIC_HasCachedPawnOwner();
};


// Class TgGame.TgDevice_CuChulainn_Dev4
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_CuChulainn_Dev4 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CuChulainn_Dev4");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	float GetDevicePowerPoolToConsume();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_CuChulainn_Dev4_Alt
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_CuChulainn_Dev4_Alt : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CuChulainn_Dev4_Alt");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	float GetDevicePowerPoolToConsume();
};


// Class TgGame.TgDeviceFire_CuChulainn_Dev2
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_CuChulainn_Dev2 : public UTgDeviceFire
{
public:
	class ATgPawn_CuChulainn*                          m_CachedOwner;                                            // 0x01C0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CuChulainn_Dev2");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	float STATIC_GetShotPowerCost(int nPacingType, bool bBaseOnly);
	bool STATIC_HasCachedPawnOwner();
};


// Class TgGame.TgDeviceFire_CuChulainn_HitLimit
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_CuChulainn_HitLimit : public UTgDeviceFire
{
public:
	int                                                m_nSuccessfulHitCount;                                    // 0x01C0(0x0004)
	int                                                m_nSuccessfulHitLimit;                                    // 0x01C4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CuChulainn_HitLimit");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
};


// Class TgGame.TgDeviceFire_CuChulainn_Dev3
// 0x0000 (0x01C8 - 0x01C8)
class UTgDeviceFire_CuChulainn_Dev3 : public UTgDeviceFire_CuChulainn_HitLimit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CuChulainn_Dev3");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_CuChulainn_Passive
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_CuChulainn_Passive : public UTgDeviceFire
{
public:
	float                                              fManaMirror;                                              // 0x01C0(0x0004)
	float                                              fMP5Mirror;                                               // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_CuChulainn_Passive");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	void UpdateMP5Mirror(float fNewMP5);
	void UpdateManaMirror(float fNewMana);
};


// Class TgGame.TgPawn_CuChulainn
// 0x009C (0x2680 - 0x25E4)
class ATgPawn_CuChulainn : public ATgPawn_MeshSwapper
{
public:
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x25E4(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fFerocityFromTakingDamage;                              // 0x25EC(0x0004) (Const)
	float                                              m_fFerocityFromAllyRange;                                 // 0x25F0(0x0004) (Const)
	struct FCuChulainnFerocityData                     m_BerserkData;                                            // 0x25F4(0x0018)
	struct FCuChulainnFerocityRefundData               m_FerocityRefundDataDev1;                                 // 0x260C(0x001C)
	struct FCuChulainnFerocityRefundData               m_FerocityRefundDataDev3;                                 // 0x2628(0x001C)
	struct FCuChulainnFerocityRefundData               m_FerocityRefundDataDev4;                                 // 0x2644(0x001C)
	int                                                m_nMaxRefundHitCount;                                     // 0x2660(0x0004) (Const)
	TEnumAsByte<ECuChulainnFerocityLevel>              m_CurrentFerocityLevel;                                   // 0x2664(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2665(0x0003) MISSED OFFSET
	unsigned long                                      r_bBerserkActive : 1;                                     // 0x2668(0x0004) (Net)
	unsigned long                                      m_bVentSteamFxActive : 1;                                 // 0x2668(0x0004)
	unsigned long                                      m_bVentSteamIconActive : 1;                               // 0x2668(0x0004)
	unsigned long                                      r_bTransitionFxActive : 1;                                // 0x2668(0x0004) (Net)
	unsigned long                                      c_bTransitionFxActive : 1;                                // 0x2668(0x0004)
	unsigned long                                      m_bBerserkEmoteActivated : 1;                             // 0x2668(0x0004)
	unsigned long                                      r_bA04PlayedYellAudio : 1;                                // 0x2668(0x0004) (Net)
	float                                              m_fBerserkEmoteTime;                                      // 0x266C(0x0004) (Const)
	float                                              m_fSuperSketchyEnergyRefund;                              // 0x2670(0x0004)
	float                                              m_fHeatMin;                                               // 0x2674(0x0004) (Const)
	float                                              m_fHeatMax;                                               // 0x2678(0x0004) (Const)
	float                                              r_fAltA03KnockbackDist;                                   // 0x267C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CuChulainn");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void SetTargetingDevice(class ATgDevice* Dev);
	bool STATIC_IgnoreFaceRotationWithInterp();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
	float ApplyPitchLimit(float fPitch);
	void ToggleTransitionFX();
	void STATIC_OnRespawn();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PlayA04YellAudio();
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void STATIC_PerformPunchKnockback(class ATgPawn* HitActor);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	void STATIC_PawnOnAllyDamaged(class ATgPawn* ally, struct FOnDamagedParams* Params);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_SetSpawnEnergy();
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveBool(int* bResult);
	void UpdateVentSteamFx();
	void BerserkEmote();
	void BerserkTransitionFX();
	void BerserkTimeout();
	void BerserkEngage();
	void STATIC_HandleBerserkPostSwap();
	void STATIC_HandleBerserkPreSwap();
	void ActivateBerserk(bool bSetActive);
	class ATgDevice* STATIC_GetDeviceLockingBerserk();
	float STATIC_GiveFerocity(float fDeltaFerocity, float fMaxValue);
	float STATIC_GetFountainRecharge(float deltaSecond);
	void UpdateFerocity(float deltaSecond);
	void STATIC_InitializeFerocityData();
};


// Class TgGame.TgAchievement_Artio_Invigorate
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Artio_Invigorate : public UTgAchievement
{
public:
	class ATgPawn_Artio*                               m_CachedOwner;                                            // 0x0084(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Artio_Invigorate");
		return ptr;
	}


	bool STATIC_HasCachedOwner();
};


// Class TgGame.TgAchievement_Artio_MauledToDeath
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Artio_MauledToDeath : public UTgAchievement
{
public:
	class ATgPawn_Artio*                               m_CachedOwner;                                            // 0x0084(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Artio_MauledToDeath");
		return ptr;
	}


	bool STATIC_HasCachedOwner();
};


// Class TgGame.TgDeployable_Artio_GroundedZone
// 0x0004 (0x0480 - 0x047C)
class ATgDeployable_Artio_GroundedZone : public ATgDeploy_MovingEffectVolume
{
public:
	float                                              m_fSpawnZ;                                                // 0x047C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Artio_GroundedZone");
		return ptr;
	}

};


// Class TgGame.TgDevice_Artio_StanceChange
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Artio_StanceChange : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Artio_StanceChange");
		return ptr;
	}


	bool STATIC_ShouldApplyModeEquipEffects();
	bool STATIC_HasBeenTrained();
};


// Class TgGame.TgDevice_Artio_GroundedZone
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Artio_GroundedZone : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Artio_GroundedZone");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void ReplicatedEvent(const struct FName& VarName);
	bool IsToggledOn();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Artio_Maul
// 0x0004 (0x0520 - 0x051C)
class ATgDevice_Artio_Maul : public ATgDevice_RadialSweep
{
public:
	int                                                m_SwipeIndex;                                             // 0x051C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Artio_Maul");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
	void InterruptFiring();
	void STATIC_StartSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime);
	void ProxyEndSweep(bool bInterrupt);
};


// Class TgGame.TgPawn_Artio
// 0x008C (0x2670 - 0x25E4)
class ATgPawn_Artio : public ATgPawn_MeshSwapper
{
public:
	class ATgDevice*                                   s_EnergySurgeHealDevice;                                  // 0x25E4(0x0008)
	TArray<int>                                        s_LifeTapHits;                                            // 0x25EC(0x0010) (NeedCtorLink)
	int                                                s_nLastLifeTapHit;                                        // 0x25FC(0x0004)
	TEnumAsByte<EArtioStances>                         r_eStance;                                                // 0x2600(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2601(0x0003) MISSED OFFSET
	struct FArtioDev4TrackingData                      s_Dev4Tracking[0x6];                                      // 0x2604(0x0008)
	class UTgSpecialFx*                                c_Dev4PassiveBurstFx;                                     // 0x2634(0x0008)
	int                                                r_nDev4PassiveBurstCount;                                 // 0x263C(0x0004) (Net)
	class ATgDevice*                                   r_CachedDruidDev1;                                        // 0x2640(0x0008) (Net)
	class ATgDevice*                                   r_CachedDruidDev2;                                        // 0x2648(0x0008) (Net)
	class ATgDevice*                                   r_CachedDruidDev3;                                        // 0x2650(0x0008) (Net)
	class ATgDevice*                                   r_CachedBearDev1;                                         // 0x2658(0x0008) (Net)
	class ATgDevice*                                   r_CachedBearDev2;                                         // 0x2660(0x0008) (Net)
	class ATgDevice*                                   r_CachedBearDev3;                                         // 0x2668(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Artio");
		return ptr;
	}


	void SetTargetingDevice(class ATgDevice* Dev);
	void PlayDev4PassiveBurstFx();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_StanceSwap();
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
};


// Class TgGame.TgAnimNodeBlendList_Hachiman_Dev2
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendList_Hachiman_Dev2 : public UTgAnimNodeBlentList_IntroLoopOutro
{
public:
	class ATgPawn_Hachiman*                            m_TgPawn;                                                 // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_Hachiman_Dev2");
		return ptr;
	}


	void STATIC_PlayOutro();
};


// Class TgGame.TgAnimNodeSequence_Hachiman_Ult
// 0x0008 (0x01BC - 0x01B4)
class UTgAnimNodeSequence_Hachiman_Ult : public UTgAnimNodeSequence
{
public:
	class ATgPawn_Hachiman*                            m_HachimanPawn;                                           // 0x01B4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_Hachiman_Ult");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Hachiman_Dev2
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeployable_Hachiman_Dev2 : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Hachiman_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDevice_Hachiman_Dev3_V2
// 0x0034 (0x0570 - 0x053C)
class ATgDevice_Hachiman_Dev3_V2 : public ATgDevice_Charge
{
public:
	class ATgCollisionProxy_RadialSweep*               m_SweepCollisionProxy;                                    // 0x053C(0x0008)
	TArray<class AActor*>                              m_SweepHitActors;                                         // 0x0544(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_CachedChargeHitActors;                                  // 0x0554(0x0010) (NeedCtorLink)
	class UTgDeviceFire*                               m_SweepFiremode;                                          // 0x0564(0x0008)
	unsigned long                                      m_bAlreadySwept : 1;                                      // 0x056C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hachiman_Dev3_V2");
		return ptr;
	}


	void Destroyed();
	void STATIC_EndSweep();
	void STATIC_StartSweep(class UTgDeviceFire* FireMode, const struct FRotator& AimRotation, float fPersistTime);
	bool IsSweepActive();
	float GetPersistTime(int nMode);
	void ProxyEndSweep(bool bInterrupt);
	void SweepUnTouch(class AActor* Other);
	void SweepTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UpdateSweepCollisionProxyDelegates();
};


// Class TgGame.TgDevice_Hachiman_Dev4
// 0x0050 (0x058C - 0x053C)
class ATgDevice_Hachiman_Dev4 : public ATgDevice_Charge
{
public:
	float                                              m_fStartChargeTimeStamp;                                  // 0x053C(0x0004)
	float                                              m_fStartFireGroundSpeed;                                  // 0x0540(0x0004)
	class UClass*                                      m_ChargeControlModuleClass;                               // 0x0544(0x0008)
	class UClass*                                      m_PrevControlModuleClass;                                 // 0x054C(0x0008)
	class UTgControlModule*                            m_ChargeControlModule;                                    // 0x0554(0x0008)
	class UClass*                                      m_DefaultCameraModuleClass;                               // 0x055C(0x0008)
	class UClass*                                      m_FiringCameraModuleClass;                                // 0x0564(0x0008)
	class UTgCameraModule*                             m_FiringCameraModule;                                     // 0x056C(0x0008)
	float                                              m_fCameraTweenInTime;                                     // 0x0574(0x0004)
	float                                              m_fCameraTweenOutTime;                                    // 0x0578(0x0004)
	float                                              m_fFiringCameraZOffset;                                   // 0x057C(0x0004)
	struct FName                                       m_nmCustomFireLockout;                                    // 0x0580(0x0008) (Const)
	unsigned long                                      m_bShooterHasFired : 1;                                   // 0x0588(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hachiman_Dev4");
		return ptr;
	}


	void InterruptFiring();
	void AttemptShooterFire();
	void STATIC_CustomFireLockout();
	void TurnOffSpecialCamera();
	void TurnOnSpecialCamera();
	float STATIC_CalcFinalSpeed();
	float STATIC_GetAccelTime();
	void STATIC_ClientSwapOutNextShooter();
	void STATIC_SwapOutNextShooter();
	void STATIC_ClientSwapInNextShooter();
	void STATIC_SwapInNextShooter();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_ServerOnRightMousePressed();
	void STATIC_OnRightMousePressed();
	bool CanBeCanceled();
	void STATIC_SetPointsAllocated(int nPoints);
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_Hachiman_Dev2_V2
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Hachiman_Dev2_V2 : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hachiman_Dev2_V2");
		return ptr;
	}

};


// Class TgGame.TgDevice_Hachiman_Dev1_V2
// 0x000C (0x04FC - 0x04F0)
class ATgDevice_Hachiman_Dev1_V2 : public ATgDevice
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                                       // 0x04F0(0x0004) (Net)
	unsigned long                                      m_bStimShot : 1;                                          // 0x04F0(0x0004)
	int                                                m_nStacksRemaining;                                       // 0x04F4(0x0004)
	int                                                m_nMaxStacks;                                             // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hachiman_Dev1_V2");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void HandleActiveState();
	void STATIC_FireAmmunition();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	void STATIC_SetPointsAllocated(int nPoints);
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_Hachiman_Dev4Shooter
// 0x0020 (0x0510 - 0x04F0)
class ATgDevice_Hachiman_Dev4Shooter : public ATgDevice
{
public:
	TArray<struct FImpactInfo>                         m_TrackedHits;                                            // 0x04F0(0x0010) (Component, NeedCtorLink)
	TArray<class ATgPawn*>                             m_AlreadyHitGods;                                         // 0x0500(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hachiman_Dev4Shooter");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool UsesTrackingTarget();
	void STATIC_CleanUpShooter();
	class AActor* STATIC_GetTrackingTarget(int nFireIndex);
	void AttemptAlternateFire();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	TEnumAsByte<EDeviceTargetMode> STATIC_GetTargetingMode();
	bool UsesCachedAim();
};


// Class TgGame.TgDeviceFire_Hachiman_Dev2
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Hachiman_Dev2 : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hachiman_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Hachiman_Dev3
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Hachiman_Dev3 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hachiman_Dev3");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Hachiman_Dev4Shooter
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Hachiman_Dev4Shooter : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hachiman_Dev4Shooter");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	int STATIC_GetShotsPerFire();
};


// Class TgGame.TgDeviceFire_Hachiman_Inhand
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Hachiman_Inhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hachiman_Inhand");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceForm_Hachiman_InHand
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Hachiman_InHand : public UTgDeviceForm_AlternateFX
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hachiman_InHand");
		return ptr;
	}


	bool STATIC_CustomShouldBeActive();
};


// Class TgGame.TgDeviceForm_Hachiman_Ult
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_Hachiman_Ult : public UTgDeviceForm_MultipleTargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hachiman_Ult");
		return ptr;
	}


	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
};


// Class TgGame.TgInventoryObject_Listen_Hachiman_Dev1
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_Hachiman_Dev1 : public UTgInventoryObject_Listen
{
public:
	int                                                m_nFiringInstance;                                        // 0x00D0(0x0004)
	int                                                m_nStacksRemaining;                                       // 0x00D4(0x0004)
	unsigned long                                      m_bStimShot : 1;                                          // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Hachiman_Dev1");
		return ptr;
	}


	void DeviceCleanup();
};


// Class TgGame.TgPawn_Hachiman
// 0x00F4 (0x26AC - 0x25B8)
class ATgPawn_Hachiman : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_devicePsv;                                              // 0x25B8(0x0008)
	class ATgDevice_Hachiman_Dev1_V2*                  m_deviceA01;                                              // 0x25C0(0x0008)
	class ATgDevice_Hachiman_Dev2_V2*                  m_deviceA02;                                              // 0x25C8(0x0008)
	class ATgDevice_Hachiman_Dev3_V2*                  m_deviceA03;                                              // 0x25D0(0x0008)
	class ATgDevice_Hachiman_Dev4*                     m_deviceA04;                                              // 0x25D8(0x0008)
	class ATgDevice*                                   r_ExplosionInHandDevice;                                  // 0x25E0(0x0008)
	class ATgDevice_Hachiman_Dev4Shooter*              r_DeviceA04_Shooter;                                      // 0x25E8(0x0008) (Net)
	float                                              r_fPSVGainedMP5;                                          // 0x25F0(0x0004) (Net)
	int                                                m_eCurrentInhandActiveMode;                               // 0x25F4(0x0004)
	class ATgDevice_ActiveMode*                        r_InHandDevice;                                           // 0x25F8(0x0008) (Net)
	unsigned long                                      r_bCanCancelInhand : 1;                                   // 0x2600(0x0004)
	unsigned long                                      r_bActivateOrbs : 1;                                      // 0x2600(0x0004) (Net)
	unsigned long                                      r_bDev1InStimmedAnim : 1;                                 // 0x2600(0x0004) (Net)
	unsigned long                                      r_bA02IsFiring : 1;                                       // 0x2600(0x0004) (Net)
	unsigned long                                      r_bA02ShouldPlayHitOutro : 1;                             // 0x2600(0x0004) (Net)
	unsigned long                                      r_bForceHorseCleanUp : 1;                                 // 0x2600(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    c_BowStimMesh;                                            // 0x2604(0x0008) (ExportObject, Component, EditInline)
	unsigned char                                      r_nShowBowStimMesh;                                       // 0x260C(0x0001) (Net)
	TEnumAsByte<EHachimanUltHorsePhase>                r_CurrentHorsePhase;                                      // 0x260D(0x0001) (Net)
	TEnumAsByte<EHachimanUltHorsePhase>                r_PreviousHorsePhase;                                     // 0x260E(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x260F(0x0001) MISSED OFFSET
	int                                                r_nMaxAmmo;                                               // 0x2610(0x0004) (Net)
	int                                                r_nCurrentAmmo;                                           // 0x2614(0x0004) (Net)
	int                                                m_nEnragePostureId;                                       // 0x2618(0x0004)
	TArray<class UTgAnimNodeBlentList_IntroLoopOutro*> m_A02SequenceNodes;                                       // 0x261C(0x0010) (NeedCtorLink)
	float                                              m_fLastChargeSpeed;                                       // 0x262C(0x0004)
	float                                              r_fRootlessGroundSpeed;                                   // 0x2630(0x0004)
	float                                              fChargeTurnSpeedMultiplier;                               // 0x2634(0x0004) (Const)
	float                                              r_fChargeYaw;                                             // 0x2638(0x0004) (Net)
	int                                                m_nMaxHorseRotationPerSec;                                // 0x263C(0x0004) (Const)
	int                                                m_nPrevHorseYaw;                                          // 0x2640(0x0004)
	class UTgSkeletalMeshComponent*                    m_HorseMesh;                                              // 0x2644(0x0008) (ExportObject, Component, EditInline)
	class UTgAnimNodeAimOffset*                        m_HorseLeanAimNode;                                       // 0x264C(0x0008)
	class UTgAnimNodeAimOffset_Charge*                 m_HachimanA04AimNode;                                     // 0x2654(0x0008)
	struct FName                                       c_IntroAnimName;                                          // 0x265C(0x0008)
	struct FName                                       c_OutroAnimName;                                          // 0x2664(0x0008)
	float                                              m_fUltHorseZOffset;                                       // 0x266C(0x0004)
	float                                              m_fUltGallopInSpeed;                                      // 0x2670(0x0004)
	float                                              m_fGallopInRemainingTime;                                 // 0x2674(0x0004)
	float                                              m_fUltGallopOutSpeed;                                     // 0x2678(0x0004)
	float                                              m_fGallopOutRemainingTime;                                // 0x267C(0x0004)
	float                                              r_fGallopInTime;                                          // 0x2680(0x0004) (Net)
	float                                              r_fGallopOutTime;                                         // 0x2684(0x0004) (Net)
	struct FVector                                     m_vUltHorseInitialLocation;                               // 0x2688(0x000C)
	struct FVector                                     m_vGallopOutHorseSourceLocation;                          // 0x2694(0x000C)
	struct FVector                                     m_vGallopOutTargetLocation;                               // 0x26A0(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Hachiman");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void TogglePosture();
	void UpdateAmmoBeltStacks();
	void ActivateOrbs();
	void UpdateBowMesh(unsigned char NewShowBowStim);
	void EndHorse();
	void CleanUpHorse();
	void MountHorse();
	void PlayDismount();
	void SpawnHorse();
	void InitializeUltVisuals();
	void PlayA02OutroAnim();
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_OnRightMousePressed();
	void A04ChargeEndCleanup();
	void STATIC_ServerOnRightMousePressed();
	void SetTargetingDevice(class ATgDevice* Dev);
	float STATIC_GetChargeTurnRate();
	bool STATIC_IgnoreFaceRotationWithInterp();
	void ChangeInhandActiveMode(int newActiveMode);
	bool PostPawnSetup();
	void STATIC_ServerSetSpecialFloat1(float fValue);
	bool STATIC_GetPassiveInt1(int* nResult);
	float STATIC_GetMaxEnergy();
	float STATIC_GetSmoothEnergy();
	void UpdateHorse(float DeltaTime);
	float STATIC_GetUIGroundSpeed();
	void STATIC_DeviceOnPostHit(class ATgDevice* Dev);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_OnMeshSwapped();
	float STATIC_CalculatePSVMP5Gain(class UTgEffectGroup* EffectGroup);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_HachiBasicAttackFiring(class ATgDevice* Dev);
};


// Class TgGame.TgProj_Hachiman_Dev4Shooter
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Hachiman_Dev4Shooter : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Hachiman_Dev4Shooter");
		return ptr;
	}


	bool UseAOE();
};


// Class TgGame.TgAchievement_Discordia_CurseOfDiscord
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Discordia_CurseOfDiscord : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Discordia_CurseOfDiscord");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Discordia_SpreadingStrife
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Discordia_SpreadingStrife : public UTgAchievement
{
public:
	int                                                m_nSpreadCount;                                           // 0x0084(0x0004)
	int                                                m_nLastSpreadInstance;                                    // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Discordia_SpreadingStrife");
		return ptr;
	}

};


// Class TgGame.TgCharmComponent_Discordia
// 0x0000 (0x00D8 - 0x00D8)
class UTgCharmComponent_Discordia : public UTgCharmComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCharmComponent_Discordia");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Discordia_ErraticBehavior
// 0x0014 (0x040C - 0x03F8)
class ATgDeployable_Discordia_ErraticBehavior : public ATgDeploy_EffectVolume
{
public:
	class ATgPawn_Discordia*                           s_Discordia;                                              // 0x03F8(0x0008)
	class ATgDevice_Discordia_ErraticBehavior*         s_SpawnerDevice;                                          // 0x0400(0x0008)
	unsigned long                                      s_bIsOwnerTouching : 1;                                   // 0x0408(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Discordia_ErraticBehavior");
		return ptr;
	}


	void Cleanup();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ApplyProperEffectStatus();
};


// Class TgGame.TgDeployable_Discordia_ChaosBlast
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_Discordia_ChaosBlast : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Discordia_ChaosBlast");
		return ptr;
	}


	void STATIC_SpawnProjectiles();
};


// Class TgGame.TgDeployable_Discordia_TurnAgainst
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_Discordia_TurnAgainst : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Discordia_TurnAgainst");
		return ptr;
	}


	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDevice_Discordia_ChaosBlast
// 0x0034 (0x0530 - 0x04FC)
class ATgDevice_Discordia_ChaosBlast : public ATgDevice_Deployable
{
public:
	struct FAimData                                    m_LockedAim;                                              // 0x04FC(0x0030)
	unsigned long                                      m_bIsTargeterBehindWall : 1;                              // 0x052C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Discordia_ChaosBlast");
		return ptr;
	}


	bool StartFire();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Discordia_TurnAgainst
// 0x0028 (0x0518 - 0x04F0)
class ATgDevice_Discordia_TurnAgainst : public ATgDevice
{
public:
	int                                                m_nCharmedMeleeDeviceId;                                  // 0x04F0(0x0004)
	int                                                m_nCharmedProjectileDeviceId;                             // 0x04F4(0x0004)
	TArray<class UTgDeviceFire*>                       m_CharmedMeleeFireMode;                                   // 0x04F8(0x0010) (NeedCtorLink)
	TArray<class UTgDeviceFire*>                       m_CharmedProjectileFireMode;                              // 0x0508(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Discordia_TurnAgainst");
		return ptr;
	}


	class UTgDeviceFire* STATIC_GetCharmedProjectileMode(int nMode);
	class UTgDeviceFire* STATIC_GetCurrentCharmedProjectileMode();
	class UTgDeviceFire* STATIC_GetCharmedMeleeMode(int nMode);
	class UTgDeviceFire* STATIC_GetCurrentCharmedMeleeMode();
};


// Class TgGame.TgDevice_Discordia_GoldenAppleOfDiscord_EnemyToss
// 0x0008 (0x04FC - 0x04F4)
class ATgDevice_Discordia_GoldenAppleOfDiscord_EnemyToss : public ATgDevice_GroundTarget_LockOn
{
public:
	class ATgPawn_Discordia*                           m_InstigatorDiscordia;                                    // 0x04F4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Discordia_GoldenAppleOfDiscord_EnemyToss");
		return ptr;
	}


	bool UsesTrackingTarget();
};


// Class TgGame.TgDevice_Discordia_GoldenAppleOfDiscord_Spread
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Discordia_GoldenAppleOfDiscord_Spread : public ATgDevice_Listener_AOEOnRemove
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Discordia_GoldenAppleOfDiscord_Spread");
		return ptr;
	}


	void STATIC_OnUnequipAsEffectListener();
};


// Class TgGame.TgDevice_Discordia_GoldenAppleOfDiscord
// 0x0004 (0x04FC - 0x04F8)
class ATgDevice_Discordia_GoldenAppleOfDiscord : public ATgDevice_Spline
{
public:
	int                                                m_nMaxTargetingBounces;                                   // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Discordia_GoldenAppleOfDiscord");
		return ptr;
	}


	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	bool STATIC_CalculateFlightPath(int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Discordia_ErraticBehavior
// 0x0010 (0x0508 - 0x04F8)
class ATgDevice_Discordia_ErraticBehavior : public ATgDevice_TweenBase
{
public:
	TArray<class ATgDeployable_Discordia_ErraticBehavior*> s_Deployables;                                            // 0x04F8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Discordia_ErraticBehavior");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDeviceFire_Discordia_ChaosBlast
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Discordia_ChaosBlast : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Discordia_ChaosBlast");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcLinearFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseProximityDistance, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Discordia_TurnAgainst
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Discordia_TurnAgainst : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Discordia_TurnAgainst");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcCustomFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, float fWidth, float fLength, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcWeaponModeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgEffectForm_Discordia_GoldenAppleOfDiscord
// 0x0000 (0x0110 - 0x0110)
class UTgEffectForm_Discordia_GoldenAppleOfDiscord : public UTgEffectForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Discordia_GoldenAppleOfDiscord");
		return ptr;
	}


	void TickUpdateTimer(float TimerPercent);
	class ATgPawn_Discordia* STATIC_GetFxInstigator();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgInventoryObject_Listen_Discordia_ContestOfGods
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Discordia_ContestOfGods : public UTgInventoryObject_Listen
{
public:
	class ATgPawn*                                     m_CurrentContestWinner;                                   // 0x00D0(0x0008)
	int                                                m_nCurrentContestLevel;                                   // 0x00D8(0x0004)
	unsigned long                                      m_bContestEnabled : 1;                                    // 0x00DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Discordia_ContestOfGods");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Discordia_GoldenAppleOfDiscord_EnemyToss
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Discordia_GoldenAppleOfDiscord_EnemyToss : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Discordia_GoldenAppleOfDiscord_EnemyToss");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Discordia_TurnAgainst
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Discordia_TurnAgainst : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Discordia_TurnAgainst");
		return ptr;
	}

};


// Class TgGame.TgPawn_Discordia
// 0x0044 (0x25FC - 0x25B8)
class ATgPawn_Discordia : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_DevicePsv_ContestOfGods;                                // 0x25B8(0x0008)
	class ATgDevice_Discordia_ChaosBlast*              m_DeviceA01_ChaosBlast;                                   // 0x25C0(0x0008)
	class ATgDevice_Discordia_TurnAgainst*             m_DeviceA02_TurnAgainst;                                  // 0x25C8(0x0008)
	class ATgDevice_Discordia_ErraticBehavior*         m_DeviceA03_ErraticBehavior;                              // 0x25D0(0x0008)
	class ATgDevice*                                   m_DeviceA04_GoldenAppleOfDiscord;                         // 0x25D8(0x0008)
	struct FString                                     r_sTargetPlayerName;                                      // 0x25E0(0x0010) (Net, NeedCtorLink)
	int                                                r_nTargetPlayerProfileId;                                 // 0x25F0(0x0004) (Net)
	unsigned long                                      m_bStealthOverrideEnabled : 1;                            // 0x25F4(0x0004)
	unsigned long                                      m_bCurseOfDiscordAchievementEarned : 1;                   // 0x25F4(0x0004)
	unsigned long                                      m_bUltProjectileForwardFacing : 1;                        // 0x25F4(0x0004)
	float                                              m_fUltProjectileHideDelay;                                // 0x25F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Discordia");
		return ptr;
	}


	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_EffectGroupCanBeHardCleared(class UTgEffectGroup* EffectGroup);
	void STATIC_PawnOnSpecialCleanup();
	void AdjustFadeOverlay(float fFadeValue);
	void STATIC_SwapOverlayMICs(TEnumAsByte<EOverlayMICType> Type);
	bool STATIC_GetPassiveString(struct FString* sResult);
	float STATIC_GetSmoothEnergy();
};


// Class TgGame.TgProj_Discordia_GoldenAppleOfDiscord
// 0x0048 (0x0404 - 0x03BC)
class ATgProj_Discordia_GoldenAppleOfDiscord : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:
	unsigned long                                      m_bIsRolling : 1;                                         // 0x03BC(0x0004)
	unsigned long                                      m_bApplyBounceVelocity : 1;                               // 0x03BC(0x0004)
	float                                              m_fGroundDistTraveled;                                    // 0x03C0(0x0004)
	float                                              m_fGroundRange;                                           // 0x03C4(0x0004)
	float                                              m_fRollingDampening;                                      // 0x03C8(0x0004)
	struct FVector                                     m_vBounceVelocity;                                        // 0x03CC(0x000C)
	int                                                m_iNumBounces;                                            // 0x03D8(0x0004)
	TArray<struct FAppleHitInfo>                       m_HitActors;                                              // 0x03DC(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              m_HitActorsThisWallBounce;                                // 0x03EC(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                c_GroundHitFx;                                            // 0x03FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Discordia_GoldenAppleOfDiscord");
		return ptr;
	}


	void STATIC_DelayedHideProjectile();
	void STATIC_HideProjectile();
	void STATIC_RangeReached();
	bool STATIC_CheckTargetDistance(const struct FVector& vLocOverride);
	void STATIC_TargetReached();
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void HitWall(const struct FVector& HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void STATIC_SpawnGroundHitEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_StartCollision();
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Discordia_ChaosBlastMajor
// 0x0014 (0x03C0 - 0x03AC)
class ATgProj_Discordia_ChaosBlastMajor : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_fTravelDistanceOffset;                                  // 0x03AC(0x0004)
	struct FVector                                     m_vDeployableLocation;                                    // 0x03B0(0x000C)
	unsigned long                                      m_bHasDeployableLocation : 1;                             // 0x03BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Discordia_ChaosBlastMajor");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_RangeReached();
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	struct FVector STATIC_GetDeployablePlacement(const struct FVector& HitLoc);
};


// Class TgGame.TgProj_Discordia_ChaosBlastMinor
// 0x0014 (0x03C0 - 0x03AC)
class ATgProj_Discordia_ChaosBlastMinor : public ATgProj_SimulatedPassThrough
{
public:
	struct FVector                                     m_LastBounceLocation;                                     // 0x03AC(0x000C)
	int                                                m_nBounceCount;                                           // 0x03B8(0x0004)
	int                                                m_nMaxBounceCount;                                        // 0x03BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Discordia_ChaosBlastMinor");
		return ptr;
	}


	void HitWall(const struct FVector& HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp);
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
};


// Class TgGame.TgAchievement_Cerberus_SoulExpulsion
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Cerberus_SoulExpulsion : public UTgAchievement
{
public:
	TArray<class ATgPawn*>                             m_SoulConsumedPawns;                                      // 0x0084(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Cerberus_SoulExpulsion");
		return ptr;
	}

};


// Class TgGame.TgDevice_Cerberus_Soul_KillOnTouch
// 0x0004 (0x0528 - 0x0524)
class ATgDevice_Cerberus_Soul_KillOnTouch : public ATgDevice_Aura
{
public:
	unsigned long                                      m_bLanded : 1;                                            // 0x0524(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cerberus_Soul_KillOnTouch");
		return ptr;
	}


	void AuraApplied(class AActor* Other);
};


// Class TgGame.TgDevice_Cerberus_Dev1
// 0x0040 (0x0530 - 0x04F0)
class ATgDevice_Cerberus_Dev1 : public ATgDevice
{
public:
	TArray<class ATgProjectile*>                       s_ActiveProjectiles;                                      // 0x04F0(0x0010) (NeedCtorLink)
	TArray<struct FTerrifyingVisageHitInfo>            s_ActiveTargets;                                          // 0x0500(0x0010) (NeedCtorLink)
	unsigned long                                      m_bSpecialFireLeft : 1;                                   // 0x0510(0x0004)
	unsigned long                                      m_bSpecialFireMiddle : 1;                                 // 0x0510(0x0004)
	unsigned long                                      m_bSpecialFireRight : 1;                                  // 0x0510(0x0004)
	float                                              m_fUpOffset;                                              // 0x0514(0x0004)
	float                                              m_fForwardOffset;                                         // 0x0518(0x0004)
	float                                              m_fRightOffset;                                           // 0x051C(0x0004)
	int                                                m_ProjectileIDs[0x4];                                     // 0x0520(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cerberus_Dev1");
		return ptr;
	}


	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void GetSpecialFireAim(TEnumAsByte<ECerberusHead> HeadType, struct FAimData* Aim);
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void UpdateSpecialFireForm(TEnumAsByte<ECerberusHead> HeadType);
	void DisableSpecialFireRight();
	void DisableSpecialFireMiddle();
	void DisableSpecialFireLeft();
	void EnableSpecialFireRight();
	void EnableSpecialFireMiddle();
	void EnableSpecialFireLeft();
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Cerberus_UltCCImmunity
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Cerberus_UltCCImmunity : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cerberus_UltCCImmunity");
		return ptr;
	}


	void STATIC_OnUnequipAsEffectListener();
	void STATIC_OnEquipAsEffectListener();
};


// Class TgGame.TgDevice_Cerberus_Dev2
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Cerberus_Dev2 : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cerberus_Dev2");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Cerberus_Dev2_V2
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Cerberus_Dev2_V2 : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cerberus_Dev2_V2");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
	void DeliverQueuedPendingHits();
	bool IsInSweetSpot(class AActor* Target, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Cerberus_Dev4_V2
// 0x003C (0x058C - 0x0550)
class ATgDevice_Cerberus_Dev4_V2 : public ATgDevice_LobToTarget
{
public:
	TArray<class ATgPawn*>                             m_AffectedPawns;                                          // 0x0550(0x0010) (NeedCtorLink)
	unsigned long                                      m_bHasTriggeredPull : 1;                                  // 0x0560(0x0004)
	int                                                m_nArrowUltID;                                            // 0x0564(0x0004)
	TArray<class UTgSpecialFx*>                        c_ArrowUltFXs;                                            // 0x0568(0x0010) (NeedCtorLink)
	TArray<class ATgSkeletalMeshActorSpawnable*>       c_ArrowUltMeshes;                                         // 0x0578(0x0010) (NeedCtorLink)
	int                                                r_nTogglePopulateAffectedPawns;                           // 0x0588(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cerberus_Dev4_V2");
		return ptr;
	}


	void Tick(float fDeltaSeconds);
	void ApplyLobFx();
	void STATIC_ClientUpdateAffectedList();
	void STATIC_ClientPopulateAffectedList();
	void TickUpdateUltArrowFX();
	void STATIC_DestroyUltArrowFX(int nIndex);
	void STATIC_CleanupAllUltArrowFX();
	void STATIC_CreateAllUltArrowFX();
	void STATIC_CreateUltArrowFX();
	void TriggerPull();
	void LobPawnToTargetPawn(class ATgPawn* Pawn, class ATgPawn* Target);
};


// Class TgGame.TgDevice_Cerberus_Dev3
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Cerberus_Dev3 : public ATgDevice_TweenBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cerberus_Dev3");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDeviceFire_Cerberus
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Cerberus : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cerberus");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Cerberus_Auto
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Cerberus_Auto : public UTgDeviceFire_Cerberus
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cerberus_Auto");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Cerberus_Dev1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Cerberus_Dev1 : public UTgDeviceFire_Cerberus
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cerberus_Dev1");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceFire_Cerberus_SpawnPet
// 0x0014 (0x01D4 - 0x01C0)
class UTgDeviceFire_Cerberus_SpawnPet : public UTgDeviceFire_Cerberus
{
public:
	int                                                m_SoulGodBotIds[0x5];                                     // 0x01C0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cerberus_SpawnPet");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Cerberus_Dev2
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Cerberus_Dev2 : public UTgDeviceFire_RadialOffsetCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Cerberus_Dev2");
		return ptr;
	}


	void STATIC_CustomFire();
};


// Class TgGame.TgDeviceForm_Cerberus_Dev1
// 0x0004 (0x025C - 0x0258)
class UTgDeviceForm_Cerberus_Dev1 : public UTgDeviceForm_MultiTargeters
{
public:
	unsigned long                                      m_bSpecialFireLeft : 1;                                   // 0x0258(0x0004)
	unsigned long                                      m_bSpecialFireMiddle : 1;                                 // 0x0258(0x0004)
	unsigned long                                      m_bSpecialFireRight : 1;                                  // 0x0258(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Cerberus_Dev1");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target);
	class UTgSpecialFx* GetTargetFX(TEnumAsByte<ECerberusHead> HeadType);
	void UpdateTargeter(TEnumAsByte<ECerberusHead> HeadType);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_GrayOutTargeter(class UTgSpecialFx* TargetModeFx);
};


// Class TgGame.TgDeviceForm_Cerberus_Dev2
// 0x0000 (0x0258 - 0x0258)
class UTgDeviceForm_Cerberus_Dev2 : public UTgDeviceForm_MultiTargeters
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Cerberus_Dev2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Cerberus_Dev1
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Cerberus_Dev1 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Cerberus_Dev1");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Cerberus_Dev3
// 0x0020 (0x00F0 - 0x00D0)
class UTgInventoryObject_Listen_Cerberus_Dev3 : public UTgInventoryObject_Listen
{
public:
	TArray<class ATgPawn_Cerberus_Soul*>               s_ToApplyKnockupActors;                                   // 0x00D0(0x0010) (NeedCtorLink)
	TArray<class ATgPawn_Cerberus_Soul*>               s_ActiveSouls;                                            // 0x00E0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Cerberus_Dev3");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Cerberus_UltCCImmunity
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Cerberus_UltCCImmunity : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Cerberus_UltCCImmunity");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Cerberus_Passive
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_Cerberus_Passive : public UTgInventoryObject_Listen_Effect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Cerberus_Passive");
		return ptr;
	}

};


// Class TgGame.TgPawn_Cerberus
// 0x0060 (0x2618 - 0x25B8)
class ATgPawn_Cerberus : public ATgPawn_Character
{
public:
	class ATgDevice_ChainedMelee*                      m_DeviceA_Auto;                                           // 0x25B8(0x0008)
	class ATgDevice_PassiveAura*                       m_DeviceA_PSV;                                            // 0x25C0(0x0008)
	class ATgDevice_Cerberus_Dev1*                     m_DeviceA_01;                                             // 0x25C8(0x0008)
	class ATgDevice_Cerberus_Dev2_V2*                  m_DeviceA_02;                                             // 0x25D0(0x0008)
	class ATgDevice_Cerberus_Dev3*                     m_DeviceA_03;                                             // 0x25D8(0x0008)
	class ATgDevice_Cerberus_Dev4_V2*                  m_DeviceA_04;                                             // 0x25E0(0x0008)
	unsigned long                                      r_A01_bSpecialFireLeft : 1;                               // 0x25E8(0x0004) (Net)
	unsigned long                                      r_A01_bSpecialFireMiddle : 1;                             // 0x25E8(0x0004) (Net)
	unsigned long                                      r_A01_bSpecialFireRight : 1;                              // 0x25E8(0x0004) (Net)
	unsigned long                                      c_A04_bTickUltTargetFX : 1;                               // 0x25E8(0x0004)
	unsigned long                                      r_A04_bStartedFiring : 1;                                 // 0x25E8(0x0004) (Net)
	unsigned long                                      r_A04_bDeactivateUltTargeter : 1;                         // 0x25E8(0x0004) (Net)
	TEnumAsByte<ECerberusA01Anims>                     m_A01_AnimState;                                          // 0x25EC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x25ED(0x0003) MISSED OFFSET
	int                                                m_A04_nUltTargeterID;                                     // 0x25F0(0x0004)
	class UTgSpecialFx*                                c_A04_UltFXTargeter;                                      // 0x25F4(0x0008)
	class ATgSkeletalMeshActor*                        c_A04_UltTargeterMesh;                                    // 0x25FC(0x0008)
	struct FVector                                     r_A04_UltLocation;                                        // 0x2604(0x000C) (Net)
	float                                              r_A04_fUltDistance;                                       // 0x2610(0x0004) (Net)
	float                                              m_A04_fTargeterDuration;                                  // 0x2614(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Cerberus");
		return ptr;
	}


	void DeactivateUltTargeter();
	void STATIC_SetA01FireMode(int nFireMode);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void UpdateA01AnimState();
	bool PostPawnSetup();
	void ResetUltTargetFXTick();
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_SetUltFX();
	void UpdateUltFX();
	void STATIC_ProperlyActivateUltFX();
	bool STATIC_InitializeUltFx();
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_SetupA01SpecialFire(TEnumAsByte<ECerberusHead> HeadToSetup);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_OnPawnDied();
};


// Class TgGame.TgPawn_Cerberus_Soul
// 0x0048 (0x24AC - 0x2464)
class ATgPawn_Cerberus_Soul : public ATgPawn_Familiar
{
public:
	class ATgDevice*                                   m_DeviceA_PSV;                                            // 0x2464(0x0008)
	class ATgPawn*                                     r_OwnerPawn;                                              // 0x246C(0x0008) (Net)
	class ATgPawn*                                     r_ConnectedPawn;                                          // 0x2474(0x0008) (Net)
	int                                                r_nMeshOverrideId;                                        // 0x247C(0x0004) (Net)
	TEnumAsByte<ECerberusSoul>                         r_SoulState;                                              // 0x2480(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2481(0x0003) MISSED OFFSET
	unsigned long                                      s_bIsGod : 1;                                             // 0x2484(0x0004)
	unsigned long                                      s_bDied : 1;                                              // 0x2484(0x0004)
	float                                              m_fPhysicalProtectionStolen;                              // 0x2488(0x0004)
	float                                              m_fMagicalProtectionStolen;                               // 0x248C(0x0004)
	class UTgDeviceFire*                               s_OwnerDevFire;                                           // 0x2490(0x0008)
	int                                                m_SoulFXSetIds[0x3];                                      // 0x2498(0x0004) (Const)
	class UMaterialInstanceConstant*                   m_SoulMaterialInstanceConstant;                           // 0x24A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Cerberus_Soul");
		return ptr;
	}


	void Suicide();
	void Tick(float DeltaSeconds);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void ApplySoulMICFx();
	float STATIC_GetMagicalProtection();
	float STATIC_GetPhysicalProtection();
	void STATIC_FireRedirectDamageProjectiles(const struct FImpactInfo& redirectImpact, class ATgPawn* HitPawn, class UTgEffectGroup* EffectGroup);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
};


// Class TgGame.TgProj_Cerberus_Dev1
// 0x0004 (0x03B0 - 0x03AC)
class ATgProj_Cerberus_Dev1 : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_fForwardOffset;                                         // 0x03AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Cerberus_Dev1");
		return ptr;
	}

};


// Class TgGame.TgProj_Cerberus_Dev4
// 0x0088 (0x0454 - 0x03CC)
class ATgProj_Cerberus_Dev4 : public ATgProj_SimulatedSeeking
{
public:
	struct FImpactInfo                                 m_RedirectImpact;                                         // 0x03CC(0x0078) (Component)
	class ATgPawn*                                     m_SourcePawn;                                             // 0x0444(0x0008)
	class UTgEffectGroup*                              m_SourceEffectGroup;                                      // 0x044C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Cerberus_Dev4");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgAchievement_Achilles_CrowdCheers
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_Achilles_CrowdCheers : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nTargetAmount;                                          // 0x0088(0x0004)
	int                                                m_nHealCount;                                             // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Achilles_CrowdCheers");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendList_God94_Dev3
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendList_God94_Dev3 : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_God94*                               owningPawn;                                               // 0x0168(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_God94_Dev3");
		return ptr;
	}


	void STATIC_ReplayAnim();
};


// Class TgGame.TgDevice_God94_Dev3
// 0x0020 (0x055C - 0x053C)
class ATgDevice_God94_Dev3 : public ATgDevice_Charge_MovementAim
{
public:
	unsigned long                                      r_bIsSpecialCooldown : 1;                                 // 0x053C(0x0004) (Net)
	unsigned long                                      r_bWillSwap : 1;                                          // 0x053C(0x0004) (Net)
	unsigned long                                      r_bIsSwapped : 1;                                         // 0x053C(0x0004) (Net)
	int                                                m_nCurrentSkipCount;                                      // 0x0540(0x0004)
	int                                                m_nMaxSkipCount;                                          // 0x0544(0x0004) (Const)
	float                                              m_fTimerLength;                                           // 0x0548(0x0004) (Const)
	class ATgPawn_God94*                               r_GodOwner;                                               // 0x054C(0x0008) (Const, Net)
	class ATgDevice_God94_Dev3_Shooter*                r_ChildG94Dev;                                            // 0x0554(0x0008) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God94_Dev3");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void SpecialConsumePowerPool();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
	void DeviceCleanup(bool bForceCleanup);
	void STATIC_OnChargeEnd();
	bool CanBeCanceled();
	void STATIC_SwapChildForDevice();
	void STATIC_SwapDeviceForChild();
	void STATIC_RefreshStacks();
	bool IsToggledOn();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void AttemptSpecialCooldownSetup();
};


// Class TgGame.TgDevice_God94_Dev4
// 0x001C (0x0564 - 0x0548)
class ATgDevice_God94_Dev4 : public ATgDevice_DoubleCharge
{
public:
	unsigned long                                      r_bCanRefire : 1;                                         // 0x0548(0x0004) (Net)
	unsigned long                                      c_bCanRefire : 1;                                         // 0x0548(0x0004)
	unsigned long                                      m_bRefireLockout : 1;                                     // 0x0548(0x0004)
	unsigned long                                      m_bAppliedTouch : 1;                                      // 0x0548(0x0004)
	float                                              s_fTargetingHighlightRange;                               // 0x054C(0x0004)
	TArray<struct FValidTargetInfo>                    s_ValidTargets;                                           // 0x0550(0x0010) (NeedCtorLink)
	int                                                m_nSuccesses;                                             // 0x0560(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God94_Dev4");
		return ptr;
	}


	void InterruptFiring();
	void ClearLockout();
	float GetLockoutTime();
	float GetAimTime();
	bool Use();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void ApplyKillEffects();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	bool STATIC_CanApplyTargetingFX(class AActor* A, class UTgDeviceFire* DeviceMode, bool bPredicting);
	bool UsesCachedAim();
};


// Class TgGame.TgDevice_God94_Dev2
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_God94_Dev2 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God94_Dev2");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
	bool CanBeCanceled();
	bool CanJumpWhileFiring();
};


// Class TgGame.TgDevice_God94_Dev3_Shooter
// 0x000C (0x04FC - 0x04F0)
class ATgDevice_God94_Dev3_Shooter : public ATgDevice
{
public:
	class ATgDevice_God94_Dev3*                        r_ParentG94Dev;                                           // 0x04F0(0x0008) (Net)
	unsigned long                                      r_bAllowFire : 1;                                         // 0x04F8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God94_Dev3_Shooter");
		return ptr;
	}


	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_God94_PSV
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_God94_PSV : public ATgDevice
{
public:
	TEnumAsByte<EGod94PassiveType>                     r_CurrentPassiveType;                                     // 0x04F0(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F1(0x0003) MISSED OFFSET
	unsigned long                                      c_bActiveTargeter : 1;                                    // 0x04F4(0x0004)
	unsigned long                                      r_bActiveTargeter : 1;                                    // 0x04F4(0x0004) (Net)
	unsigned long                                      r_bInitialized : 1;                                       // 0x04F4(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God94_PSV");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ClientInterrupt();
	void InterruptFiring();
	void RefreshPassiveType();
	void SetPassiveType(TEnumAsByte<EGod94PassiveType> selectedType);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool CanBeInterrupted();
	bool CanJumpWhileFiring();
	bool STATIC_CanFireWhileFalling();
	bool CanBeCanceled();
	void STATIC_FireAmmunition();
	bool IsCurrentTargetingDevice();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceForm_God94_PSV
// 0x0008 (0x0240 - 0x0238)
class UTgDeviceForm_God94_PSV : public UTgDeviceForm
{
public:
	int                                                c_nArmorTargetingModeFxId;                                // 0x0238(0x0004)
	int                                                c_nUnarmorTargetingModeFxId;                              // 0x023C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_God94_PSV");
		return ptr;
	}


	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_God94_Dev2
// 0x0020 (0x00F0 - 0x00D0)
class UTgInventoryObject_Listen_God94_Dev2 : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00D0(0x0004)
	int                                                m_nTotalHeals;                                            // 0x00D4(0x0004)
	int                                                m_nTargetGoal;                                            // 0x00D8(0x0004)
	int                                                m_nHealLimit;                                             // 0x00DC(0x0004)
	TArray<struct FGod94Dev2HealData>                  m_HealData;                                               // 0x00E0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_God94_Dev2");
		return ptr;
	}


	int IsDeviceInstanceTracked(class ATgDevice* Dev, int nFiringInstance);
	void TrackFiringInstance(class ATgDevice* Dev, int nFireInstance);
};


// Class TgGame.TgInventoryObject_Listen_God94_Dev3
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_God94_Dev3 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_God94_Dev3");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_God94_Dev4
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_God94_Dev4 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_God94_Dev4");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_God94_PSV
// 0x0004 (0x00D8 - 0x00D4)
class UTgInventoryObject_Listen_God94_PSV : public UTgInventoryObject_Listen_OnExitStore
{
public:
	unsigned long                                      m_bWasDead : 1;                                           // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_God94_PSV");
		return ptr;
	}


	bool OnEnterStore();
	bool OnExitStore();
};


// Class TgGame.TgPawn_God94
// 0x0084 (0x263C - 0x25B8)
class ATgPawn_God94 : public ATgPawn_Character
{
public:
	class ATgDevice_God94_PSV*                         r_Device_Psv;                                             // 0x25B8(0x0008) (Net)
	class ATgDevice*                                   m_Device_A01;                                             // 0x25C0(0x0008)
	class ATgDevice*                                   m_Device_A02;                                             // 0x25C8(0x0008)
	class ATgDevice_God94_Dev3*                        r_Device_A03;                                             // 0x25D0(0x0008) (Net)
	class ATgDevice_God94_Dev3_Shooter*                r_Device_A03_Shooter;                                     // 0x25D8(0x0008) (Net)
	class ATgDevice_God94_Dev4*                        m_Device_A04;                                             // 0x25E0(0x0008)
	class ATgDevice*                                   r_Device_Inhand;                                          // 0x25E8(0x0008) (Net)
	unsigned long                                      r_bPSVIsArmored : 1;                                      // 0x25F0(0x0004) (Net)
	unsigned long                                      r_bPSVInBase : 1;                                         // 0x25F0(0x0004) (Net)
	unsigned long                                      r_bPSVArmorMeshActive : 1;                                // 0x25F0(0x0004) (Net)
	unsigned long                                      r_bDev3IsSwapped : 1;                                     // 0x25F0(0x0004) (Net)
	unsigned long                                      r_bDev4TimerActive : 1;                                   // 0x25F0(0x0004) (Net)
	float                                              r_nPSVFloat1;                                             // 0x25F4(0x0004) (Net)
	float                                              r_nPSVFloat2;                                             // 0x25F8(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    c_BodyArmorMesh;                                          // 0x25FC(0x0008) (ExportObject, Component, EditInline)
	float                                              r_fArmorColorBlend;                                       // 0x2604(0x0004) (Net)
	float                                              r_fArmorOpacityBlend;                                     // 0x2608(0x0004) (Net)
	float                                              r_fArmorColorSpeed;                                       // 0x260C(0x0004) (Net)
	float                                              r_fArmorOpacitySpeed;                                     // 0x2610(0x0004) (Net)
	float                                              m_fArmorColorSpeed_Base_In;                               // 0x2614(0x0004)
	float                                              m_fArmorColorSpeed_Base_Out;                              // 0x2618(0x0004)
	float                                              m_fArmorOpacitySpeed_Base_In;                             // 0x261C(0x0004)
	float                                              m_fArmorOpacitySpeed_Base_Out;                            // 0x2620(0x0004)
	float                                              m_fArmorMaxOpacity;                                       // 0x2624(0x0004)
	float                                              m_fArmorMaxColor;                                         // 0x2628(0x0004)
	int                                                r_nDev4DebuffCount;                                       // 0x262C(0x0004) (Net)
	int                                                m_nDev4FXTier1;                                           // 0x2630(0x0004)
	int                                                m_nDev4FXTier2;                                           // 0x2634(0x0004)
	int                                                m_nDev4FXTier3;                                           // 0x2638(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_God94");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
	void ManageDev4DebuffFx();
	void ManageDev4TimerFx();
	void ManagePSVArmorMIC();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool PostPawnSetup();
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	void STATIC_OnPawnDied();
	void STATIC_SwapA03SubTargeterOut();
	void STATIC_SwapA03SubTargeterIn();
	void STATIC_CalculatePSVFloat2(class UTgEffectGroup* EffectGroup);
	void STATIC_CalculatePSVFloat1(class UTgEffectGroup* EffectGroup);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_OnMeshSwapped();
	float STATIC_GetBodyArmorOutTime();
	float STATIC_GetBodyArmorInTime();
	void BlendOutBodyArmor();
	void BlendInBodyArmor();
	void ToggleBodyArmorMesh(bool activeArmor);
	void STATIC_CleanUpBodyArmorMesh();
	void ManageBodyArmorMesh(float DeltaTime);
	void STATIC_InitializeBodyArmorMesh();
	void STATIC_CheckTargeterState();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_EffectGroupOnApplied(class UTgEffectGroup* EffectGroup, bool bInterval);
	void STATIC_DeviceOnKilled(class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgAchievement_God95_FearOfTheNight
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_God95_FearOfTheNight : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_God95_FearOfTheNight");
		return ptr;
	}

};


// Class TgGame.TgAchievement_God95_TrueNightmare
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_God95_TrueNightmare : public UTgAchievement
{
public:
	int                                                m_nGodKillCount;                                          // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_God95_TrueNightmare");
		return ptr;
	}

};


// Class TgGame.TgDeployable_God95_A01
// 0x000C (0x03E0 - 0x03D4)
class ATgDeployable_God95_A01 : public ATgDeployable
{
public:
	class ATgPawn_God95*                               m_OwningGod95;                                            // 0x03D4(0x0008)
	unsigned long                                      m_bApplyA02ComboEffects : 1;                              // 0x03DC(0x0004)
	unsigned long                                      m_bHasExploded : 1;                                       // 0x03DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_God95_A01");
		return ptr;
	}


	void STATIC_DetonatedByProjectile(class ATgProj_Simulated* Proj);
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void Explode();
};


// Class TgGame.TgDevice_God95_A03
// 0x0024 (0x0560 - 0x053C)
class ATgDevice_God95_A03 : public ATgDevice_Charge
{
public:
	class ATgPawn_God95*                               r_God95Owner;                                             // 0x053C(0x0008) (Net)
	class ATgDeployable*                               m_InhabitedWallDeployable;                                // 0x0544(0x0008)
	unsigned long                                      r_bLeavingWall : 1;                                       // 0x054C(0x0004) (Net)
	unsigned long                                      m_bHasWallImpact : 1;                                     // 0x054C(0x0004)
	unsigned long                                      s_bHadWallImpactAtFire : 1;                               // 0x054C(0x0004)
	unsigned long                                      s_bUpdateWallImpactAtFire : 1;                            // 0x054C(0x0004)
	unsigned long                                      m_bIsRefireCancelled : 1;                                 // 0x054C(0x0004)
	struct FVector                                     m_WallImpactEndTrace;                                     // 0x0550(0x000C)
	float                                              m_fNudgeVal;                                              // 0x055C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God95_A03");
		return ptr;
	}


	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	bool PredictChargeHit(const struct FVector& ChargeDir, const struct FVector& ChargeStart, float fChargeRange, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	unsigned char STATIC_IncrementFiringInstance();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_God95_A01
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_God95_A01 : public ATgDevice
{
public:
	int                                                s_nLastA02ComboHitGodCount;                               // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God95_A01");
		return ptr;
	}


	struct FVector STATIC_GetSpecificOffset();
	bool STATIC_HasSpecificOffset();
	void STATIC_GetCachedAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_God95_A02
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_God95_A02 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God95_A02");
		return ptr;
	}

};


// Class TgGame.TgDevice_God95_A04_Shooter
// 0x0008 (0x04FC - 0x04F4)
class ATgDevice_God95_A04_Shooter : public ATgDevice_GroundTarget_LockOn
{
public:
	float                                              m_FireIntroTime;                                          // 0x04F4(0x0004)
	float                                              m_FireOutroTime;                                          // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God95_A04_Shooter");
		return ptr;
	}


	bool SimulateStartFire();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_SpawnWarningDeployable();
	float STATIC_GetFireDuration();
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgDevice_God95_A04_Staging
// 0x0010 (0x0538 - 0x0528)
class ATgDevice_God95_A04_Staging : public ATgDevice_Staging
{
public:
	TArray<class ATgPawn*>                             s_WarnedPawns;                                            // 0x0528(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_God95_A04_Staging");
		return ptr;
	}


	void RemoveWarningEffects();
	void SpawnBots();
	void ApplyWarningEffects();
	bool STATIC_FireEndStageDevice();
	void OnStageShooterStopFire(bool bInterrupted);
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	bool CanBeCanceled();
};


// Class TgGame.TgDeviceFire_God95_A02
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_God95_A02 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_God95_A02");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_God95_A04_Staging
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_God95_A04_Staging : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_God95_A04_Staging");
		return ptr;
	}


	class ATgPawn* STATIC_SpawnBotAtTarget(bool bPet, class ATgPawn* PawnTarget);
};


// Class TgGame.TgDeviceFire_God95_A04_Shooter
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_God95_A04_Shooter : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_God95_A04_Shooter");
		return ptr;
	}


	float STATIC_GetMinimumDamageRadius();
	float STATIC_GetDamageRadius();
	float STATIC_GetRange();
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
	void STATIC_Deploy();
};


// Class TgGame.TgDeviceForm_God95_A02
// 0x000C (0x0244 - 0x0238)
class UTgDeviceForm_God95_A02 : public UTgDeviceForm
{
public:
	class UTgSpecialFx*                                c_ExplosionTargeterFx;                                    // 0x0238(0x0008)
	int                                                c_nExplosionTargeterFxId;                                 // 0x0240(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_God95_A02");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingList(TArray<struct FImpactInfo>* ImpactList);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_God95_A03
// 0x000C (0x0250 - 0x0244)
class UTgDeviceForm_God95_A03 : public UTgDeviceForm_LineCone
{
public:
	class UTgSpecialFx*                                c_RefireTargetModeFx;                                     // 0x0244(0x0008)
	int                                                c_nRefireTargetFxId;                                      // 0x024C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_God95_A03");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_God95_A04
// 0x0001 (0x024D - 0x024C)
class UTgDeviceForm_God95_A04 : public UTgDeviceForm_TargetIndicator
{
public:
	unsigned char                                      c_nPreviousStatus;                                        // 0x024C(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_God95_A04");
		return ptr;
	}


	void UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_God95_A03
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_God95_A03 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_God95_A03");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_God95_PSV
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_God95_PSV : public UTgInventoryObject_Listen
{
public:
	class ATgPawn*                                     m_lastDetonatedPawn;                                      // 0x00D0(0x0008)
	float                                              m_fLastDetonationTime;                                    // 0x00D8(0x0004)
	float                                              m_fRepeatTimeDelta;                                       // 0x00DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_God95_PSV");
		return ptr;
	}

};


// Class TgGame.TgPawn_God95
// 0x00E4 (0x269C - 0x25B8)
class ATgPawn_God95 : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_deviceInhand;                                           // 0x25B8(0x0008)
	class ATgDevice*                                   m_devicePsv;                                              // 0x25C0(0x0008)
	class ATgDevice*                                   m_deviceA01;                                              // 0x25C8(0x0008)
	class ATgDevice_God95_A02*                         m_deviceA02;                                              // 0x25D0(0x0008)
	class ATgDevice*                                   m_deviceA02_Sub;                                          // 0x25D8(0x0008)
	class ATgDevice_God95_A03*                         m_deviceA03;                                              // 0x25E0(0x0008)
	class ATgDevice_God95_A04_Staging*                 m_deviceA04;                                              // 0x25E8(0x0008)
	struct FVector                                     m_vDefaultFireLocationOffset;                             // 0x25F0(0x000C)
	struct FVector                                     m_vFlyingFireLocationOffset;                              // 0x25FC(0x000C)
	TEnumAsByte<ETG_POSTURE>                           c_eMovementPosture;                                       // 0x2608(0x0001)
	TEnumAsByte<EGod95UltState>                        r_eUltState;                                              // 0x2609(0x0001) (Net)
	unsigned char                                      r_nTriggerUltimateDismount;                               // 0x260A(0x0001) (Net)
	TEnumAsByte<ETG_POSTURE>                           c_eUltimatePosture;                                       // 0x260B(0x0001)
	TEnumAsByte<EGod95UltState>                        c_ePrevUltState;                                          // 0x260C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x260D(0x0003) MISSED OFFSET
	int                                                c_nMovementPostureId;                                     // 0x2610(0x0004)
	float                                              c_fMovementPostureIdleDelay;                              // 0x2614(0x0004)
	unsigned long                                      r_bA02Stim : 1;                                           // 0x2618(0x0004) (Net)
	unsigned long                                      r_bIsInWall : 1;                                          // 0x2618(0x0004) (Net)
	unsigned long                                      r_bA03ForceRefire : 1;                                    // 0x2618(0x0004) (Net)
	unsigned long                                      r_bUltCancelled : 1;                                      // 0x2618(0x0004) (Net)
	unsigned long                                      r_bInUltimateJump : 1;                                    // 0x2618(0x0004) (Net)
	unsigned long                                      r_bUltimateStim : 1;                                      // 0x2618(0x0004) (Net)
	unsigned long                                      c_bUltFlyingPostProcessActive : 1;                        // 0x2618(0x0004)
	struct FVector                                     r_vWallHitLocation;                                       // 0x261C(0x000C) (Net)
	struct FRotator                                    r_rWallHitRotation;                                       // 0x2628(0x000C) (Net)
	int                                                r_nWallDeployableId;                                      // 0x2634(0x0004) (Net)
	class ATgDeployable*                               c_WallDeployableFx;                                       // 0x2638(0x0008)
	float                                              m_fWallProjSafeDistance;                                  // 0x2640(0x0004)
	float                                              r_fUltimatePreFireTime;                                   // 0x2644(0x0004) (Net)
	struct FVector                                     r_UltTargetLocation;                                      // 0x2648(0x000C) (Net)
	float                                              r_fPostProcessRange;                                      // 0x2654(0x0004) (Net)
	float                                              r_fMapRangeLimit;                                         // 0x2658(0x0004) (Net)
	float                                              r_fInitialDistanceToTarget;                               // 0x265C(0x0004) (Net)
	float                                              m_fPrevDistanceToTarget;                                  // 0x2660(0x0004)
	TArray<class ATgPawn*>                             m_UltPostProcessTargets;                                  // 0x2664(0x0010) (NeedCtorLink)
	class ATgPlayerController*                         c_CachedController;                                       // 0x2674(0x0008)
	class UPostProcessChain*                           c_UltFlyingPostProcessChain;                              // 0x267C(0x0008)
	class UPostProcessChain*                           c_UltPostProcessChain;                                    // 0x2684(0x0008)
	int                                                c_nUltimatePostureId;                                     // 0x268C(0x0004)
	float                                              c_fBoneStr;                                               // 0x2690(0x0004)
	float                                              c_fUltimateJumpTime;                                      // 0x2694(0x0004)
	float                                              c_fLinearPitchMult;                                       // 0x2698(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_God95");
		return ptr;
	}


	float GetWallProjSafeDistance();
	bool CheckProjectileTargetableState(class ATgProjectile* Proj);
	void ApplyPostProcessToEnemies();
	void SetUltPostProcess(class ATgPawn* OtherTarget);
	void ClearUltPostProcess();
	void SetUltFlyingPostProcess();
	void ClearUltFlyingPostProcess();
	bool PostPawnSetup();
	void UpdateUltimateState(bool bShouldBeInUltPosture);
	void StartUltFiringOutro();
	void StartUltFiringLoop();
	bool IsInClassSpecificMovement();
	bool IsInClassSpecificChannel();
	float ApplyPitchLimit(float fPitch);
	void StopUltimateFBAnimIfDead();
	void TriggerUltimateDismount();
	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
	void STATIC_ServerOnRightMousePressed();
	void STATIC_OnRightMousePressed();
	void SetTargetingDevice(class ATgDevice* Dev);
	bool DeviceOverrideLockedDown(class ATgDevice* Dev);
	void ForceFireA03();
	void EmergeFromWall();
	void HideInWall();
	void ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetFireLocationOffset(class ATgDevice* Dev);
	void ClearMovementPosture();
	void ApplyMovementPosture();
	void STATIC_SpawnWallDeployableFx(const struct FVector& DepLocation, const struct FRotator& DepRotation, int DepId);
	void STATIC_InitializeUltPostProcess();
	void STATIC_PostPawnSetupServer();
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	bool STATIC_OverrideDistanceFadeRange();
	void STATIC_EndUltimateJump();
	void STATIC_StartUltimateJump();
	bool STATIC_ShouldAllowOffhandFireLock();
	float STATIC_GetManaCostModifier();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void UpdateClientDevices(bool bForce);
};


// Class TgGame.TgPawn_God95_Bot
// 0x0018 (0x2418 - 0x2400)
class ATgPawn_God95_Bot : public ATgPawn
{
public:
	class ATgPawn_God95*                               r_OwnerGod95;                                             // 0x2400(0x0008) (Net)
	unsigned long                                      s_bTriggerSuicide : 1;                                    // 0x2408(0x0004)
	TEnumAsByte<ETG_POSTURE>                           c_eMovementPosture;                                       // 0x240C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x240D(0x0003) MISSED OFFSET
	int                                                c_nMovementPostureId;                                     // 0x2410(0x0004)
	float                                              c_fMovementPostureIdleDelay;                              // 0x2414(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_God95_Bot");
		return ptr;
	}


	bool ShouldSuppressNameplate();
	void Tick(float DeltaSeconds);
	void ClearMovementPosture();
	void ApplyMovementPosture();
};


// Class TgGame.TgProj_God95_A01
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_God95_A01 : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_God95_A01");
		return ptr;
	}

};


// Class TgGame.TgSkelCon_God95UltBoneScale
// 0x0008 (0x0108 - 0x0100)
class UTgSkelCon_God95UltBoneScale : public USkelControlSingleBone
{
public:
	class ATgPawn_God95*                               m_OwningPawn;                                             // 0x0100(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkelCon_God95UltBoneScale");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BaronSamedi_BrushWithDeath
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_BaronSamedi_BrushWithDeath : public UTgAchievement_AbilityMultiHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BaronSamedi_BrushWithDeath");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BaronSamedi_SpreadTheFun
// 0x0004 (0x00B4 - 0x00B0)
class UTgAchievement_BaronSamedi_SpreadTheFun : public UTgAchievement_AbilityMultiHit
{
public:
	int                                                m_nMinHysteriaThreshold;                                  // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BaronSamedi_SpreadTheFun");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_BaronSamedi_Dev3
// 0x0010 (0x02CC - 0x02BC)
class ATgCollisionProxy_BaronSamedi_Dev3 : public ATgCollisionProxy_Cylinder
{
public:
	class ATgDevice*                                   s_Device;                                                 // 0x02BC(0x0008)
	class UTgDeviceFire*                               s_FireMode;                                               // 0x02C4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_BaronSamedi_Dev3");
		return ptr;
	}


	bool IsTargetAffected(class ATgPawn* Target);
	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void STATIC_OnPlayerRemoved(class ATgPawn* aPawn);
	void STATIC_OnPlayerAdded(class ATgPawn* aPawn);
	bool STATIC_ShouldWarnTarget(class ATgPawn* Target);
	void AttackTarget(class ATgPawn* Target);
	void WarnTarget(class ATgPawn* Target);
	void Tick(float DeltaTime);
};


// Class TgGame.TgCollisionProxy_Vortex_BaronSamedi_Dev4
// 0x0024 (0x0304 - 0x02E0)
class ATgCollisionProxy_Vortex_BaronSamedi_Dev4 : public ATgCollisionProxy_Vortex
{
public:
	float                                              m_fConeAngle;                                             // 0x02E0(0x0004)
	float                                              m_fConeRadius;                                            // 0x02E4(0x0004)
	float                                              m_fInnerConeRadius;                                       // 0x02E8(0x0004)
	int                                                m_nHysteriaMinThreshold;                                  // 0x02EC(0x0004)
	int                                                m_nHysteriaMaxThreshold;                                  // 0x02F0(0x0004)
	float                                              m_fHysteriaMinSpeed;                                      // 0x02F4(0x0004)
	float                                              m_fHysteriaMaxSpeed;                                      // 0x02F8(0x0004)
	class ATgDevice_BaronSamedi_Dev4*                  s_BaronUltDev;                                            // 0x02FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Vortex_BaronSamedi_Dev4");
		return ptr;
	}


	bool ShouldIgnoreActor(class ATgPawn* aPawn);
	void Tick(float DeltaTime);
};


// Class TgGame.TgDeployable_BaronSamedi_Dev2
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_BaronSamedi_Dev2 : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_BaronSamedi_Dev2");
		return ptr;
	}


	void STATIC_FireAmmunitionDeployable();
};


// Class TgGame.TgDevice_BaronSamedi_Dev1
// 0x0020 (0x051C - 0x04FC)
class ATgDevice_BaronSamedi_Dev1 : public ATgDevice_Deployable
{
public:
	TArray<class ATgDeployable*>                       s_ActiveDeployables;                                      // 0x04FC(0x0010) (NeedCtorLink)
	TArray<struct FMultiHitInfo>                       s_ActiveTargetInfos;                                      // 0x050C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BaronSamedi_Dev1");
		return ptr;
	}


	bool GetGroundTargetOffset(float* FMin, float* FMax);
	bool ShouldClampGroundTarget();
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_BaronSamedi_Dev2
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_BaronSamedi_Dev2 : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BaronSamedi_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDevice_BaronSamedi_Dev4
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_BaronSamedi_Dev4 : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BaronSamedi_Dev4");
		return ptr;
	}


	void STATIC_ClientStartPostHitDelay();
	void STATIC_InnerRadiusHit(class ATgPawn* Target);
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_BaronSamedi_Dev3
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_BaronSamedi_Dev3 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BaronSamedi_Dev3");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_BaronSamedi_Dev1_Sub
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_BaronSamedi_Dev1_Sub : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BaronSamedi_Dev1_Sub");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceFire_BaronSamedi_Dev2_Sub
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_BaronSamedi_Dev2_Sub : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BaronSamedi_Dev2_Sub");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_BaronSamedi_Inhand
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_BaronSamedi_Inhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BaronSamedi_Inhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_BaronSamedi_Dev1
// 0x0000 (0x0258 - 0x0258)
class UTgDeviceForm_BaronSamedi_Dev1 : public UTgDeviceForm_MultiTargeters
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BaronSamedi_Dev1");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BaronSamedi_Passive
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_BaronSamedi_Passive : public UTgInventoryObject_Listen
{
public:
	class UTgDeviceFire*                               m_CachedFireMode;                                         // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BaronSamedi_Passive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect_BaronSamedi_Hysteria
// 0x0010 (0x00F4 - 0x00E4)
class UTgInventoryObject_Listen_Effect_BaronSamedi_Hysteria : public UTgInventoryObject_Listen_Effect
{
public:
	class UTgDeviceFire*                               m_OwningFireMode;                                         // 0x00E4(0x0008)
	float                                              m_fCurrentStacks;                                         // 0x00EC(0x0004)
	unsigned long                                      m_bIsBaronInCombatWithMe : 1;                             // 0x00F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_BaronSamedi_Hysteria");
		return ptr;
	}


	void STATIC_DecrementHysteria();
	void STATIC_ResetBaronCombatFlag();
	void STATIC_OnRemovedAsListener();
	void STATIC_OnAppliedAsListener();
};


// Class TgGame.TgPawn_BaronSamedi
// 0x0190 (0x2748 - 0x25B8)
class ATgPawn_BaronSamedi : public ATgPawn_Character
{
public:
	class ATgDevice*                                   s_Device_Auto;                                            // 0x25B8(0x0008)
	class ATgDevice*                                   s_Device_PSV;                                             // 0x25C0(0x0008)
	class ATgDevice*                                   s_Device_01;                                              // 0x25C8(0x0008)
	class ATgDevice*                                   s_Device_02;                                              // 0x25D0(0x0008)
	class ATgDevice*                                   s_Device_02_Heal;                                         // 0x25D8(0x0008)
	class ATgDevice*                                   s_Device_03;                                              // 0x25E0(0x0008)
	class ATgDevice*                                   s_Device_04;                                              // 0x25E8(0x0008)
	class UTgSkeletalMeshComponent*                    c_CoffinDeathSkeletalMesh;                                // 0x25F0(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      m_bSpawnDeathCoffin : 1;                                  // 0x25F8(0x0004)
	unsigned long                                      c_dev4_bDefferedSpawnCoffin : 1;                          // 0x25F8(0x0004)
	unsigned long                                      c_dev4_bDefferedCleanupCoffin : 1;                        // 0x25F8(0x0004)
	unsigned long                                      r_dev4_bSpawnVortex : 1;                                  // 0x25F8(0x0004) (Net)
	unsigned char                                      UnknownData00[0x48];                                      // 0x25FC(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgPawn_BaronSamedi.m_psv_UniqueFiringInstanceMap
	unsigned char                                      UnknownData01[0x48];                                      // 0x2644(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgPawn_BaronSamedi.s_dev3_SnakeProxyMap
	unsigned char                                      UnknownData02[0x48];                                      // 0x268C(0x0048) UNKNOWN PROPERTY: MapProperty TgGame.TgPawn_BaronSamedi.s_dev3_SnakeTargetMap
	float                                              r_dev3_fSnakeWarningLifetime;                             // 0x26D4(0x0004) (Net)
	TEnumAsByte<EBaronCoffin>                          r_dev4_eCoffinState;                                      // 0x26D8(0x0001) (Net)
	unsigned char                                      UnknownData03[0x3];                                       // 0x26D9(0x0003) MISSED OFFSET
	class UTgSkeletalMeshComponent*                    c_dev4_CoffinSkeletalMesh;                                // 0x26DC(0x0008) (ExportObject, Component, EditInline)
	class UTgAnimNodeSlot*                             c_dev4_CoffinFullBodyAnimNode;                            // 0x26E4(0x0008)
	float                                              c_dev4_fCoffinCleanupDelay;                               // 0x26EC(0x0004)
	int                                                r_dev4_nSpawnCoffin;                                      // 0x26F0(0x0004) (Net)
	int                                                r_dev4_nCleanupCoffin;                                    // 0x26F4(0x0004) (Net)
	struct FName                                       c_CoffinIntroAnimName;                                    // 0x26F8(0x0008) (Const)
	struct FName                                       c_CoffinLoopAnimName;                                     // 0x2700(0x0008) (Const)
	struct FName                                       c_CoffinOutroMissAnimName;                                // 0x2708(0x0008) (Const)
	struct FName                                       c_CoffinOutroHitAnimName;                                 // 0x2710(0x0008) (Const)
	class ATgCollisionProxy_Vortex_BaronSamedi_Dev4*   m_dev4_Vortex;                                            // 0x2718(0x0008)
	float                                              r_dev4_fDuration;                                         // 0x2720(0x0004) (Net)
	float                                              r_dev4_fConeAngle;                                        // 0x2724(0x0004) (Net)
	float                                              r_dev4_fConeRadius;                                       // 0x2728(0x0004) (Net)
	float                                              r_dev4_fInnerConeRadius;                                  // 0x272C(0x0004) (Net)
	float                                              r_dev4_fVortexPercSlow;                                   // 0x2730(0x0004) (Net)
	float                                              r_dev4_fHysteriaNilSpeed;                                 // 0x2734(0x0004) (Net)
	float                                              r_dev4_fHysteriaMinSpeed;                                 // 0x2738(0x0004) (Net)
	float                                              r_dev4_fHysteriaMaxSpeed;                                 // 0x273C(0x0004) (Net)
	int                                                r_dev4_nHysteriaMinThreshold;                             // 0x2740(0x0004) (Net)
	int                                                r_dev4_nHysteriaMaxThreshold;                             // 0x2744(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BaronSamedi");
		return ptr;
	}


	float GetEffectFormChangeFilterDelay(int nEffectGroupId, float fEffectFormDuration);
	void STATIC_PlayCoffinOutroAnimation(bool bHit);
	void STATIC_PlayCoffinLoopingAnimation();
	void STATIC_SetCoffinDirty(bool bSpawning);
	void STATIC_CleanupCoffin();
	void STATIC_StartCoffinCleanupTimer();
	void STATIC_SpawnCoffin();
	void Destroyed();
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PerformHysteriaEffect(class ATgDevice* HysteriaDev, class UTgDeviceFire* HysteriaDevFire, bool bSpecialCondition, int nCachedHysteria, struct FImpactInfo* Impact);
	void STATIC_CleanupVortex();
	void STATIC_SpawnVortex(class ATgDevice* Dev);
	void AttackWithAnotherSnake(class ATgPawn* Target);
	bool STATIC_ShouldRemoveSnakeEffectGroups(class ATgCollisionProxy_BaronSamedi_Dev3* DyingSnakeProxy, class ATgPawn* Target);
	void STATIC_CleanupSnakeProxy(class AActor* Target);
	void STATIC_SpawnSnakeProxy(class ATgDevice* Dev, class UTgDeviceFire* FireMode, class ATgPawn* Target);
	void STATIC_CleanupHysteria();
	void STATIC_SpawnHysteriaHealProjectile(const struct FVector& SourceLocation, const struct FVector& TargetLocation, const struct FRotator& StartRotation, class ATgDevice* SourceDevice, class AActor* projTarget, bool bApplyingHysteriaEffect, bool bMaxEffect);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnFire(class ATgDevice* Dev);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_BaronSamediSkin
// 0x0014 (0x275C - 0x2748)
class ATgPawn_BaronSamediSkin : public ATgPawn_BaronSamedi
{
public:
	TEnumAsByte<EBaronSamediSkinState>                 r_eBaronSamediSkinState;                                  // 0x2748(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x2749(0x0003) MISSED OFFSET
	struct FPointer                                    m_pAmPetSetup;                                            // 0x274C(0x0008) (Const, Native)
	float                                              m_fPetSpawnSecs;                                          // 0x2754(0x0004) (Const)
	int                                                m_nPetId;                                                 // 0x2758(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BaronSamediSkin");
		return ptr;
	}


	void STATIC_OnSkinLevelChanged();
	void LevelUpSkin(unsigned char NewSkinLevel);
	void STATIC_DespawnPet();
	void STATIC_SpawnPet();
	void STATIC_PawnOnRevive();
	void STATIC_PawnOnDied(class AController* pKiller);
	void STATIC_PostPawnSetupServer();
	struct FString STATIC_GetEmoteCustomSuffix(TEnumAsByte<EEmote> Emote, int ExtraInfo);
	struct FString STATIC_GetVGSCustomSuffix(int nPreferredVPSetting);
	void STATIC_OnLevelUp(int nLevel);
};


// Class TgGame.TgProj_BaronSamedi_Dev2_Heal
// 0x0004 (0x03D0 - 0x03CC)
class ATgProj_BaronSamedi_Dev2_Heal : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bApplyingHysteriaEffect : 1;                            // 0x03CC(0x0004)
	unsigned long                                      m_bMaxEffect : 1;                                         // 0x03CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BaronSamedi_Dev2_Heal");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool UseAOE();
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgAchievement_Pele_GetErupted
// 0x0004 (0x00B0 - 0x00AC)
class UTgAchievement_Pele_GetErupted : public UTgAchievement_DeviceMultiHit_ByType
{
public:
	unsigned long                                      m_bHitInner : 1;                                          // 0x00AC(0x0004)
	unsigned long                                      m_bHitMiddle : 1;                                         // 0x00AC(0x0004)
	unsigned long                                      m_bHitOuter : 1;                                          // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Pele_GetErupted");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Pele_EverlastingFlame
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Pele_EverlastingFlame : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nCurrentSuccesses;                                      // 0x0088(0x0004)
	int                                                m_nMaxSuccesses;                                          // 0x008C(0x0004)
	unsigned long                                      m_bPSVTriggered : 1;                                      // 0x0090(0x0004)
	unsigned long                                      m_bPSVIsActive : 1;                                       // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Pele_EverlastingFlame");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Pele_A01
// 0x001C (0x03F8 - 0x03DC)
class ATgDeploy_Pele_A01 : public ATgDeploy_DelayedPulse
{
public:
	unsigned long                                      r_bForceDestroy : 1;                                      // 0x03DC(0x0004) (Net)
	TArray<class ATgProj_SimulatedSeekingPassThrough*> m_Projectiles;                                            // 0x03E0(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                c_TargetLineFx;                                           // 0x03F0(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Pele_A01");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	void DestroyIt(bool bSkipFx);
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void STATIC_HandlePulseFire();
	float GetDelayLength();
	struct FVector STATIC_GetPhysicalFireStartLoc();
	float GetMaxShotCount();
	void STATIC_PreventFire();
};


// Class TgGame.TgDeploy_Pele_A03
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeploy_Pele_A03 : public ATgDeploy_EffectVolume_WithCollision
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Pele_A03");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Pele_A02
// 0x0024 (0x03F8 - 0x03D4)
class ATgDeploy_Pele_A02 : public ATgDeployable
{
public:
	int                                                r_nInnerType;                                             // 0x03D4(0x0004) (Net)
	int                                                r_nMiddleType;                                            // 0x03D8(0x0004) (Net)
	int                                                r_nOuterType;                                             // 0x03DC(0x0004) (Net)
	int                                                r_nFireCount;                                             // 0x03E0(0x0004) (Net)
	int                                                m_nMaxFires;                                              // 0x03E4(0x0004)
	TArray<class AActor*>                              m_PrevHitActors;                                          // 0x03E8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Pele_A02");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void TimeDeviceFiring();
	void ManageFX();
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_InstantFireDeployable();
};


// Class TgGame.TgDeploy_Pele_A04
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeploy_Pele_A04 : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Pele_A04");
		return ptr;
	}


	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDevice_Pele_Inhand
// 0x0000 (0x0538 - 0x0538)
class ATgDevice_Pele_Inhand : public ATgDevice_ChainedMelee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pele_Inhand");
		return ptr;
	}


	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Pele_A04
// 0x000C (0x0548 - 0x053C)
class ATgDevice_Pele_A04 : public ATgDevice_Charge
{
public:
	class UTgDeviceFire*                               m_CachedFire;                                             // 0x053C(0x0008)
	unsigned long                                      m_bHasTarget : 1;                                         // 0x0544(0x0004)
	unsigned long                                      m_bAppliedEffect : 1;                                     // 0x0544(0x0004)
	unsigned long                                      r_bCharging : 1;                                          // 0x0544(0x0004) (Net)
	unsigned long                                      c_bSkipCharge : 1;                                        // 0x0544(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pele_A04");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void DoSecondaryFire(class AActor* HitActor, bool bFreeCast);
	void STATIC_ClientForcePostFire();
	struct FImpactInfo STATIC_CalcCustomTargetingFire(class AActor* DamageInstigator, class UTgDeviceFire* devFire, const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	float STATIC_GetConePullbackDistance();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Pele_A02
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Pele_A02 : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pele_A02");
		return ptr;
	}


	int GetOuterFireType();
	int GetMiddleFireType();
	int GetInnerFireType();
	void OnDeployableSpawned(class ATgDeployable* deployable);
};


// Class TgGame.TgDevice_Pele_A03
// 0x0004 (0x0500 - 0x04FC)
class ATgDevice_Pele_A03 : public ATgDevice_HitPulse
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                                       // 0x04FC(0x0004) (Net)
	unsigned long                                      r_bIsBuffed : 1;                                          // 0x04FC(0x0004) (Net)
	unsigned long                                      c_bSkipStart : 1;                                         // 0x04FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pele_A03");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	float GetMinEnergy(unsigned char FireModeNum);
	float GetEnergyCost(unsigned char FireModeNum);
	void HandleBuffState();
	void HandleActiveState();
	float GetPersistTime(int nMode);
	bool ApplyGlobalOffhandCooldown();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool ShouldInterruptInhand();
	bool CanJumpWhileFiring();
	bool CanBeCanceled();
	bool IsToggleDevice();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ShouldTriggerCastReactionItems();
	bool SimulateStartFire();
	void STATIC_ServerStartFire(const struct FAimData& ClientAim, float EndTraceX, float EndTraceY, int nCompressedRot);
	bool Use();
	void FirePostHitDelay();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void UpdateDeviceUsedState();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Pele_A03_Sub
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Pele_A03_Sub : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pele_A03_Sub");
		return ptr;
	}


	void STATIC_EndSecondaryTargeting();
	void BeginSecondaryTargeting();
	bool ShouldTriggerCastReactionItems();
};


// Class TgGame.TgDevice_Pele_A01
// 0x0008 (0x0508 - 0x0500)
class ATgDevice_Pele_A01 : public ATgDevice_WithAmmo
{
public:
	int                                                m_nTrackingMode;                                          // 0x0500(0x0004)
	unsigned long                                      m_bOwnerWasDead : 1;                                      // 0x0504(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Pele_A01");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void ResetCooldown(int nMode, float fCooldownTimeOverride);
	void EndCooldown();
	void StartCooldown(int nMode, float fCooldownTimeOverride);
	bool ShouldCooldownAfterFire();
	void DisplayAmmoCount(int nCount);
	void SetAmmoCount(int nAmmoCount, bool bDoNotFowardToClient);
	void GrantAmmo();
	float GetRegainTime();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_GetReticleTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Pele_A03
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Pele_A03 : public UTgDeviceFire_ConditionalHitType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Pele_A03");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
	bool STATIC_ShouldUseHitSpecial(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceFire_Pele_Inhand
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Pele_Inhand : public UTgDeviceFire_ConditionalHitType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Pele_Inhand");
		return ptr;
	}


	bool STATIC_ShouldUseHitSpecial(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Pele_A02_Sub
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Pele_A02_Sub : public UTgDeviceFire
{
public:
	int                                                m_nCurrentFireType;                                       // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Pele_A02_Sub");
		return ptr;
	}


	float GetOuterTimer();
	float GetOuterMinRadius();
	float GetMiddleTimer();
	float GetMiddleMinRadius();
	float GetInnerTimer();
	float GetInnerMinRadius();
	float GetRefireTime();
	float STATIC_GetMinimumRadius();
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceFire_Pele_A04
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Pele_A04 : public UTgDeviceFire
{
public:
	int                                                m_nMaxConeTargetCount;                                    // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Pele_A04");
		return ptr;
	}


	float STATIC_GetSpawnOffsetValue();
	struct FVector STATIC_GetSpawnOffset(const struct FAimData& Aim);
	void STATIC_Deploy();
	struct FImpactInfo STATIC_CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceForm_Pele_Inhand
// 0x0004 (0x0250 - 0x024C)
class UTgDeviceForm_Pele_Inhand : public UTgDeviceForm_AlternateFX
{
public:
	unsigned long                                      m_bIsValidTargeter : 1;                                   // 0x024C(0x0004)
	unsigned long                                      m_bWasValidTargeter : 1;                                  // 0x024C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Pele_Inhand");
		return ptr;
	}


	bool STATIC_CustomShouldBeActive();
};


// Class TgGame.TgDeviceForm_Pele_A04
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Pele_A04 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Pele_A04");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Pele_A02
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Pele_A02 : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Pele_A02");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Pele_A03
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Pele_A03 : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Pele_A03");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Pele_A03
// 0x0000 (0x00D4 - 0x00D4)
class UTgInventoryObject_Listen_Pele_A03 : public UTgInventoryObject_Listen_OnExitStore
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Pele_A03");
		return ptr;
	}


	bool OnEnterStore();
};


// Class TgGame.TgInventoryObject_Listen_Pele_A04
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Pele_A04 : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bIsSecondaryActive : 1;                                 // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Pele_A04");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Pele_Psv
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Pele_Psv : public UTgInventoryObject_Listen_Proc_At_HealthPCT
{
public:
	unsigned long                                      m_bIsActive : 1;                                          // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Pele_Psv");
		return ptr;
	}

};


// Class TgGame.TgPawn_Pele
// 0x0054 (0x260C - 0x25B8)
class ATgPawn_Pele : public ATgPawn_Character
{
public:
	class ATgDevice*                                   r_Device_Psv;                                             // 0x25B8(0x0008) (Net)
	class ATgDevice_Pele_Inhand*                       r_Device_Inhand;                                          // 0x25C0(0x0008) (Net)
	class ATgDevice_Pele_A01*                          m_Device_A01;                                             // 0x25C8(0x0008)
	class ATgDevice_Pele_A02*                          m_Device_A02;                                             // 0x25D0(0x0008)
	class ATgDevice_Pele_A03*                          m_Device_A03;                                             // 0x25D8(0x0008)
	class ATgDevice_Pele_A04*                          r_Device_A04;                                             // 0x25E0(0x0008) (Net)
	unsigned long                                      r_bPSVIsActive : 1;                                       // 0x25E8(0x0004) (Net)
	unsigned long                                      r_bA03Active : 1;                                         // 0x25E8(0x0004) (Net)
	unsigned long                                      r_bA04AllowHit : 1;                                       // 0x25E8(0x0004) (Net)
	unsigned long                                      r_bA04ActiveSecondary : 1;                                // 0x25E8(0x0004) (Net)
	int                                                r_nA01CurrentAmmoCount;                                   // 0x25EC(0x0004) (Net)
	float                                              r_fA01AmmoReplenishTime;                                  // 0x25F0(0x0004) (Net)
	int                                                r_nA03Type;                                               // 0x25F4(0x0004) (Net)
	int                                                r_nA03PrevType;                                           // 0x25F8(0x0004) (Net)
	int                                                c_A03PostureId;                                           // 0x25FC(0x0004)
	class AActor*                                      r_A04HitActor;                                            // 0x2600(0x0008) (Net)
	float                                              r_fA04OffsetValue;                                        // 0x2608(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Pele");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void ActivatePSVBonus();
	void ToggleA03FX();
	void STATIC_HandlePsvVisuals();
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_SetSpawnEnergy();
	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
};


// Class TgGame.TgProj_Pele_A01
// 0x0000 (0x03C0 - 0x03C0)
class ATgProj_Pele_A01 : public ATgProj_SimulatedPassThrough_SpawnDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Pele_A01");
		return ptr;
	}


	struct FVector STATIC_GetDeployablePlacement(const struct FVector& HitLoc);
	struct FVector STATIC_GetDeployableExtent();
};


// Class TgGame.TgAchievement_Hera_ArgusKills
// 0x0004 (0x008C - 0x0088)
class UTgAchievement_Hera_ArgusKills : public UTgAchievement_FamiliarGetsXKills
{
public:
	int                                                m_nDeviceId;                                              // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Hera_ArgusKills");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Hera_RoyalAssault
// 0x0018 (0x009C - 0x0084)
class UTgAchievement_Hera_RoyalAssault : public UTgAchievement
{
public:
	TArray<struct FRoyalAssaultData>                   m_TrackedData;                                            // 0x0084(0x0010) (NeedCtorLink)
	int                                                m_nDeviceId;                                              // 0x0094(0x0004)
	int                                                m_nTargetCount;                                           // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Hera_RoyalAssault");
		return ptr;
	}


	void UpdateTrackedData(class AActor* HitActor, class ATgDevice* Dev);
};


// Class TgGame.TgDeploy_Hera_Dev1
// 0x001C (0x0400 - 0x03E4)
class ATgDeploy_Hera_Dev1 : public ATgDeploy_ProjectileOwner
{
public:
	TArray<class ATgSkeletalMeshActorSpawnable_HeraArms*> c_ArmMeshes;                                              // 0x03E4(0x0010) (NeedCtorLink)
	int                                                m_nLeftArmMeshID;                                         // 0x03F4(0x0004)
	int                                                m_nRightArmMeshID;                                        // 0x03F8(0x0004)
	unsigned long                                      m_bHasFiredFirstShot : 1;                                 // 0x03FC(0x0004)
	unsigned long                                      r_bIsSpawning : 1;                                        // 0x03FC(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Hera_Dev1");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_FireAmmunitionDeployable();
	void DestroyIt(bool bSkipFx);
	float STATIC_GetProjectileIDOverride();
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	struct FVector STATIC_GetPhysicalFireStartLoc();
	struct FVector GetRightMeshSpawnLoc();
	struct FVector GetLeftMeshSpawnLoc();
	class AProjectile* STATIC_ProjectileFireDeployable();
	float GetArmMeshScale();
	float GetArmHeightOffset();
	float GetArmMeshSpeed();
	float GetAnimDelayTime();
	void STATIC_DestroyArmMeshes();
	void STATIC_PlayArmAnim();
	void STATIC_CreateArmMeshes();
};


// Class TgGame.TgDevice_Argus_Explosion
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Argus_Explosion : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Argus_Explosion");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Hera_Dev3
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_Hera_Dev3 : public ATgDevice_ActiveAura_VisualToggle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hera_Dev3");
		return ptr;
	}


	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
};


// Class TgGame.TgDevice_Argus_Aura
// 0x0004 (0x0528 - 0x0524)
class ATgDevice_Argus_Aura : public ATgDevice_Aura
{
public:
	unsigned long                                      m_bAuraIsActive : 1;                                      // 0x0524(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Argus_Aura");
		return ptr;
	}


	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void Tick(float DeltaTime);
	bool STATIC_ShouldAuraBeActive();
	void EndAura();
	void BeginAura();
	bool IsAuraActive();
	bool STATIC_HasBeenTrained();
};


// Class TgGame.TgDevice_Hera_Dev1
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Hera_Dev1 : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hera_Dev1");
		return ptr;
	}


	void STATIC_OutroLockout();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_GetValidPushLocation(class ATgPawn* Target, struct FVector* OutLocation);
	void TryToPushBack(class ATgPawn* Target);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Hera_Dev4
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Hera_Dev4 : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hera_Dev4");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void STATIC_FireAmmunition();
	void InstantFire();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool IsToggledOn();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool UsesTargetingMode();
	bool STATIC_HasBeenTrained();
	bool AllocateDevicePoint();
};


// Class TgGame.TgDevice_Hera_Dev4_Sub
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Hera_Dev4_Sub : public ATgDevice_Hera_Dev4
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hera_Dev4_Sub");
		return ptr;
	}


	bool ApplyGlobalOffhandCooldown();
};


// Class TgGame.TgDeviceFire_Hera_Dev4
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Hera_Dev4 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hera_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Hera_Dev1
// 0x0000 (0x0258 - 0x0258)
class UTgDeviceForm_Hera_Dev1 : public UTgDeviceForm_MultiTargeters
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hera_Dev1");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Hera_Dev2
// 0x0008 (0x011C - 0x0114)
class UTgEffectForm_Hera_Dev2 : public UTgEffectForm_DisablePawn
{
public:
	class UMeshComponent*                              m_Mesh;                                                   // 0x0114(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Hera_Dev2");
		return ptr;
	}


	void STATIC_DetachMeshes();
	void AttachMeshes(class AActor* pOwner);
	void AdjustHidden();
	void Detach();
	void STATIC_Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgInventoryObject_Listen_Hera_A01
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Hera_A01 : public UTgInventoryObject_Listen
{
public:
	TArray<class AActor*>                              s_SlamList;                                               // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Hera_A01");
		return ptr;
	}

};


// Class TgGame.TgPawn_Hera
// 0x00DC (0x2694 - 0x25B8)
class ATgPawn_Hera : public ATgPawn_Character
{
public:
	TArray<int>                                        s_PolymorphMeshIds;                                       // 0x25B8(0x0010) (Const, NeedCtorLink)
	struct FHeraPolymorphPair                          r_PolymorphMeshMap[0x14];                                 // 0x25C8(0x0008) (Net)
	TArray<class ATgPawn*>                             m_PolymorphTargets;                                       // 0x2668(0x0010) (NeedCtorLink)
	class ATgPawn_Hera_Argus*                          r_ArgusPawn;                                              // 0x2678(0x0008) (Net)
	class ATgPawn*                                     r_ArgusTarget;                                            // 0x2680(0x0008) (Net)
	class ATgPawn*                                     m_OldArgusTarget;                                         // 0x2688(0x0008)
	unsigned long                                      s_bClearingOldTarget : 1;                                 // 0x2690(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Hera");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	void SetArgusTarget(class ATgPawn* NewTarget);
	void STATIC_SendDev4ToggleEvent();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void ResetUltTargeting();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_PostPawnSetupServer();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_OnPetDead(class ATgPawn* PetPawn);
	void STATIC_SetPet(class ATgPawn* PetPawn);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	float STATIC_GetArgusRetargetRange();
	float STATIC_GetArgusLeashRange();
	void AutoSelectArgusTarget();
};


// Class TgGame.TgPawn_Hera_Argus
// 0x0004 (0x2494 - 0x2490)
class ATgPawn_Hera_Argus : public ATgPawn_Familiar_LongTerm
{
public:
	unsigned long                                      m_bHasFiredExplosion : 1;                                 // 0x2490(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Hera_Argus");
		return ptr;
	}


	void STATIC_OnTeleportToBaseNotify(class AActor* TeleportingActor);
	void STATIC_PostTeleport(class ATeleporter* OutTeleporter);
	bool IsPet();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void Tick(float DeltaSeconds);
	bool STATIC_GetSpecialTargetAI(class ATgPawn** NewTarget);
	void MoveToDesiredRelativePosition();
	struct FVector STATIC_GetDesiredRelativePosition();
	void STATIC_TeleportToOwner();
	void STATIC_OnOwnerPostTeleport();
};


// Class TgGame.TgProj_Hera_Dev2
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Hera_Dev2 : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Hera_Dev2");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool UseAOE();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	struct FVector STATIC_GetDeployablePlacement(const struct FVector& HitLoc);
};


// Class TgGame.TgProj_Hera_Dev1_Arms
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Hera_Dev1_Arms : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Hera_Dev1_Arms");
		return ptr;
	}


	bool UseAOE();
	void CheckRangeAtLimit();
	void STATIC_RangeReached();
};


// Class TgGame.TgSkeletalMeshActorSpawnable_HeraArms
// 0x0004 (0x0320 - 0x031C)
class ATgSkeletalMeshActorSpawnable_HeraArms : public ATgSkeletalMeshActorSpawnable
{
public:
	unsigned long                                      m_bInSmashState : 1;                                      // 0x031C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable_HeraArms");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Knight_The_Legend_Of_Excalibur
// 0x0028 (0x00AC - 0x0084)
class UTgAchievement_Knight_The_Legend_Of_Excalibur : public UTgAchievement
{
public:
	TArray<int>                                        m_nDevices;                                               // 0x0084(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nTracking;                                              // 0x0094(0x0010) (NeedCtorLink)
	float                                              m_fDuration;                                              // 0x00A4(0x0004)
	float                                              m_fMinWorldTime;                                          // 0x00A8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Knight_The_Legend_Of_Excalibur");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Knight_True_Strike
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Knight_True_Strike : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Knight_True_Strike");
		return ptr;
	}

};


// Class TgGame.TgDevice_Knight_Dev4B
// 0x0008 (0x056C - 0x0564)
class ATgDevice_Knight_Dev4B : public ATgDevice_Charge_ChainSubDevice
{
public:
	class ATgPawn*                                     m_StunnedPawn;                                            // 0x0564(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev4B");
		return ptr;
	}


	void OnSubDeviceStopFire(class ATgDevice* devSub);
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	void STATIC_OnChargeEnd();
	int STATIC_GetSubDeviceIndex();
	void STATIC_RemoveCripple();
	void ApplyCripple();
	void CleanUpDevice();
	bool STATIC_ShouldUpdateTimer();
};


// Class TgGame.TgDevice_Knight_Auto
// 0x0010 (0x054C - 0x053C)
class ATgDevice_Knight_Auto : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bShouldCharge : 1;                                      // 0x053C(0x0004)
	unsigned long                                      c_bServerStartedFire : 1;                                 // 0x053C(0x0004) (Transient)
	unsigned long                                      m_bHandledEndChargeLogic : 1;                             // 0x053C(0x0004) (Transient)
	unsigned long                                      s_bGotClientAim : 1;                                      // 0x053C(0x0004) (Transient)
	float                                              m_fClearChargeDelay;                                      // 0x0540(0x0004)
	class ATgPawn*                                     m_LockOnTarget;                                           // 0x0544(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Auto");
		return ptr;
	}


	void STATIC_ClearHasCharged();
	float GetChargeRange();
	void STATIC_ClientAllowFire();
	void STATIC_CooldownTimerExpired(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	void DeliverQueuedPendingHits();
	void STATIC_OnChargeStart();
	class ATgPawn* STATIC_GetAndCacheLockOnTarget();
	void STATIC_StartChargePhysics();
	void STATIC_OnChargeEnd();
	void STATIC_ServerStartFire(const struct FAimData& ClientAim, float EndTraceX, float EndTraceY, int nCompressedRot);
	bool StartFire();
	void STATIC_ProcessChargeNumber(int nChargeNumber);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	struct FAimData STATIC_CacheAim();
};


// Class TgGame.TgDevice_Knight_Dev2B
// 0x0004 (0x0540 - 0x053C)
class ATgDevice_Knight_Dev2B : public ATgDevice_Charge
{
public:
	unsigned long                                      r_bShouldKnockup : 1;                                     // 0x053C(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev2B");
		return ptr;
	}


	void STATIC_ClientEndPhysCharge();
	bool CanBeCanceled();
	void STATIC_OnChargeEnd();
	bool STATIC_ShouldUpdateTimer();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Knight_Dev3B
// 0x0004 (0x0500 - 0x04FC)
class ATgDevice_Knight_Dev3B : public ATgDevice_HitPulse
{
public:
	unsigned long                                      s_bDoingStrikeAttack : 1;                                 // 0x04FC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev3B");
		return ptr;
	}


	bool CanBeCanceled();
	void STATIC_EndDeviceCharge(bool bWasInterrupted);
	void CleanUpDevice(bool bWasInterrupted);
	void DeliverQueuedPendingHits();
	void STATIC_DoStrikeAttack();
	bool STATIC_ShouldUpdateTimer();
};


// Class TgGame.TgDevice_Knight_Dev4B_Sub
// 0x0034 (0x0530 - 0x04FC)
class ATgDevice_Knight_Dev4B_Sub : public ATgDevice_HitPulse
{
public:
	class ATgPawn*                                     m_TargetPawn;                                             // 0x04FC(0x0008)
	class ATgPawn*                                     s_FinalExplosionTargetPawn;                               // 0x0504(0x0008)
	struct FVector                                     s_vTargetReturnLocation;                                  // 0x050C(0x000C)
	struct FVector                                     s_vInstigatorStartLocation;                               // 0x0518(0x000C)
	unsigned long                                      s_bHasCleanedUp : 1;                                      // 0x0524(0x0004)
	unsigned long                                      s_bWantsCleanup : 1;                                      // 0x0524(0x0004)
	unsigned long                                      s_bTargetDiedMidAir : 1;                                  // 0x0524(0x0004)
	unsigned long                                      s_bHasRestoredTargetCollisions : 1;                       // 0x0524(0x0004)
	class UTgDeviceFire*                               s_FinalExplosionMode;                                     // 0x0528(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev4B_Sub");
		return ptr;
	}


	void STATIC_CleanupStates();
	void InterruptFiring();
	struct FImpactInfo STATIC_CreateTargetImpact();
	void STATIC_CustomFire();
	void STATIC_DoFinalExplosion();
	void STATIC_DoFinalSmash();
	void SetFinalSmashTimer();
	bool IsUltimateDevice();
	bool IsValidGroundLoc(const struct FVector& GroundLoc, const struct FVector& Extent);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_GetCachedAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Knight_Dev1A
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Knight_Dev1A : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev1A");
		return ptr;
	}


	void STATIC_FireAmmunition();
	bool STATIC_ShouldUpdateTimer();
};


// Class TgGame.TgDevice_Knight_Dev1B
// 0x0024 (0x0514 - 0x04F0)
class ATgDevice_Knight_Dev1B : public ATgDevice
{
public:
	unsigned long                                      m_bIsStriking : 1;                                        // 0x04F0(0x0004)
	TArray<class ATgProjectile*>                       s_ActiveProjectiles;                                      // 0x04F4(0x0010) (NeedCtorLink)
	TArray<struct FMultiHitInfo>                       s_ActiveTargetInfos;                                      // 0x0504(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev1B");
		return ptr;
	}


	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void STATIC_FireAmmunition();
	bool STATIC_ShouldUpdateTimer();
};


// Class TgGame.TgDevice_Knight_Dev2A
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Knight_Dev2A : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev2A");
		return ptr;
	}


	void DeliverQueuedPendingHits();
	bool STATIC_ShouldUpdateTimer();
};


// Class TgGame.TgDevice_Knight_Dev4A
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Knight_Dev4A : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev4A");
		return ptr;
	}


	void STATIC_FireAmmunition();
	bool STATIC_ShouldUpdateTimer();
};


// Class TgGame.TgDevice_Knight_Dev3A
// 0x001C (0x0564 - 0x0548)
class ATgDevice_Knight_Dev3A : public ATgDevice_RadialSweep_IndependentSpeed
{
public:
	TEnumAsByte<EKnightDev3AState>                     m_eAttackState;                                           // 0x0548(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0549(0x0003) MISSED OFFSET
	int                                                m_nSpeedSequence;                                         // 0x054C(0x0004) (Transient)
	float                                              m_fSweepTimeA;                                            // 0x0550(0x0004)
	float                                              m_fSweepTimeB;                                            // 0x0554(0x0004)
	float                                              m_fUpdateSweepTime;                                       // 0x0558(0x0004)
	float                                              m_fSweepSpeedA;                                           // 0x055C(0x0004)
	float                                              m_fSweepSpeedB;                                           // 0x0560(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev3A");
		return ptr;
	}


	bool CanBeInterrupted();
	void UpdateSweepSpeed();
	void STATIC_DoChargeForward();
	void STATIC_DoStrikeAttack();
	bool STATIC_ShouldUpdateTimer();
};


// Class TgGame.TgDeviceFire_Knight_Dev1B
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Knight_Dev1B : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Knight_Dev1B");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
	float STATIC_GetRange();
};


// Class TgGame.TgDeviceFire_Knight_Dev2B
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Knight_Dev2B : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Knight_Dev2B");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	float STATIC_GetDamageRadius();
	float STATIC_GetRange();
};


// Class TgGame.TgDeviceFire_Knight_Dev3A
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Knight_Dev3A : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Knight_Dev3A");
		return ptr;
	}


	float STATIC_GetRange();
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceForm_Knight_Dev4B_Sub
// 0x0044 (0x027C - 0x0238)
class UTgDeviceForm_Knight_Dev4B_Sub : public UTgDeviceForm
{
public:
	int                                                m_nMeshId;                                                // 0x0238(0x0004) (Const)
	float                                              m_fTweenTime;                                             // 0x023C(0x0004)
	struct FVector                                     c_vTargetReturnLocation;                                  // 0x0240(0x000C)
	float                                              c_fTweenDist;                                             // 0x024C(0x0004)
	unsigned long                                      c_bTweening : 1;                                          // 0x0250(0x0004)
	unsigned long                                      c_bShouldInitializeSpinMeshActorNextTick : 1;             // 0x0250(0x0004)
	unsigned long                                      c_bBaseRequired : 1;                                      // 0x0250(0x0004)
	class ATgSkeletalMeshActor*                        c_SpinMeshActor;                                          // 0x0254(0x0008)
	class ATgPawn*                                     c_CachedTargetPawn;                                       // 0x025C(0x0008)
	class UTgAnimNodeSlot*                             c_FullBodyNode;                                           // 0x0264(0x0008)
	class UTgCameraModule_Action*                      c_ActionCameraModule;                                     // 0x026C(0x0008)
	int                                                c_nTargetPostureId;                                       // 0x0274(0x0004)
	float                                              c_fSpinMeshRelativeZ;                                     // 0x0278(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Knight_Dev4B_Sub");
		return ptr;
	}


	void TurnOffActionCameraTimer();
	void STATIC_PopTargetPosture();
	void STATIC_PlayFinalSmashAnimation();
	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target);
	void TurnOffActionCamera(class ATgPawn* TargetPawn);
	void TurnOnActionCamera(class ATgPawn* TargetPawn, class ATgPawn_Knight* Knight);
	void STATIC_CleanupSpinMeshActor();
	void STATIC_InitializeSpinMeshActor();
};


// Class TgGame.TgInventoryObject_Listen_Knight_Dev1A
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Knight_Dev1A : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Knight_Dev1A");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Knight_PSV
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Knight_PSV : public UTgInventoryObject_Listen
{
public:
	TArray<struct FKnightFireInstanceData>             m_TrackedFireInstances;                                   // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Knight_PSV");
		return ptr;
	}


	bool IsDeviceInstanceTracked(class ATgDevice* Dev, int nFiringInstance);
	void STATIC_ClearTrackedInstances(int nLength);
	void TrackFiringInstance(class ATgDevice* Dev, int nFiringInstance);
};


// Class TgGame.TgPawn_Knight
// 0x00F4 (0x26AC - 0x25B8)
class ATgPawn_Knight : public ATgPawn_Character
{
public:
	struct FPointer                                    VfTable_ITgPawn_DialogueInterface;                        // 0x25B8(0x0008) (Const, Native, NoExport)
	TEnumAsByte<EKnightStance>                         r_eKnightStance;                                          // 0x25C0(0x0001) (Net)
	TEnumAsByte<EKnightUltStance>                      r_eKnightUltStance;                                       // 0x25C1(0x0001) (Net)
	TEnumAsByte<EKnight4BState>                        r_dev4b_eUltState;                                        // 0x25C2(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x25C3(0x0001) MISSED OFFSET
	class ATgDevice*                                   m_MostRecentlyUsedDevice;                                 // 0x25C4(0x0008)
	TArray<struct FKnightFiringInstance>               m_TrackedDamageInstances;                                 // 0x25CC(0x0010) (NeedCtorLink)
	unsigned long                                      r_bLockDeviceFiring : 1;                                  // 0x25DC(0x0004) (Net)
	unsigned long                                      m_bLockFaceRotation : 1;                                  // 0x25DC(0x0004)
	unsigned long                                      m_auto_bHasCharged : 1;                                   // 0x25DC(0x0004) (Transient)
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               m_NormalEquipSlots;                                       // 0x25E0(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               m_SpartanEquipSlots;                                      // 0x25F0(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               m_UltEquipSlots;                                          // 0x2600(0x0010) (NeedCtorLink)
	int                                                m_nChargeCounter;                                         // 0x2610(0x0004)
	float                                              m_auto_fLockFireTimer;                                    // 0x2614(0x0004)
	float                                              c_auto_fCancelCooldown;                                   // 0x2618(0x0004)
	float                                              m_dev3b_fChargeSpeed;                                     // 0x261C(0x0004)
	float                                              m_dev3b_fSlowSpeedModifier;                               // 0x2620(0x0004)
	class ATgPawn*                                     r_dev4b_TargetPawn;                                       // 0x2624(0x0008) (Net)
	struct FVector                                     r_dev4b_vTargetReturnLocation;                            // 0x262C(0x000C) (Net)
	struct FVector                                     r_dev4B_vTargetOriginalLocation;                          // 0x2638(0x000C) (Net)
	class ATgDevice*                                   s_Device_Auto;                                            // 0x2644(0x0008)
	class ATgDevice*                                   s_Device_Passive;                                         // 0x264C(0x0008)
	class ATgDevice*                                   s_Device_Dev1A;                                           // 0x2654(0x0008)
	class ATgDevice*                                   s_Device_Dev2A;                                           // 0x265C(0x0008)
	class ATgDevice*                                   s_Device_Dev3A;                                           // 0x2664(0x0008)
	class ATgDevice*                                   s_Device_Dev4A;                                           // 0x266C(0x0008)
	class ATgDevice*                                   s_Device_Dev1B;                                           // 0x2674(0x0008)
	class ATgDevice*                                   s_Device_Dev2B;                                           // 0x267C(0x0008)
	class ATgDevice*                                   s_Device_Dev2B_SubA;                                      // 0x2684(0x0008)
	class ATgDevice*                                   s_Device_Dev3B;                                           // 0x268C(0x0008)
	class ATgDevice*                                   s_Device_Dev4B;                                           // 0x2694(0x0008)
	class ATgDevice_Knight_Dev4B_Sub*                  s_Device_Dev4B_Sub;                                       // 0x269C(0x0008)
	class ATgDevice_Dialogue*                          s_Device_Dialogue;                                        // 0x26A4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Knight");
		return ptr;
	}


	bool STATIC_ShouldOverrideChargeAccel();
	bool STATIC_ShouldCacheAndResetChargeValues();
	void STATIC_PlayFinalSmashTargetAnim();
	bool WillOverrideTakeDamage(class APawn* Victim, int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void TgPawnControllerSet();
	float STATIC_GetChargeTurnRate();
	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	class ATgDevice_Dialogue* STATIC_GetDialogueDevice();
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	void AddUltMeter(float fAmount);
	bool IsDamageInstanceTracked(class ATgDevice* Dev, int* bHasDamagedGod);
	void STATIC_ClearDamageInstance(class ATgDevice* Dev);
	void TrackDamageInstance(class ATgDevice* Dev, bool bHasDamagedGod);
	void STATIC_PawnOnRevive();
	float STATIC_GetAttackSpeed();
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	void STATIC_FlashStopFire(int nDeviceInstanceId, int nFireModeNum);
	void STATIC_FlashStartFire(int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target);
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void STATIC_ConsumePowerPool(class ATgDevice* Dev, int nPacingType, float fAmount);
	void STATIC_DeviceOnHitSpecial(class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceOnBeforeHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	void STATIC_DeviceAdjustHeal(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal);
	void STATIC_DeviceAdjustCrit(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void STATIC_DeviceCalcConditionalDamageTakenPerc(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamageTakenPerc);
	void STATIC_DeviceOnHealed(struct FOnHealedParams* Params);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_DeviceOnStartCooldown(class ATgDevice* Dev, float fCooldownTime);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_DeviceAdjustDamage(class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage);
	void DeviceOnFire(class ATgDevice* Dev);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_ResetAllAbilityCooldowns();
	void STATIC_SetUltDevice(TEnumAsByte<EKnightUltStance> eKUS);
	TEnumAsByte<EKnightUltStance> STATIC_SwitchUltStance();
	bool IsUltDevice(class ATgDevice* Dev);
	bool STATIC_ShouldSwitchStance(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool IsValidStanceEquipSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetMirroredEquipSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetActiveEquipSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp, bool bActive);
	TEnumAsByte<EKnightStance> STATIC_SwitchStance();
	void STATIC_SetStance(TEnumAsByte<EKnightStance> eKS);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
};


// Class TgGame.TgAchievement_Wizard_ElementalMastery
// 0x0001 (0x0085 - 0x0084)
class UTgAchievement_Wizard_ElementalMastery : public UTgAchievement
{
public:
	unsigned char                                      m_nStanceKillFlags;                                       // 0x0084(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Wizard_ElementalMastery");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Wizard_A01
// 0x0E5C (0x1290 - 0x0434)
class ATgDeploy_Wizard_A01 : public ATgDeploy_EffectVolume_WithEncroachment
{
public:
	struct FVector                                     r_vStartTrace;                                            // 0x0434(0x000C) (Const, Net)
	struct FVector                                     r_vEndTrace;                                              // 0x0440(0x000C) (Const, Net)
	float                                              r_fTraceDist;                                             // 0x044C(0x0004) (Const, Net)
	float                                              r_fRangeMin;                                              // 0x0450(0x0004) (Const, Net)
	float                                              r_fRangeMax;                                              // 0x0454(0x0004) (Const, Net)
	float                                              r_fRangeSpan;                                             // 0x0458(0x0004) (Const, Net)
	float                                              r_fRadiusMin;                                             // 0x045C(0x0004) (Const, Net)
	float                                              r_fRadiusMax;                                             // 0x0460(0x0004) (Const, Net)
	float                                              r_fIntervalTime;                                          // 0x0464(0x0004) (Const, Net)
	float                                              r_fPersistTime;                                           // 0x0468(0x0004) (Const, Net)
	float                                              r_fLinkBonusRadiusMax;                                    // 0x046C(0x0004) (Const, Net)
	int                                                r_nLinkMeshId;                                            // 0x0470(0x0004) (Const, Net)
	float                                              m_fEdgeOffset;                                            // 0x0474(0x0004) (Const)
	unsigned long                                      m_bProjectilesEnabled : 1;                                // 0x0478(0x0004) (Const)
	unsigned long                                      m_bRangeReached : 1;                                      // 0x0478(0x0004)
	class AActor*                                      s_MarkedTargets[0x20];                                    // 0x047C(0x0008)
	float                                              m_fCurrentRadius;                                         // 0x057C(0x0004)
	struct FWizardA01LinkInfo                          r_LinkInfos[0x20];                                        // 0x0580(0x0054) (Net)
	float                                              r_fRemainingTime;                                         // 0x1000(0x0004) (Net)
	int                                                r_nForceUpdateLinkedTargets;                              // 0x1004(0x0004) (Net)
	class UTgStaticMeshComponent*                      c_Links[0x20];                                            // 0x1008(0x0008) (ExportObject, Component, EditInline)
	class ATgProj_SimulatedSeeking*                    c_Projectiles[0x20];                                      // 0x1108(0x0008)
	float                                              c_FiringTimers[0x20];                                     // 0x1208(0x0004)
	class UTgTimerManager*                             c_ProjLifetimeManager;                                    // 0x1288(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wizard_A01");
		return ptr;
	}


	void STATIC_DeployComplete();
	void DestroyIt(bool bSkipFx);
	void HandleTouch(class AActor* Other);
	void ReplicatedEvent(const struct FName& VarName);
	void TransmitTiDiClient();
	void ToggleGroundRadiusFX(bool bEffectOn);
};


// Class TgGame.TgDeploy_Wizard_C02
// 0x001C (0x0450 - 0x0434)
class ATgDeploy_Wizard_C02 : public ATgDeploy_EffectVolume_WithEncroachment
{
public:
	class UTgTimerManager*                             m_PulseTimers;                                            // 0x0434(0x0008)
	TArray<class ATgPawn*>                             m_PulseTimerOccupancy;                                    // 0x043C(0x0010) (NeedCtorLink)
	float                                              m_fHitPulseTime;                                          // 0x044C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wizard_C02");
		return ptr;
	}


	void DestroyAllTimers();
	void DestroyIt(bool bSkipFx);
	void STATIC_HitPulse(int nTimerId, TEnumAsByte<ETGT_EVENT> eEvent);
	int STATIC_GetFirstInactiveTimerIndex();
	int STATIC_GetTimerIndex(class ATgPawn* Other);
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
};


// Class TgGame.TgDeploy_Wizard_A02
// 0x0010 (0x0408 - 0x03F8)
class ATgDeploy_Wizard_A02 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	TArray<class AActor*>                              s_TiDiAppliedList;                                        // 0x03F8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wizard_A02");
		return ptr;
	}


	void Cleanup();
	void RemoveLocalTiDiFromActor(class AActor* Other);
	void ApplyLocalTiDiToActor(class AActor* Other);
	class AActor* GetTiDiActor(class AActor* Other);
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
};


// Class TgGame.TgDeploy_Wizard_A02v2
// 0x0024 (0x041C - 0x03F8)
class ATgDeploy_Wizard_A02v2 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	class ATgPawn_NPC_Wizard*                          m_wizard;                                                 // 0x03F8(0x0008) (Const)
	float                                              m_fDestinationRadius;                                     // 0x0400(0x0004) (Const)
	float                                              m_fMaxHeight;                                             // 0x0404(0x0004) (Const)
	int                                                m_nPropelCount;                                           // 0x0408(0x0004)
	TArray<class ATgPawn*>                             s_ApplyMotionToPawns;                                     // 0x040C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wizard_A02v2");
		return ptr;
	}


	void STATIC_PropelTargetList();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void Tick(float fDeltaSeconds);
	bool STATIC_CanBeKnockedUp(class ATgPawn* Target);
	void STATIC_PropelPawnTarget(class ATgPawn* Target);
};


// Class TgGame.TgDeploy_Wizard_A04
// 0x0044 (0x04F0 - 0x04AC)
class ATgDeploy_Wizard_A04 : public ATgDeploy_CylinderPulse
{
public:
	float                                              r_fImplosionTime;                                         // 0x04AC(0x0004) (Const, Net)
	float                                              r_fImplosionLockoutTime;                                  // 0x04B0(0x0004) (Const, Net)
	unsigned long                                      r_bShouldApplyHitEffects : 1;                             // 0x04B4(0x0004) (Const, Net)
	unsigned long                                      m_bPreparingToDeploy : 1;                                 // 0x04B4(0x0004)
	TArray<int>                                        m_SituationalTypeMap;                                     // 0x04B8(0x0010) (Const, NeedCtorLink)
	struct FName                                       m_nmImpulseOutDamageType;                                 // 0x04C8(0x0008) (Const)
	struct FName                                       m_nmOnFireDamageType;                                     // 0x04D0(0x0008) (Const)
	struct FName                                       m_nmCharredDamageType;                                    // 0x04D8(0x0008) (Const)
	struct FName                                       m_nmFrozenDamageType;                                     // 0x04E0(0x0008) (Const)
	struct FName                                       m_nmDefaultDamageType;                                    // 0x04E8(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wizard_A04");
		return ptr;
	}


	void STATIC_DeployComplete();
	void ApplyWizardTypeEffects(class AActor* Other);
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void STATIC_FinishExplosion();
	void TriggerCooldown();
	void TriggerImplosion();
	float STATIC_GetExplosionTime();
};


// Class TgGame.TgDeploy_Wizard_B02
// 0x002C (0x0400 - 0x03D4)
class ATgDeploy_Wizard_B02 : public ATgDeployable
{
public:
	float                                              r_fRevolutionsPerSecond;                                  // 0x03D4(0x0004) (Const, Net)
	struct FRotator                                    r_rCurrentRotation;                                       // 0x03D8(0x000C) (Net)
	struct FRotator                                    r_rTargetRotation;                                        // 0x03E4(0x000C) (Net)
	TEnumAsByte<EWizardB02Position>                    r_ePosition;                                              // 0x03F0(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03F1(0x0003) MISSED OFFSET
	class ATgDevice_Wizard_B02*                        m_Device_B02;                                             // 0x03F4(0x0008)
	unsigned long                                      m_bRotationsEnabled : 1;                                  // 0x03FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Wizard_B02");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void ReplicatedEvent(const struct FName& VarName);
	void UpdateMaterials();
};


// Class TgGame.TgDevice_WizardDeployable
// 0x0010 (0x050C - 0x04FC)
class ATgDevice_WizardDeployable : public ATgDevice_Deployable
{
public:
	struct FPointer                                    VfTable_ITgDevice_WizardInterface;                        // 0x04FC(0x0008) (Const, Native, NoExport)
	class ATgPawn_NPC_Wizard*                          m_wizard;                                                 // 0x0504(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WizardDeployable");
		return ptr;
	}


	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool IsLockedDown();
	bool STATIC_ShouldUpdateTimer();
	unsigned char STATIC_IncrementFiringInstance();
	bool STATIC_HasBeenTrained();
	int STATIC_GetAllocatedDevicePoints(bool bForceBasePoints);
	int STATIC_GetTotalDevicePoints();
	bool IsDeviceCoolingDown();
	void STATIC_SetWizard(class ATgPawn_NPC_Wizard* wizard);
	class ATgPawn_NPC_Wizard* STATIC_GetWizard();
};


// Class TgGame.TgDevice_Wizard_A01
// 0x0010 (0x051C - 0x050C)
class ATgDevice_Wizard_A01 : public ATgDevice_WizardDeployable
{
public:
	float                                              m_fRangeMax;                                              // 0x050C(0x0004)
	float                                              m_fRangeMin;                                              // 0x0510(0x0004)
	float                                              m_fRadiusMax;                                             // 0x0514(0x0004)
	float                                              m_fRadiusMin;                                             // 0x0518(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Wizard_A01");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Wizard_A04
// 0x0018 (0x0524 - 0x050C)
class ATgDevice_Wizard_A04 : public ATgDevice_WizardDeployable
{
public:
	unsigned long                                      m_bTypeSelectionEnabled : 1;                              // 0x050C(0x0004) (Const)
	TArray<int>                                        m_nDisplayIconOverrides;                                  // 0x0510(0x0010) (Const, NeedCtorLink)
	float                                              m_fLastStartFireTime;                                     // 0x0520(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Wizard_A04");
		return ptr;
	}


	bool IsChanneling();
	float GetPersistTime(int nMode);
	bool ShouldCooldownAfterFire();
	bool STATIC_NativeIsFiring();
	float STATIC_GetLockoutExtensionTime();
	bool STATIC_ShouldApplyModeEquipEffects();
	bool STATIC_HasBeenTrained();
};


// Class TgGame.TgDevice_WizardHitPulse
// 0x0010 (0x050C - 0x04FC)
class ATgDevice_WizardHitPulse : public ATgDevice_HitPulse
{
public:
	struct FPointer                                    VfTable_ITgDevice_WizardInterface;                        // 0x04FC(0x0008) (Const, Native, NoExport)
	class ATgPawn_NPC_Wizard*                          m_wizard;                                                 // 0x0504(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WizardHitPulse");
		return ptr;
	}


	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool IsLockedDown();
	bool STATIC_ShouldUpdateTimer();
	unsigned char STATIC_IncrementFiringInstance();
	bool STATIC_HasBeenTrained();
	int STATIC_GetAllocatedDevicePoints(bool bForceBasePoints);
	int STATIC_GetTotalDevicePoints();
	bool IsDeviceCoolingDown();
	void STATIC_SetWizard(class ATgPawn_NPC_Wizard* wizard);
	class ATgPawn_NPC_Wizard* STATIC_GetWizard();
};


// Class TgGame.TgDevice_Wizard_B01
// 0x0000 (0x050C - 0x050C)
class ATgDevice_Wizard_B01 : public ATgDevice_WizardHitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Wizard_B01");
		return ptr;
	}


	bool StartFire();
	bool CanBeCanceled();
	bool STATIC_NativeIsFiring();
};


// Class TgGame.TgDevice_Wizard_B02
// 0x009D (0x05A9 - 0x050C)
class ATgDevice_Wizard_B02 : public ATgDevice_WizardHitPulse
{
public:
	class ATgDeploy_Wizard_B02*                        r_Deployables[0x2];                                       // 0x050C(0x0008) (Net)
	int                                                r_nMarkedTargetIds[0x20];                                 // 0x051C(0x0004) (Net)
	unsigned long                                      r_bDeploying : 1;                                         // 0x059C(0x0004) (Net)
	unsigned long                                      r_bCurrentlyDeployed : 1;                                 // 0x059C(0x0004) (Net)
	float                                              m_fDamageRadius;                                          // 0x05A0(0x0004)
	float                                              m_fLateralOffset;                                         // 0x05A4(0x0004)
	unsigned char                                      s_nLastFiringInstance;                                    // 0x05A8(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Wizard_B02");
		return ptr;
	}


	void InterruptFiring();
	void STATIC_DeviceFormToggleOff();
	bool CanJumpWhileFiring();
	bool StartFire();
	float GetPersistTime(int nMode);
	void STATIC_ResetTargetingDevice();
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableDeployComplete(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	bool ShouldCooldownAfterFire();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void UpdateAimWhileFiring(struct FAimData* Aim);
	void STATIC_CustomUpdateTargetingModeLocation();
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_WizardRange
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_WizardRange : public ATgDevice_Range
{
public:
	struct FPointer                                    VfTable_ITgDevice_WizardInterface;                        // 0x04F0(0x0008) (Const, Native, NoExport)
	class ATgPawn_NPC_Wizard*                          m_wizard;                                                 // 0x04F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WizardRange");
		return ptr;
	}


	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool IsLockedDown();
	bool STATIC_ShouldUpdateTimer();
	unsigned char STATIC_IncrementFiringInstance();
	bool STATIC_HasBeenTrained();
	int STATIC_GetAllocatedDevicePoints(bool bForceBasePoints);
	int STATIC_GetTotalDevicePoints();
	bool IsDeviceCoolingDown();
	void STATIC_SetWizard(class ATgPawn_NPC_Wizard* wizard);
	class ATgPawn_NPC_Wizard* STATIC_GetWizard();
};


// Class TgGame.TgDevice_Wizard_C01
// 0x0014 (0x0514 - 0x0500)
class ATgDevice_Wizard_C01 : public ATgDevice_WizardRange
{
public:
	struct FVector                                     m_vProxExtent;                                            // 0x0500(0x000C) (Const)
	float                                              m_fMaxTravelDist;                                         // 0x050C(0x0004) (Const)
	unsigned long                                      c_bHasHumanoidTarget : 1;                                 // 0x0510(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Wizard_C01");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_WizardBase
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_WizardBase : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDevice_WizardInterface;                        // 0x04F0(0x0008) (Const, Native, NoExport)
	class ATgPawn_NPC_Wizard*                          m_wizard;                                                 // 0x04F8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WizardBase");
		return ptr;
	}


	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool IsLockedDown();
	bool STATIC_ShouldUpdateTimer();
	unsigned char STATIC_IncrementFiringInstance();
	bool STATIC_HasBeenTrained();
	int STATIC_GetAllocatedDevicePoints(bool bForceBasePoints);
	int STATIC_GetTotalDevicePoints();
	bool IsDeviceCoolingDown();
	void STATIC_SetWizard(class ATgPawn_NPC_Wizard* wizard);
	class ATgPawn_NPC_Wizard* STATIC_GetWizard();
};


// Class TgGame.TgDevice_Wizard_A03
// 0x0014 (0x0514 - 0x0500)
class ATgDevice_Wizard_A03 : public ATgDevice_WizardBase
{
public:
	unsigned long                                      r_bDeviceFormEnabled : 1;                                 // 0x0500(0x0004) (Net)
	TArray<int>                                        m_nDisplayIconOverrides;                                  // 0x0504(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Wizard_A03");
		return ptr;
	}


	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	bool STATIC_CanBeCrippled();
};


// Class TgGame.TgDevice_WizardInterface
// 0x0000 (0x0060 - 0x0060)
class UTgDevice_WizardInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_WizardInterface");
		return ptr;
	}


	void STATIC_SetWizard(class ATgPawn_NPC_Wizard* wizard);
	class ATgPawn_NPC_Wizard* STATIC_GetWizard();
};


// Class TgGame.TgDeviceFire_Wizard_A03
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Wizard_A03 : public UTgDeviceFire_Blink
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Wizard_A03");
		return ptr;
	}


	void STATIC_TeleportFire();
};


// Class TgGame.TgDeviceFire_Wizard_A01
// 0x0014 (0x01D4 - 0x01C0)
class UTgDeviceFire_Wizard_A01 : public UTgDeviceFire_Deploy
{
public:
	float                                              m_fRangeMax;                                              // 0x01C0(0x0004) (Const)
	float                                              m_fRangeMin;                                              // 0x01C4(0x0004) (Const)
	float                                              m_fRadiusMax;                                             // 0x01C8(0x0004) (Const)
	float                                              m_fRadiusMin;                                             // 0x01CC(0x0004) (Const)
	unsigned long                                      m_bDebugMode : 1;                                         // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Wizard_A01");
		return ptr;
	}


	void STATIC_CalcQuadFire(class AActor* aDamageInstigator, const struct FAimData& Aim, bool bPredicting, const struct FVector& vStartPos, const struct FVector& vEndPos, float fRadius, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcDeployableTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, int nDeployableId, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Wizard_A02
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Wizard_A02 : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Wizard_A02");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcDeployableTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, int nDeployableId, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceFire_Wizard_B02
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Wizard_B02 : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Wizard_B02");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcDeployableTargetingFire(class AActor* DamageInstigator, const struct FAimData& Aim, int nDeployableId, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	struct FImpactInfo STATIC_CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_CustomDeploy();
	void STATIC_CustomFire();
};


// Class TgGame.TgDeviceForm_Wizard_A01
// 0x002C (0x0264 - 0x0238)
class UTgDeviceForm_Wizard_A01 : public UTgDeviceForm
{
public:
	TArray<class UMaterialInstanceConstant*>           c_ConeTargetMICs;                                         // 0x0238(0x0010) (NeedCtorLink)
	class ATgSkeletalMeshActor*                        c_ConeTargetMeshIndicator;                                // 0x0248(0x0008)
	class UTgSpecialFx*                                c_ConeTargetFx;                                           // 0x0250(0x0008)
	int                                                c_nConeTargetFxId;                                        // 0x0258(0x0004)
	float                                              c_fRangeMin;                                              // 0x025C(0x0004)
	float                                              c_fRangeSpan;                                             // 0x0260(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Wizard_A01");
		return ptr;
	}


	void NotifyTargetingModeStatusChange();
	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateConeTargetFade(float fAimPct);
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeConeTargetMICs();
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_Wizard_B02
// 0x0018 (0x0250 - 0x0238)
class UTgDeviceForm_Wizard_B02 : public UTgDeviceForm
{
public:
	class ATgDevice_Wizard_B02*                        c_DeviceOwner;                                            // 0x0238(0x0008) (Const)
	TArray<struct FWizardB02Targeter>                  c_Targeters;                                              // 0x0240(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Wizard_B02");
		return ptr;
	}


	bool STATIC_TargetersInitialized();
	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargeter(struct FWizardB02Targeter* targeter);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_Wizard_B02
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Wizard_B02 : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Wizard_B02");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Wizard_Passive
// 0x0020 (0x00F0 - 0x00D0)
class UTgInventoryObject_Listen_Wizard_Passive : public UTgInventoryObject_Listen
{
public:
	TArray<struct FWizardChargeBuffInfo>               m_SpellTracker;                                           // 0x00D0(0x0010) (NeedCtorLink)
	TArray<struct FWizardChargeBuffInfo>               m_ChargedShots;                                           // 0x00E0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Wizard_Passive");
		return ptr;
	}

};


// Class TgGame.TgPawn_NPC_Wizard
// 0x00EC (0x26A4 - 0x25B8)
class ATgPawn_NPC_Wizard : public ATgPawn_Character
{
public:
	struct FPointer                                    VfTable_ITgPawn_DialogueInterface;                        // 0x25B8(0x0008) (Const, Native, NoExport)
	struct FWizardTypeTracker                          r_TypeTracker;                                            // 0x25C0(0x000C) (Net)
	float                                              r_fCurrentTypeAnimProperty;                               // 0x25CC(0x0004) (Net)
	int                                                r_WizardFxIds[0x3];                                       // 0x25D0(0x0004) (Net)
	TArray<struct FWizardEqpSet>                       m_EqpTable;                                               // 0x25DC(0x0010) (Const, NeedCtorLink)
	struct FWizardA03Fx                                c_WizardA03Fx[0x3];                                       // 0x25EC(0x0010) (Const)
	struct FVector                                     c_vA03StartingLocation;                                   // 0x261C(0x000C)
	class ATgDevice_WizardRange*                       m_Device_Auto;                                            // 0x2628(0x0008)
	class ATgDevice_WizardBase*                        m_Device_Psv;                                             // 0x2630(0x0008)
	class ATgDevice_Wizard_A01*                        m_Device_A01;                                             // 0x2638(0x0008)
	class ATgDevice_WizardDeployable*                  m_Device_A02;                                             // 0x2640(0x0008)
	class ATgDevice_Wizard_A03*                        m_Device_A03;                                             // 0x2648(0x0008)
	class ATgDevice_Wizard_A04*                        m_Device_A04;                                             // 0x2650(0x0008)
	class ATgDevice_WizardHitPulse*                    m_Device_B01;                                             // 0x2658(0x0008)
	class ATgDevice_Wizard_B02*                        m_Device_B02;                                             // 0x2660(0x0008)
	class ATgDevice_Wizard_A03*                        m_Device_B03;                                             // 0x2668(0x0008)
	class ATgDevice_Wizard_A04*                        m_Device_B04;                                             // 0x2670(0x0008)
	class ATgDevice_Wizard_C01*                        m_Device_C01;                                             // 0x2678(0x0008)
	class ATgDevice_WizardDeployable*                  m_Device_C02;                                             // 0x2680(0x0008)
	class ATgDevice_Wizard_A03*                        m_Device_C03;                                             // 0x2688(0x0008)
	class ATgDevice_Wizard_A04*                        m_Device_C04;                                             // 0x2690(0x0008)
	class ATgDevice_Dialogue*                          m_Device_Dialogue;                                        // 0x2698(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x26A0(0x0004) (Const)
	unsigned long                                      m_bDevicesInitialized : 1;                                // 0x26A0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_NPC_Wizard");
		return ptr;
	}


	void Tick(float DeltaTime);
	bool STATIC_CheckValidTransitionState();
	void ResetSelectionState();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool IsInClassSpecificChannel();
	void HandleClientPostPawnSetup();
	void SetTargetingDevice(class ATgDevice* Dev);
	bool StartAction(class ATgDevice* Dev, bool bUpdateTimeStamp, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_SelectType(class ATgDevice* Dev);
	bool DeviceOverrideLockedDown(class ATgDevice* Dev);
	void ReplicatedEvent(const struct FName& VarName);
	class ATgDevice_Dialogue* STATIC_GetDialogueDevice();
	void UpdateWizardTypeFx();
	void STATIC_SpawnTeleportProjectile(const struct FVector& vDestination);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	unsigned char STATIC_IncrementFiringInstances(class ATgDevice* Dev);
	void STATIC_ReduceActiveCooldownForOffhand(TEnumAsByte<ETG_EQUIP_POINT> offhandType, float fValue, bool bPercentage);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_DeviceOnStartCooldown(class ATgDevice* Dev, float fCooldownTime);
	void STATIC_DeviceOnAboutToFire(class ATgDevice* Dev);
	void STATIC_OnPawnDied();
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_PawnOnSetLevel(int nLevel, bool bIsLower);
	void STATIC_PawnOnEffectGroupSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	int STATIC_GetCustomParticleSystemFilter();
	TEnumAsByte<EWizardEquipPoint> STATIC_GetWizardEqpPoint(class ATgDevice* Dev);
	class ATgDevice* STATIC_GetNextDevice(TEnumAsByte<ETG_EQUIP_POINT> eqpDisplayAt);
	class ATgDevice* STATIC_GetPreviousDevice(TEnumAsByte<ETG_EQUIP_POINT> eqpDisplayAt);
	class ATgDevice* STATIC_GetActiveDevice(TEnumAsByte<ETG_EQUIP_POINT> eqpDisplayAt);
	class ATgDevice* STATIC_GetDevice(TEnumAsByte<EWizardType> eWizType, TEnumAsByte<ETG_EQUIP_POINT> eqpDisplayAt);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetNextEquipSlot(TEnumAsByte<ETG_EQUIP_POINT> eqpDisplayAt);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetPreviousEquipSlot(TEnumAsByte<ETG_EQUIP_POINT> eqpDisplayAt);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetActiveEquipSlot(TEnumAsByte<ETG_EQUIP_POINT> eqpDisplayAt);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetEquipSlot(TEnumAsByte<EWizardType> eWizType, TEnumAsByte<ETG_EQUIP_POINT> eqpDisplayAt);
	void STATIC_ServerSetSpecialFloat1(float fValue);
	void UpdateSelectionIcons(TEnumAsByte<EWizardType> ePrevSelectedWT, TEnumAsByte<EWizardType> eSelectedWT);
	void STATIC_ShowSelectionIcons();
	void STATIC_HideOffhandIcons();
	void STATIC_DisplaySelectionUI();
	void STATIC_ClearSelectionUI();
	void UpdateCurrentTargeting();
	void UpdateIconDisplayData();
	void UpdateMaterials();
	void UpdateFX();
	void UpdateBasicAttack();
	void STATIC_ResetCooldowns();
	void UpdateType(bool bResetCooldowns);
	void STATIC_SetType(TEnumAsByte<EWizardType> eWT);
	bool ApplyPawnSetup();
	void STATIC_PostPawnSetupServer();
	void UpdateClientDevices(bool bForce);
	void STATIC_InitializeDevices();
	void STATIC_PrecacheDevices();
};


// Class TgGame.TgProj_Wizard_AUTO
// 0x0020 (0x03B8 - 0x0398)
class ATgProj_Wizard_AUTO : public ATgProj_Simulated
{
public:
	struct FVector                                     m_vInstigatorSpawnLocation;                               // 0x0398(0x000C) (Const)
	TArray<struct FWizardAutoVisibilityDelay>          m_visibilityDelays;                                       // 0x03A4(0x0010) (Const, NeedCtorLink)
	unsigned long                                      c_bVisibilityDelayed : 1;                                 // 0x03B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Wizard_AUTO");
		return ptr;
	}


	bool IsValidTarget(class AActor* A);
	void Tick(float DeltaSeconds);
	void STATIC_ShowProjectile();
	void STATIC_HideProjectile();
	void TurnOnStimmedShotFX();
};


// Class TgGame.TgAchievement_Jormungandr_Toxic_Veins
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_Jormungandr_Toxic_Veins : public UTgAchievement_AbilityMultiKill
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Jormungandr_Toxic_Veins");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Jormungandr_The_Destroyer
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Jormungandr_The_Destroyer : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Jormungandr_The_Destroyer");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Jormungandr_PoisonCloud
// 0x0030 (0x0428 - 0x03F8)
class ATgDeployable_Jormungandr_PoisonCloud : public ATgDeploy_EffectVolume_WithCollision
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	unsigned long                                      m_bPulse : 1;                                             // 0x0400(0x0004)
	unsigned long                                      r_bIsLightCloud : 1;                                      // 0x0400(0x0004) (Net)
	float                                              r_fPersistTime;                                           // 0x0404(0x0004) (Net)
	float                                              r_fHeavyLifetimeSkipped;                                  // 0x0408(0x0004) (Net)
	float                                              m_fTimeAlive;                                             // 0x040C(0x0004)
	struct FProjSeekLocations                          r_ExplosionProjLocs;                                      // 0x0410(0x0018) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Jormungandr_PoisonCloud");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void TimeDeviceFiring();
	void STATIC_PulseTimer();
	void STATIC_DeployComplete();
	void ReplicatedEvent(const struct FName& VarName);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void STATIC_SpawnClientExplosionProjectile(const struct FVector& seekLocation);
	void STATIC_FireExplosionProjectiles(float fDistFromJorm, float fAngleOffset);
	void STATIC_FirePoisonTendril();
	void TurnToLight();
};


// Class TgGame.TgDeployable_Jormungandr_A03_Sonar
// 0x0001 (0x0499 - 0x0498)
class ATgDeployable_Jormungandr_A03_Sonar : public ATgDeploy_ExplodingCylinder
{
public:
	unsigned char                                      s_nDeployIdx;                                             // 0x0498(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Jormungandr_A03_Sonar");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Jorm_ArcV2
// 0x008C (0x0498 - 0x040C)
class ATgDeployable_Jorm_ArcV2 : public ATgDeploy_Wall
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x040C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Jormungandr*                         c_OwningJorm;                                             // 0x0414(0x0008)
	TArray<int>                                        m_nAdditionalAestheticOffsetSkins;                        // 0x041C(0x0010) (Const, NeedCtorLink)
	struct FVector                                     r_vTargetLocation;                                        // 0x042C(0x000C) (Net)
	struct FJormArcContainer                           c_JormArc;                                                // 0x0438(0x0054) (NeedCtorLink)
	float                                              c_fJormDeltaPercent;                                      // 0x048C(0x0004)
	TEnumAsByte<EeJormArcState>                        r_eArcState;                                              // 0x0490(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0491(0x0003) MISSED OFFSET
	unsigned long                                      c_bClientSounded : 1;                                     // 0x0494(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Jorm_ArcV2");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void Tick(float DeltaSeconds);
	void FinishArc();
	void STATIC_DeployComplete();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	float STATIC_GetCleanTimer();
	float STATIC_GetFallTimer();
	float STATIC_GetDelayTimer();
	void AllDone();
	void STATIC_StartFalldown();
	void TriggerFalldownLandingDamage();
	void STATIC_FirePiecewiseDisplayGroup(const struct FVector& vFxLoc);
	void TickFalldown(float fDeltaTime);
	void STATIC_CopyLightingEnvironmentTo(class AActor* destActor);
	void UpdateArcVisuals(float fDeltaTime);
};


// Class TgGame.TgDeployable_Jormungandr_Arch
// 0x0000 (0x040C - 0x040C)
class ATgDeployable_Jormungandr_Arch : public ATgDeploy_Wall
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Jormungandr_Arch");
		return ptr;
	}

};


// Class TgGame.TgDevice_Jormungandr_Dev2
// 0x0020 (0x0544 - 0x0524)
class ATgDevice_Jormungandr_Dev2 : public ATgDevice_Aura
{
public:
	unsigned long                                      m_bEnableInstaCheck : 1;                                  // 0x0524(0x0004)
	TArray<class ATgDeployable_Jormungandr_PoisonCloud*> m_TouchedPoisonCloudList;                                 // 0x0528(0x0010) (NeedCtorLink)
	float                                              r_fEruptGrowAmount;                                       // 0x0538(0x0004) (Net)
	int                                                m_nNumBuffStacks;                                         // 0x053C(0x0004)
	int                                                r_nNumTouchedClouds;                                      // 0x0540(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jormungandr_Dev2");
		return ptr;
	}


	bool CanJumpWhileFiring();
	bool CanBeCanceled();
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ApplyToAllHitAura();
	void ApplyHitToCloud(class AActor* Other);
	void ApplyHitAura(class AActor* Other);
	void ApplyOverheatBuff();
	void STATIC_ClearPoisonCloudList();
	void AddPoisonToList(class ATgDeployable_Jormungandr_PoisonCloud* cloud);
	void STATIC_GetEruptFXIds();
	void STATIC_DetectPoisonClouds();
};


// Class TgGame.TgDevice_Jormungandr_Dev1
// 0x0008 (0x0504 - 0x04FC)
class ATgDevice_Jormungandr_Dev1 : public ATgDevice_Deployable
{
public:
	float                                              m_fDistFromJorm;                                          // 0x04FC(0x0004)
	float                                              m_fCloudSpawnAngle;                                       // 0x0500(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jormungandr_Dev1");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Jormungandr_Dev3_Sonar
// 0x0148 (0x0644 - 0x04FC)
class ATgDevice_Jormungandr_Dev3_Sonar : public ATgDevice_Deployable
{
public:
	class ATgDeployable_Jormungandr_A03_Sonar*         r_SonarPulses[0x4];                                       // 0x04FC(0x0008) (Net)
	class ATgPawn*                                     r_RevealedPawns[0x20];                                    // 0x051C(0x0008) (Net)
	float                                              r_fPulsePersistTime;                                      // 0x061C(0x0004) (Net)
	int                                                r_nPostProcessToggle;                                     // 0x0620(0x0004) (Net)
	int                                                s_nDeployableCounter;                                     // 0x0624(0x0004)
	class ATgPawn_Jormungandr*                         m_jorm;                                                   // 0x0628(0x0008)
	class ATgPlayerController*                         c_CachedController;                                       // 0x0630(0x0008)
	class UPostProcessChain*                           c_PostProcess;                                            // 0x0638(0x0008)
	unsigned long                                      c_bPostProcessActive : 1;                                 // 0x0640(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jormungandr_Dev3_Sonar");
		return ptr;
	}


	bool ApplyGlobalOffhandCooldown();
	bool ShouldCancelStealth();
	void RemovePostProcess();
	void ApplyPostProcess();
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	void StopPulsing();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_Pulse();
	bool STATIC_ShouldRevealFromStealth();
	void STATIC_InitPostProcessChain();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Jormungandr_Basic
// 0x002C (0x051C - 0x04F0)
class ATgDevice_Jormungandr_Basic : public ATgDevice
{
public:
	float                                              r_fCurrentOverheatCost;                                   // 0x04F0(0x0004) (Net)
	float                                              m_fOverheatAmount;                                        // 0x04F4(0x0004)
	float                                              m_fOverheatRate;                                          // 0x04F8(0x0004)
	float                                              m_fBaseCooldownRate;                                      // 0x04FC(0x0004)
	float                                              m_fBaseCooldownAmount;                                    // 0x0500(0x0004)
	float                                              m_fBaseCooldownPercent;                                   // 0x0504(0x0004)
	float                                              m_fMaxAttackRate;                                         // 0x0508(0x0004)
	unsigned long                                      r_bOverheatDisengaged : 1;                                // 0x050C(0x0004) (Net)
	float                                              r_fBaseAttackSpeed;                                       // 0x0510(0x0004) (Net)
	float                                              r_fCurrentCooldownAmount;                                 // 0x0514(0x0004) (Net)
	float                                              m_fTickRate;                                              // 0x0518(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jormungandr_Basic");
		return ptr;
	}


	void DeliverQueuedPendingHits();
	void STATIC_FireAmmunition();
	void ApplyOverheatCooldown();
	void ApplyOverheat();
	void ToggleOverheatBuff();
	bool STATIC_CanBeDisarmed();
	float STATIC_GetConePullbackDistance();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	float GetRefireTime(int nMode);
};


// Class TgGame.TgDevice_Jormungandr_Dev3
// 0x000C (0x04FC - 0x04F0)
class ATgDevice_Jormungandr_Dev3 : public ATgDevice
{
public:
	class ATgDeployable_Jormungandr_PoisonCloud*       m_closestCloud;                                           // 0x04F0(0x0008)
	float                                              m_fClosestCloudDist;                                      // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jormungandr_Dev3");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void STATIC_SpawnPoisonClouds();
};


// Class TgGame.TgDevice_Jormungandr_Passive
// 0x0020 (0x0510 - 0x04F0)
class ATgDevice_Jormungandr_Passive : public ATgDevice
{
public:
	int                                                m_nDecayStackCost;                                        // 0x04F0(0x0004)
	float                                              m_fDecayRate;                                             // 0x04F4(0x0004)
	int                                                m_nMaxStacks;                                             // 0x04F8(0x0004)
	int                                                m_nCurrentDazeStacks;                                     // 0x04FC(0x0004)
	TArray<int>                                        m_SendImmuneMsgList;                                      // 0x0500(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jormungandr_Passive");
		return ptr;
	}


	void STATIC_DecayDazeStacks();
	void ApplyDazeStacks();
};


// Class TgGame.TgDevice_Jormungandr_Dev3_Staging
// 0x0000 (0x0528 - 0x0528)
class ATgDevice_Jormungandr_Dev3_Staging : public ATgDevice_Staging
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jormungandr_Dev3_Staging");
		return ptr;
	}


	void OnStageShooterFire();
};


// Class TgGame.TgDevice_Jormungandr_Dev4_Staging
// 0x000C (0x0538 - 0x052C)
class ATgDevice_Jormungandr_Dev4_Staging : public ATgDevice_StagingRefresh
{
public:
	class ATgPawn_Jormungandr*                         s_Jormungandr;                                            // 0x052C(0x0008)
	float                                              m_fZoomFactor;                                            // 0x0534(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jormungandr_Dev4_Staging");
		return ptr;
	}


	void InterruptFiring();
	bool STATIC_ClientFireOnEndStage();
	void STATIC_ClientInterrupt();
	void ToggleSkipClientAdjustment(bool bSkip);
	void OnStageShooterStopFire(bool bInterrupted);
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	bool STATIC_CanRefreshPostHitDelay();
	float STATIC_GetRefreshTime();
	bool CanJumpWhileFiring();
	bool CanBeCanceled();
	bool LockStageShooterFiring();
};


// Class TgGame.TgDevice_Jormungandr_Dev4_Shooter
// 0x0058 (0x0550 - 0x04F8)
class ATgDevice_Jormungandr_Dev4_Shooter : public ATgDevice_TweenBase
{
public:
	struct FPointer                                    VfTable_ITgSplineDeviceInterface;                         // 0x04F8(0x0008) (Const, Native, NoExport)
	int                                                m_nAmmoCount;                                             // 0x0500(0x0004)
	int                                                m_nMaxAmmoCount;                                          // 0x0504(0x0004)
	int                                                m_nAmmoCountSituationalType;                              // 0x0508(0x0004)
	class ATgDeployable_Jorm_ArcV2*                    m_ArchDeployable;                                         // 0x050C(0x0008)
	unsigned long                                      m_bForceCast : 1;                                         // 0x0514(0x0004)
	struct FAimData                                    s_LastValidAim;                                           // 0x0518(0x0030)
	TEnumAsByte<ETargetingTimerCheckpointType>         m_eStartTimerCheckpoint;                                  // 0x0548(0x0001)
	TEnumAsByte<ETargetingTimerCheckpointType>         m_eStopTimerCheckpoint;                                   // 0x0549(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x054A(0x0002) MISSED OFFSET
	float                                              m_fCachedDistanceScale;                                   // 0x054C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jormungandr_Dev4_Shooter");
		return ptr;
	}


	void STATIC_ResolveCamera();
	void GetAdjustedAimSpline(int nShotIndex, struct FAimData* Aim);
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_ClientForceFireCharge(float EndX, float EndY);
	bool STATIC_ForceFireCharge();
	void STATIC_OnTweenEnd(bool bInterrupted);
	void STATIC_OnTweenStart();
	void STATIC_ClientSetAmmoCount(int nAmmoCount);
	void SetAmmoCount(int nAmmoCount, bool bDoNotFowardToClient);
	void InterruptFiring();
	void DeviceConsumePowerPool(unsigned char FireModeNum);
	bool STATIC_CalculateFlightPath(int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void EnterTargetingMode();
	int STATIC_GetProjectileNum();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void RemoveEquipEffects();
	void ApplyEquipEffects();
	void STATIC_SpawnArchDeployable();
};


// Class TgGame.TgDevice_Visual_SplineTest
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Visual_SplineTest : public ATgDevice_TweenBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Visual_SplineTest");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Jormungandr_Dev1
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Jormungandr_Dev1 : public UTgDeviceFire_MultiDeploy
{
public:
	unsigned long                                      m_bCloudDeploy : 1;                                       // 0x01C0(0x0004)
	int                                                m_nDeployableId;                                          // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Jormungandr_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Jormungandr_Dev2
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Jormungandr_Dev2 : public UTgDeviceFire
{
public:
	unsigned long                                      m_bCheckClouds : 1;                                       // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Jormungandr_Dev2");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceFire_Jormungandr_Dev3_Shooter
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Jormungandr_Dev3_Shooter : public UTgDeviceFire
{
public:
	unsigned long                                      m_bCheckClouds : 1;                                       // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Jormungandr_Dev3_Shooter");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Jormungandr_Dev4_Shooter
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Jormungandr_Dev4_Shooter : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Jormungandr_Dev4_Shooter");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcLinearFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseProximityDistance, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_EmergeFromGround();
};


// Class TgGame.TgDeviceFire_Jormungandr_Dev4_Sub
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Jormungandr_Dev4_Sub : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Jormungandr_Dev4_Sub");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcLinearFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseProximityDistance, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeviceForm_Jormungandr_Dev3_Shooter
// 0x0020 (0x0258 - 0x0238)
class UTgDeviceForm_Jormungandr_Dev3_Shooter : public UTgDeviceForm
{
public:
	class UTgSpecialFx*                                c_LeftCloudTargeterFx;                                    // 0x0238(0x0008)
	class UTgSpecialFx*                                c_RightCloudTargeterFx;                                   // 0x0240(0x0008)
	float                                              m_fDistanceFromJorm;                                      // 0x0248(0x0004)
	float                                              m_fAngleOffset;                                           // 0x024C(0x0004)
	int                                                m_nTargeterFXId;                                          // 0x0250(0x0004)
	unsigned long                                      m_bShowTargeters : 1;                                     // 0x0254(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Jormungandr_Dev3_Shooter");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
	void STATIC_SetPoisonSpawnTargeterVisiblity(bool bInvisible);
};


// Class TgGame.TgDeviceForm_Jormungandr_A04_Shooter
// 0x0018 (0x02B4 - 0x029C)
class UTgDeviceForm_Jormungandr_A04_Shooter : public UTgDeviceForm_SplineTarget
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorB;                            // 0x029C(0x0008)
	class UTgSpecialFx*                                c_TargetingModeFxB;                                       // 0x02A4(0x0008)
	int                                                m_TargetingModeFxIdB;                                     // 0x02AC(0x0004)
	int                                                m_SplineScale;                                            // 0x02B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Jormungandr_A04_Shooter");
		return ptr;
	}


	void EnterTargetingMode();
	void ExitTargetingMode();
	int STATIC_SetupSplineActors(int nSplineIndex, int nLength);
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgInventoryObject_Listen_Jormungandr_Dev3_Sonar
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Jormungandr_Dev3_Sonar : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_Jormungandr_Dev3_Sonar*            s_dev3Sonar;                                              // 0x00D0(0x0008)
	class ATgPawn_Jormungandr*                         s_jorm;                                                   // 0x00D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Jormungandr_Dev3_Sonar");
		return ptr;
	}

};


// Class TgGame.TgPawn_Jormungandr
// 0x00CC (0x2684 - 0x25B8)
class ATgPawn_Jormungandr : public ATgPawn_Character
{
public:
	struct FEruptFXIds                                 r_EruptIds;                                               // 0x25B8(0x0008) (Net)
	float                                              r_fMaxEruptRadius;                                        // 0x25C0(0x0004) (Net)
	float                                              r_fInitialEruptRadius;                                    // 0x25C4(0x0004) (Net)
	float                                              r_fCurrentEruptRadius;                                    // 0x25C8(0x0004) (Net)
	float                                              r_fEruptGrowRate;                                         // 0x25CC(0x0004) (Net)
	unsigned long                                      r_bEruptionActive : 1;                                    // 0x25D0(0x0004) (Net)
	unsigned long                                      m_bSpawnLightClouds : 1;                                  // 0x25D0(0x0004)
	unsigned long                                      m_bFireLastShot : 1;                                      // 0x25D0(0x0004)
	unsigned long                                      m_bDebugHideSplineMesh : 1;                               // 0x25D0(0x0004)
	unsigned long                                      s_bKillOnStopFire : 1;                                    // 0x25D0(0x0004)
	TEnumAsByte<EJormungandrUltimateState>             r_eUltimateState;                                         // 0x25D4(0x0001) (Net)
	TEnumAsByte<EJormungandrUltimateState>             m_eLocalUltState;                                         // 0x25D5(0x0001)
	TEnumAsByte<ETG_POSTURE>                           c_eUltimatePosture;                                       // 0x25D6(0x0001)
	TEnumAsByte<EJomungandrSubmergeState>              r_eSubmergeState;                                         // 0x25D7(0x0001) (Net)
	int                                                c_nUltimatePostureId;                                     // 0x25D8(0x0004)
	float                                              s_fUltimateTakeDownTime;                                  // 0x25DC(0x0004)
	float                                              m_fUltTweenStartTime;                                     // 0x25E0(0x0004)
	int                                                m_nAmmoUsed;                                              // 0x25E4(0x0004)
	int                                                m_nMaxAmmoCount;                                          // 0x25E8(0x0004)
	class ATgDevice_Jormungandr_Dev1*                  m_Jorm_A01;                                               // 0x25EC(0x0008)
	class ATgDevice_Jormungandr_Dev2*                  m_Jorm_A02;                                               // 0x25F4(0x0008)
	class ATgDevice_Jormungandr_Dev3_Staging*          m_Jorm_A03_Staging;                                       // 0x25FC(0x0008)
	class ATgDevice_Jormungandr_Dev3*                  m_Jorm_A03_Shooter;                                       // 0x2604(0x0008)
	class ATgDevice_Jormungandr_Dev4_Staging*          m_Jorm_A04_Staging;                                       // 0x260C(0x0008)
	class ATgDevice_Jormungandr_Dev4_Shooter*          m_Jorm_A04_Shooter;                                       // 0x2614(0x0008)
	class ATgDevice_Jormungandr_Passive*               m_Jorm_Passive;                                           // 0x261C(0x0008)
	float                                              m_fEruptionScale;                                         // 0x2624(0x0004)
	class UTgGameplayCurves*                           m_gcJormTweenRate;                                        // 0x2628(0x0008)
	class UTgGameplayCurves*                           c_JormSplineHeight;                                       // 0x2630(0x0008)
	int                                                m_nJormTweenResId;                                        // 0x2638(0x0004)
	int                                                m_nJormSplineResId;                                       // 0x263C(0x0004)
	struct FVector                                     r_vUltStartLoc;                                           // 0x2640(0x000C) (Net)
	TArray<class ATgSplineLoftActorSpawnable*>         c_ReusableMeshes;                                         // 0x264C(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                c_EmergeCameraShakeFx;                                    // 0x265C(0x0008) (Transient)
	class UTgSpecialFx*                                c_SubmergeCameraShakeFx;                                  // 0x2664(0x0008) (Transient)
	float                                              m_fEmergeCameraShakeRadius;                               // 0x266C(0x0004)
	float                                              m_fSubmergeCameraShakeRadius;                             // 0x2670(0x0004)
	float                                              r_fA04CrushRadius;                                        // 0x2674(0x0004) (Net)
	class APawn*                                       s_Killer;                                                 // 0x2678(0x0008)
	float                                              r_fGroundHeight;                                          // 0x2680(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Jormungandr");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void DeathPreventedFrom(class APawn* attacker);
	void STATIC_StopSubmergeCameraShake();
	void STATIC_StopEmergeCameraShake();
	void STATIC_PlayCameraShake(TEnumAsByte<EJormungandrShakeState> eShakeState, float fDuration);
	void UltimateTweenEnd(bool bInterrupted);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	bool CannotJumpNow();
	float ApplyPitchLimit(float fPitch);
	void STATIC_PlayNearDeathCleanup();
	void STATIC_OnRespawn();
	void STATIC_EndUltimateTakeDown();
	void UpdateUltCollision();
	void UpdateUltimateState(TEnumAsByte<EJormungandrUltimateState> NewState);
	float GetUltCrushRadius();
	bool IsInClassSpecificMovement();
	void SpecialFXAttached(class UTgSpecialFx* NewFX, int FxId);
	void Slide(bool bSliding, TEnumAsByte<EChargeState> eSlideType);
	bool CanBeHardDisplaced();
	bool CanBeVortexed();
	bool CanBePulled(bool bIsActuallyPulling);
	void TgPawnControllerSet();
	void ResolveUltDeath();
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	bool PostPawnSetup();
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	bool STATIC_DeviceOverrideTargetingAim(class ATgDevice* Dev, struct FAimData* Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_RecycleSpline(class ATgSplineLoftActorSpawnable* tgSLAS);
	class ATgSplineLoftActorSpawnable* STATIC_GetReusableSpline(int nMeshId);
	void STATIC_PostPawnSetupServer();
	float STATIC_GetUltTweenPercent();
	int STATIC_GetSplineMeshId();
	void STATIC_GenerateClientSpline(const struct FVector& vStartLoc, const struct FVector& vEndLoc, struct FInterpCurveVector* icvSpline, struct FInterpCurveFloat* icfTravelRate);
	void STATIC_SetupUltCurves();
	void STATIC_SetMeshVisibilityMic();
	int STATIC_GetUltHeadMeshId();
	void STATIC_EngageOverheatBuff(float Time);
	void STATIC_SpawnUltCloud();
	void STATIC_SpawnMultiClouds(float fDistFromJorm, float fAngle);
	void STATIC_ScaleEruptionTargeter(float DeltaSeconds);
	float STATIC_GetSoulRipHeightOffset();
	class UTgSkeletalMeshComponent* STATIC_GetSoulRipMesh();
	void STATIC_PawnOnVortexTouchedOnce(class ATgPawn* InstigatorPawn);
	void STATIC_RecalculateMaterial(bool bIsFriendlyWithLocalPawn, bool bForce);
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
};


// Class TgGame.TgPawn_Jormungandr_WithExtraMesh
// 0x0020 (0x26A4 - 0x2684)
class ATgPawn_Jormungandr_WithExtraMesh : public ATgPawn_Jormungandr
{
public:
	TArray<struct FJormungandrSecondaryMesh>           c_JormSecondaryMeshes;                                    // 0x2684(0x0010) (Const, NeedCtorLink)
	float                                              c_fMaxDepth;                                              // 0x2694(0x0004) (Const)
	float                                              c_fSubmergeRate;                                          // 0x2698(0x0004) (Const)
	float                                              c_fCachedGroundZ;                                         // 0x269C(0x0004) (Const)
	float                                              c_fJormSubmergeDepth;                                     // 0x26A0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Jormungandr_WithExtraMesh");
		return ptr;
	}


	float STATIC_GetCurrentSubmergeRate();
	void Tick(float DeltaTime);
	void STATIC_SetMeshVisibility(bool bVisible);
	void STATIC_ForceMeshToGround();
	void AdjustTranslations();
	void STATIC_CreateSpawnedMeshEntry(int nMeshId, bool bPAC);
	void STATIC_PawnOnRevive();
};


// Class TgGame.TgProj_Jormungandr_PoisonSpit
// 0x0000 (0x03BC - 0x03BC)
class ATgProj_Jormungandr_PoisonSpit : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Jormungandr_PoisonSpit");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshActorSpawnable_JormHead
// 0x0000 (0x031C - 0x031C)
class ATgSkeletalMeshActorSpawnable_JormHead : public ATgSkeletalMeshActorSpawnable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable_JormHead");
		return ptr;
	}

};


// Class TgGame.TgSplineLoftActorSpawnable_JormSection
// 0x0000 (0x0320 - 0x0320)
class ATgSplineLoftActorSpawnable_JormSection : public ATgSplineLoftActorSpawnable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineLoftActorSpawnable_JormSection");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Set_FromAllAngles
// 0x001C (0x00A0 - 0x0084)
class UTgAchievement_Set_FromAllAngles : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004)
	int                                                m_nCloneDeviceId;                                         // 0x0088(0x0004)
	TArray<class ATgPawn*>                             m_HitPawns;                                               // 0x008C(0x0010) (NeedCtorLink)
	int                                                m_nTargetCount;                                           // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Set_FromAllAngles");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Set_RiseOfTheClones
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Set_RiseOfTheClones : public UTgAchievement
{
public:
	int                                                m_nTargetGoal;                                            // 0x0084(0x0004)
	int                                                m_nDeviceId;                                              // 0x0088(0x0004)
	class ATgPawn_Set*                                 m_GodSet;                                                 // 0x008C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Set_RiseOfTheClones");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFire_GodSet
// 0x001C (0x0208 - 0x01EC)
class UTgAnimBlendByFire_GodSet : public UTgAnimBlendByFire
{
public:
	struct FDeviceParameters                           m_OffHand3DeployDeviceParameters;                         // 0x01EC(0x0014) (Edit, NeedCtorLink)
	class ATgPawn_Set*                                 m_OwningSetPawn;                                          // 0x0200(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFire_GodSet");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Set_A03
// 0x000C (0x0440 - 0x0434)
class ATgDeploy_Set_A03 : public ATgDeploy_EffectVolume_WithEncroachment
{
public:
	class ATgPlayerController*                         m_OwnerController;                                        // 0x0434(0x0008) (Const)
	unsigned long                                      m_bFollowOwnerRotation : 1;                               // 0x043C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Set_A03");
		return ptr;
	}

};


// Class TgGame.TgDevice_Set_A04
// 0x0010 (0x0534 - 0x0524)
class ATgDevice_Set_A04 : public ATgDevice_ActiveAura
{
public:
	class UTgInventoryObject_Listen_Set_A04*           s_GodInventoryObj;                                        // 0x0524(0x0008)
	class ATgPawn_Set*                                 s_GodSetOwner;                                            // 0x052C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Set_A04");
		return ptr;
	}


	void EndAura();
	void BeginAura();
	void AuraRemoved(class AActor* Other);
	void AuraApplied(class AActor* Other);
	bool CanBeInterrupted();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Set_Clone_A01
// 0x000C (0x0548 - 0x053C)
class ATgDevice_Set_Clone_A01 : public ATgDevice_Charge
{
public:
	class ATgPawn_Set_Clone*                           r_pCloneOwner;                                            // 0x053C(0x0008) (Const, Net)
	float                                              m_fTargetingRange;                                        // 0x0544(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Set_Clone_A01");
		return ptr;
	}


	void STATIC_EndChargePhysics(bool bInterrupted);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_GetLinearTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Set_A03
// 0x0024 (0x0518 - 0x04F4)
class ATgDevice_Set_A03 : public ATgDevice_GroundTarget_LockOn
{
public:
	class ATgPawn_Set*                                 r_GodSetOwner;                                            // 0x04F4(0x0008) (Const, Net)
	class ATgDevice_Set_A03_Sub*                       r_ChildSetDev;                                            // 0x04FC(0x0008) (Net)
	TEnumAsByte<EDeviceSetA03State>                    r_eCurrentState;                                          // 0x0504(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0505(0x0003) MISSED OFFSET
	unsigned long                                      r_bAllowDeploy : 1;                                       // 0x0508(0x0004) (Net)
	int                                                s_nLastFiringInstanceManaWasConsumed;                     // 0x050C(0x0004)
	float                                              m_fFailStateRefireTime;                                   // 0x0510(0x0004) (Const)
	float                                              m_fDefaultFailStateRefireTime;                            // 0x0514(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Set_A03");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void InterruptFiring();
	void SpecialConsumePowerPool();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_StartChildDeviceFire();
	void STATIC_FireAmmunition();
	bool ShouldCooldownAfterFire();
	void UpdateDeviceForm(TArray<struct FImpactInfo>* ImpactList);
	void UpdateTargetingHighlight(TArray<struct FImpactInfo>* ImpactList);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_ClientDeviceSetup();
	void AttemptDeviceCleanup();
	void STATIC_ClientDeviceCleanup();
	void DeviceCleanup();
	unsigned char STATIC_IncrementFiringInstance();
	float STATIC_GetFiringPostHitDelay(int nMode);
	void UpdateManaUseVitals(class ATgPlayerController* PC);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Set_A03_Sub
// 0x0010 (0x050C - 0x04FC)
class ATgDevice_Set_A03_Sub : public ATgDevice_HitPulse
{
public:
	class ATgPawn_Set*                                 r_GodSetOwner;                                            // 0x04FC(0x0008) (Net)
	class ATgDevice_Set_A03*                           r_ParentSetDev;                                           // 0x0504(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Set_A03_Sub");
		return ptr;
	}


	void RemoveSelfBuff();
	void ApplySelfBuff();
	void STATIC_PersistTimer();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool CanBeInterrupted();
	bool CanJumpWhileFiring();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Set_A01
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Set_A01 : public ATgDevice_Range
{
public:
	class ATgPawn_Set*                                 r_GodSetOwner;                                            // 0x04F0(0x0008) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Set_A01");
		return ptr;
	}


	void InterruptFiring();
	void TurnOffCloneTargetFx(class ATgPawn_Set_Clone* pClone);
	void TurnOnCloneTargetFx(class ATgPawn_Set_Clone* pClone);
	void UpdateAllCloneTargetFx();
	void ExitTargetingMode();
	void EnterTargetingMode();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Set_A02
// 0x000C (0x0514 - 0x0508)
class ATgDevice_Set_A02 : public ATgDevice_WithAmmo_Additive
{
public:
	class ATgPawn_Set*                                 m_GodSetOwner;                                            // 0x0508(0x0008)
	float                                              m_fBonusRadius;                                           // 0x0510(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Set_A02");
		return ptr;
	}


	struct FAimData STATIC_CalcRandomAim();
	void STATIC_SpawnBonusClone();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDeviceFire_Set_Clone_A01
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Set_Clone_A01 : public UTgDeviceFire_ConditionalHitType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Set_Clone_A01");
		return ptr;
	}


	bool STATIC_ShouldUseHitSpecial(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Set_A01
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Set_A01 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Set_A01");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Set_A03
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Set_A03 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Set_A03");
		return ptr;
	}


	void STATIC_TeleportFire();
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceForm_Set_A03
// 0x0008 (0x0254 - 0x024C)
class UTgDeviceForm_Set_A03 : public UTgDeviceForm_AlternateFX
{
public:
	class ATgPawn_Set*                                 m_GodSetOwner;                                            // 0x024C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Set_A03");
		return ptr;
	}


	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	bool STATIC_CustomShouldBeActive();
};


// Class TgGame.TgInventoryObject_Listen_Set_A01
// 0x0020 (0x00F0 - 0x00D0)
class UTgInventoryObject_Listen_Set_A01 : public UTgInventoryObject_Listen
{
public:
	TArray<int>                                        m_nValidDeviceIds;                                        // 0x00D0(0x0010) (Const, NeedCtorLink)
	TArray<class ATgPawn*>                             m_HitPawns;                                               // 0x00E0(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Set_A01");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Set_A02
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_Set_A02 : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_Set_A02*                           s_OwningSetDev;                                           // 0x00D0(0x0008) (Const)
	int                                                m_nGrantedAmmo;                                           // 0x00D8(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Set_A02");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Set_A04
// 0x0038 (0x0108 - 0x00D0)
class UTgInventoryObject_Listen_Set_A04 : public UTgInventoryObject_Listen
{
public:
	int                                                m_nMaxThreshold;                                          // 0x00D0(0x0004) (Const)
	unsigned long                                      s_bIsActive : 1;                                          // 0x00D4(0x0004)
	TArray<int>                                        m_nSituationalTypeIds;                                    // 0x00D8(0x0010) (Const, NeedCtorLink)
	TArray<int>                                        m_nValidDeviceIds;                                        // 0x00E8(0x0010) (Const, NeedCtorLink)
	TArray<struct FSetA04StackData>                    m_StackData;                                              // 0x00F8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Set_A04");
		return ptr;
	}


	void MaxStacksReached(const struct FImpactInfo& Impact);
	void STATIC_RemoveMarks(class ATgPawn* OtherPawn);
	void STATIC_RemoveSpecificMark(class ATgPawn* OtherPawn, int nLevel);
	void ApplySpecificMark(class ATgPawn* OtherPawn, int nLevel, const struct FImpactInfo& Impact);
	int STATIC_FindStackData(class ATgPawn* HitPawn);
	void STATIC_ClearStackData();
	void UpdateStackData(const struct FImpactInfo& Impact);
	void AddStackData(class ATgPawn* HitPawn, int nStackCount);
};


// Class TgGame.TgInventoryObject_Listen_Set_PSV
// 0x0034 (0x0104 - 0x00D0)
class UTgInventoryObject_Listen_Set_PSV : public UTgInventoryObject_Listen
{
public:
	TArray<struct FSetPSVDamageInstanceData>           m_TrackedFireInstances;                                   // 0x00D0(0x0010) (NeedCtorLink)
	TArray<struct FSetPSVDamageTimeData>               m_TrackedTimeStamps;                                      // 0x00E0(0x0010) (NeedCtorLink)
	class ATgPawn*                                     m_OwnerPawn;                                              // 0x00F0(0x0008) (Const)
	int                                                m_nMaxThreshold;                                          // 0x00F8(0x0004) (Const)
	unsigned long                                      s_bIsA04Active : 1;                                       // 0x00FC(0x0004)
	float                                              m_fA03DamageInterval;                                     // 0x0100(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Set_PSV");
		return ptr;
	}


	void STATIC_ServerUpdateStackCount();
	void TransferBuffedStacksToBasic();
	void TransferBasicStacksToBuffed();
	void ApplyStacks();
	void STATIC_RegisterDamageTimeTracking(int nDevId);
	void STATIC_RegisterFireInstanceTracking(int nDevId);
	void AttemptDeviceRegister(int nDevId);
	bool TrackDamageTime(int nDevId, float fDamageTime);
	bool TrackFireInstance(int nDevId, int nFireInstance);
	bool TrackUniqueDamage(class ATgDevice* Dev);
};


// Class TgGame.TgPawn_Set
// 0x0120 (0x26D8 - 0x25B8)
class ATgPawn_Set : public ATgPawn_Character
{
public:
	struct FPointer                                    VfTable_ITgPawn_DialogueInterface;                        // 0x25B8(0x0008) (Const, Native, NoExport)
	class ATgDevice*                                   m_Device_Psv;                                             // 0x25C0(0x0008)
	class ATgDevice_Set_A01*                           m_Device_A01;                                             // 0x25C8(0x0008)
	class ATgDevice_Set_A02*                           m_Device_A02;                                             // 0x25D0(0x0008)
	class ATgDevice_Set_A03*                           m_Device_A03;                                             // 0x25D8(0x0008)
	class ATgDevice_Set_A03_Sub*                       m_Device_A03_Sub;                                         // 0x25E0(0x0008)
	class ATgDevice_Set_A04*                           m_Device_A04;                                             // 0x25E8(0x0008)
	class ATgDevice_Dialogue*                          m_Device_Dialogue;                                        // 0x25F0(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x25F8(0x0004) (Const)
	unsigned long                                      r_bA03ActiveMesh : 1;                                     // 0x25F8(0x0004) (Net)
	unsigned long                                      m_bA03DeployFollowsRotation : 1;                          // 0x25F8(0x0004) (Const)
	unsigned long                                      r_bA04IsActive : 1;                                       // 0x25F8(0x0004) (Net)
	int                                                r_nPsvCount;                                              // 0x25FC(0x0004) (Net)
	class ATgPawn_Set_Clone*                           r_Clones[0x14];                                           // 0x2600(0x0008) (Net)
	int                                                r_nCloneCount;                                            // 0x26A0(0x0004) (Net)
	int                                                r_nA03AnimState;                                          // 0x26A4(0x0004) (Net)
	int                                                r_nA03FireModeID;                                         // 0x26A8(0x0004) (Net)
	int                                                c_nA03TeleportProjId;                                     // 0x26AC(0x0004) (Const)
	class UTgSpecialFx*                                c_A03TeleportFx_Intro;                                    // 0x26B0(0x0008) (Const)
	class UTgSpecialFx*                                c_A03TeleportFx_Outro;                                    // 0x26B8(0x0008) (Const)
	struct FVector                                     c_vA03StartingLocation;                                   // 0x26C0(0x000C)
	int                                                r_nA04ActiveWings;                                        // 0x26CC(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    c_SandWingsMesh;                                          // 0x26D0(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Set");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
	bool PostPawnSetup();
	class ATgDevice_Dialogue* STATIC_GetDialogueDevice();
	void STATIC_EndA04WingMesh();
	void STATIC_StartA04WingMesh();
	void UpdateA04WingMesh(bool bActive);
	void STATIC_InitializeA04WingMesh();
	void STATIC_SpawnTeleportProjectile(const struct FVector& vDestination);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_InitializeA03TeleportFx();
	void ToggleA03FX();
	void STATIC_InterruptA01Fire();
	void UpdateSandCloneState(TEnumAsByte<EPetPhase> ePhase);
	void STATIC_RemoveSandClone(class ATgPawn_Set_Clone* clone);
	void AddSandClone(class ATgPawn_Set_Clone* clone);
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void UpdateClientDevices(bool bForce);
	void STATIC_PrecacheDevices();
};


// Class TgGame.TgPawn_Set_Clone
// 0x0034 (0x2498 - 0x2464)
class ATgPawn_Set_Clone : public ATgPawn_Familiar
{
public:
	class ATgPawn_Set*                                 r_pGodSetOwner;                                           // 0x2464(0x0008) (Const, Net)
	unsigned long                                      m_bDevicesCached : 1;                                     // 0x246C(0x0004)
	class ATgDevice_Set_Clone_A01*                     m_Device_A01;                                             // 0x2470(0x0008) (Const)
	int                                                r_nChargingState;                                         // 0x2478(0x0004) (Net)
	struct FVector                                     r_vTargetLocation;                                        // 0x247C(0x000C) (Net)
	TArray<struct FSetPSVDamageInstanceData>           m_TrackedFireInstances;                                   // 0x2488(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Set_Clone");
		return ptr;
	}


	bool VerifyChargeHit(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& TargetLocation, class AActor* Other, bool bAllowHitFromBehind);
	void ReplicatedEvent(const struct FName& VarName);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_PlayDyingEffects();
	bool TrackFireInstance(int nDevId, int nFireInstance);
	void AttemptDeviceRegister(int nDevId);
	void STATIC_ClearChargeFx();
	void ManageEndChargeFx();
	void ManageStartChargeFx();
	void ManageChargeFx(bool bChargeStarted);
	bool IsNonCombat();
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgAchievement_Horus_TheProtectorKing
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_Horus_TheProtectorKing : public UTgAchievement
{
public:
	float                                              m_nHealthThresholdPct;                                    // 0x0084(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Horus_TheProtectorKing");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Horus_WhereWeDropping
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_Horus_WhereWeDropping : public UTgAchievement
{
public:
	int                                                m_nNumTeleportedThreshold;                                // 0x0084(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Horus_WhereWeDropping");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Horus_Dev4
// 0x0020 (0x0418 - 0x03F8)
class ATgDeploy_Horus_Dev4 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	class ATgDevice_Horus_Dev4_Staging*                s_HorusOwningDev;                                         // 0x03F8(0x0008)
	TArray<class AActor*>                              s_EnchroachingActors;                                     // 0x0400(0x0010) (NeedCtorLink)
	unsigned char                                      r_nActivateWarningFX;                                     // 0x0410(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0411(0x0003) MISSED OFFSET
	unsigned long                                      m_bIsOwningClient : 1;                                    // 0x0414(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Horus_Dev4");
		return ptr;
	}


	void ActivateWarningFX();
	void DestroyIt(bool bSkipFx);
	void STATIC_DeviceFired();
	void StartDeploy();
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDevice_Horus_Dev2
// 0x0008 (0x056C - 0x0564)
class ATgDevice_Horus_Dev2 : public ATgDevice_Charge_ChainSubDevice
{
public:
	class ATgPawn_Horus*                               r_Horus;                                                  // 0x0564(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Horus_Dev2");
		return ptr;
	}


	void STATIC_ClientSetOwnerTargetingDevice(class ATgDevice* Dev);
	void STATIC_ChainSubDevice(class ATgDevice* SubDevice);
	int STATIC_GetSubDeviceIndex();
};


// Class TgGame.TgDevice_Horus_Dev3
// 0x0034 (0x0528 - 0x04F4)
class ATgDevice_Horus_Dev3 : public ATgDevice_GroundTarget_LockOn
{
public:
	class ATgPawn_Horus*                               r_Horus;                                                  // 0x04F4(0x0008) (Net)
	struct FVector                                     m_vLastValidTargetLocation;                               // 0x04FC(0x000C)
	float                                              m_fForceDescentTime;                                      // 0x0508(0x0004) (Const)
	float                                              m_fTweenSpeed;                                            // 0x050C(0x0004) (Const)
	float                                              m_fMinRadius;                                             // 0x0510(0x0004) (Const)
	float                                              m_fMaxRadius;                                             // 0x0514(0x0004) (Const)
	float                                              m_fDescentTweenTime;                                      // 0x0518(0x0004) (Const)
	unsigned long                                      m_bIsInPreHit : 1;                                        // 0x051C(0x0004)
	unsigned long                                      r_bIsFollowingTarget : 1;                                 // 0x051C(0x0004) (Net)
	class ATgPawn*                                     r_TargetPawn;                                             // 0x0520(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Horus_Dev3");
		return ptr;
	}


	void ToggleSkipClientAdjustment(bool bSkip);
	void DeliverQueuedPendingHits();
	void InstantFire();
	bool CanBeCanceled();
	void STATIC_OnTweenEndHorus(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void STATIC_OnTweenStartHorus(TEnumAsByte<ETweenState> newTweenState);
	bool STATIC_CanLockOnToTarget(class AActor* Target);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool IsValidToFollow(class ATgPawn* TargetPawn);
	void STATIC_HandleMovingTarget();
	bool STATIC_ShouldStartDescent();
	bool IsFollowingTargetThroughMovement(class ATgPawn* TargetPawn);
	bool IsFollowingTarget();
	struct FVector STATIC_GetBestTargetLocation(class ATgPawn* TargetPawn, struct FVector* BackupLoc);
	void STATIC_StartDescent();
};


// Class TgGame.TgDevice_Horus_Dev4_Shooter
// 0x0048 (0x0538 - 0x04F0)
class ATgDevice_Horus_Dev4_Shooter : public ATgDevice
{
public:
	class ATgPawn_Horus*                               r_Horus;                                                  // 0x04F0(0x0008) (Net)
	class ATgDevice_Horus_Dev4_Staging*                m_StagingDevice;                                          // 0x04F8(0x0008)
	struct FAimData                                    s_LastValidAim;                                           // 0x0500(0x0030)
	TEnumAsByte<ETargetingTimerCheckpointType>         m_eStartTimerCheckpoint;                                  // 0x0530(0x0001)
	TEnumAsByte<ETargetingTimerCheckpointType>         m_eStopTimerCheckpoint;                                   // 0x0531(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0532(0x0002) MISSED OFFSET
	float                                              m_fCachedDistanceScale;                                   // 0x0534(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Horus_Dev4_Shooter");
		return ptr;
	}


	void STATIC_SetupAimValues(const struct FAimData& LastValidAim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Horus_AltAuto
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Horus_AltAuto : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Horus_AltAuto");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_CanCrit();
};


// Class TgGame.TgDevice_Horus_Dev1
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_Horus_Dev1 : public ATgDevice_Range
{
public:
	class ATgDevice*                                   m_AltAutoDev;                                             // 0x04F0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Horus_Dev1");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_SetPointsAllocated(int nPoints);
};


// Class TgGame.TgDevice_Horus_Dev2_Sub
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Horus_Dev2_Sub : public ATgDevice_Range
{
public:
	float                                              m_fConePullbackDistance;                                  // 0x04F0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Horus_Dev2_Sub");
		return ptr;
	}


	void UpdateTargetingModeStatus(struct FAimData* Aim);
	float STATIC_GetConePullbackDistance();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Horus_Dev4_Staging
// 0x0098 (0x05C0 - 0x0528)
class ATgDevice_Horus_Dev4_Staging : public ATgDevice_Staging
{
public:
	class ATgPawn_Horus*                               r_Horus;                                                  // 0x0528(0x0008) (Net)
	class ATgDevice_Horus_Dev4_Shooter*                r_HorusStageShooter;                                      // 0x0530(0x0008) (Net)
	unsigned long                                      m_bIsTeleporting : 1;                                     // 0x0538(0x0004)
	TEnumAsByte<EHorusUltState>                        r_UltState;                                               // 0x053C(0x0001) (Net)
	TEnumAsByte<EHorusUltState>                        c_UltState;                                               // 0x053D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x053E(0x0002) MISSED OFFSET
	class ATgDeploy_Horus_Dev4*                        r_TeleportDeployables[0x2];                               // 0x0540(0x0008) (Net)
	struct FAimData                                    s_EndTeleportAim;                                         // 0x0550(0x0030)
	class UTgDeviceFire_MultiDeploy*                   m_CurrentFireMode;                                        // 0x0580(0x0008) (Const)
	float                                              m_fTeleportTime;                                          // 0x0588(0x0004) (Const)
	float                                              m_fRiseHeight;                                            // 0x058C(0x0004) (Const)
	float                                              m_fPostTeleportDelay;                                     // 0x0590(0x0004) (Const)
	struct FVector                                     r_StartLocation;                                          // 0x0594(0x000C) (Net)
	struct FRotator                                    m_StartRotation;                                          // 0x05A0(0x000C)
	class ATgSkeletalMeshActor*                        c_CachedGroundTargetPreviewActor;                         // 0x05AC(0x0008)
	class ATgSkeletalMeshActor*                        c_CachedGroundTargetRulerActor;                           // 0x05B4(0x0008)
	int                                                s_ach_nNumTeleported;                                     // 0x05BC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Horus_Dev4_Staging");
		return ptr;
	}


	void STATIC_CustomFire();
	void STATIC_CleanupValues();
	void STATIC_CleanupTeleportDeployables();
	void STATIC_SpawnTeleportDeployable(TEnumAsByte<EHorusTeleportDeployable> TeleportDepType);
	bool STATIC_FireEndStageDevice();
	void STATIC_ForceUnrestrictedPitch(bool bForce);
	void STATIC_ShowGroundTargeterFX();
	void STATIC_HideGroundTargeterFX();
	void STATIC_CleanupHorusClone();
	void LockCloneRotation();
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void STATIC_CleanupPhysics();
	void STATIC_SetupPhysics();
	void STATIC_SetupRisingState();
	void STATIC_SetupStartLocation();
	void UpdateUltimateState(TEnumAsByte<EHorusUltState> NewState);
	void STATIC_SetEndTeleportAim();
	void TriggerTeleportState();
	void OnStageShooterFire();
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
	void STATIC_OnDeployableStoppedFiring(class ATgDeployable* dep);
	void STATIC_TeleportTargets();
	void ReplicatedEvent(const struct FName& VarName);
	struct FVector STATIC_GetBestTeleportLocation(class ATgPawn* TargetPawn, class ATgDeployable* StartDep, class ATgDeployable* EndDep);
	void STATIC_SpawnHorusClone();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDeviceFire_Horus_Dev4_Staging
// 0x0014 (0x01D4 - 0x01C0)
class UTgDeviceFire_Horus_Dev4_Staging : public UTgDeviceFire_MultiDeploy
{
public:
	int                                                m_nEndDepId;                                              // 0x01C0(0x0004) (Const)
	struct FPointer                                    m_pEndDepSetup;                                           // 0x01C4(0x0008) (Native)
	struct FPointer                                    m_pHorusCloneSetup;                                       // 0x01CC(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Horus_Dev4_Staging");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Horus_Dev3
// 0x0004 (0x01C8 - 0x01C4)
class UTgDeviceFire_Horus_Dev3 : public UTgDeviceFire_GroundTarget_LockOn
{
public:
	float                                              m_fHealRadius;                                            // 0x01C4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Horus_Dev3");
		return ptr;
	}


	float STATIC_GetDamageRadius();
};


// Class TgGame.TgInventoryObject_Listen_Horus_Passive
// 0x000C (0x00DC - 0x00D0)
class UTgInventoryObject_Listen_Horus_Passive : public UTgInventoryObject_Listen_Apply_On_Take_Damage_GodsOnly
{
public:
	int                                                s_psv_nHealMultiplier;                                    // 0x00D0(0x0004)
	class ATgPawn_Horus*                               m_Horus;                                                  // 0x00D4(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Horus_Passive");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Horus_AltAuto
// 0x0004 (0x00D4 - 0x00D0)
class UTgInventoryObject_Listen_Horus_AltAuto : public UTgInventoryObject_Listen
{
public:
	float                                              m_fDamageMultiplier;                                      // 0x00D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Horus_AltAuto");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Horus_Dev1
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Horus_Dev1 : public UTgInventoryObject_Listen
{
public:
	class UTgDeviceFire*                               s_CachedOwnerFireMode;                                    // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Horus_Dev1");
		return ptr;
	}

};


// Class TgGame.TgPawn_Horus
// 0x008C (0x2644 - 0x25B8)
class ATgPawn_Horus : public ATgPawn_Character
{
public:
	struct FPointer                                    VfTable_ITgPawn_DialogueInterface;                        // 0x25B8(0x0008) (Const, Native, NoExport)
	class ATgDevice_ChainedMelee*                      m_Device_Auto;                                            // 0x25C0(0x0008)
	class ATgDevice_Range*                             m_Device_AltAuto;                                         // 0x25C8(0x0008)
	class ATgDevice*                                   m_Device_Psv;                                             // 0x25D0(0x0008)
	class ATgDevice_Horus_Dev1*                        m_Device_Dev1;                                            // 0x25D8(0x0008)
	class ATgDevice_Horus_Dev2*                        m_Device_Dev2;                                            // 0x25E0(0x0008)
	class ATgDevice_Horus_Dev2_Sub*                    m_Device_Dev2_Sub;                                        // 0x25E8(0x0008)
	class ATgDevice_Horus_Dev3*                        m_Device_Dev3;                                            // 0x25F0(0x0008)
	class ATgDevice_Horus_Dev4_Staging*                m_Device_Dev4_Staging;                                    // 0x25F8(0x0008)
	class ATgDevice_Horus_Dev4_Shooter*                m_Device_Dev4_Shooter;                                    // 0x2600(0x0008)
	class ATgDevice_Dialogue*                          m_Device_Dialogue;                                        // 0x2608(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x2610(0x0004) (Const)
	unsigned long                                      r_auto_bAltAuto : 1;                                      // 0x2610(0x0004) (Net)
	unsigned long                                      m_dev3_bHasPhysTweenedTicked : 1;                         // 0x2610(0x0004)
	unsigned long                                      r_dev4_bInitUltTeleportFx : 1;                            // 0x2610(0x0004) (Net)
	int                                                r_psv_nStackCount;                                        // 0x2614(0x0004) (Net)
	float                                              r_psv_fRemainingTime;                                     // 0x2618(0x0004) (Net)
	TArray<int>                                        m_nDev2ComboHitPawnIds;                                   // 0x261C(0x0010) (NeedCtorLink)
	TEnumAsByte<EHorusUltState>                        r_dev4_UltAnimState;                                      // 0x262C(0x0001) (Net)
	TEnumAsByte<EHorusUltState>                        c_dev4_UltAnimState;                                      // 0x262D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x262E(0x0002) MISSED OFFSET
	int                                                c_UltPostureId;                                           // 0x2630(0x0004)
	class ATgPawn_Horus_AstralProjection*              r_HorusClone;                                             // 0x2634(0x0008) (Net)
	class UTgSpecialFx*                                c_dev4_TeleportFx;                                        // 0x263C(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Horus");
		return ptr;
	}


	void Destroyed();
	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	void STATIC_PushUltPosture(TEnumAsByte<ETG_POSTURE> ePosture);
	void STATIC_PopUltPosture();
	void UpdateUltAnimState(TEnumAsByte<EHorusUltState> NewState);
	struct FVector GetPhysTweenTargetLocation();
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	bool InvObjCastTrackingException(struct FOnDamagedParams* Params);
	class ATgDevice_Dialogue* STATIC_GetDialogueDevice();
	void STATIC_SetAutoTargetingDevice();
	void STATIC_SetupAltAuto(bool bEnable);
	void STATIC_SwapToAltAuto(bool bAltFire);
	float STATIC_GetTweenSpeed();
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	void STATIC_DeviceOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void STATIC_EffectGroupOnSetActive(bool bActive, bool bRemoving, class UTgEffectGroup* EffectGroup);
	class ATgDevice* STATIC_GetDeviceByEqPoint(int eEqPoint);
	void STATIC_InitializeUltTeleportFx();
	void STATIC_InitializeClone();
	void UpdateClientDevices(bool bForce);
	void STATIC_PrecacheDevices();
	void STATIC_PostPawnSetupServer();
};


// Class TgGame.TgPawn_Horus_AstralProjection
// 0x001C (0x254C - 0x2530)
class ATgPawn_Horus_AstralProjection : public ATgPawn_Biped
{
public:
	int                                                c_UltPostureId;                                           // 0x2530(0x0004)
	struct FRotator                                    r_rFinalUltRot;                                           // 0x2534(0x000C) (Net)
	unsigned long                                      r_bIsRotLocked : 1;                                       // 0x2540(0x0004) (Net)
	unsigned long                                      r_bIsVisible : 1;                                         // 0x2540(0x0004) (Net)
	class ATgPawn_Horus*                               r_Horus;                                                  // 0x2544(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Horus_AstralProjection");
		return ptr;
	}


	bool ShouldSuppressNameplate();
	void ClientPlayEmote(TEnumAsByte<EEmote> Emote, int nExtraInfo);
	struct FName GetDeathAnimName();
	void ToggleVisibilityState(bool bIsVisible);
	void STATIC_JumpOffPawn();
	void STATIC_DetachFromHorus();
	void AttachToHorus();
	void SetInvisibleState();
	void SetVisibleState();
	void LockUltRotation(const struct FVector& vTargetLoc);
	void STATIC_PushUltPosture(TEnumAsByte<ETG_POSTURE> ePosture);
	bool ForceHideOnMinimap();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_InitializeClone(class ATgPawn_Horus* Horus);
	void STATIC_CalcStealthFadeValue(float fDeltaTime);
};


// Class TgGame.TgAchievement_Olorun_Eternal_Ruler
// 0x0002 (0x0086 - 0x0084)
class UTgAchievement_Olorun_Eternal_Ruler : public UTgAchievement
{
public:
	unsigned char                                      m_nCurrentKillCount;                                      // 0x0084(0x0001)
	unsigned char                                      m_nCurrentFireInstance;                                   // 0x0085(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Olorun_Eternal_Ruler");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Olorun_Fabricated_Destiny
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Olorun_Fabricated_Destiny : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Olorun_Fabricated_Destiny");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Olorun_Dev3
// 0x0010 (0x04A8 - 0x0498)
class ATgDeployable_Olorun_Dev3 : public ATgDeploy_ExplodingCylinder
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x0498(0x0008) (Const, Native, NoExport)
	class ATgPawn_Olorun*                              m_OlorunPawn;                                             // 0x04A0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Olorun_Dev3");
		return ptr;
	}


	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDeploy_Olorun_Dev4
// 0x00DC (0x04D4 - 0x03F8)
class ATgDeploy_Olorun_Dev4 : public ATgDeploy_EffectVolume
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgTiDiVolumeInterface;                           // 0x0400(0x0008) (Const, Native, NoExport)
	class ATgPawn_Olorun*                              m_OlorunPawn;                                             // 0x0408(0x0008) (Const)
	TArray<class ATgDeployable*>                       m_ManagedTidiDeployables;                                 // 0x0410(0x0010) (NeedCtorLink)
	TArray<class ATgProjectile*>                       m_ManagedTidiProjectiles;                                 // 0x0420(0x0010) (NeedCtorLink)
	TArray<class ATgPawn*>                             m_ManagedTidiPawns;                                       // 0x0430(0x0010) (NeedCtorLink)
	class ATgSkeletalMeshActorSpawnable_OlorunClone*   c_aLeftClone;                                             // 0x0440(0x0008)
	class ATgSkeletalMeshActorSpawnable_OlorunClone*   c_aRightClone;                                            // 0x0448(0x0008)
	float                                              r_fFriendlyTiDi;                                          // 0x0450(0x0004) (Const, Net)
	float                                              r_fEnemyTiDi;                                             // 0x0454(0x0004) (Const, Net)
	float                                              r_fGrowRate;                                              // 0x0458(0x0004) (Const, Net)
	float                                              m_fCurrentLength;                                         // 0x045C(0x0004)
	unsigned long                                      m_bIsExpanding : 1;                                       // 0x0460(0x0004)
	unsigned long                                      m_bDebugMode : 1;                                         // 0x0460(0x0004)
	float                                              r_fWidth;                                                 // 0x0464(0x0004) (Const, Net)
	float                                              r_fMaxLength;                                             // 0x0468(0x0004) (Const, Net)
	float                                              r_fHeight;                                                // 0x046C(0x0004) (Const, Net)
	struct FVector                                     m_vFrontLeftPoint;                                        // 0x0470(0x000C) (Const)
	struct FVector                                     m_vFrontRightPoint;                                       // 0x047C(0x000C) (Const)
	struct FVector                                     m_vBackRightPoint;                                        // 0x0488(0x000C) (Const)
	struct FVector                                     m_vBackLeftPoint;                                         // 0x0494(0x000C) (Const)
	struct FVector                                     m_vInwardLeftSide;                                        // 0x04A0(0x000C) (Const)
	struct FVector                                     m_vInwardRightSide;                                       // 0x04AC(0x000C) (Const)
	struct FVector                                     m_vInwardFrontSide;                                       // 0x04B8(0x000C) (Const)
	struct FVector                                     m_vInwardBackSide;                                        // 0x04C4(0x000C) (Const)
	int                                                s_nTiDiRegisteredIndex;                                   // 0x04D0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Olorun_Dev4");
		return ptr;
	}


	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void DestroyIt(bool bSkipFx);
	float STATIC_GetEnemyTiDi();
	float STATIC_GetFriendlyTiDi();
	bool IsCollidingWithTimeField(float fRadius, struct FVector* vLoc);
	int STATIC_GetCachedRegisteredIndex();
	void STATIC_CacheRegisteredIndex(int nIndex);
	void UpdatePawnTidi(class ATgPawn* Pawn);
	void UpdateProjectileTidi(class ATgProjectile* Projectile);
	void UpdateDeployableTidi(class ATgDeployable* deployable);
	void UpdateClonePosition(float DeltaTime);
	void STATIC_ScaleTimeField(float DeltaTime);
	void STATIC_CalcCollisionBox();
	void STATIC_ClearManagedTidiObjects();
	bool STATIC_ShouldRemoveOlorunTiDi(class ATgPawn* Pawn);
	void ApplyCustomLocalTidiRule(class AActor* ATarget);
	void UpdateManagedTidiObjects();
};


// Class TgGame.TgDeployable_Olorun_Dev2
// 0x0094 (0x0478 - 0x03E4)
class ATgDeployable_Olorun_Dev2 : public ATgDeploy_ProjectileOwner
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03E4(0x0008) (Const, Native, NoExport)
	class ATgPawn_Olorun*                              m_OlorunPawn;                                             // 0x03EC(0x0008)
	struct FVector                                     r_vOriginalTargetLoc;                                     // 0x03F4(0x000C) (Const, Net)
	struct FAimData                                    r_vGroundAim;                                             // 0x0400(0x0030) (Net)
	int                                                r_nAmmoCount;                                             // 0x0430(0x0004) (Net)
	int                                                r_nMaxAmmoCount;                                          // 0x0434(0x0004) (Const, Net)
	int                                                m_nShotsFired;                                            // 0x0438(0x0004)
	int                                                m_nRandomSeed;                                            // 0x043C(0x0004) (Const)
	int                                                m_nRandomShotMinimum;                                     // 0x0440(0x0004) (Const)
	float                                              m_fRadiusRangeIncrease;                                   // 0x0444(0x0004) (Const)
	float                                              m_fRefireTime;                                            // 0x0448(0x0004) (Const)
	float                                              m_fMaxRefireTime;                                         // 0x044C(0x0004) (Const)
	float                                              m_fDuration;                                              // 0x0450(0x0004) (Const)
	float                                              m_fLifeAfterFinalShot;                                    // 0x0454(0x0004) (Const)
	float                                              r_fMinimumSunScale;                                       // 0x0458(0x0004) (Const, Net)
	float                                              r_fSunShrinkRate;                                         // 0x045C(0x0004) (Const, Net)
	float                                              m_fCurrentSunScale;                                       // 0x0460(0x0004)
	unsigned long                                      m_bFirstShot : 1;                                         // 0x0464(0x0004)
	TArray<struct FOlorunSun_TrackedPlayerInfo>        m_TrackedPlayerList;                                      // 0x0468(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Olorun_Dev2");
		return ptr;
	}


	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void Destroyed();
	void STATIC_SpawnProjectiles();
	void STATIC_FireAmmunitionDeployable();
	void STATIC_DeployComplete();
	void TimeDeviceFiring();
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	struct FVector STATIC_GetPhysicalFireStartLoc();
	struct FVector STATIC_GetProjTargetLocation();
	void STATIC_OverrideDestroyTimer();
	float STATIC_GetProjectileIDOverride();
	void STATIC_RandomizeShotDirection();
	void STATIC_RandomizeGroundTargetLoc();
	void STATIC_CalcCustomRefireRate();
	void STATIC_ScaleSunSize(float DeltaTime);
	void STATIC_SetupSunScaling();
	void STATIC_GrabSunDataFromOlorun();
};


// Class TgGame.TgDevice_Olorun_Dev2
// 0x0064 (0x0560 - 0x04FC)
class ATgDevice_Olorun_Dev2 : public ATgDevice_Deployable
{
public:
	class UTgInventoryObject_Listen_Olorun_Dev2*       s_TriggerListener;                                        // 0x04FC(0x0008)
	class ATgPawn_Olorun*                              r_OlorunPawn;                                             // 0x0504(0x0008) (Const, Net)
	class ATgDevice*                                   m_SubDevice;                                              // 0x050C(0x0008) (Const)
	float                                              m_fStimPrefireDelay;                                      // 0x0514(0x0004) (Const)
	float                                              m_fStimPostfireDelay;                                     // 0x0518(0x0004) (Const)
	int                                                r_nTriggerFireIncrement;                                  // 0x051C(0x0004) (Net)
	unsigned long                                      r_bTriggerActive : 1;                                     // 0x0520(0x0004) (Net)
	unsigned long                                      m_bPendingStimFire : 1;                                   // 0x0520(0x0004)
	unsigned long                                      r_bStimActive : 1;                                        // 0x0520(0x0004) (Net)
	unsigned long                                      m_bConsumePowerPool : 1;                                  // 0x0520(0x0004)
	float                                              m_fSunHeight;                                             // 0x0524(0x0004) (Const)
	int                                                m_nMaxAmmoCount;                                          // 0x0528(0x0004) (Const)
	int                                                r_nCurrentAmmoCount;                                      // 0x052C(0x0004) (Net)
	struct FAimData                                    r_vCachedSunAim;                                          // 0x0530(0x0030) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Olorun_Dev2");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	bool CanJumpWhileFiring();
	void UseDevice();
	bool StartFire();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool CanBeInterrupted();
	bool CanBeCanceled();
	void STATIC_FireAmmunition();
	void STATIC_StimPostFireDelay();
	void STATIC_StimPreFireDelay();
	void STATIC_StartCustomCooldown();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void TriggerFireDevice();
};


// Class TgGame.TgDevice_Olorun_Dev4
// 0x0008 (0x0504 - 0x04FC)
class ATgDevice_Olorun_Dev4 : public ATgDevice_Deployable
{
public:
	class ATgDevice*                                   m_SubDevice;                                              // 0x04FC(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Olorun_Dev4");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Olorun_Dev1
// 0x0024 (0x0514 - 0x04F0)
class ATgDevice_Olorun_Dev1 : public ATgDevice
{
public:
	float                                              m_fCurrentRange;                                          // 0x04F0(0x0004)
	float                                              m_fMinimumRange;                                          // 0x04F4(0x0004) (Const)
	float                                              m_fGrowRate;                                              // 0x04F8(0x0004) (Const)
	float                                              m_fTidiGrowModifier;                                      // 0x04FC(0x0004) (Const)
	float                                              m_fSetupDelay;                                            // 0x0500(0x0004) (Const)
	unsigned long                                      m_bInSetupDelay : 1;                                      // 0x0504(0x0004)
	unsigned long                                      r_bTriggerActive : 1;                                     // 0x0504(0x0004) (Net)
	unsigned long                                      r_bUseTidiGrowModifier : 1;                               // 0x0504(0x0004) (Net)
	int                                                r_nTriggerFireIncrement;                                  // 0x0508(0x0004) (Net)
	class ATgPawn_Olorun*                              r_OlorunPawn;                                             // 0x050C(0x0008) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Olorun_Dev1");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void UseDevice();
	bool StartFire();
	bool CanBeCanceled();
	void STATIC_FireAmmunition();
	void STATIC_SetupDelay();
	bool STATIC_CanFireWhileTargetingWhenOffhandPressed();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	bool STATIC_ForceDefaultCastMode();
	bool IsInFriendlyTidi();
	void TriggerFireDevice();
};


// Class TgGame.TgDevice_Olorun_Dev3
// 0x001C (0x050C - 0x04F0)
class ATgDevice_Olorun_Dev3 : public ATgDevice
{
public:
	class ATgDevice*                                   m_SubDevice;                                              // 0x04F0(0x0008) (Const)
	int                                                s_nTrackedFiringInstance;                                 // 0x04F8(0x0004)
	TArray<class ATgPawn*>                             s_HealedAlliesList;                                       // 0x04FC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Olorun_Dev3");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void ApplyProtectionStack(int nFiringInstance, class ATgPawn* aPawn);
	bool IsA03AllyHeal(struct FOnHealedParams* healParams);
};


// Class TgGame.TgDevice_Olorun_PSV
// 0x0018 (0x0508 - 0x04F0)
class ATgDevice_Olorun_PSV : public ATgDevice
{
public:
	class ATgPawn_Olorun*                              r_OlorunPawn;                                             // 0x04F0(0x0008) (Net)
	float                                              m_fMinimumMagicalPower;                                   // 0x04F8(0x0004) (Const)
	float                                              m_fStartingCritChance;                                    // 0x04FC(0x0004) (Const)
	float                                              m_fCritChancePerMP;                                       // 0x0500(0x0004) (Const)
	float                                              m_fMaxCritChance;                                         // 0x0504(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Olorun_PSV");
		return ptr;
	}


	void STATIC_CalcCritChance();
};


// Class TgGame.TgDeviceFire_Olorun_A02Sub
// 0x0010 (0x01D0 - 0x01C0)
class UTgDeviceFire_Olorun_A02Sub : public UTgDeviceFire
{
public:
	float                                              m_fLossIntervalPercent;                                   // 0x01C0(0x0004) (Const)
	float                                              m_fMaxTotalDamageLossPercent;                             // 0x01C4(0x0004) (Const)
	class ATgProj_Olorun_Dev2*                         m_CurrentProjectile;                                      // 0x01C8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Olorun_A02Sub");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	void STATIC_SubmitHitEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact, int nType);
	float STATIC_GetPawnDamageLossPercent(class ATgDeployable_Olorun_Dev2* SunDeployable, class ATgPawn* HitPawn);
};


// Class TgGame.TgDeviceFire_Olorun_Dev1
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Olorun_Dev1 : public UTgDeviceFire
{
public:
	class ATgDevice_Olorun_Dev1*                       m_OwnerDevice;                                            // 0x01C0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Olorun_Dev1");
		return ptr;
	}


	float STATIC_GetRange();
};


// Class TgGame.TgDeviceForm_Olorun_Dev1
// 0x0024 (0x025C - 0x0238)
class UTgDeviceForm_Olorun_Dev1 : public UTgDeviceForm
{
public:
	class ATgPawn_Olorun*                              m_OlorunPawn;                                             // 0x0238(0x0008) (Const)
	class ATgDevice_Olorun_Dev1*                       m_DeviceOwner;                                            // 0x0240(0x0008) (Const)
	class AWorldInfo*                                  m_WorldInfo;                                              // 0x0248(0x0008) (Const)
	float                                              m_fTargeterLength;                                        // 0x0250(0x0004) (Const)
	float                                              m_fTriggerTime;                                           // 0x0254(0x0004) (Const)
	float                                              m_fTriggerTimeElapsed;                                    // 0x0258(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Olorun_Dev1");
		return ptr;
	}


	void EnterTargetingMode();
};


// Class TgGame.TgEffectDamage_OlorunCrit
// 0x0000 (0x00B8 - 0x00B8)
class UTgEffectDamage_OlorunCrit : public UTgEffectDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_OlorunCrit");
		return ptr;
	}


	void STATIC_SendDamageMessages(class AActor* Source, class AActor* Target, float fDamage, float fMitigated, const struct FImpactInfo& thisImpact, bool bWasCritical);
	void STATIC_PlayCustomCritSound(class AActor* aSource, class AActor* ATarget);
};


// Class TgGame.TgInventoryObject_Listen_Olorun_Dev1
// 0x0008 (0x00EC - 0x00E4)
class UTgInventoryObject_Listen_Olorun_Dev1 : public UTgInventoryObject_Listen_EffectGroupTrigger
{
public:
	class ATgDevice_Olorun_Dev1*                       s_Olorun_A01;                                             // 0x00E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Olorun_Dev1");
		return ptr;
	}


	void TriggerRemoved(bool bRemovedEarly);
	void TriggerApplied();
};


// Class TgGame.TgInventoryObject_Listen_Olorun_Dev2
// 0x0008 (0x00EC - 0x00E4)
class UTgInventoryObject_Listen_Olorun_Dev2 : public UTgInventoryObject_Listen_EffectGroupTrigger
{
public:
	class ATgDevice_Olorun_Dev2*                       s_Olorun_A02;                                             // 0x00E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Olorun_Dev2");
		return ptr;
	}


	void TriggerRemoved(bool bRemovedEarly);
	void TriggerApplied();
};


// Class TgGame.TgPawn_Olorun
// 0x006A (0x2622 - 0x25B8)
class ATgPawn_Olorun : public ATgPawn_Character
{
public:
	struct FPointer                                    VfTable_ITgPawn_DialogueInterface;                        // 0x25B8(0x0008) (Const, Native, NoExport)
	class ATgDevice_Range*                             m_Auto_Device;                                            // 0x25C0(0x0008)
	class ATgDevice_Olorun_PSV*                        m_PSV_Device;                                             // 0x25C8(0x0008)
	class ATgDevice_Olorun_Dev1*                       m_A01_Device;                                             // 0x25D0(0x0008)
	class ATgDevice_Olorun_Dev2*                       m_A02_Device;                                             // 0x25D8(0x0008)
	class ATgDevice*                                   m_A02_SubDevice;                                          // 0x25E0(0x0008)
	class ATgDevice_Olorun_Dev3*                       m_A03_Device;                                             // 0x25E8(0x0008)
	class ATgDevice*                                   m_A03_SubDevice;                                          // 0x25F0(0x0008)
	class ATgDevice_Olorun_Dev4*                       m_A04_Device;                                             // 0x25F8(0x0008)
	class ATgDevice*                                   m_A04_SubDevice;                                          // 0x2600(0x0008)
	class ATgDevice_Dialogue*                          m_dialogueDevice;                                         // 0x2608(0x0008)
	unsigned long                                      m_bDevices_Cached : 1;                                    // 0x2610(0x0004) (Const)
	float                                              r_fCurrentCritChance;                                     // 0x2614(0x0004) (Net)
	float                                              r_fA01ProjRange;                                          // 0x2618(0x0004) (Net)
	float                                              r_fSunAmmoPercent;                                        // 0x261C(0x0004) (Net)
	TEnumAsByte<EOlorunDev1State>                      r_eDev1CurrentAnimState;                                  // 0x2620(0x0001) (Net)
	TEnumAsByte<EOlorunDev2State>                      r_eDev2CurrentAnimState;                                  // 0x2621(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Olorun");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void SpecialFXAttached(class UTgSpecialFx* NewFX, int FxId);
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_OnRightMousePressed();
	class ATgDevice_Dialogue* STATIC_GetDialogueDevice();
	void STATIC_DeviceOnHealed(struct FOnHealedParams* Params);
	void DeviceOnHit(class ATgDevice* Dev, struct FImpactInfo* Impact);
	bool STATIC_DeviceOnCanDeviceCriticalStrike(class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance);
	float STATIC_GetCriticalStrike();
	void STATIC_OnAttackDamagePropertyChange();
	void UpdateClientDevices(bool bForce);
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveAux(float* fResult);
	class UTgSpecialFx* STATIC_GetAmmoIndicatorFX();
	void UpdateSunAmmoCount(float fAmmoCount, float fMaxAmmo);
	void UpdateSunAmmoIndicatorMIC(class UTgSpecialFx* Fx);
};


// Class TgGame.TgProj_Olorun_Dev1
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Olorun_Dev1 : public ATgProj_SimulatedPassThroughUntilGod_CollidesWorld
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Olorun_Dev1");
		return ptr;
	}

};


// Class TgGame.TgProj_Olorun_Dev2
// 0x0010 (0x03DC - 0x03CC)
class ATgProj_Olorun_Dev2 : public ATgProj_SimulatedSeeking
{
public:
	class ATgDeployable_Olorun_Dev2*                   m_SunOwner;                                               // 0x03CC(0x0008)
	class ATgSkeletalMeshActor*                        m_WarningFxMesh;                                          // 0x03D4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Olorun_Dev2");
		return ptr;
	}


	void ServerDetonate();
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	void ShutDown();
	void STATIC_CreateWarningFX();
};


// Class TgGame.TgSkeletalMeshActorSpawnable_OlorunClone
// 0x001C (0x0338 - 0x031C)
class ATgSkeletalMeshActorSpawnable_OlorunClone : public ATgSkeletalMeshActorSpawnable
{
public:
	TEnumAsByte<EOlorunCloneState>                     m_eCurrentState;                                          // 0x031C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x031D(0x0003) MISSED OFFSET
	class UTgSkeletalMeshComponent*                    m_CloneMesh;                                              // 0x0320(0x0008) (ExportObject, Component, EditInline)
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                                       // 0x0328(0x0008)
	float                                              m_fCloneIntroSpeed;                                       // 0x0330(0x0004) (Const)
	unsigned long                                      m_bIsLeftClone : 1;                                       // 0x0334(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable_OlorunClone");
		return ptr;
	}


	void STATIC_CreateCloneMesh(class ATgPawn_Olorun* olorunPawn);
};


// Class TgGame.TgAchievement_Persephone_GraspingVines
// 0x0010 (0x0094 - 0x0084)
class UTgAchievement_Persephone_GraspingVines : public UTgAchievement
{
public:
	int                                                m_nNumTrappedThreshold;                                   // 0x0084(0x0004) (Const)
	class UTgDeviceFire*                               m_CurrentFire;                                            // 0x0088(0x0008)
	int                                                m_TrappedPawns;                                           // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Persephone_GraspingVines");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Persephone_MasterHarvester
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_Persephone_MasterHarvester : public UTgAchievement
{
public:
	int                                                m_nSeedCount;                                             // 0x0084(0x0004)
	int                                                m_nTargetGoal;                                            // 0x0088(0x0004)
	int                                                m_nDeviceId;                                              // 0x008C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Persephone_MasterHarvester");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Persephone_A01
// 0x003D (0x0435 - 0x03F8)
class ATgDeploy_Persephone_A01 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	class ATgPawn_Persephone*                          r_Persephone;                                             // 0x03F8(0x0008) (Net)
	struct FVector                                     r_vStartLocation;                                         // 0x0400(0x000C) (Net)
	struct FVector                                     r_vEndLocation;                                           // 0x040C(0x000C) (Net)
	struct FVector                                     r_vCachedAimLocation;                                     // 0x0418(0x000C) (Net)
	unsigned long                                      s_bHasCachedAimLocation : 1;                              // 0x0424(0x0004)
	unsigned long                                      r_bPlaySubDeviceFx : 1;                                   // 0x0424(0x0004) (Net)
	float                                              r_fMaxRange;                                              // 0x0428(0x0004) (Const, Net)
	float                                              r_fMaxRangeSq;                                            // 0x042C(0x0004) (Const, Net)
	float                                              r_fSpeed;                                                 // 0x0430(0x0004) (Const, Net)
	TEnumAsByte<EPersephoneWarriorState>               r_eWarriorState;                                          // 0x0434(0x0001) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Persephone_A01");
		return ptr;
	}


	void STATIC_FireAmmunitionDeployable();
	void Destroyed();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_PlaySubDeviceFx();
	void STATIC_DeviceFired();
	void LeaveMovingState();
	void FireSubDevice();
	struct FVector STATIC_GetPhysicalFireStartLoc();
	void HandleTouch(class AActor* Other);
	void STATIC_DeployComplete();
	void StartDeploy();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SpawnPlant();
	bool STATIC_FindValidPlantSpawn(struct FVector* ValidSpawnLoc);
};


// Class TgGame.TgDeploy_Persephone_A04
// 0x06B4 (0x0AAC - 0x03F8)
class ATgDeploy_Persephone_A04 : public ATgDeploy_EffectVolume
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	struct FPersephoneA04DeployableData                r_TetherData[0x20];                                       // 0x0400(0x001C) (Net)
	struct FPersephoneA04ClientDeployableData          c_MeshData[0x20];                                         // 0x0780(0x0018) (Component)
	struct FVector                                     m_ChainUltimateOffset;                                    // 0x0A80(0x000C)
	class ATgPawn_Persephone*                          r_Persephone;                                             // 0x0A8C(0x0008) (Net)
	class ATgPawn*                                     m_hitByProj;                                              // 0x0A94(0x0008)
	int                                                m_HitsToKill;                                             // 0x0A9C(0x0004) (Const)
	int                                                m_HitsToKillOnWallImpact;                                 // 0x0AA0(0x0004) (Const)
	int                                                m_nTetherMax;                                             // 0x0AA4(0x0004) (Const)
	unsigned long                                      m_bAllowInternalDamage : 1;                               // 0x0AA8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Persephone_A04");
		return ptr;
	}


	void STATIC_InitWallHitHealth();
	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void UpdateDeployableWalls();
	int GetTetheredPawnCount();
	void WentImmune(class ATgDeploy_Persephone_A04_Bounds* bound);
	bool WentOutOfRange(class ATgPawn* TetheredPawn);
	void UpdateMeshData();
	void UpdateTetherChainServer(float DeltaSeconds);
	void UpdateTetheredPawns();
	void PopulateTetherList();
	void AttemptTetherHits();
	int STATIC_FindMeshPawnIndex(class ATgPawn* pHitPawn);
	int STATIC_FindTetheredPawnIndex(class ATgPawn* pHitPawn);
	void UpdateTetherData();
	void STATIC_GenerateNewTetherData(class ATgPawn* pHitPawn, int nHitApplied);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	void InitReplicationInfo();
	class UTgStaticMeshComponent* STATIC_CreateTetherMeshComponent();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDeploy_Persephone_A04_Bounds
// 0x0020 (0x042C - 0x040C)
class ATgDeploy_Persephone_A04_Bounds : public ATgDeploy_Wall
{
public:
	struct FPointer                                    VfTable_ITgCustomBlockingTypeInterface;                   // 0x040C(0x0008) (Const, Native, NoExport)
	float                                              r_fRadius;                                                // 0x0414(0x0004) (Net)
	float                                              r_fExtraRadius;                                           // 0x0418(0x0004) (Net)
	class ATgPawn*                                     r_HitPawn;                                                // 0x041C(0x0008) (Net)
	class ATgDeploy_Persephone_A04*                    r_UltimateDeployable;                                     // 0x0424(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Persephone_A04_Bounds");
		return ptr;
	}


	bool AllowPassthrough(bool bFriendly);
	void UpdateBounds();
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	TEnumAsByte<ETG_CUSTOM_BLOCKING_TYPE> STATIC_GetCustomBlockingType();
	float STATIC_GetScaleFactor();
	bool IsPushable(class AActor* Other);
};


// Class TgGame.TgDeploy_Persephone_A02
// 0x00D8 (0x04AC - 0x03D4)
class ATgDeploy_Persephone_A02 : public ATgDeployable
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03D4(0x0008) (Const, Native, NoExport)
	class UClass*                                      m_SilhouetteOverlayClass;                                 // 0x03DC(0x0008) (Const)
	class UTgSilhouetteComponent*                      c_Silhouette;                                             // 0x03E4(0x0008) (ExportObject, Component, EditInline)
	class ATgPawn_Persephone*                          m_OwningPersephone;                                       // 0x03EC(0x0008)
	class UTgDeviceFire*                               m_Stage1FireMode;                                         // 0x03F4(0x0008)
	class UTgDeviceFire*                               m_Stage2FireMode;                                         // 0x03FC(0x0008)
	class UTgDeviceFire*                               m_Stage3FireMode;                                         // 0x0404(0x0008)
	class UTgSpecialFx*                                c_T2PlantTargeterFx;                                      // 0x040C(0x0008)
	struct FName                                       m_nmT3UpdateLoop;                                         // 0x0414(0x0008) (Const)
	struct FName                                       m_nmBitePrefire;                                          // 0x041C(0x0008) (Const)
	int                                                c_nT2PlantTargeterFxId;                                   // 0x0424(0x0004) (Const)
	TArray<struct FImpactInfo>                         m_PossibleTargetsList;                                    // 0x0428(0x0010) (Component, NeedCtorLink)
	class ATgPawn*                                     m_CurrentTarget;                                          // 0x0438(0x0008)
	unsigned long                                      m_bT3InPrefireDelay : 1;                                  // 0x0440(0x0004)
	unsigned long                                      m_bChaseStarted : 1;                                      // 0x0440(0x0004) (Net)
	unsigned long                                      m_bInPreFire : 1;                                         // 0x0440(0x0004)
	unsigned long                                      r_bIsFlowering : 1;                                       // 0x0440(0x0004) (Net)
	unsigned long                                      r_bStopMoving : 1;                                        // 0x0440(0x0004) (Net)
	int                                                r_nDevA02Index;                                           // 0x0444(0x0004) (Net)
	struct FVector                                     r_vFinalDestination;                                      // 0x0448(0x000C) (Net)
	struct FRotator                                    r_rBiteTargetRotation;                                    // 0x0454(0x000C) (Net)
	TEnumAsByte<EPersephoneA02DeployStage>             r_eDeployStage;                                           // 0x0460(0x0001) (Net)
	TEnumAsByte<EPersephoneA02DeployStage>             r_eForcePlayStageFx;                                      // 0x0461(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0462(0x0002) MISSED OFFSET
	struct FPersephoneA02DeployableData                r_StageData[0x3];                                         // 0x0464(0x000C) (Const, Net)
	struct FPersephoneA02Stage3Defaults                r_Stage3Config;                                           // 0x0488(0x0020) (Const, Net)
	int                                                r_nDefaultMeshId;                                         // 0x04A8(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Persephone_A02");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
	void STATIC_FireAmmunitionDeployable();
	void StartFire();
	void TimeDeviceFiring();
	void STATIC_SpawnSeed();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	class UTgDeviceFire* STATIC_GetStageDeviceFire(TEnumAsByte<EPersephoneA02DeployStage> eStage);
	void ToggleTargeterFx(bool bOn);
	void STATIC_PlayStageFx(TEnumAsByte<EPersephoneA02DeployStage> eStage);
	void UpdateStage3ActiveVisuals();
	void UpdateVisuals();
	void STATIC_T3TargetUpdate();
	void STATIC_PerformBite();
	void BitePrefireDelay();
	void ActivateStage3();
	void ActivateStage2();
	void ActivateStage1();
	void STATIC_Harvest();
	void STATIC_Cultivate();
	void STATIC_Grow();
};


// Class TgGame.TgDevice_Persephone_A01
// 0x0040 (0x053C - 0x04FC)
class ATgDevice_Persephone_A01 : public ATgDevice_Deployable
{
public:
	struct FAimData                                    aimMove;                                                  // 0x04FC(0x0030)
	class ATgDevice_PersephoneW_A01_Sub*               s_SubDevice;                                              // 0x052C(0x0008)
	float                                              r_fSubRange;                                              // 0x0534(0x0004) (Net)
	float                                              r_fSubRadius;                                             // 0x0538(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Persephone_A01");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_GetMoveAim();
};


// Class TgGame.TgDevice_Persephone_A02
// 0x014C (0x0648 - 0x04FC)
class ATgDevice_Persephone_A02 : public ATgDevice_Deployable
{
public:
	class ATgPawn_Persephone*                          m_persephone;                                             // 0x04FC(0x0008) (Const)
	class ATgDeploy_Persephone_A02*                    r_deployList[0x20];                                       // 0x0504(0x0008) (Net)
	unsigned char                                      r_nDeployCount;                                           // 0x0604(0x0001) (Net)
	TEnumAsByte<EPersephoneA02DeployStage>             m_eSpawnPlantStage;                                       // 0x0605(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0606(0x0002) MISSED OFFSET
	TArray<class ATgDevice*>                           m_SubDevices;                                             // 0x0608(0x0010) (NeedCtorLink)
	struct FVector                                     m_vLocInstigator;                                         // 0x0618(0x000C)
	unsigned long                                      m_bIsPetDeploying : 1;                                    // 0x0624(0x0004)
	float                                              m_fReqDistBetweenPlantsSq;                                // 0x0628(0x0004) (Const)
	struct FName                                       m_nmGainSkullAmmo;                                        // 0x062C(0x0008) (Const)
	float                                              m_fAmmoRegenTime;                                         // 0x0634(0x0004) (Const)
	int                                                m_nMaxAmmoCount;                                          // 0x0638(0x0004) (Const)
	int                                                r_nCurrentAmmoCount;                                      // 0x063C(0x0004) (Net)
	int                                                s_nFiringInstanceB;                                       // 0x0640(0x0004)
	int                                                s_nFiringInstanceC;                                       // 0x0644(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Persephone_A02");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_FireAmmunition();
	void STATIC_GetGroundTargetAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void UpdateListVisuals();
	void STATIC_GainSkullAmmo();
	void Remove(class ATgDeploy_Persephone_A02* deployable);
	void Add(class ATgDeploy_Persephone_A02* deployable);
};


// Class TgGame.TgDevice_Persephone_A04
// 0x0014 (0x0510 - 0x04FC)
class ATgDevice_Persephone_A04 : public ATgDevice_Deployable
{
public:
	class ATgPawn*                                     m_HitPawn;                                                // 0x04FC(0x0008)
	class ATgDevice_Persephone_A04_Deploy*             m_SubDevice;                                              // 0x0504(0x0008) (Const)
	unsigned long                                      m_bHitWall : 1;                                           // 0x050C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Persephone_A04");
		return ptr;
	}


	void OnDeployableSpawned(class ATgDeployable* deployable);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Persephone_A04_Deploy
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Persephone_A04_Deploy : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Persephone_A04_Deploy");
		return ptr;
	}


	void OnDeployableDestroyed(class ATgDeployable* deployable);
	class ATgDeploy_Persephone_A04_Bounds* STATIC_SpawnDeployable(class ATgPawn* HitPawn, class ATgDeploy_Persephone_A04* ultimateDeploy);
};


// Class TgGame.TgDevice_Persephone_PSV
// 0x0016 (0x0506 - 0x04F0)
class ATgDevice_Persephone_PSV : public ATgDevice
{
public:
	class ATgPawn_Persephone*                          m_persephone;                                             // 0x04F0(0x0008)
	float                                              m_fRegrowthSelectionTime;                                 // 0x04F8(0x0004) (Const)
	float                                              m_fRegrowthTime;                                          // 0x04FC(0x0004) (Const)
	float                                              m_fDamageDealtPct;                                        // 0x0500(0x0004) (Const)
	unsigned char                                      m_nRegrowthCost;                                          // 0x0504(0x0001) (Const)
	unsigned char                                      m_nGoldConversionRate;                                    // 0x0505(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Persephone_PSV");
		return ptr;
	}


	bool STATIC_CanFireIfLeftMouseDown();
	bool CanFireWhileDead();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_PersephoneW_A01_Sub
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_PersephoneW_A01_Sub : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PersephoneW_A01_Sub");
		return ptr;
	}


	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_CanFireWhileFalling();
};


// Class TgGame.TgDevice_Persephone_A03
// 0x0018 (0x0510 - 0x04F8)
class ATgDevice_Persephone_A03 : public ATgDevice_TweenBase
{
public:
	float                                              m_fRangeSq;                                               // 0x04F8(0x0004) (Const)
	unsigned long                                      m_bJumpBackByDefault : 1;                                 // 0x04FC(0x0004) (Const)
	class ATgPawn_Persephone*                          r_Persephone;                                             // 0x0500(0x0008) (Net)
	class ATgPlayerController*                         m_cachedController;                                       // 0x0508(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Persephone_A03");
		return ptr;
	}


	bool CanBeCanceled();
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
	void STATIC_HandleDeviceFormBuildup(int nDeviceModeNum, float fBuildupTime);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_GetLeapAim(struct FAimData* Aim);
	void STATIC_CultivateTargets();
};


// Class TgGame.TgDeviceFire_Persephone_A04
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Persephone_A04 : public UTgDeviceFire_Deploy
{
public:
	struct FPointer                                    m_pDepSetup;                                              // 0x01C0(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Persephone_A04");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Persephone_A03
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Persephone_A03 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Persephone_A03");
		return ptr;
	}


	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_Persephone_BasicAttack
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Persephone_BasicAttack : public UTgDeviceFire
{
public:
	float                                              m_fActivationRadius;                                      // 0x01C0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Persephone_BasicAttack");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcAoeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceForm_Persephone_A03
// 0x0028 (0x0260 - 0x0238)
class UTgDeviceForm_Persephone_A03 : public UTgDeviceForm
{
public:
	TArray<class ATgDeploy_Persephone_A02*>            c_TargetedPlants;                                         // 0x0238(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                c_AOETargeterFx;                                          // 0x0248(0x0008)
	class UTgSpecialFx*                                c_CompassTargeterFX;                                      // 0x0250(0x0008)
	int                                                c_nAOETargeterFxId;                                       // 0x0258(0x0004)
	int                                                c_nCompassTargeterFxId;                                   // 0x025C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Persephone_A03");
		return ptr;
	}


	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void ExitTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_Persephone_BasicAttack
// 0x001C (0x0254 - 0x0238)
class UTgDeviceForm_Persephone_BasicAttack : public UTgDeviceForm
{
public:
	class ATgDeploy_Persephone_A02*                    c_TargetedPlant;                                          // 0x0238(0x0008)
	class UTgDeviceFire*                               c_Firemode;                                               // 0x0240(0x0008)
	struct FVector                                     c_vProjectileExtent;                                      // 0x0248(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Persephone_BasicAttack");
		return ptr;
	}


	void ExitTargetingMode();
	bool UsesTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_SetFireMode(int nMode);
};


// Class TgGame.TgInventoryObject_Listen_PersephonePassive
// 0x006C (0x0140 - 0x00D4)
class UTgInventoryObject_Listen_PersephonePassive : public UTgInventoryObject_Listen_OnExitStore
{
public:
	class ATgDevice_Persephone_PSV*                    m_devPsv;                                                 // 0x00D4(0x0008)
	class ATgPawn_Persephone*                          m_persephone;                                             // 0x00DC(0x0008)
	unsigned char                                      m_nCurrentSellCount;                                      // 0x00E4(0x0001)
	unsigned char                                      m_nCurrentRemoveCount;                                    // 0x00E5(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00E6(0x0002) MISSED OFFSET
	struct FPersephonePSVTracker                       s_TrackedDevices[0xA];                                    // 0x00E8(0x0008)
	int                                                s_nCurrentTrackIndex;                                     // 0x0138(0x0004)
	float                                              s_fTrackedDamageMult;                                     // 0x013C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_PersephonePassive");
		return ptr;
	}


	void STATIC_SellSeedsInterval();
};


// Class TgGame.TgInventoryObject_Listen_Persephone_A02
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Persephone_A02 : public UTgInventoryObject_Listen
{
public:
	float                                              m_fDiminishingReturnPctB;                                 // 0x00D0(0x0004) (Const)
	float                                              m_fDiminishingReturnPctC;                                 // 0x00D4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Persephone_A02");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Persephone_A03
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Persephone_A03 : public UTgInventoryObject_Listen
{
public:
	class ATgPawn_Persephone*                          m_persephone;                                             // 0x00D0(0x0008)
	class ATgDevice_Persephone_A03*                    m_devA03;                                                 // 0x00D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Persephone_A03");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Persephone_A04_EffectListener
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Persephone_A04_EffectListener : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Persephone_A04_EffectListener");
		return ptr;
	}

};


// Class TgGame.TgPawn_Persephone
// 0x00A8 (0x2660 - 0x25B8)
class ATgPawn_Persephone : public ATgPawn_Character
{
public:
	struct FPointer                                    VfTable_ITgExecuteVictimInterface;                        // 0x25B8(0x0008) (Const, Native, NoExport)
	float                                              m_fLockOutDuration;                                       // 0x25C0(0x0004) (Const)
	int                                                r_nPSVStacks;                                             // 0x25C4(0x0004) (Net)
	unsigned long                                      r_bInRegrowthSelection : 1;                               // 0x25C8(0x0004) (Net)
	unsigned long                                      r_bInRegrowthSelectionLockOut : 1;                        // 0x25C8(0x0004) (Net)
	unsigned long                                      r_bInRegrowth : 1;                                        // 0x25C8(0x0004) (Net)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x25C8(0x0004) (Const)
	unsigned long                                      s_bRegrowthCanceled : 1;                                  // 0x25C8(0x0004)
	unsigned long                                      c_bActiveRegrowthWarningFX : 1;                           // 0x25C8(0x0004)
	unsigned long                                      c_bA03TargetingForward : 1;                               // 0x25C8(0x0004)
	unsigned long                                      c_bA03FiringForward : 1;                                  // 0x25C8(0x0004)
	class ATgDevice_Range*                             m_persephoneAuto;                                         // 0x25CC(0x0008)
	class ATgDevice_Persephone_PSV*                    m_persephonePassive;                                      // 0x25D4(0x0008)
	class ATgDevice_Persephone_A01*                    m_persephoneA01;                                          // 0x25DC(0x0008)
	class ATgDevice_PersephoneW_A01_Sub*               m_persephoneA01a;                                         // 0x25E4(0x0008)
	class ATgDevice_Persephone_A02*                    m_persephoneA02;                                          // 0x25EC(0x0008)
	class ATgDevice*                                   m_persephoneA02a;                                         // 0x25F4(0x0008)
	class ATgDevice*                                   m_persephoneA02b;                                         // 0x25FC(0x0008)
	class ATgDevice*                                   m_persephoneA02c;                                         // 0x2604(0x0008)
	class ATgDevice_Persephone_A03*                    m_persephoneA03;                                          // 0x260C(0x0008)
	class ATgDevice_Persephone_A04*                    m_persephoneA04;                                          // 0x2614(0x0008)
	class ATgDevice_Persephone_A04_Deploy*             m_A04_SubDevice;                                          // 0x261C(0x0008)
	TArray<class ATgDevice*>                           m_CoreOffhandDevices;                                     // 0x2624(0x0010) (NeedCtorLink)
	TArray<class ATgDevice*>                           c_DisplayablePassiveClones;                               // 0x2634(0x0010) (NeedCtorLink)
	struct FVector                                     s_vDeathLocation;                                         // 0x2644(0x000C)
	float                                              s_fDeathTime;                                             // 0x2650(0x0004)
	int                                                m_nActiveRegrowthSeedThreshold;                           // 0x2654(0x0004)
	class UMaterialInstanceConstant*                   c_ActiveRegrowthMIC;                                      // 0x2658(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Persephone");
		return ptr;
	}


	void ChangeRegrowthVisuals();
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_SelectDeathDevices();
	void STATIC_ServerOnRightMousePressed();
	void STATIC_OnRightMousePressed();
	bool STATIC_PawnScoresOnDeath();
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_SetLeapFireMode(int nFireMode);
	void STATIC_OnDeviceFormBuildup(int nEquipSlot, float fBuildupTime);
	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_CanBeExecuted();
	int STATIC_GetCustomParticleSystemFilter();
	void STATIC_SpawnDiffLocPlant(const struct FVector& vLocInstigator);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveBool(int* nResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void STATIC_PawnOnRevive();
	float AdjustRespawnTime(float InRespawnTime);
	void STATIC_ClientDeactivateRegrowthWarningFX();
	void STATIC_ClientActivateRegrowthWarningFX();
	void STATIC_ClientToggleRegrowthWarningFX();
	void STATIC_ClientEndRegrowth();
	void STATIC_ClientStartRegrowth();
	void STATIC_ClientEndRegrowthSelection();
	void STATIC_ClientEndRegrowthSelectionLockOut();
	void STATIC_ClientStartRegrowthSelection();
	void STATIC_EndRegrowth();
	void STATIC_StartRegrowth();
	void STATIC_StartRegrowthSelection();
	bool STATIC_CanReceiveHarvest();
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	void STATIC_SetupParentOwnership(class ATgDevice* Parent, class ATgDevice* SubDevice);
	void STATIC_PrecacheDevices();
	void UpdateClientDevices(bool bForce);
};


// Class TgGame.TgProj_Persephone_A04
// 0x0004 (0x03B0 - 0x03AC)
class ATgProj_Persephone_A04 : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      m_bHitWall : 1;                                           // 0x03AC(0x0004)
	unsigned long                                      m_hasDeployed : 1;                                        // 0x03AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Persephone_A04");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	struct FVector STATIC_GetDeployablePlacement(const struct FVector& HitLoc, class ATgPawn* Target);
};


// Class TgGame.TgAchievement_Yemoja_Turbulent_Waters
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_Yemoja_Turbulent_Waters : public UTgAchievement_AbilityMultiHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Yemoja_Turbulent_Waters");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Yemoja_OmiMastery
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_Yemoja_OmiMastery : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Yemoja_OmiMastery");
		return ptr;
	}

};


// Class TgGame.TgCollisionProxy_Yemoja_A04
// 0x0034 (0x02F0 - 0x02BC)
class ATgCollisionProxy_Yemoja_A04 : public ATgCollisionProxy_Box
{
public:
	struct FPointer                                    VfTable_ITgCustomBlockingTypeInterface;                   // 0x02BC(0x0008) (Const, Native, NoExport)
	class ATgDeploy_Yemoja_A04*                        m_YemojaDep;                                              // 0x02C4(0x0008)
	float                                              m_fMaxLength;                                             // 0x02CC(0x0004) (Const)
	float                                              m_fMaxDist;                                               // 0x02D0(0x0004) (Const)
	float                                              m_fTimeToFinish;                                          // 0x02D4(0x0004) (Const)
	float                                              m_fTimeElapsed;                                           // 0x02D8(0x0004) (Const)
	struct FVector                                     m_vStartingLoc;                                           // 0x02DC(0x000C) (Const)
	float                                              m_fStartingLength;                                        // 0x02E8(0x0004) (Const)
	unsigned long                                      m_bIsGrowthActive : 1;                                    // 0x02EC(0x0004)
	unsigned long                                      m_bIsTweenActive : 1;                                     // 0x02EC(0x0004)
	unsigned long                                      m_bBlockActors : 1;                                       // 0x02EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_Yemoja_A04");
		return ptr;
	}


	TEnumAsByte<ETG_CUSTOM_BLOCKING_TYPE> STATIC_GetCustomBlockingType();
	void STATIC_FindOverlappingActors(TArray<struct FYemojaOverlappingActor>* ValidOverlappingActors);
	void NativeCheckEncroachment();
};


// Class TgGame.TgDeploy_Yemoja_A03
// 0x003C (0x0434 - 0x03F8)
class ATgDeploy_Yemoja_A03 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	class ATgPawn_Yemoja*                              m_YemojaPawn;                                             // 0x03F8(0x0008) (Const)
	float                                              m_fCenterTweenTime;                                       // 0x0400(0x0004) (Const)
	TArray<struct FRiptideTouchedPawns>                m_TouchedPawns;                                           // 0x0404(0x0010) (NeedCtorLink)
	unsigned long                                      r_bIsBackwards : 1;                                       // 0x0414(0x0004) (Net)
	struct FCollisionBoxBounds                         r_CollisionBoxBounds;                                     // 0x0418(0x000C) (Net)
	float                                              r_fForwardCollisionOffset;                                // 0x0424(0x0004) (Net)
	int                                                m_nLaunchingSituationalType;                              // 0x0428(0x0004) (Const)
	int                                                m_nKnockUpSituationalType;                                // 0x042C(0x0004) (Const)
	int                                                r_nActivateKnockUpFx;                                     // 0x0430(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Yemoja_A03");
		return ptr;
	}


	void Destroyed();
	bool STATIC_CanTargetBeLaunched(class ATgPawn* Target);
	float STATIC_GetLifetimeRemaining();
	void TweenTargetToCenter(class ATgPawn* Target);
	bool IsValidTarget(class ATgPawn* Target);
	void HandleTouch(class AActor* Other);
	void ActivateKnockUpFx();
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_HasLineOfSightToCenter(class ATgPawn* Target);
	void UpdateCollisionBoxTransform();
};


// Class TgGame.TgDeploy_Yemoja_A04
// 0x00E8 (0x04F4 - 0x040C)
class ATgDeploy_Yemoja_A04 : public ATgDeploy_Wall
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x040C(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgCustomBlockingTypeInterface;                   // 0x0414(0x0008) (Const, Native, NoExport)
	class ATgPawn_Yemoja*                              m_YemojaPawn;                                             // 0x041C(0x0008)
	float                                              r_fWaveLength;                                            // 0x0424(0x0004) (Const, Net)
	float                                              r_fWaveWidth;                                             // 0x0428(0x0004) (Const, Net)
	float                                              r_fRollOutDuration;                                       // 0x042C(0x0004) (Const, Net)
	float                                              r_fSweepDuration;                                         // 0x0430(0x0004) (Const, Net)
	float                                              r_fRadiusBetweenWaves;                                    // 0x0434(0x0004) (Const, Net)
	float                                              r_fZipperLength;                                          // 0x0438(0x0004) (Const, Net)
	float                                              r_fDelayBeforeSweep;                                      // 0x043C(0x0004) (Const, Net)
	float                                              r_fVisionLengthMargin;                                    // 0x0440(0x0004) (Const)
	float                                              r_fVisionWidthMargin;                                     // 0x0444(0x0004) (Const)
	unsigned long                                      s_bIsZipperActive : 1;                                    // 0x0448(0x0004) (Const)
	class ATgCollisionProxy_Yemoja_A04*                m_WaveProxies[0x2];                                       // 0x044C(0x0008)
	class ATgCollisionProxy_Yemoja_A04*                m_InterriorProxies[0x3];                                  // 0x045C(0x0008)
	TArray<class AActor*>                              s_HitActors;                                              // 0x0474(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_ZipperHitActors;                                        // 0x0484(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_TargetsWaitingToBeHit;                                  // 0x0494(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_RevealedHitActors;                                      // 0x04A4(0x0010) (NeedCtorLink)
	TArray<struct FYemojaWallActorHitInfo>             m_DeferredActorsToCheckForProjectiles;                    // 0x04B4(0x0010) (Component, NeedCtorLink)
	struct FVector                                     m_vAnchorPointRelativeLoc;                                // 0x04C4(0x000C)
	struct FVector                                     m_vRightTriangleNormal;                                   // 0x04D0(0x000C)
	struct FVector                                     m_vLeftTriangleNormal;                                    // 0x04DC(0x000C)
	int                                                m_nSelfBuffSituationalType;                               // 0x04E8(0x0004) (Const)
	int                                                m_nLingeringBuffSituationalType;                          // 0x04EC(0x0004) (Const)
	int                                                m_nRevealSituationalType;                                 // 0x04F0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Yemoja_A04");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
	void RestoreDefaultWallPushoutAccel(class ATgPawn* Target);
	struct FImpactInfo STATIC_CreateHitImpact(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool IsValidSelfTarget(class AActor* Other);
	bool IsValidHitTarget(class AActor* Other);
	bool IsValidTarget(class AActor* Other);
	void STATIC_HitTarget(class AActor* Target);
	bool IsTargetBehindZipper(class AActor* Target);
	bool IsTargetInZipper(class AActor* Target);
	bool IsTargetInRange(class AActor* Target);
	bool STATIC_CanHitTarget(class AActor* Target);
	bool STATIC_HandleProjectileBlock(class AActor* Target, class UPrimitiveComponent* HitComp);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void VisionProxyUnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void VisionProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ZipperHitProxyUnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ZipperHitProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void RiverProxyUnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void RiverProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	TEnumAsByte<ETG_CUSTOM_BLOCKING_TYPE> STATIC_GetCustomBlockingType();
	void STATIC_RemoveOverlappingActor(class AActor* Other);
	void AddOverlappingActor(class AActor* Other, const struct FVector& PushDirection, bool bForceNewEntry);
	bool IsPushable(class AActor* Other);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void STATIC_FindOverlappingActors();
	void STATIC_StartZipperSweep();
	void STATIC_CleanupProxies();
	void STATIC_SpawnCollisionProxies();
};


// Class TgGame.TgDeploy_Yemoja_A01
// 0x0058 (0x042C - 0x03D4)
class ATgDeploy_Yemoja_A01 : public ATgDeployable
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03D4(0x0008) (Const, Native, NoExport)
	class ATgPawn_Yemoja*                              m_YemojaPawn;                                             // 0x03DC(0x0008) (Const)
	struct FVector                                     m_vStartLoc;                                              // 0x03E4(0x000C) (Const)
	struct FVector                                     r_vFirstBounceLoc;                                        // 0x03F0(0x000C) (Const, Net)
	struct FVector                                     r_vSecondBounceLoc;                                       // 0x03FC(0x000C) (Const, Net)
	float                                              m_fBounceTime;                                            // 0x0408(0x0004) (Const)
	float                                              m_fDeployExplosionRadius;                                 // 0x040C(0x0004) (Const)
	int                                                m_nNumSmallBubbles;                                       // 0x0410(0x0004) (Const)
	float                                              m_fSmallBubbleDistOffset;                                 // 0x0414(0x0004) (Const)
	int                                                m_nBounced;                                               // 0x0418(0x0004)
	TArray<class AActor*>                              m_TrackedPlayerList;                                      // 0x041C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Yemoja_A01");
		return ptr;
	}


	void STATIC_DeployComplete();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void STATIC_SeekToBounceLoc();
	void STATIC_FireProjectile(const struct FVector& vTargetLoc, class UTgDeviceFire* FireMode);
	void STATIC_FireMultiBounce();
	void STATIC_FireBounce();
};


// Class TgGame.TgDeploy_Yemoja_B01
// 0x006D (0x0441 - 0x03D4)
class ATgDeploy_Yemoja_B01 : public ATgDeployable
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03D4(0x0008) (Const, Native, NoExport)
	class ATgPawn_Yemoja*                              m_YemojaPawn;                                             // 0x03DC(0x0008) (Const)
	struct FVector                                     r_vInnerFractureLeft;                                     // 0x03E4(0x000C) (Const, Net)
	struct FVector                                     r_vInnerFractureRight;                                    // 0x03F0(0x000C) (Const, Net)
	struct FVector                                     r_vOuterFractureLeft;                                     // 0x03FC(0x000C) (Const, Net)
	struct FVector                                     r_vOuterFractureRight;                                    // 0x0408(0x000C) (Const, Net)
	float                                              m_fSmallFractureRadius;                                   // 0x0414(0x0004) (Const)
	float                                              m_fCenterFractureRadius;                                  // 0x0418(0x0004) (Const)
	float                                              r_fRangeRatio;                                            // 0x041C(0x0004) (Const, Net)
	float                                              r_fMaxRadiusMultiplier;                                   // 0x0420(0x0004) (Const, Net)
	float                                              r_fDamageDelay;                                           // 0x0424(0x0004) (Const, Net)
	float                                              r_fTimesToWarn[0x3];                                      // 0x0428(0x0004) (Net)
	float                                              r_fTimesToActivate[0x3];                                  // 0x0434(0x0004) (Net)
	unsigned char                                      m_byHasFxActivated;                                       // 0x0440(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Yemoja_B01");
		return ptr;
	}


	void STATIC_DeployComplete();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void ActivateCenterFracture();
	void ActivateInnerFracture();
	void ActivateOuterFracture();
	void WarnCenterFracture();
	void WarnInnerFracture();
	void WarnOuterFracture();
};


// Class TgGame.TgDevice_Yemoja_A01
// 0x004C (0x0548 - 0x04FC)
class ATgDevice_Yemoja_A01 : public ATgDevice_Deployable
{
public:
	class ATgPawn_Yemoja*                              r_YemojaPawn;                                             // 0x04FC(0x0008) (Const, Net)
	class ATgDevice*                                   m_SubDevice;                                              // 0x0504(0x0008) (Const)
	struct FVector                                     m_vFirstBounceLoc;                                        // 0x050C(0x000C) (Const)
	struct FVector                                     m_vSecondBounceLoc;                                       // 0x0518(0x000C) (Const)
	float                                              m_fBounceDamageRadius;                                    // 0x0524(0x0004) (Const)
	TArray<struct FVector>                             m_vSmallBubbleLocs;                                       // 0x0528(0x0010) (NeedCtorLink)
	int                                                m_nNumSmallBubbles;                                       // 0x0538(0x0004) (Const)
	float                                              m_fSmallBubbleOffset;                                     // 0x053C(0x0004) (Const)
	float                                              m_fBubbleDamageRadius;                                    // 0x0540(0x0004) (Const)
	unsigned long                                      m_bInitializedSubDeviceVars : 1;                          // 0x0544(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Yemoja_A01");
		return ptr;
	}


	void STATIC_GetCachedAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Yemoja_A03
// 0x0014 (0x0510 - 0x04FC)
class ATgDevice_Yemoja_A03 : public ATgDevice_Deployable
{
public:
	TEnumAsByte<EYemojaRiptideOrientation>             m_eTransformType;                                         // 0x04FC(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04FD(0x0003) MISSED OFFSET
	float                                              m_fTransformRanges[0x2];                                  // 0x0500(0x0004) (Const)
	class UTgDeviceForm_Yemoja_A03*                    c_YemojaDeviceForm;                                       // 0x0508(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Yemoja_A03");
		return ptr;
	}


	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void STATIC_CustomFire();
	void TickTargetingMode(float DeltaSeconds);
	void STATIC_PopSelfKnockupPosture();
	TEnumAsByte<EYemojaRiptideOrientation> STATIC_GetBestTransform(const struct FAimData& Aim);
};


// Class TgGame.TgDevice_Yemoja_A04
// 0x000C (0x0508 - 0x04FC)
class ATgDevice_Yemoja_A04 : public ATgDevice_Deployable
{
public:
	class ATgDevice*                                   m_SubDevice;                                              // 0x04FC(0x0008)
	float                                              m_fConePullbackDistance;                                  // 0x0504(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Yemoja_A04");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	float STATIC_GetConePullbackDistance();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Yemoja_B01
// 0x0068 (0x0564 - 0x04FC)
class ATgDevice_Yemoja_B01 : public ATgDevice_Deployable
{
public:
	int                                                c_nNumSmallFractures;                                     // 0x04FC(0x0004) (Const)
	class ATgPawn_Yemoja*                              r_YemojaPawn;                                             // 0x0500(0x0008) (Const, Net)
	class ATgDevice*                                   m_SubDevice;                                              // 0x0508(0x0008) (Const)
	float                                              m_fRadialPercBeforeNextFracture;                          // 0x0510(0x0004) (Const)
	struct FVector                                     m_vInnerFractureLeft;                                     // 0x0514(0x000C)
	struct FVector                                     m_vInnerFractureRight;                                    // 0x0520(0x000C)
	struct FVector                                     m_vOuterFractureLeft;                                     // 0x052C(0x000C)
	struct FVector                                     m_vOuterFractureRight;                                    // 0x0538(0x000C)
	unsigned long                                      m_bInitializedSubDeviceVars : 1;                          // 0x0544(0x0004) (Const)
	float                                              m_fRangeSq;                                               // 0x0548(0x0004) (Const)
	float                                              m_fRangeRatio;                                            // 0x054C(0x0004) (Const)
	float                                              m_fMaxRadiusMultiplier;                                   // 0x0550(0x0004) (Const)
	float                                              m_fSmallFractureRadius;                                   // 0x0554(0x0004) (Const)
	float                                              m_fCenterFractureRadius;                                  // 0x0558(0x0004) (Const)
	float                                              m_fSmallFractureRadiusMin;                                // 0x055C(0x0004) (Const)
	float                                              m_fCenterFractureRadiusMin;                               // 0x0560(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Yemoja_B01");
		return ptr;
	}


	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Yemoja_A02
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Yemoja_A02 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Yemoja_A02");
		return ptr;
	}

};


// Class TgGame.TgDevice_Yemoja_Basic
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Yemoja_Basic : public ATgDevice_Range
{
public:
	float                                              m_fEnemyProjCollisionRadius;                              // 0x04F0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Yemoja_Basic");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Yemoja_A01_Sub
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Yemoja_A01_Sub : public UTgDeviceFire
{
public:
	float                                              m_fPercAbsorbedDamage;                                    // 0x01C0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Yemoja_A01_Sub");
		return ptr;
	}


	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceFire_Yemoja_A02
// 0x0010 (0x01D0 - 0x01C0)
class UTgDeviceFire_Yemoja_A02 : public UTgDeviceFire
{
public:
	int                                                m_nArcingProjId;                                          // 0x01C0(0x0004) (Const)
	int                                                m_nHealSituationalType;                                   // 0x01C4(0x0004) (Const)
	int                                                m_nShieldSituationalType;                                 // 0x01C8(0x0004) (Const)
	int                                                m_nDamageSituationalType;                                 // 0x01CC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Yemoja_A02");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void STATIC_SpawnArcingProjectile(class AActor* Target, const struct FVector& SpawnLoc, const struct FVector& SpawnDir, int nFiringInstance);
};


// Class TgGame.TgDeviceForm_Yemoja_A03
// 0x0015 (0x0269 - 0x0254)
class UTgDeviceForm_Yemoja_A03 : public UTgDeviceForm_SunWukong_Transform
{
public:
	int                                                c_nBackwardTargeterFxId;                                  // 0x0254(0x0004) (Const)
	class UTgSpecialFx*                                c_ForwardsTargeterFx;                                     // 0x0258(0x0008) (Const)
	class UTgSpecialFx*                                c_BackwardsTargeterFx;                                    // 0x0260(0x0008) (Const)
	TEnumAsByte<EYemojaRiptideOrientation>             c_eCurrentOrientation;                                    // 0x0268(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Yemoja_A03");
		return ptr;
	}


	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_Yemoja_A01
// 0x0024 (0x025C - 0x0238)
class UTgDeviceForm_Yemoja_A01 : public UTgDeviceForm
{
public:
	int                                                c_nBubbleTargeterFxId;                                    // 0x0238(0x0004) (Const)
	class ATgDevice_Yemoja_A01*                        c_A01Device;                                              // 0x023C(0x0008)
	TArray<class UTgSpecialFx*>                        c_BubbleTargeterFxs;                                      // 0x0244(0x0010) (NeedCtorLink)
	class UTgSpecialFx*                                c_BounceTargeterFx;                                       // 0x0254(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Yemoja_A01");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
	void MoveFXLocationAndRotation(class UTgSpecialFx* Fx, const struct FVector& NewLoc, const struct FRotator& NewRotation);
	void UpdateTargeterPositions();
};


// Class TgGame.TgDeviceForm_Yemoja_B01
// 0x0028 (0x0260 - 0x0238)
class UTgDeviceForm_Yemoja_B01 : public UTgDeviceForm
{
public:
	int                                                c_nSmallFractureTargeterFxId;                             // 0x0238(0x0004) (Const)
	int                                                c_nNumOfSmallFractures;                                   // 0x023C(0x0004) (Const)
	class ATgDevice_Yemoja_B01*                        c_B01Device;                                              // 0x0240(0x0008)
	TArray<struct FFractureTargeterFx>                 c_FractureTargeterFxs;                                    // 0x0248(0x0010) (NeedCtorLink)
	float                                              c_fSmallerScaleModifier;                                  // 0x0258(0x0004) (Const)
	float                                              c_fPreviousScale;                                         // 0x025C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Yemoja_B01");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
	void UpdateTargeterPositions();
};


// Class TgGame.TgInventoryObject_Listen_Yemoja_A02_Effect
// 0x0008 (0x00EC - 0x00E4)
class UTgInventoryObject_Listen_Yemoja_A02_Effect : public UTgInventoryObject_Listen_Effect
{
public:
	class UTgDeviceFire_Yemoja_A02*                    s_YemojaA02FireMode;                                      // 0x00E4(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Yemoja_A02_Effect");
		return ptr;
	}


	void STATIC_OnAppliedAsListener();
};


// Class TgGame.TgInventoryObject_Listen_Yemoja_PSV
// 0x0024 (0x00F4 - 0x00D0)
class UTgInventoryObject_Listen_Yemoja_PSV : public UTgInventoryObject_Listen
{
public:
	class ATgPawn_Yemoja*                              s_Yemoja;                                                 // 0x00D0(0x0008) (Const)
	struct FYemojaPipObjective                         s_PipObjectives[0x3];                                     // 0x00D8(0x0008) (Const)
	int                                                s_nAppliedPipCount;                                       // 0x00F0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Yemoja_PSV");
		return ptr;
	}


	void AsyncFinishPip();
};


// Class TgGame.TgPawn_Yemoja
// 0x0094 (0x264C - 0x25B8)
class ATgPawn_Yemoja : public ATgPawn_Character
{
public:
	struct FPointer                                    VfTable_ITgPawn_DialogueInterface;                        // 0x25B8(0x0008) (Const, Native, NoExport)
	class ATgDevice_Range*                             m_yemojaAuto;                                             // 0x25C0(0x0008)
	class ATgDevice*                                   m_yemojaPSV;                                              // 0x25C8(0x0008)
	class ATgDevice_Yemoja_A01*                        m_yemojaA01;                                              // 0x25D0(0x0008)
	class ATgDevice*                                   m_yemojaA01_SubDevice;                                    // 0x25D8(0x0008)
	class ATgDevice_Yemoja_B01*                        m_yemojaB01;                                              // 0x25E0(0x0008)
	class ATgDevice*                                   m_yemojaB01_SubDevice;                                    // 0x25E8(0x0008)
	class ATgDevice_Yemoja_A02*                        m_yemojaA02;                                              // 0x25F0(0x0008)
	class ATgDevice_Yemoja_A03*                        m_yemojaA03;                                              // 0x25F8(0x0008)
	class ATgDevice_Yemoja_A04*                        m_yemojaA04;                                              // 0x2600(0x0008)
	class ATgDevice*                                   m_yemojaA04_SubDevice;                                    // 0x2608(0x0008)
	class ATgDevice_Dialogue*                          m_dialogueDevice;                                         // 0x2610(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x2618(0x0004) (Const)
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               m_A01EquipSlots;                                          // 0x261C(0x0010) (NeedCtorLink)
	TEnumAsByte<EYemojaStance>                         r_eYemojaStance;                                          // 0x262C(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x262D(0x0003) MISSED OFFSET
	float                                              m_CostOfPip;                                              // 0x2630(0x0004) (Const)
	int                                                r_nPipThresholdsPSV[0x3];                                 // 0x2634(0x0004) (Net)
	int                                                r_nExtraPipCount;                                         // 0x2640(0x0004) (Net)
	float                                              m_fCooldownEnergyRegenBase;                               // 0x2644(0x0004) (Const)
	float                                              m_fAsyncEnergyRewarded;                                   // 0x2648(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Yemoja");
		return ptr;
	}


	bool STATIC_ShouldPawnTriggerCastReactionItems(class UTgDeviceFire* FireMode);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
	class ATgDevice_Dialogue* STATIC_GetDialogueDevice();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	TEnumAsByte<ESpecialItemPurchaseException> STATIC_HasSpecialPurchaseException(int nItemId);
	void STATIC_ReduceYemojaActiveCooldown(float fCooldownReductionAmt, bool bPercentage);
	void STATIC_ReduceActiveCooldownForOffhand(TEnumAsByte<ETG_EQUIP_POINT> offhandType, float fValue, bool bPercentage);
	void STATIC_ReduceActiveCooldowns(float fValue, bool bPercentage);
	void STATIC_RegainEnergyPool(float fDelta);
	void STATIC_SetSpawnEnergy();
	float STATIC_GetManaPercent();
	void STATIC_DeviceOnSetFireMode(class ATgDevice* Dev);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	void DeviceOnStartFire(class ATgDevice* Dev);
	void STATIC_PrecacheDevices();
	void UpdateClientDevices(bool bForce);
	void STATIC_PostPawnSetupServer();
	bool IsValidStanceEquipSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetActiveEquipSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp, bool bActive);
	void STATIC_SetA01Stance(TEnumAsByte<EYemojaStance> eYS);
	bool STATIC_ShouldSwitchStance(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	TEnumAsByte<EYemojaStance> STATIC_SwitchStance();
};


// Class TgGame.TgProj_Yemoja_A02_Straight
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Yemoja_A02_Straight : public ATgProj_SimulatedPassThroughUntilAlliedGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Yemoja_A02_Straight");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Yemoja_BasicAttack
// 0x0014 (0x03C0 - 0x03AC)
class ATgProj_Yemoja_BasicAttack : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_fEnemyProjCollisionRadius;                              // 0x03AC(0x0004) (Const)
	TArray<class AActor*>                              m_EnemiesTouched;                                         // 0x03B0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Yemoja_BasicAttack");
		return ptr;
	}


	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Yemoja_A02_Arcing
// 0x0024 (0x0430 - 0x040C)
class ATgProj_Yemoja_A02_Arcing : public ATgProj_SimulatedArcing
{
public:
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x040C(0x0010) (NeedCtorLink)
	float                                              m_fCollisionSizeOverride;                                 // 0x041C(0x0004) (Const)
	float                                              m_fVertStrengthMaxThreshold;                              // 0x0420(0x0004) (Const)
	float                                              m_fVertStrengthMinThreshold;                              // 0x0424(0x0004) (Const)
	float                                              m_fVertStrengthMax;                                       // 0x0428(0x0004) (Const)
	float                                              m_fVertStrengthMin;                                       // 0x042C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Yemoja_A02_Arcing");
		return ptr;
	}


	void STATIC_OverrideSeekingRotation(struct FRotator* SeekingRotation);
	bool IsValidTargetClient(class AActor* A);
	bool IsValidTargetServer(class AActor* A);
	bool IsValidTarget(class AActor* A);
	void Tick(float fDeltaTime);
	void PostProjectileInitialize();
};


// Class TgGame.TgAchievement_Heimdallr_FarSeeingSight
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_Heimdallr_FarSeeingSight : public UTgAchievement
{
public:
	float                                              m_fTravelDistanceSq;                                      // 0x0084(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Heimdallr_FarSeeingSight");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Heimdallr_JourneyThroughTheRealms
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Heimdallr_JourneyThroughTheRealms : public UTgAchievement
{
public:
	int                                                m_nKillGoal;                                              // 0x0084(0x0004) (Const)
	int                                                m_nKillCount;                                             // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Heimdallr_JourneyThroughTheRealms");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Heimdallr_A03
// 0x0088 (0x0534 - 0x04AC)
class ATgDeployable_Heimdallr_A03 : public ATgDeploy_AutoPortal
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x04AC(0x0008) (Const, Native, NoExport)
	class ATgDevice_Heimdallr_A03*                     s_CachedHeimDev;                                          // 0x04B4(0x0008)
	class UTgDeviceFire*                               s_CachedFireMode;                                         // 0x04BC(0x0008)
	class ATgPawn*                                     s_CachedTouchedPawn;                                      // 0x04C4(0x0008)
	float                                              c_fCurrentExplosionPerc;                                  // 0x04CC(0x0004)
	float                                              c_fCurrentFireDelay;                                      // 0x04D0(0x0004)
	TEnumAsByte<EHeimdallrDeployableFxState>           c_eCurrentFxState;                                        // 0x04D4(0x0001)
	TEnumAsByte<EHeimdallrA03ActiveStatus>             r_eActiveStatus;                                          // 0x04D5(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x04D6(0x0002) MISSED OFFSET
	struct FName                                       m_nmSuccessfulFire;                                       // 0x04D8(0x0008) (Const)
	struct FName                                       m_nmExplode;                                              // 0x04E0(0x0008) (Const)
	struct FName                                       m_nmWarble;                                               // 0x04E8(0x0008) (Const)
	float                                              m_fExplodeMin;                                            // 0x04F0(0x0004) (Const)
	float                                              m_fExplodeMax;                                            // 0x04F4(0x0004) (Const)
	float                                              m_fWarbleMin;                                             // 0x04F8(0x0004) (Const)
	float                                              m_fWarbleThreshold;                                       // 0x04FC(0x0004) (Const)
	float                                              m_fWarbleMax;                                             // 0x0500(0x0004) (Const)
	float                                              m_fWarblePowerMod;                                        // 0x0504(0x0004) (Const)
	float                                              m_fGrowthDuration;                                        // 0x0508(0x0004) (Const)
	class ATgDeployable_Heimdallr_A03*                 r_HeimA03Twin;                                            // 0x050C(0x0008) (Net)
	class ATgPawn_Heimdallr*                           r_heimdallr;                                              // 0x0514(0x0008) (Net)
	float                                              r_fFireDelay;                                             // 0x051C(0x0004) (Net)
	float                                              r_fOscillationFactor;                                     // 0x0520(0x0004) (Net)
	float                                              r_fInitialCooldown;                                       // 0x0524(0x0004) (Net)
	float                                              r_fCurrentCooldown;                                       // 0x0528(0x0004) (Net)
	int                                                r_nTeleportFxId;                                          // 0x052C(0x0004) (Net)
	unsigned long                                      r_bIsActive : 1;                                          // 0x0530(0x0004) (Net)
	unsigned long                                      r_bHasTarget : 1;                                         // 0x0530(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Heimdallr_A03");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void Teleport(class AActor* Target);
	void DestroyIt(bool bSkipFx);
	void SetCurrentCooldown(float fNewCooldown);
	void SetInactive(float fStartingCooldown);
	void SetActive();
	void SuccessfulFire();
	void AttemptStartFire(class AActor* Other);
	void InterruptTeleportAttempt(class AActor* Other);
	void ValidateTeleport();
	void UpdateLinkBeamFX();
	void STATIC_InitializeCustomParticleSystemFilter(int nFilter);
	void STATIC_HandleOscillationVisuals();
	void STATIC_HandleActiveStateVisuals(float fDeltaSeconds);
	void STATIC_SetFireDelay(float fNewDelay, bool bRescursivePass);
	void STATIC_CleanUpDeployable();
	void UnRegisterTwin(bool bRecursivePass);
	void STATIC_RegisterTwin(class ATgDeployable_Heimdallr_A03* twinDeploy, bool bRecursivePass);
	void UpdateFireMode(class UTgDeviceFire* newFireMode);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void STATIC_InitializeTeleportFX();
};


// Class TgGame.TgDeployable_Heimdallr_A01
// 0x00A4 (0x0478 - 0x03D4)
class ATgDeployable_Heimdallr_A01 : public ATgDeployable
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03D4(0x0008) (Const, Native, NoExport)
	class ATgPawn_Heimdallr*                           m_heimdallr;                                              // 0x03DC(0x0008)
	class ATgDevice_Heimdallr_A01SubDeploy*            m_subDeploy;                                              // 0x03E4(0x0008)
	class ATgDevice_Heimdallr_A01SubDev*               m_subDev;                                                 // 0x03EC(0x0008)
	struct FRotator                                    m_rCachedTargetRotation;                                  // 0x03F4(0x000C)
	struct FRotator                                    m_rCachedStartRotation;                                   // 0x0400(0x000C)
	struct FVector                                     m_vCachedStartLocation;                                   // 0x040C(0x000C)
	unsigned long                                      m_bTravelingToTarget : 1;                                 // 0x0418(0x0004)
	unsigned long                                      r_bHasTarget : 1;                                         // 0x0418(0x0004) (Net)
	float                                              r_fTravelWarmupTime;                                      // 0x041C(0x0004) (Const, Net)
	float                                              r_fTargetSpeed;                                           // 0x0420(0x0004) (Const, Net)
	float                                              r_fMinTimeToTarget;                                       // 0x0424(0x0004) (Const, Net)
	float                                              r_fMaxTimeToTarget;                                       // 0x0428(0x0004) (Const, Net)
	float                                              r_fMaxActiveScale;                                        // 0x042C(0x0004) (Const, Net)
	float                                              r_fHeightOffsetScalar;                                    // 0x0430(0x0004) (Const, Net)
	float                                              r_fTimeToWarn;                                            // 0x0434(0x0004) (Const, Net)
	struct FAimData                                    s_TargetAim;                                              // 0x0438(0x0030)
	float                                              s_fTargetDistanceSq;                                      // 0x0468(0x0004)
	struct FVector                                     r_vTargetLocation;                                        // 0x046C(0x000C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Heimdallr_A01");
		return ptr;
	}


	void STATIC_ResetTargetingDevice();
	void UnregisterFromSubDevice();
	void STATIC_StopSubDeployDevice();
	void DestroyIt(bool bSkipFx);
	void STATIC_ExplodeAtTarget();
	void WarnAtTarget();
	void AccelerateToTarget();
	void Warmup();
	void Tick(float DeltaSeconds);
	float STATIC_CalculateTimeToLand();
	void BeginTraveling();
	void Activate();
	void STATIC_SetTargetAim(const struct FAimData& targetAim);
	void ReplicatedEvent(const struct FName& VarName);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void STATIC_FireSwordHit();
};


// Class TgGame.TgDeployable_Heimdallr_A04
// 0x00F4 (0x04C8 - 0x03D4)
class ATgDeployable_Heimdallr_A04 : public ATgDeployable
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03D4(0x0008) (Const, Native, NoExport)
	struct FVector2D                                   r_vEnterPointOffset;                                      // 0x03DC(0x0008) (Const, Net)
	float                                              r_fExitPointMinDistance;                                  // 0x03E4(0x0004) (Const, Net)
	float                                              r_fExitPointMaxDistance;                                  // 0x03E8(0x0004) (Const, Net)
	float                                              r_fExitPointConeAngle;                                    // 0x03EC(0x0004) (Const, Net)
	float                                              r_fExitPointZOffset;                                      // 0x03F0(0x0004) (Const, Net)
	float                                              r_fIntroTime;                                             // 0x03F4(0x0004) (Const, Net)
	float                                              r_fOutroTime;                                             // 0x03F8(0x0004) (Const, Net)
	class ATgPawn_Heimdallr*                           r_cachedHeimdallr;                                        // 0x03FC(0x0008) (Net)
	class ATgPawn*                                     r_pHitPawn;                                               // 0x0404(0x0008) (Net)
	class ATgPawn*                                     r_pAttachedPawn;                                          // 0x040C(0x0008) (Net)
	struct FVector                                     r_vDeployEndPoint;                                        // 0x0414(0x000C) (Net)
	struct FVector                                     r_vIntroLocation;                                         // 0x0420(0x000C) (Net)
	struct FVector                                     r_vVictimEnterPoint;                                      // 0x042C(0x000C) (Net)
	struct FVector                                     r_vVictimExitPortalLocation;                              // 0x0438(0x000C) (Net)
	struct FVector                                     r_vVictimExitLandingPoint;                                // 0x0444(0x000C) (Net)
	TEnumAsByte<EHeimA04VisibilityState>               r_eVisibilityState;                                       // 0x0450(0x0001) (Net)
	unsigned char                                      r_nPortalActivationEvent;                                 // 0x0451(0x0001) (Net)
	unsigned char                                      r_nPostureCleanupEvent;                                   // 0x0452(0x0001) (Net)
	TEnumAsByte<EHeimA04VisibilityState>               r_eCurrentBarrierBreakState;                              // 0x0453(0x0001) (Net)
	unsigned long                                      r_bApplyCameraOverride : 1;                               // 0x0454(0x0004) (Net)
	unsigned long                                      r_bApplyCameraRot : 1;                                    // 0x0454(0x0004) (Net)
	unsigned long                                      r_bApplyCameraAnim : 1;                                   // 0x0454(0x0004) (Net)
	unsigned long                                      s_bKillHitPawnOnExit : 1;                                 // 0x0454(0x0004)
	class UTgDeviceFire*                               s_CachedFireMode;                                         // 0x0458(0x0008)
	class UTgHeimdallr_A04MeshProcessor*               c_meshProcessor;                                          // 0x0460(0x0008)
	class UCameraAnim*                                 m_UltCinematicAnim;                                       // 0x0468(0x0008)
	struct FRotator                                    m_rCameraOffset;                                          // 0x0470(0x000C)
	struct FHeimA04SectionTimings                      m_SectionTimings[0x2];                                    // 0x047C(0x000C) (Const)
	int                                                m_nUltCameraResId;                                        // 0x0494(0x0004) (Const)
	int                                                m_nMeshBId;                                               // 0x0498(0x0004) (Const)
	float                                              m_fDeployLength;                                          // 0x049C(0x0004) (Const)
	float                                              m_fDefaultTravelTime;                                     // 0x04A0(0x0004) (Const)
	float                                              m_fDefaultDelayTime;                                      // 0x04A4(0x0004) (Const)
	float                                              m_fBarrierPercent;                                        // 0x04A8(0x0004) (Const)
	float                                              m_fBarrierLength;                                         // 0x04AC(0x0004) (Const)
	float                                              m_fAnimRate;                                              // 0x04B0(0x0004) (Const)
	float                                              m_fAnimScale;                                             // 0x04B4(0x0004) (Const)
	float                                              m_fAnimBlendInTime;                                       // 0x04B8(0x0004) (Const)
	float                                              m_fAnimBlendOutTime;                                      // 0x04BC(0x0004) (Const)
	float                                              m_fAnimDuration;                                          // 0x04C0(0x0004) (Const)
	float                                              m_fCameraInterpDegreeOffset;                              // 0x04C4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Heimdallr_A04");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_EndingOutroLogic();
	void STATIC_StageTwoOutro();
	void STATIC_StageTwoExplosion();
	void STATIC_StageOneOutro();
	void STATIC_StageOneExplosion();
	void STATIC_EndingIntroLogic();
	void STATIC_CycleAnyTargetSpectators();
	void STATIC_PrintUltEndDebugLog(class ATgPawn* debugPawn, bool bIsAttachedPawn);
	void STATIC_DeactivateExitPortal();
	void STATIC_DeactivateEntrancePortal();
	void ActivateExitPortal();
	void ActivateEntrancePortal();
	void ManageFinalExitPostures();
	void ManageCameraAnimOverrideState(bool bTurnOn);
	void ManageCameraOverrideState(bool bTurnOn);
	void STATIC_SetAttachedPawns();
	void STATIC_SetHitPawn(class ATgPawn* HitPawn);
	bool IsValidPawn(class ATgPawn* HitPawn);
	void CustomDeployableStart(class ATgPawn* HitPawn);
	float STATIC_GetStageOutroTimeBySection(TEnumAsByte<EHeimA04VisibilityState> eVisState);
	float STATIC_GetStagePersistTimeBySection(TEnumAsByte<EHeimA04VisibilityState> eVisState);
	float STATIC_GetStageTotalTimeBySection(TEnumAsByte<EHeimA04VisibilityState> eVisState);
	void STATIC_CleanupFinalExitPosturesFromTarget(class ATgPawn* PawnTarget);
	void STATIC_CleanupFinalExitPostures();
	void STATIC_RemoveActionCameraRotOverrideFromTarget(class ATgPawn* PawnTarget);
	void STATIC_RemoveActionCameraRotOverride();
	void ApplyActionCameraRotOverrideToTarget(class ATgPawn* PawnTarget);
	void ApplyActionCameraRotOverride();
	void STATIC_RemoveCameraAnimFromTarget(class ATgPawn* PawnTarget);
	void STATIC_RemoveCameraAnim();
	void ApplyCameraAnimToTarget(class ATgPawn* PawnTarget);
	void ApplyCameraAnim();
	void STATIC_RemoveCameraOverrideFromTarget(class ATgPawn* PawnTarget);
	void STATIC_RemoveCameraOverride();
	void ApplyCameraOverrideToTarget(class ATgPawn* PawnTarget);
	void ApplyCameraOverride();
	struct FVector NativeSelectExitLocation(struct FVector* vIntroLocation);
	float STATIC_GetTotalTime();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void STATIC_DeferredPawnRegister();
	void ApplyPostProcess();
	void TurnOffActionCamera(class ATgPawn* PawnTarget);
	void TurnOnActionCamera(class ATgPawn* PawnTarget);
	void UpdateTimings();
	void UpdateFireMode(class UTgDeviceFire* newFireMode);
	void STATIC_DeactivateBarrierBreakFX(int nSectionIndex);
	void ActivateBarrierBreakFX(int nSectionIndex);
	void STATIC_DeactivateBarrierFX(int nSectionIndex);
	void ActivateBarrierFX(int nSectionIndex);
	void STATIC_SetSectionMeshVisibility(int nSectionIndex, bool bVisible);
	void STATIC_SetVisibilityState(TEnumAsByte<EHeimA04VisibilityState> eNewState);
	void ManageSectionVisibility();
	void STATIC_SetUpCameraAnim();
};


// Class TgGame.TgDevice_Heimdallr_A01SubDeploy
// 0x0008 (0x052C - 0x0524)
class ATgDevice_Heimdallr_A01SubDeploy : public ATgDevice_Aura
{
public:
	class ATgPawn_Heimdallr*                           r_heimdallr;                                              // 0x0524(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Heimdallr_A01SubDeploy");
		return ptr;
	}


	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Heimdallr_A04
// 0x002C (0x0590 - 0x0564)
class ATgDevice_Heimdallr_A04 : public ATgDevice_Charge_ChainSubDevice
{
public:
	float                                              m_fExitMinRange;                                          // 0x0564(0x0004) (Const)
	float                                              m_fExitMaxRange;                                          // 0x0568(0x0004) (Const)
	float                                              m_fExitAngle;                                             // 0x056C(0x0004) (Const)
	float                                              m_fExitHeight;                                            // 0x0570(0x0004) (Const)
	unsigned long                                      r_bIsActive : 1;                                          // 0x0574(0x0004) (Net)
	class UTgDeviceFire*                               s_CachedFireMode;                                         // 0x0578(0x0008)
	class ATgPawn_Heimdallr*                           s_HeimOwner;                                              // 0x0580(0x0008)
	class ATgPawn*                                     m_pHitPawn;                                               // 0x0588(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Heimdallr_A04");
		return ptr;
	}


	void DeviceCleanup();
	void STATIC_ChainSubDevice(class ATgDevice* SubDevice);
	bool STATIC_CanChainSubDevice(class ATgDevice* SubDevice);
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	int STATIC_GetSubDeviceIndex();
	void STATIC_ClientForcePostFire();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Heimdallr_A01
// 0x001C (0x0518 - 0x04FC)
class ATgDevice_Heimdallr_A01 : public ATgDevice_Deployable
{
public:
	class ATgPawn_Heimdallr*                           r_heimdallr;                                              // 0x04FC(0x0008) (Net)
	TArray<class ATgDevice*>                           m_SubDevices;                                             // 0x0504(0x0010) (NeedCtorLink)
	unsigned long                                      m_bWaitingOnDeployable : 1;                               // 0x0514(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Heimdallr_A01");
		return ptr;
	}


	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void OnDeployableSpawned(class ATgDeployable* deployable);
	bool HasSwordFoundTarget();
	bool HasDeployedSword();
	bool CanBeCanceled();
	bool STATIC_InSecondaryFire();
	bool StartFire();
	bool ShouldCooldownAfterFire();
	bool IsToggleDevice();
	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_CanBeSilenced();
	bool IsToggledOn();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	unsigned char STATIC_IncrementFiringInstance();
};


// Class TgGame.TgDevice_Heimdallr_A03
// 0x0050 (0x054C - 0x04FC)
class ATgDevice_Heimdallr_A03 : public ATgDevice_Deployable
{
public:
	class ATgDeployable_Heimdallr_A03*                 r_Deployables[0x2];                                       // 0x04FC(0x0008) (Net)
	float                                              r_fDeployFireDelay;                                       // 0x050C(0x0004) (Const, Net)
	float                                              r_fDeployIntitialCooldown;                                // 0x0510(0x0004) (Const, Net)
	float                                              r_fDeployCurrentCooldown;                                 // 0x0514(0x0004) (Const, Net)
	TEnumAsByte<EHeimdallrA03State>                    r_eDeployState;                                           // 0x0518(0x0001) (Const, Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0519(0x0003) MISSED OFFSET
	struct FVector2D                                   m_vDistanceValues;                                        // 0x051C(0x0008) (Const)
	struct FVector2D                                   m_vCooldownValues;                                        // 0x0524(0x0008) (Const)
	struct FVector2D                                   m_vDelayValues;                                           // 0x052C(0x0008) (Const)
	class ATgCollisionProxy_Box*                       s_CollisionProxy;                                         // 0x0534(0x0008)
	TArray<class ATgPawn*>                             s_AppliedPawns;                                           // 0x053C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Heimdallr_A03");
		return ptr;
	}


	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void BuildProxy();
	void OnDeployableSpawned(class ATgDeployable* deployable);
	float GetDeployCurrentCooldown();
	bool ShouldTriggerCastReactionItems();
	void STATIC_SetTrackingState(TEnumAsByte<EHeimdallrA03State> eNewState);
	void STATIC_SetDeployablesCooldownTime();
	void STATIC_SetDeployablesInactive(bool bCooldown);
	void STATIC_SetDeployablesActive();
	void STATIC_HandleDeployCooldown();
	void STATIC_HandleDeploySuccessfulFire();
	void STATIC_CalcDeployCurrentCooldown();
	void STATIC_CalcDeployInitialCooldown(float fDist);
	void STATIC_CalcDeployFireDelay(float fDist);
	void STATIC_CalcDeployVars();
	int STATIC_FindOldestDeployable();
	void STATIC_RegisterNewDeploy(class ATgDeployable_Heimdallr_A03* heimDeploy);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Heimdallr_A04Sub
// 0x001C (0x0518 - 0x04FC)
class ATgDevice_Heimdallr_A04Sub : public ATgDevice_Deployable
{
public:
	class ATgPawn_Heimdallr*                           s_HeimOwner;                                              // 0x04FC(0x0008)
	class ATgDeployable_Heimdallr_A04*                 r_HeimDeploy;                                             // 0x0504(0x0008)
	struct FVector                                     m_vSpawnOffset;                                           // 0x050C(0x000C) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Heimdallr_A04Sub");
		return ptr;
	}


	void STATIC_ForwardHitPawnToDeploy(class ATgPawn* pHitPawn);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	class ATgDeployable_Heimdallr_A04* STATIC_InitializingDeploy();
};


// Class TgGame.TgDevice_Heimdallr_A01SubDev
// 0x001C (0x050C - 0x04F0)
class ATgDevice_Heimdallr_A01SubDev : public ATgDevice
{
public:
	class ATgPawn_Heimdallr*                           r_heimdallr;                                              // 0x04F0(0x0008) (Net)
	class ATgDeployable_Heimdallr_A01*                 m_deployable;                                             // 0x04F8(0x0008)
	float                                              m_fAutoDevSwapTime;                                       // 0x0500(0x0004) (Const)
	float                                              m_fLockOutTime;                                           // 0x0504(0x0004) (Const)
	unsigned long                                      m_bInLockOut : 1;                                         // 0x0508(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Heimdallr_A01SubDev");
		return ptr;
	}


	bool SimulateStartFire();
	bool StartFire();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool STATIC_NativeIsFiring();
	void LockOutTimer();
	void STATIC_StartLockOutTimer();
	void STATIC_SwapToAutoTargetingDev();
};


// Class TgGame.TgDevice_Heimdallr_PSV
// 0x011C (0x060C - 0x04F0)
class ATgDevice_Heimdallr_PSV : public ATgDevice
{
public:
	class ATgPawn_Heimdallr*                           m_heimdallr;                                              // 0x04F0(0x0008)
	TArray<struct FHeidallrPSVTarget>                  s_psvTargets;                                             // 0x04F8(0x0010) (NeedCtorLink)
	class ATgPawn*                                     r_psvTargets[0x20];                                       // 0x0508(0x0008) (Net)
	int                                                r_nAppliedEffectGroupId;                                  // 0x0608(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Heimdallr_PSV");
		return ptr;
	}


	void STATIC_ClientUpdatePsvTargets();
};


// Class TgGame.TgDevice_Heimdallr_A02
// 0x0028 (0x0524 - 0x04FC)
class ATgDevice_Heimdallr_A02 : public ATgDevice_HitPulse
{
public:
	class ATgPawn_Heimdallr*                           r_heimdallr;                                              // 0x04FC(0x0008) (Const, Net)
	class UTgDeviceFire*                               m_CachedFire;                                             // 0x0504(0x0008)
	unsigned long                                      m_bInLockOut : 1;                                         // 0x050C(0x0004)
	float                                              m_fConePullbackDistace;                                   // 0x0510(0x0004) (Const)
	float                                              m_fCustomRadius;                                          // 0x0514(0x0004) (Const)
	float                                              m_fCustomMinRadius;                                       // 0x0518(0x0004) (Const)
	float                                              m_fLockOutTime;                                           // 0x051C(0x0004) (Const)
	float                                              m_fOutroTime;                                             // 0x0520(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Heimdallr_A02");
		return ptr;
	}


	void InterruptFiring();
	bool CanJumpWhileFiring();
	bool CanBeInterrupted();
	bool CanBeCanceledByRightMouse();
	float STATIC_GetCustomMinRadius();
	float STATIC_GetCustomRadius();
	float STATIC_GetConePullbackDistance();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_OutroTimer();
	void LockOutTimer();
	void STATIC_StartLockOutTimer();
	void STATIC_HandleSecondaryState();
};


// Class TgGame.TgDeviceForm_Heimdallr_A01SubDev
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Heimdallr_A01SubDev : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Heimdallr_A01SubDev");
		return ptr;
	}


	void UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
};


// Class TgGame.TgDeviceForm_Heimdallr_A03
// 0x0008 (0x0240 - 0x0238)
class UTgDeviceForm_Heimdallr_A03 : public UTgDeviceForm
{
public:
	class ATgPawn_Heimdallr*                           c_heimdallr;                                              // 0x0238(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Heimdallr_A03");
		return ptr;
	}


	void UpdateTargetingModeStatusForFX(class UTgSpecialFx* Fx, TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
};


// Class TgGame.TgHeimdallr_A04MeshProcessor
// 0x003C (0x009C - 0x0060)
class UTgHeimdallr_A04MeshProcessor : public UObject
{
public:
	struct FPointer                                    VfTable_ITgPawnSingletonProcessor;                        // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<struct FHeimUltMeshMap>                     c_ClientAssets;                                           // 0x0068(0x0010) (Component, NeedCtorLink)
	TArray<class ATgPawn_Heimdallr*>                   c_CandidateList;                                          // 0x0078(0x0010) (NeedCtorLink)
	TArray<struct FHeimA04Meshes>                      c_MeshConfig;                                             // 0x0088(0x0010) (Component, NeedCtorLink)
	unsigned long                                      c_bIsFinal : 1;                                           // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHeimdallr_A04MeshProcessor");
		return ptr;
	}


	void STATIC_OnHeimSkinLevelChange(class ATgPawn* PawnRep);
	struct FHeimUltMeshMap STATIC_GetVisualsFor(class ATgPawn_Heimdallr* tgHeimdallr);
	int STATIC_GetVisualsIndexFor(class ATgPawn_Heimdallr* tgHeimdallr);
	void UnregisterPawn(class ATgPawn* PawnRep);
	bool STATIC_HasFinalizedRepresentation();
	void STATIC_FinalizeRepresentation();
	void STATIC_RegisterPawn(class ATgPawn* PawnRep);
	bool STATIC_RepresentsPawn(class ATgPawn* PawnRep);
};


// Class TgGame.TgInventoryObject_Listen_Heimdallr_A04Sub
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Heimdallr_A04Sub : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Heimdallr_A04Sub");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Heimdallr_AUTO
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Heimdallr_AUTO : public UTgInventoryObject_Listen
{
public:
	float                                              s_fCleaveDamageReduction;                                 // 0x00D0(0x0004) (Const)
	float                                              s_fCleaveLifeStealReduction;                              // 0x00D4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Heimdallr_AUTO");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Heimdallr_PSV
// 0x0011 (0x00E1 - 0x00D0)
class UTgInventoryObject_Listen_Heimdallr_PSV : public UTgInventoryObject_Listen
{
public:
	class ATgPawn_Heimdallr*                           s_heimdallr;                                              // 0x00D0(0x0008)
	float                                              s_fPPScalingBase;                                         // 0x00D8(0x0004) (Const)
	float                                              s_fCSConversionRate;                                      // 0x00DC(0x0004) (Const)
	unsigned char                                      s_nStacks;                                                // 0x00E0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Heimdallr_PSV");
		return ptr;
	}

};


// Class TgGame.TgPawn_Heimdallr
// 0x0054 (0x260C - 0x25B8)
class ATgPawn_Heimdallr : public ATgPawn_Character
{
public:
	class ATgDevice_ChainedMelee*                      m_heimdallrAuto;                                          // 0x25B8(0x0008)
	class ATgDevice_Heimdallr_PSV*                     m_heimdallrPSV;                                           // 0x25C0(0x0008)
	class ATgDevice_Heimdallr_A01*                     m_heimdallrA01;                                           // 0x25C8(0x0008)
	class ATgDevice_Heimdallr_A01SubDev*               m_heimdallrA01SubDev;                                     // 0x25D0(0x0008)
	class ATgDevice_Heimdallr_A01SubDeploy*            m_heimdallrA01SubDeploy;                                  // 0x25D8(0x0008)
	class ATgDevice_Heimdallr_A02*                     m_heimdallrA02;                                           // 0x25E0(0x0008)
	class ATgDevice_Heimdallr_A03*                     m_heimdallrA03;                                           // 0x25E8(0x0008)
	class ATgDevice_Heimdallr_A04*                     m_heimdallrA04;                                           // 0x25F0(0x0008)
	class ATgDevice_Heimdallr_A04Sub*                  m_heimdallrA04Sub;                                        // 0x25F8(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x2600(0x0004) (Const)
	unsigned long                                      r_bA02HornBlastFired : 1;                                 // 0x2600(0x0004) (Net)
	class UTgSpecialFx*                                c_fxA03Teleport;                                          // 0x2604(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Heimdallr");
		return ptr;
	}


	bool IsA01InSecondaryFire();
	void SetTargetingDevice(class ATgDevice* Dev);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_OverrideOffhandSlot(TEnumAsByte<ETG_EQUIP_POINT> eqp);
	bool WillOverrideTakeDamage(class APawn* Victim, int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_DeactivatePortal(const struct FName& nmDisplayGroup);
	void ActivatePortal(const struct FName& nmDisplayGroup, const struct FVector& vLocation, const struct FRotator& rRotation);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_PlayTeleportFx(int nTeleportState, const struct FVector& vLoc);
	bool STATIC_ShouldPawnMeshBeHiddenThisTick();
	float STATIC_GetPhysicalPower(const struct FImpactInfo& Impact);
	class UClass* STATIC_CreatePawnSpecificProcessor();
	bool UsesSinglePawnProcessor();
	void STATIC_PrecacheDevices();
	void UpdateClientDevices(bool bForce);
};


// Class TgGame.TgAchievement_Mulan_TwoForOne
// 0x0048 (0x00CC - 0x0084)
class UTgAchievement_Mulan_TwoForOne : public UTgAchievement
{
public:
	int                                                m_nHitRequirement;                                        // 0x0084(0x0004) (Const)
	class ATgPawn_Mulan*                               m_mulan;                                                  // 0x0088(0x0008) (Const)
	struct FMulanUltimateHitInfo                       m_a04Info;                                                // 0x0090(0x0014) (NeedCtorLink)
	struct FMulanUltimateHitInfo                       m_b04Info;                                                // 0x00A4(0x0014) (NeedCtorLink)
	struct FMulanUltimateHitInfo                       m_c04Info;                                                // 0x00B8(0x0014) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Mulan_TwoForOne");
		return ptr;
	}


	bool UnlockAchievement();
	void UpdateUltimateTracking(class ATgDevice* Dev, const struct FImpactInfo& Impact);
	bool IsValidTarget(class ATgPawn* HitPawn);
	bool IsValidUltimateDevice(class ATgDevice* Dev);
	class ATgPawn_Mulan* STATIC_GetMulan();
};


// Class TgGame.TgAchievement_Mulan_WeaponMasteryS
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Mulan_WeaponMasteryS : public UTgAchievement
{
public:
	class ATgPawn_Mulan*                               m_mulan;                                                  // 0x0084(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Mulan_WeaponMasteryS");
		return ptr;
	}


	class ATgPawn_Mulan* STATIC_GetMulan();
};


// Class TgGame.TgAnimBlendByFire_Mulan
// 0x0008 (0x03D4 - 0x03CC)
class UTgAnimBlendByFire_Mulan : public UTgAnimBlendByFire_Complete
{
public:
	class ATgPawn_Mulan*                               m_mulanPawn;                                              // 0x03CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFire_Mulan");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendByMulanA03
// 0x0008 (0x0170 - 0x0168)
class UTgAnimNodeBlendByMulanA03 : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Mulan*                               c_mulan;                                                  // 0x0168(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendByMulanA03");
		return ptr;
	}


	void STATIC_PlayAnimState(TEnumAsByte<EMulanA03AnimState> eAnimState);
};


// Class TgGame.TgDevice_Mulan_A04
// 0x0010 (0x0574 - 0x0564)
class ATgDevice_Mulan_A04 : public ATgDevice_Charge_ChainSubDevice
{
public:
	class ATgPawn_Mulan*                               r_mulanPawn;                                              // 0x0564(0x0008) (Const, Net)
	float                                              m_fChargeTimeElapsed;                                     // 0x056C(0x0004)
	unsigned long                                      m_bHasChargeHit : 1;                                      // 0x0570(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mulan_A04");
		return ptr;
	}


	void STATIC_ChainSubDevice(class ATgDevice* SubDevice);
	bool STATIC_CanChainSubDevice(class ATgDevice* SubDevice);
	bool STATIC_NativeIsFiring();
	void STATIC_ClientSetOwnerTargetingDevice(class ATgDevice* Dev);
};


// Class TgGame.TgDevice_Mulan_B04
// 0x001C (0x050C - 0x04F0)
class ATgDevice_Mulan_B04 : public ATgDevice
{
public:
	int                                                m_nMaxAttacks;                                            // 0x04F0(0x0004) (Const)
	TEnumAsByte<EWeaponFireType>                       m_C04AttackType;                                          // 0x04F4(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F5(0x0003) MISSED OFFSET
	class ATgPawn_Mulan*                               r_mulanPawn;                                              // 0x04F8(0x0008) (Const, Net)
	class ATgDevice*                                   m_SubDevice;                                              // 0x0500(0x0008)
	int                                                m_nAttacksFired;                                          // 0x0508(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mulan_B04");
		return ptr;
	}


	void STATIC_FireAmmunition();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
};


// Class TgGame.TgDevice_Mulan_EvolutionDevice
// 0x003C (0x052C - 0x04F0)
class ATgDevice_Mulan_EvolutionDevice : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgMulanEvolutionInterface;                       // 0x04F0(0x0008) (Const, Native, NoExport)
	int                                                m_nEvolution1Icon;                                        // 0x04F8(0x0004) (Const)
	int                                                m_nEvolution2Icon;                                        // 0x04FC(0x0004) (Const)
	int                                                m_nEvolution3Icon;                                        // 0x0500(0x0004) (Const)
	class ATgPawn_Mulan*                               r_mulanPawn;                                              // 0x0504(0x0008) (Const, Net)
	struct FMulanEvolutionXPLevels                     m_EvolutionXPLevels;                                      // 0x050C(0x000C) (Const)
	TEnumAsByte<EMulanEvolutionState>                  r_eCurrentEvolution;                                      // 0x0518(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0519(0x0003) MISSED OFFSET
	float                                              m_fNextEvolutionXPThreshold;                              // 0x051C(0x0004)
	float                                              r_fCurrentEvolutionXP;                                    // 0x0520(0x0004) (Net)
	float                                              m_eEvolutionAtStartFire;                                  // 0x0524(0x0004)
	unsigned long                                      m_bDebugNoEvolving : 1;                                   // 0x0528(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mulan_EvolutionDevice");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_CanApplyEvolutionStatIncrease();
	void STATIC_FireEvolutionAbility();
	bool STATIC_CanFireEvolutionAbility();
	void ApplyEvolutionStatusEffects(struct FImpactInfo* targetImpact);
	bool STATIC_CanApplyEvolutionStatusEffects(const struct FImpactInfo& targetImpact, class UTgEffectGroup* hitEG);
	void STATIC_GainEvolutionXP(const struct FOnDamagedParams& DamageInfo);
	bool STATIC_CanGainXPFromTarget(class ATgPawn* HitPawn);
	bool STATIC_CanGainXPFromUlt(class ATgDevice* impactDevice, struct FImpactInfo* Impact);
	void STATIC_SetEvolution(TEnumAsByte<EMulanEvolutionState> evolveState);
	void STATIC_Devolve();
	void STATIC_Evolve();
	float STATIC_GetEvolutionXPThreshold(TEnumAsByte<EMulanEvolutionState> evolveState);
	TEnumAsByte<EMulanEvolutionState> STATIC_GetEvolutionState();
	void STATIC_InitializeEvolution();
	void ApplyEquipEffects();
};


// Class TgGame.TgDevice_Mulan_A01
// 0x0018 (0x0544 - 0x052C)
class ATgDevice_Mulan_A01 : public ATgDevice_Mulan_EvolutionDevice
{
public:
	int                                                m_nMaxBaseAttacks;                                        // 0x052C(0x0004) (Const)
	int                                                m_nMaxEvolvedAttacks;                                     // 0x0530(0x0004) (Const)
	class ATgDevice*                                   m_SubDevice;                                              // 0x0534(0x0008) (Const)
	int                                                m_nAttacksFired;                                          // 0x053C(0x0004)
	unsigned long                                      m_bInEvolutionFire : 1;                                   // 0x0540(0x0004)
	unsigned long                                      m_bLockRotationDuringFire : 1;                            // 0x0540(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mulan_A01");
		return ptr;
	}


	void STATIC_FireEvolutionAbility();
	bool STATIC_CanFireEvolutionAbility();
	bool STATIC_CanApplyEvolutionStatusEffects(const struct FImpactInfo& targetImpact, class UTgEffectGroup* hitEG);
	bool STATIC_CanGainXPFromUlt(class ATgDevice* impactDevice, struct FImpactInfo* Impact);
	void STATIC_FireAmmunition();
	bool StartFire();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool UsesControllerRotation();
	void STATIC_GetSecondaryAim(struct FAimData* Aim);
	void TickTargetingMode(float DeltaSeconds);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	class UTgDeviceFire* STATIC_GetCurrentFire();
};


// Class TgGame.TgDevice_Mulan_A02
// 0x0028 (0x0554 - 0x052C)
class ATgDevice_Mulan_A02 : public ATgDevice_Mulan_EvolutionDevice
{
public:
	int                                                m_nMaxHealsPerFire;                                       // 0x052C(0x0004) (Const)
	class ATgDevice*                                   m_SubDevice;                                              // 0x0530(0x0008) (Const)
	TArray<class ATgPawn*>                             s_pawnsHit;                                               // 0x0538(0x0010) (NeedCtorLink)
	int                                                m_nNumFires;                                              // 0x0548(0x0004)
	int                                                m_nHealsApplied;                                          // 0x054C(0x0004)
	unsigned long                                      m_bInEvolutionFire : 1;                                   // 0x0550(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mulan_A02");
		return ptr;
	}


	void STATIC_FireEvolutionAbility();
	bool STATIC_CanFireEvolutionAbility();
	void ApplyEvolutionStatusEffects(struct FImpactInfo* targetImpact);
	bool STATIC_CanApplyEvolutionStatusEffects(const struct FImpactInfo& targetImpact, class UTgEffectGroup* hitEG);
	bool STATIC_CanGainXPFromUlt(class ATgDevice* impactDevice, struct FImpactInfo* Impact);
	void STATIC_FireAmmunition();
	bool StartFire();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	void TickTargetingMode(float DeltaSeconds);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	class UTgDeviceFire* STATIC_GetCurrentFire();
};


// Class TgGame.TgDevice_Mulan_A03
// 0x0054 (0x0580 - 0x052C)
class ATgDevice_Mulan_A03 : public ATgDevice_Mulan_EvolutionDevice
{
public:
	float                                              m_fSeperationDist;                                        // 0x052C(0x0004) (Const)
	float                                              m_fGodGrappleTime;                                        // 0x0530(0x0004) (Const)
	float                                              m_fWallTravelPercent;                                     // 0x0534(0x0004) (Const)
	float                                              m_fWallTweenSpeed;                                        // 0x0538(0x0004) (Const)
	float                                              m_fLongWallAnimDistanceThreshold;                         // 0x053C(0x0004) (Const)
	float                                              m_fGrappleDelay;                                          // 0x0540(0x0004) (Const)
	float                                              m_fProjWallExtent;                                        // 0x0544(0x0004) (Const)
	float                                              m_fMinWallGrappleDist;                                    // 0x0548(0x0004) (Const)
	struct FName                                       m_nmApplyGrappleEndHit;                                   // 0x054C(0x0008) (Const)
	class UTgDeviceFire*                               s_cachedGrappleFiremode;                                  // 0x0554(0x0008)
	class ATgPawn_Character*                           m_grappleTarget;                                          // 0x055C(0x0008)
	class AActor*                                      m_grappleWall;                                            // 0x0564(0x0008)
	struct FVector                                     m_vWallHitLoc;                                            // 0x056C(0x000C)
	int                                                m_nBuffLastFiringInstance;                                // 0x0578(0x0004)
	unsigned long                                      m_bAllowWallGrappleToLocation : 1;                        // 0x057C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mulan_A03");
		return ptr;
	}


	void STATIC_FireEvolutionAbility();
	bool STATIC_CanFireEvolutionAbility();
	void ApplyEvolutionStatusEffects(struct FImpactInfo* targetImpact);
	bool STATIC_CanApplyEvolutionStatusEffects(const struct FImpactInfo& targetImpact, class UTgEffectGroup* hitEG);
	bool STATIC_CanGainXPFromUlt(class ATgDevice* impactDevice, struct FImpactInfo* Impact);
	bool StartFire();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_NativeIsFiring();
	void BeginGrappleDelay(class ATgPawn_Character* grappleTarget, class UTgDeviceFire* grappleFiremode, bool bWallGrapple);
	bool STATIC_GetMulanA03TargetingAim(const struct FVector& vStartTraceOverride, const struct FVector& vEndTraceOverride, bool bAdjustEndLocationByHitNormal, struct FAimData* Aim);
	void STATIC_GetDeviceTargetingTracePoints(struct FVector* vStartTrace, struct FVector* vEndTrace);
	void STATIC_ClearGrapple();
	void STATIC_RemoveCCImmuneGrappleTarget();
	void ApplyGrappleEndHit();
	void STATIC_StartGrapple();
	bool STATIC_FindValidGrappleLoc(const struct FVector& vTweenPawnExtent, const struct FVector& vStartLoc, const struct FVector& vInitialEndLoc, const struct FVector& vTweenDirection, float fRange, bool bIsWallGrapple, struct FVector* vValidLocation);
	float STATIC_CalcWallGrappleDistance(const struct FVector& vWallHitLocation);
	float STATIC_CalcGrappleDistance();
	bool STATIC_CanGrappleToTarget(class ATgPawn_Character* grappleTarget);
};


// Class TgGame.TgDevice_Mulan_PSV
// 0x000D (0x04FD - 0x04F0)
class ATgDevice_Mulan_PSV : public ATgDevice
{
public:
	float                                              m_fCooldownReduceTime;                                    // 0x04F0(0x0004) (Const)
	class ATgPawn_Mulan*                               r_mulanPawn;                                              // 0x04F4(0x0008) (Const, Net)
	unsigned char                                      s_AbilityFiredEQP;                                        // 0x04FC(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mulan_PSV");
		return ptr;
	}


	void STATIC_CustomFire();
	void ApplyReducedAbilityCooldown();
};


// Class TgGame.TgDeviceFire_Mulan_A01
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Mulan_A01 : public UTgDeviceFire
{
public:
	class ATgDevice_Mulan_A01*                         m_A01;                                                    // 0x01C0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Mulan_A01");
		return ptr;
	}


	float GetConeAttackAngleOffset();
};


// Class TgGame.TgDeviceFire_Mulan_B04
// 0x000C (0x01CC - 0x01C0)
class UTgDeviceFire_Mulan_B04 : public UTgDeviceFire
{
public:
	class ATgDevice_Mulan_B04*                         m_b04;                                                    // 0x01C0(0x0008)
	unsigned long                                      m_bForceC04Firemode : 1;                                  // 0x01C8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Mulan_B04");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	float STATIC_GetRange();
	float STATIC_GetDamageRadius();
};


// Class TgGame.TgDeviceForm_Mulan_A03
// 0x0030 (0x0268 - 0x0238)
class UTgDeviceForm_Mulan_A03 : public UTgDeviceForm
{
public:
	int                                                m_nWallTargeterFxId;                                      // 0x0238(0x0004)
	class ATgPawn_Mulan*                               c_mulan;                                                  // 0x023C(0x0008) (Const)
	class UTgSpecialFx*                                c_mulanWallTargeterFX;                                    // 0x0244(0x0008)
	unsigned long                                      c_bHasWallTarget : 1;                                     // 0x024C(0x0004)
	struct FVector                                     c_vWallHitLocation;                                       // 0x0250(0x000C)
	struct FRotator                                    c_rWallRotator;                                           // 0x025C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Mulan_A03");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingList(TArray<struct FImpactInfo>* ImpactList);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_Mulan_EvolutionForm
// 0x0008 (0x0250 - 0x0248)
class UTgDeviceForm_Mulan_EvolutionForm : public UTgDeviceForm_TwoPhase
{
public:
	int                                                c_nBaseTargetingFxId;                                     // 0x0248(0x0004) (Const)
	int                                                c_nEvolvedTargetingFxId;                                  // 0x024C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Mulan_EvolutionForm");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Mulan_EvolutionDevice
// 0x0000 (0x00D0 - 0x00D0)
class UTgInventoryObject_Listen_Mulan_EvolutionDevice : public UTgInventoryObject_Listen
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Mulan_EvolutionDevice");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Mulan_A02
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Mulan_A02 : public UTgInventoryObject_Listen_Mulan_EvolutionDevice
{
public:
	class ATgDevice_Mulan_A02*                         m_a02;                                                    // 0x00D0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Mulan_A02");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Mulan_A03
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Mulan_A03 : public UTgInventoryObject_Listen_Mulan_EvolutionDevice
{
public:
	class ATgDevice_Mulan_A03*                         s_a03;                                                    // 0x00D0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Mulan_A03");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Mulan_PSV
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Mulan_PSV : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_Mulan_PSV*                         m_PassiveDevice;                                          // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Mulan_PSV");
		return ptr;
	}

};


// Class TgGame.TgMulanEvolutionInterface
// 0x0000 (0x0060 - 0x0060)
class UTgMulanEvolutionInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMulanEvolutionInterface");
		return ptr;
	}


	bool STATIC_CanApplyEvolutionStatIncrease();
	void STATIC_FireEvolutionAbility();
	bool STATIC_CanFireEvolutionAbility();
	void ApplyEvolutionStatusEffects(struct FImpactInfo* targetImpact);
	bool STATIC_CanApplyEvolutionStatusEffects(const struct FImpactInfo& targetImpact, class UTgEffectGroup* hitEG);
	void STATIC_GainEvolutionXP(const struct FOnDamagedParams& DamageInfo);
	bool STATIC_CanGainXPFromTarget(class ATgPawn* HitPawn);
	bool STATIC_CanGainXPFromUlt(class ATgDevice* impactDevice, struct FImpactInfo* Impact);
	void STATIC_SetEvolution(TEnumAsByte<EMulanEvolutionState> evolveState);
	void STATIC_Devolve();
	void STATIC_Evolve();
	float STATIC_GetEvolutionXPThreshold(TEnumAsByte<EMulanEvolutionState> evolveState);
	TEnumAsByte<EMulanEvolutionState> STATIC_GetEvolutionState();
	void STATIC_InitializeEvolution();
};


// Class TgGame.TgPawn_Mulan
// 0x00D0 (0x2688 - 0x25B8)
class ATgPawn_Mulan : public ATgPawn_Character
{
public:
	int                                                m_nEvolution1SituationalType;                             // 0x25B8(0x0004) (Const)
	int                                                m_nA03RopeMeshId;                                         // 0x25BC(0x0004) (Const)
	int                                                m_nMaxRopeMeshLength;                                     // 0x25C0(0x0004) (Const)
	float                                              r_fNonGodXPPercentReduction;                              // 0x25C4(0x0004) (Const, Net)
	float                                              m_fUltCameraPostFireSpinTime;                             // 0x25C8(0x0004) (Const)
	float                                              m_fMaxSpinTimePercent;                                    // 0x25CC(0x0004) (Const)
	class ATgDevice_ChainedMelee*                      m_autoDevice;                                             // 0x25D0(0x0008)
	class ATgDevice_Mulan_PSV*                         m_psvDevice;                                              // 0x25D8(0x0008)
	class ATgDevice_Mulan_A01*                         m_a01Device;                                              // 0x25E0(0x0008)
	class ATgDevice*                                   m_a01SubDevice;                                           // 0x25E8(0x0008)
	class ATgDevice_Mulan_A02*                         m_a02Device;                                              // 0x25F0(0x0008)
	class ATgDevice*                                   m_a02SubDevice;                                           // 0x25F8(0x0008)
	class ATgDevice_Mulan_A03*                         m_a03Device;                                              // 0x2600(0x0008)
	class ATgDevice_Mulan_A04*                         m_a04Device;                                              // 0x2608(0x0008)
	class ATgDevice_Mulan_B04*                         m_b04Device;                                              // 0x2610(0x0008)
	unsigned long                                      m_bDevicesCached : 1;                                     // 0x2618(0x0004) (Const)
	unsigned long                                      r_bA01InEvolve2 : 1;                                      // 0x2618(0x0004) (Net)
	unsigned long                                      r_bA02InEvolve2 : 1;                                      // 0x2618(0x0004) (Net)
	unsigned long                                      r_bIsPassiveOnCooldown : 1;                               // 0x2618(0x0004) (Net)
	unsigned long                                      r_bInC04Fire : 1;                                         // 0x2618(0x0004) (Net)
	unsigned long                                      m_bIsInA01AttackChain : 1;                                // 0x2618(0x0004)
	unsigned long                                      m_bIsInA02AttackChain : 1;                                // 0x2618(0x0004)
	unsigned long                                      r_bInGrapple : 1;                                         // 0x2618(0x0004) (Net)
	unsigned long                                      r_bInUltCamSpin : 1;                                      // 0x2618(0x0004) (Net)
	int                                                r_nPlayEvolveFx;                                          // 0x261C(0x0004) (Net)
	class UTgStaticMeshComponent*                      c_RopeMesh;                                               // 0x2620(0x0008) (ExportObject, Component, EditInline)
	class ATgPawn*                                     r_RopePawn;                                               // 0x2628(0x0008) (Net)
	struct FVector                                     r_vRopeHitLocation;                                       // 0x2630(0x000C) (Net)
	class ATgProj_Mulan_A03*                           c_A03Projectile;                                          // 0x263C(0x0008)
	struct FMulanA03AnimData                           r_A03AnimData;                                            // 0x2644(0x000C) (Net)
	class UTgAnimNodeBlendByMulanA03*                  c_a03BlendByNode;                                         // 0x2650(0x0008)
	TArray<class UTgAnimNodeFitToDuration*>            c_a03RateScaleNodes;                                      // 0x2658(0x0010) (NeedCtorLink)
	float                                              m_fCurrentRotationTime;                                   // 0x2668(0x0004)
	float                                              r_fTotalUltCamSpinTime;                                   // 0x266C(0x0004) (Net)
	struct FRotator                                    r_rInitialUltCamRotation;                                 // 0x2670(0x000C) (Net)
	struct FRotator                                    r_rFinalUltCamRotation;                                   // 0x267C(0x000C) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Mulan");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	bool PostPawnSetup();
	void STATIC_PawnDevTest(bool bSetActive, int nIndex);
	bool STATIC_ShouldAllowOffhandFireLock();
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveBool(int* bResult);
	void UpdateClientDevices(bool bForce);
	void STATIC_PlayEvolveFx();
	void UpdateUltCameraSpin(float DeltaTime);
	void BeginUltCameraSpin(float fChargeTimeRemaining, float fMaxChargeTime, const struct FVector& vHitLocation);
	void STATIC_PlayGrappleAnim(const struct FMulanA03AnimData& animData);
	struct FVector STATIC_GetRopeEndLocation();
	void AssignRopeTarget(class ATgPawn* Target, const struct FVector& HitLocation);
	void UpdatedRopeTether(float fDeltaTime);
	void STATIC_CreateRopeTetherMeshComponent();
};


// Class TgGame.TgProj_Mulan_A03
// 0x0030 (0x03C8 - 0x0398)
class ATgProj_Mulan_A03 : public ATgProj_Simulated
{
public:
	class ATgPawn_Mulan*                               m_mulanPawn;                                              // 0x0398(0x0008) (Const)
	class ATgDevice_Mulan_A03*                         m_a03;                                                    // 0x03A0(0x0008)
	unsigned long                                      m_bEvolved : 1;                                           // 0x03A8(0x0004) (Const)
	unsigned long                                      m_bHasPredictedWallImpact : 1;                            // 0x03A8(0x0004)
	float                                              m_fPredictedWallHitRange;                                 // 0x03AC(0x0004)
	struct FVector                                     m_vPredictedWallHitLocation;                              // 0x03B0(0x000C)
	struct FVector                                     m_vPreviousProjLocation;                                  // 0x03BC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Mulan_A03");
		return ptr;
	}


	void ShutDown();
	void Tick(float DeltaSeconds);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_RangeReached();
	void STATIC_CompleteInitialization();
	void STATIC_CheckWallPredictionRange();
	void STATIC_CalcWallPredictionRange(float fDistFromSpawn);
};


// Class TgGame.TgAchievement_BabaYaga_TheCabin
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_BabaYaga_TheCabin : public UTgAchievement
{
public:
	class ATgDevice_BabaYagaHut_PSV*                   m_devPsv;                                                 // 0x0084(0x0008) (Const)
	int                                                m_nEvolutionItemStackGoal;                                // 0x008C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BabaYaga_TheCabin");
		return ptr;
	}

};


// Class TgGame.TgAchievement_BabaYaga_ThePerfectBrew
// 0x0000 (0x0084 - 0x0084)
class UTgAchievement_BabaYaga_ThePerfectBrew : public UTgAchievement
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_BabaYaga_ThePerfectBrew");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendBy_BabaYaga_PotionFire
// 0x0011 (0x0179 - 0x0168)
class UTgAnimBlendBy_BabaYaga_PotionFire : public UTgAnimNodeBlendList
{
public:
	class UTgAnimBlendByFire_Complete*                 c_blendByFireComplete;                                    // 0x0168(0x0008) (Const)
	class ATgPawn_BabaYaga*                            c_babaYaga;                                               // 0x0170(0x0008) (Const)
	TEnumAsByte<EBabaYagaA02AnimState>                 c_ePotionAnimState;                                       // 0x0178(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendBy_BabaYaga_PotionFire");
		return ptr;
	}


	void STATIC_PlayAnimState(TEnumAsByte<EBabaYagaA02AnimState> eAnimState);
	void STATIC_CalculateAnimState();
};


// Class TgGame.TgCollisionProxy_BabaYaga_A01
// 0x005C (0x0310 - 0x02B4)
class ATgCollisionProxy_BabaYaga_A01 : public ATgCollisionProxy
{
public:
	class ATgDevice_BabaYaga_A01*                      m_devOwner;                                               // 0x02B4(0x0008) (Const)
	class UTgDeviceFire_BabaYaga_A01*                  m_firemodeOwner;                                          // 0x02BC(0x0008) (Const)
	class ATgProj_BabaYaga_A01*                        m_projOwner;                                              // 0x02C4(0x0008) (Const)
	class ATgDeploy_BabaYaga_A01*                      m_depOwner;                                               // 0x02CC(0x0008) (Const)
	int                                                s_nFiringInstance;                                        // 0x02D4(0x0004) (Const)
	float                                              m_fTrailEnd;                                              // 0x02D8(0x0004) (Const)
	float                                              m_fRadius;                                                // 0x02DC(0x0004) (Const)
	float                                              m_fMinRadius;                                             // 0x02E0(0x0004) (Const)
	unsigned long                                      m_bIsOvalLong : 1;                                        // 0x02E4(0x0004) (Const)
	unsigned long                                      m_bHasInitialized : 1;                                    // 0x02E4(0x0004) (Const)
	float                                              m_fOvalScale;                                             // 0x02E8(0x0004) (Const)
	TEnumAsByte<EBabaYagaProjShape>                    m_eProjShape;                                             // 0x02EC(0x0001) (Const)
	TEnumAsByte<EBabaYagaProjStatusType>               m_eProjStatusType;                                        // 0x02ED(0x0001) (Const)
	unsigned char                                      UnknownData00[0x2];                                       // 0x02EE(0x0002) MISSED OFFSET
	TArray<class AActor*>                              s_aHitTargets;                                            // 0x02F0(0x0010) (NeedCtorLink)
	TArray<class AActor*>                              s_aTargetsToCheck;                                        // 0x0300(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_BabaYaga_A01");
		return ptr;
	}


	void Despawn();
	void RemoveHitTarget(class AActor* ATarget);
	void AddHitTarget(class AActor* ATarget);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ShouldHitTarget(class AActor* ATarget);
};


// Class TgGame.TgCollisionProxy_BabaYaga_A01_Box
// 0x0008 (0x0318 - 0x0310)
class ATgCollisionProxy_BabaYaga_A01_Box : public ATgCollisionProxy_BabaYaga_A01
{
public:
	class UStaticMeshComponent*                        m_CollisionBox;                                           // 0x0310(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCollisionProxy_BabaYaga_A01_Box");
		return ptr;
	}

};


// Class TgGame.TgDeploy_BabaYaga_A01
// 0x0024 (0x03F8 - 0x03D4)
class ATgDeploy_BabaYaga_A01 : public ATgDeployable
{
public:
	class ATgCollisionProxy_BabaYaga_A01*              s_proxyTrail;                                             // 0x03D4(0x0008) (Const)
	TEnumAsByte<EBabaYagaWarningShape>                 r_eWantedWarningShape;                                    // 0x03DC(0x0001) (Const, Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03DD(0x0003) MISSED OFFSET
	struct FName                                       m_nmWarningFXDisplayGroups[0x3];                          // 0x03E0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_BabaYaga_A01");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void DestroyIt(bool bSkipFx);
	void STATIC_DeactivateWarningFX();
	void ActivateWarningFX();
	void STATIC_SetWantedWarningFX(TEnumAsByte<EBabaYagaWarningShape> eWarningShape);
	void STATIC_InitializeCustomParticleSystemFilter(int nFilter);
	void STATIC_DestroyTrailProxy();
};


// Class TgGame.TgDeploy_BabaYaga_A04
// 0x0048 (0x041C - 0x03D4)
class ATgDeploy_BabaYaga_A04 : public ATgDeployable
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03D4(0x0008) (Const, Native, NoExport)
	class ATgPawn_BabaYaga*                            r_pawnBabaYaga;                                           // 0x03DC(0x0008) (Const, Net)
	class ATgPawn*                                     m_pawnCurrentTarget;                                      // 0x03E4(0x0008)
	float                                              m_fTargetSelectionRange;                                  // 0x03EC(0x0004)
	float                                              m_fDeadzoneRadius;                                        // 0x03F0(0x0004) (Const)
	float                                              m_fRefreshRate;                                           // 0x03F4(0x0004) (Const)
	struct FName                                       m_nmTargetUpdateName;                                     // 0x03F8(0x0008) (Const)
	float                                              r_fMoveSpeed;                                             // 0x0400(0x0004) (Net)
	unsigned long                                      r_bHasTarget : 1;                                         // 0x0404(0x0004) (Const, Net)
	unsigned long                                      r_bHasSpawnedLobProjectile : 1;                           // 0x0404(0x0004) (Const, Net)
	unsigned long                                      r_bHasTargetInDeadZone : 1;                               // 0x0404(0x0004) (Net)
	struct FVector                                     r_vTargetDestination;                                     // 0x0408(0x000C) (Const, Net)
	int                                                m_nLobProjectileId;                                       // 0x0414(0x0004) (Const)
	int                                                r_nSpawnerFireModeId;                                     // 0x0418(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_BabaYaga_A04");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_SetSpawnerFireModeId(int nId);
	void STATIC_SpawnClientLobProjectile();
	class ATgPawn* STATIC_FindBestTarget(TEnumAsByte<EBabaYagaA04TargetType> eTargetType);
	bool STATIC_ShouldRecalculateCurrentTarget();
	bool STATIC_CheckCurrentTargetIsValid();
	bool STATIC_CheckTargetIsValid(class ATgPawn* pawnTest);
	void MoveToTarget();
	void STATIC_SelectTarget();
	void STATIC_HandleTargetUpdate();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDeploy_BabaYaga_A02
// 0x0038 (0x0430 - 0x03F8)
class ATgDeploy_BabaYaga_A02 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	class ATgPawn_BabaYaga*                            r_pawnBabaYaga;                                           // 0x0400(0x0008) (Const, Net)
	int                                                r_nIngredients[0x3];                                      // 0x0408(0x0004) (Const, Net)
	int                                                r_nPotionFireMode;                                        // 0x0414(0x0004) (Const, Net)
	int                                                r_nSpawnerFireModeId;                                     // 0x0418(0x0004) (Net)
	int                                                m_nCustomIngredientFilter[0x4];                           // 0x041C(0x0004) (Const)
	int                                                m_nPotionProjId;                                          // 0x042C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_BabaYaga_A02");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void ApplyTouchHitSpecial(class AActor* Other, const struct FImpactInfo& Impact);
	void STATIC_SetSpawnerFireModeId(int nId);
	void STATIC_CustomizeProjectileVisuals(class ATgProjectile* Proj);
	void STATIC_SpawnClientLobProjectile();
	void STATIC_SetCurrentPotionData(int nPotionFireMode, int nCountA, int nCountB, int nCountC);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDevice_BabaYagaHut_PSV
// 0x0034 (0x0558 - 0x0524)
class ATgDevice_BabaYagaHut_PSV : public ATgDevice_Aura_PawnsInProximity
{
public:
	struct FName                                       m_nmHandleEnergyConsumption;                              // 0x0524(0x0008) (Const)
	float                                              m_fDistancePerEnergy;                                     // 0x052C(0x0004) (Const)
	float                                              m_fItemEnergyConsumeRate;                                 // 0x0530(0x0004) (Const)
	float                                              m_fHealEnergyConsumeRate;                                 // 0x0534(0x0004) (Const)
	float                                              m_fItemPowerThreshold;                                    // 0x0538(0x0004) (Const)
	float                                              m_fHealPowerThreshold;                                    // 0x053C(0x0004) (Const)
	class ATgPawn_BabaYaga_Hut*                        r_Hut;                                                    // 0x0540(0x0008) (Const, Net)
	class ATgPawn_BabaYaga*                            r_BabaYaga;                                               // 0x0548(0x0008) (Const, Net)
	int                                                s_nEvolutionItemStacksEarned;                             // 0x0550(0x0004)
	unsigned long                                      s_bHealTetherActive : 1;                                  // 0x0554(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYagaHut_PSV");
		return ptr;
	}


	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	class UTgInventoryObject_Listen_AchieveItem* STATIC_GetBabaYagaEvolveItem();
	void STATIC_HandleEnergyConsumption();
	void STATIC_CalcEnergyFromMovement(float fDistanceMoved);
};


// Class TgGame.TgDevice_BabaYaga_A02
// 0x00C4 (0x05B4 - 0x04F0)
class ATgDevice_BabaYaga_A02 : public ATgDevice
{
public:
	int                                                r_nIngredientLimit;                                       // 0x04F0(0x0004) (Const, Net)
	struct FBabaYagaPotionData                         r_Potions[0x2];                                           // 0x04F4(0x0028) (Const, Net)
	float                                              r_fPotionManagePrefire;                                   // 0x0544(0x0004) (Const, Net)
	float                                              r_fPotionManagePostfire;                                  // 0x0548(0x0004) (Const, Net)
	class ATgDevice_BabaYaga_A02_Sub*                  r_deviceShooter;                                          // 0x054C(0x0008) (Const, Net)
	class ATgDevice_BabaYaga_A02_Consumable*           r_deviceConsumable;                                       // 0x0554(0x0008) (Const, Net)
	class ATgDevice*                                   r_deviceDeployable;                                       // 0x055C(0x0008) (Const, Net)
	unsigned long                                      r_bCanCooldown : 1;                                       // 0x0564(0x0004) (Const, Net)
	struct FName                                       m_nmBrewStateName;                                        // 0x0568(0x0008) (Const)
	struct FName                                       m_nmSwapStateName;                                        // 0x0570(0x0008) (Const)
	struct FName                                       m_nmStoreStateName;                                       // 0x0578(0x0008) (Const)
	struct FName                                       m_nmBlockStateName;                                       // 0x0580(0x0008) (Const)
	class ATgPawn_BabaYaga*                            m_pawnBabaYaga;                                           // 0x0588(0x0008) (Const)
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               m_eValidStorePoints;                                      // 0x0590(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<EDeviceFailType>>               m_eValidDeviceFailOverrides;                              // 0x05A0(0x0010) (Const, NeedCtorLink)
	int                                                s_nBrewedCount;                                           // 0x05B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYaga_A02");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_DeviceGoToPotionFiringState();
	bool STATIC_CanStateFireInCooldown(const struct FName& nmStateName);
	bool STATIC_CanStateBeCanceled(const struct FName& nmStateName);
	bool STATIC_CanIncomingStateBeCanceled();
	bool IsOverriddenStateName(const struct FName& StateName);
	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	bool ApplyGlobalOffhandCooldown();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	void STATIC_HandleShooterInterrupt();
	void STATIC_HandleConsumableFire();
	void STATIC_StartPotionCooldown();
	void STATIC_SwapPotionsFromStored();
	void STATIC_SwapPotionsFromEquipped();
	void STATIC_StorePotion();
	void UnequipPotion(struct FBabaYagaPotionData* potion);
	void STATIC_EquipPotion(struct FBabaYagaPotionData* potion);
	void STATIC_ConsumeEquippedPotion();
	void BrewPotion();
	void STATIC_RemoveTrackedPotion(struct FBabaYagaPotionData* potion);
	bool STATIC_HasPotionInSpecificSlot(TEnumAsByte<ETG_EQUIP_POINT> eTestSlot);
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetStoredPotionStorageSlot();
	bool STATIC_HasPotionInStorageSlot();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetAvailableStorageSlot();
	bool STATIC_HasAvailableStorageSlot();
	bool STATIC_HasPotionEquipped();
	struct FName STATIC_GetIncomingStateName();
	unsigned char STATIC_IncrementFiringInstance();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_BabaYaga_A02_Consumable
// 0x0024 (0x0514 - 0x04F0)
class ATgDevice_BabaYaga_A02_Consumable : public ATgDevice
{
public:
	class ATgDevice_BabaYaga_A02*                      r_deviceBrewer;                                           // 0x04F0(0x0008) (Const, Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eOriginalEquippedAt;                                    // 0x04F8(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F9(0x0003) MISSED OFFSET
	TArray<int>                                        m_nIconIDs;                                               // 0x04FC(0x0010) (NeedCtorLink)
	class ATgPawn_BabaYaga*                            m_pawnBabaYaga;                                           // 0x050C(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYaga_A02_Consumable");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	int STATIC_GetIconID(int nIngredients);
	void STATIC_HideConsumableIcon();
	void STATIC_ShowConsumableIcon(TEnumAsByte<ETG_EQUIP_POINT> eEqpPoint, int nIngredients);
};


// Class TgGame.TgDevice_BabaYaga_A02_Deployable
// 0x0008 (0x04F8 - 0x04F0)
class ATgDevice_BabaYaga_A02_Deployable : public ATgDevice
{
public:
	class ATgDevice_BabaYaga_A02_Sub*                  r_deviceSpawner;                                          // 0x04F0(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYaga_A02_Deployable");
		return ptr;
	}

};


// Class TgGame.TgDevice_BabaYaga_A03
// 0x001C (0x050C - 0x04F0)
class ATgDevice_BabaYaga_A03 : public ATgDevice
{
public:
	class ATgPawn_BabaYaga*                            r_pawnBabaYaga;                                           // 0x04F0(0x0008) (Const, Net)
	TEnumAsByte<ETweenState>                           m_eTweenState;                                            // 0x04F8(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F9(0x0003) MISSED OFFSET
	float                                              m_fChannelingTime;                                        // 0x04FC(0x0004) (Const)
	int                                                m_nChannelingSituationalType;                             // 0x0500(0x0004) (Const)
	struct FName                                       m_nmEndChannelingFunction;                                // 0x0504(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYaga_A03");
		return ptr;
	}


	void STATIC_EndTween();
	void STATIC_StartTween();
	bool CanBeCanceled();
	void STATIC_EndChanneling();
	void BeginChanneling();
	bool STATIC_NativeIsFiring();
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_BabaYaga_A04
// 0x00A4 (0x0594 - 0x04F0)
class ATgDevice_BabaYaga_A04 : public ATgDevice
{
public:
	class ATgPawn_BabaYaga_Hut*                        r_pawnHutTarget;                                          // 0x04F0(0x0008) (Const, Net)
	class ATgPawn_BabaYaga*                            r_pawnBabaYagaOwner;                                      // 0x04F8(0x0008) (Const, Net)
	class ATgDevice_BabaYaga_A04_Sub*                  r_deviceSpawner;                                          // 0x0500(0x0008) (Const, Net)
	class ATgDevice*                                   r_deviceDeployable;                                       // 0x0508(0x0008) (Const, Net)
	float                                              r_fCustomFireTime;                                        // 0x0510(0x0004) (Const, Net)
	float                                              r_fResolveTime;                                           // 0x0514(0x0004) (Const, Net)
	unsigned long                                      r_bWillResolveThisShot : 1;                               // 0x0518(0x0004) (Const, Net)
	unsigned long                                      m_bDebugSingleShot : 1;                                   // 0x0518(0x0004) (Const)
	unsigned char                                      r_nCurrentFireCount;                                      // 0x051C(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x051D(0x0003) MISSED OFFSET
	int                                                r_nAllowedFireCount;                                      // 0x0520(0x0004) (Const, Net)
	TArray<struct FName>                               m_nmBabaA04CustomStateNames;                              // 0x0524(0x0010) (Const, NeedCtorLink)
	struct FName                                       m_nmBabaCustomIntroName;                                  // 0x0534(0x0008) (Const)
	struct FName                                       m_nmOnBabaIntroEndFunctionName;                           // 0x053C(0x0008) (Const)
	struct FName                                       m_nmBabaResolveName;                                      // 0x0544(0x0008) (Const)
	struct FName                                       m_nmBabaResolveIntroName;                                 // 0x054C(0x0008) (Const)
	struct FName                                       m_nmBabaResolveOutroName;                                 // 0x0554(0x0008) (Const)
	struct FName                                       m_nmOnBabaResolveEndFunctionName;                         // 0x055C(0x0008) (Const)
	struct FName                                       m_nmBabaCustomFireName;                                   // 0x0564(0x0008) (Const)
	struct FName                                       m_nmHandleCustomFireEndFunction;                          // 0x056C(0x0008) (Const)
	class UTgCameraModule*                             m_FiringCameraModule;                                     // 0x0574(0x0008)
	class UClass*                                      m_FiringCameraModuleClass;                                // 0x057C(0x0008) (Const)
	float                                              m_fCameraTweenInTime;                                     // 0x0584(0x0004) (Const)
	float                                              m_fCameraTweenOutTime;                                    // 0x0588(0x0004) (Const)
	class UTgDeviceFire*                               s_CachedDeviceFire;                                       // 0x058C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYaga_A04");
		return ptr;
	}


	bool IsInOutro();
	bool IsInIntro();
	bool IsInHutState();
	void TurnOffSpecialCamera();
	void TurnOnSpecialCamera();
	void STATIC_ClientInterrupt();
	void InterruptFiring();
	bool CanBeInterrupted();
	bool CanBeCanceledByRightMouse();
	void UpdateHutFireCount();
	void HandleBabaCustomFireEnd();
	void STATIC_OnBabaResolveEnd();
	void STATIC_OnBabaIntroEnd();
	void STATIC_OnBabaIntroStart();
	void CleanUpDevice();
	void STATIC_ResolveFinalShot();
	void STATIC_ResetShotTracking();
	void STATIC_IncrementShotTracking();
	float STATIC_CalculateTargeterTimeScale();
	void UnequipSpawnerDevice();
	void STATIC_EquipSpawnerDevice();
	void STATIC_ReturnHut();
	void STATIC_SummonHut();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_NativeIsFiring();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_SecondaryInitialization();
};


// Class TgGame.TgDevice_BabaYaga_A02_Sub
// 0x0028 (0x0524 - 0x04FC)
class ATgDevice_BabaYaga_A02_Sub : public ATgDevice_Deployable
{
public:
	class UTgDeviceForm_BabaYaga_A02_Sub*              c_formBabaYaga;                                           // 0x04FC(0x0008) (Const)
	class ATgPawn_BabaYaga*                            m_pawnBabaYaga;                                           // 0x0504(0x0008) (Const)
	class ATgDevice_BabaYaga_A02*                      r_deviceBrewer;                                           // 0x050C(0x0008) (Const, Net)
	class ATgDeploy_BabaYaga_A02*                      r_deployPotions[0x2];                                     // 0x0514(0x0008) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYaga_A02_Sub");
		return ptr;
	}


	void InterruptFiring();
	void STATIC_FireAmmunition();
	bool CanBeCanceled();
	bool ApplyGlobalOffhandCooldown();
	void OnDeployableDestroyed(class ATgDeployable* deployable);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	void SetDeviceFormTargeterMajority(TEnumAsByte<EBabaYagaA02IngredientMajority> eMajority);
	void EnterTargetingMode();
	void STATIC_RemoveDeployableFromTracking(class ATgDeploy_BabaYaga_A02* oldDeploy);
	void AddDeployableToTracking(class ATgDeploy_BabaYaga_A02* newDeploy);
	void STATIC_GetEquippedPotionData(int* nSpawnFireMode, unsigned char* nBrewerFiringInstance, int* nCurrentIngredients);
};


// Class TgGame.TgDevice_BabaYaga_A04_Sub
// 0x0074 (0x0570 - 0x04FC)
class ATgDevice_BabaYaga_A04_Sub : public ATgDevice_Deployable
{
public:
	float                                              r_fBabaCustomFiringTotalTime;                             // 0x04FC(0x0004) (Const, Net)
	float                                              r_fBabaCustomFiringTimes[0x8];                            // 0x0500(0x0004) (Const, Net)
	class ATgPawn_BabaYaga*                            r_pawnBabaYagaOwner;                                      // 0x0520(0x0008) (Net)
	class ATgDevice_BabaYaga_A04*                      r_deviceBabaParent;                                       // 0x0528(0x0008) (Const, Net)
	int                                                m_nPotionProjId;                                          // 0x0530(0x0004) (Const)
	TEnumAsByte<EBabaYagaA04FireType>                  r_eBabaYagaA04FireType;                                   // 0x0534(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0535(0x0003) MISSED OFFSET
	TArray<struct FName>                               m_nmCustomFireStateNames;                                 // 0x0538(0x0010) (Const, NeedCtorLink)
	struct FName                                       m_nmBabaYagaA04FireName;                                  // 0x0548(0x0008)
	struct FName                                       m_nmFireAName;                                            // 0x0550(0x0008)
	struct FName                                       m_nmFireBName;                                            // 0x0558(0x0008)
	struct FName                                       m_nmFireCName;                                            // 0x0560(0x0008)
	struct FName                                       m_nmFireDName;                                            // 0x0568(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYaga_A04_Sub");
		return ptr;
	}


	bool IsOverriddenStateName(const struct FName& nmStateName);
	void STATIC_DeviceGoToOverriddenFiringState();
	struct FName STATIC_GetIncomingStateName();
	float GetPostHitDelay(int nMode);
	float GetPreHitDelay(int nMode);
	void STATIC_ResetDevice();
	void UpdateFireType(unsigned char nFireCount);
	void STATIC_SetupTimings();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	bool CanBeInterrupted();
	bool CanBeCanceled();
	bool STATIC_ShouldSwitchBackToBasicAttackTargeting(TEnumAsByte<ECastMode> CastMode);
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	void UpdateTargetingModeStatus(struct FAimData* Aim);
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
};


// Class TgGame.TgDevice_BabaYaga_A01
// 0x00DC (0x05CC - 0x04F0)
class ATgDevice_BabaYaga_A01 : public ATgDevice_Range
{
public:
	class ATgPawn_BabaYaga*                            r_pawnBabaYaga;                                           // 0x04F0(0x0008) (Const, Net)
	TEnumAsByte<EBabaYagaProjShape>                    r_eNextProjShape;                                         // 0x04F8(0x0001) (Net)
	TEnumAsByte<EBabaYagaProjStatusType>               r_eNextStatusType;                                        // 0x04F9(0x0001) (Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x04FA(0x0002) MISSED OFFSET
	struct FName                                       m_nmProjShapeNames[0x4];                                  // 0x04FC(0x0008) (Const)
	struct FName                                       m_nmProjStatusTypes[0x4];                                 // 0x051C(0x0008) (Const)
	struct FAimData                                    m_vNextProjAim;                                           // 0x053C(0x0030)
	float                                              m_fSecondaryShotRange;                                    // 0x056C(0x0004) (Const)
	float                                              m_fSecondaryShotDelay;                                    // 0x0570(0x0004) (Const)
	float                                              m_fOvalRadius;                                            // 0x0574(0x0004) (Const)
	int                                                m_nProxySituationalTypes[0x4];                            // 0x0578(0x0004) (Const)
	int                                                m_nProxyLingeringSituationalTypes[0x4];                   // 0x0588(0x0004) (Const)
	int                                                m_nProxyCategoryCodes[0x4];                               // 0x0598(0x0004) (Const)
	int                                                m_nProjHitTargetPruneThreshold;                           // 0x05A8(0x0004) (Const)
	TArray<struct FMultiHitInfo>                       s_mhiProjHitTargets;                                      // 0x05AC(0x0010) (NeedCtorLink)
	TArray<struct FMultiHitInfo>                       s_mhiProxyHitTargets;                                     // 0x05BC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYaga_A01");
		return ptr;
	}


	struct FVector STATIC_GetNextProjectileAimVector(class ATgProjectile* projBabaA01);
	void STATIC_SpawnDeployable(class ATgProj_BabaYaga_A01* projOwner);
	void SetDeviceFormTargeterStatusType(TEnumAsByte<EBabaYagaProjStatusType> eStatusType);
	void SetDeviceFormTargeterShape(TEnumAsByte<EBabaYagaProjShape> eProjShape);
	struct FName GetNextProjStatusTypeName();
	struct FName GetNextProjShapeName();
	void STATIC_GetNextProjectileAim(class ATgProj_BabaYaga_A01* projBabaA01, struct FAimData* Aim);
	struct FVector STATIC_GetRotatedAimVector(const struct FRotator& rAimRot, float fYawRot);
	void STATIC_SpawnSecondaryEffects(class ATgProj_BabaYaga_A01* projOrigin, class UTgDeviceFire* firemodeCached);
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	void DetermineNextProjType();
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ForceProjectileHit(class ATgProj_BabaYaga_A01* projA01, struct FVector* vLoc);
	void UnregisterProxyHitTarget(class AActor* ATarget, int nFiringInstance, class UTgDeviceFire* FireMode, TEnumAsByte<EBabaYagaProjStatusType> eStatusType);
	void STATIC_RegisterProxyHitTarget(class AActor* ATarget, int nFiringInstance, class UTgDeviceFire* FireMode, TEnumAsByte<EBabaYagaProjStatusType> eStatusType);
	void STATIC_PruneProjHitTargets(int nFiringInstanceThreshold);
	bool STATIC_HasPreviouslyHitProjTarget(class AActor* ATarget, int nFiringInstance);
	void AddUniqueProjHitTarget(class AActor* ATarget, int nFiringInstance);
	bool IsValidProjShapeState(struct FName* nmProjState);
	void STATIC_SpawnCircleDeployable(class ATgProj_BabaYaga_A01* projOwner);
	void STATIC_SpawnBoxDeployable(class ATgProj_BabaYaga_A01* projOwner);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_BabaYagaHut_A04_Reposition
// 0x0034 (0x0550 - 0x051C)
class ATgDevice_BabaYagaHut_A04_Reposition : public ATgDevice_WarningDeployable
{
public:
	struct FVector                                     r_vOriginPosition;                                        // 0x051C(0x000C) (Net)
	class ATgPawn_BabaYaga_Hut*                        r_pawnHutOwner;                                           // 0x0528(0x0008) (Const, Net)
	class ATgPawn_BabaYaga*                            r_pawnBabaYagaOwner;                                      // 0x0530(0x0008) (Const, Net)
	TEnumAsByte<EBabaYagaHutA04RepositionType>         r_eRepositionType;                                        // 0x0538(0x0001) (Const, Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0539(0x0003) MISSED OFFSET
	struct FName                                       m_nmRepToOwnerName;                                       // 0x053C(0x0008) (Const)
	struct FName                                       m_nmRepToOriginName;                                      // 0x0544(0x0008) (Const)
	unsigned long                                      m_bSuccessfulSecondaryInit : 1;                           // 0x054C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BabaYagaHut_A04_Reposition");
		return ptr;
	}


	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_DeviceGoToRepositionFiringState();
	bool IsOverriddenStateName(const struct FName& StateName);
	void SetOriginPosition(const struct FVector& vNewOrigin);
	struct FVector GetTweenLocation(struct FAimData* Aim);
	void STATIC_SpawnWarningDeployable();
	void STATIC_ExplosionFire();
	void STATIC_GetWarningAim(struct FAimData* Aim);
	void STATIC_GetExplosionAim(struct FAimData* Aim);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
	bool STATIC_SecondaryInitialization();
	struct FName STATIC_GetIncomingStateName();
};


// Class TgGame.TgDeviceFire_BabaYaga_A01
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_BabaYaga_A01 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BabaYaga_A01");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_BabaYagaHut_A04_Reposition
// 0x0001 (0x01C1 - 0x01C0)
class UTgDeviceFire_BabaYagaHut_A04_Reposition : public UTgDeviceFire
{
public:
	TEnumAsByte<EDeviceTargeterType>                   m_eSecondaryTargeterType;                                 // 0x01C0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BabaYagaHut_A04_Reposition");
		return ptr;
	}


	float STATIC_GetDeployTime();
	bool IsValidTarget(class AActor* P, TEnumAsByte<EDeviceTargeterType> eTargeterType, bool bIgnoreHealth);
};


// Class TgGame.TgDeviceFire_BabaYaga_VisualProjectile
// 0x000C (0x01CC - 0x01C0)
class UTgDeviceFire_BabaYaga_VisualProjectile : public UTgDeviceFire_Deploy
{
public:
	int                                                m_nPotionProjId;                                          // 0x01C0(0x0004) (Const)
	struct FPointer                                    m_pProjSetup;                                             // 0x01C4(0x0008) (Native)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BabaYaga_VisualProjectile");
		return ptr;
	}


	void STATIC_InitializeProjectile(class AProjectile* Proj);
	class UClass* STATIC_GetProjectileClass();
	int STATIC_GetOwnerProjectileId();
};


// Class TgGame.TgDeviceFire_BabaYaga_A02Sub
// 0x0000 (0x01CC - 0x01CC)
class UTgDeviceFire_BabaYaga_A02Sub : public UTgDeviceFire_BabaYaga_VisualProjectile
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BabaYaga_A02Sub");
		return ptr;
	}


	int STATIC_GetOwnerProjectileId();
};


// Class TgGame.TgDeviceFire_BabaYaga_A04Sub
// 0x0000 (0x01CC - 0x01CC)
class UTgDeviceFire_BabaYaga_A04Sub : public UTgDeviceFire_BabaYaga_VisualProjectile
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BabaYaga_A04Sub");
		return ptr;
	}


	int STATIC_GetOwnerProjectileId();
};


// Class TgGame.TgDeviceForm_BabaYaga_A02_Sub
// 0x0011 (0x0249 - 0x0238)
class UTgDeviceForm_BabaYaga_A02_Sub : public UTgDeviceForm
{
public:
	int                                                c_nCustomIngredientFilter[0x4];                           // 0x0238(0x0004)
	TEnumAsByte<EBabaYagaA02IngredientMajority>        c_eIngredientMajority;                                    // 0x0248(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BabaYaga_A02_Sub");
		return ptr;
	}


	void SetIngredientMajority(TEnumAsByte<EBabaYagaA02IngredientMajority> eMajority);
	int STATIC_GetCustomParticleSystemFilter();
};


// Class TgGame.TgDeviceForm_BabaYaga_A03
// 0x000C (0x0250 - 0x0244)
class UTgDeviceForm_BabaYaga_A03 : public UTgDeviceForm_LineCone
{
public:
	class UTgSpecialFx*                                c_TimerTargetModeFx;                                      // 0x0244(0x0008)
	int                                                c_nTimerTargetFxId;                                       // 0x024C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BabaYaga_A03");
		return ptr;
	}


	void Fire(const struct FVector& HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, bool bSuccessfulHit, float fRefireTime);
	void ExitTargetingMode();
	void SwapInTimerFX();
	void STATIC_DeactivateTargetFX();
	void STATIC_DeactivateTimerFX();
	void ActivateTimerFX();
	void STATIC_InitializeTimerFX();
	void STATIC_InitializeTargetingModeFX();
};


// Class TgGame.TgDeviceForm_BabaYaga_A01
// 0x0002 (0x025A - 0x0258)
class UTgDeviceForm_BabaYaga_A01 : public UTgDeviceForm_MultiTargeters
{
public:
	TEnumAsByte<EBabaYagaProjShape>                    c_eProjShape;                                             // 0x0258(0x0001)
	TEnumAsByte<EBabaYagaProjStatusType>               c_eProjStatusType;                                        // 0x0259(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_BabaYaga_A01");
		return ptr;
	}


	void STATIC_SetProjStatusType(TEnumAsByte<EBabaYagaProjStatusType> eProjStatusType);
	void STATIC_SetProjShape(TEnumAsByte<EBabaYagaProjShape> eProjShape);
	bool ShouldInitializeFx(int nFxTargeterIndex);
	int STATIC_GetCustomParticleSystemFilter();
};


// Class TgGame.TgInventoryObject_Listen_BabaYaga_A01
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_BabaYaga_A01 : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_BabaYaga_A01*                      s_devBabaYagaA01;                                         // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BabaYaga_A01");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_BabaYaga_A02
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_BabaYaga_A02 : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_BabaYaga_A02_Deployable*           s_deviceDeployableSub;                                    // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_BabaYaga_A02");
		return ptr;
	}

};


// Class TgGame.TgPawn_BabaYaga
// 0x0120 (0x26D8 - 0x25B8)
class ATgPawn_BabaYaga : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_deviceInhand;                                           // 0x25B8(0x0008)
	class ATgDevice*                                   m_devicePsv;                                              // 0x25C0(0x0008)
	class ATgDevice_BabaYaga_A01*                      m_deviceA01;                                              // 0x25C8(0x0008)
	class ATgDevice_BabaYaga_A02*                      m_deviceA02;                                              // 0x25D0(0x0008)
	class ATgDevice_BabaYaga_A02_Sub*                  m_deviceA02SpawnerSub;                                    // 0x25D8(0x0008)
	class ATgDevice_BabaYaga_A02_Consumable*           m_deviceA02ConsumableSub;                                 // 0x25E0(0x0008)
	class ATgDevice_BabaYaga_A02_Deployable*           m_deviceA02DeploySub;                                     // 0x25E8(0x0008)
	class ATgDevice_BabaYaga_A03*                      m_deviceA03;                                              // 0x25F0(0x0008)
	class ATgDevice_BabaYaga_A04*                      m_deviceA04;                                              // 0x25F8(0x0008)
	class ATgDevice_BabaYaga_A04_Sub*                  m_deviceA04SpawnerSub;                                    // 0x2600(0x0008)
	class ATgDevice*                                   m_deviceA04DeploySub;                                     // 0x2608(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x2610(0x0004) (Const)
	unsigned long                                      m_bPreventTargeterSwap : 1;                               // 0x2610(0x0004)
	unsigned long                                      r_bA02HasPotion : 1;                                      // 0x2610(0x0004) (Net)
	unsigned long                                      m_bInA02ConsumableFire : 1;                               // 0x2610(0x0004)
	unsigned long                                      r_bA03InMortar : 1;                                       // 0x2610(0x0004) (Net)
	unsigned long                                      r_bA04InHut : 1;                                          // 0x2610(0x0004) (Net)
	TEnumAsByte<EBabaYagaTargeterDevice>               r_eEquippedTargeter;                                      // 0x2614(0x0001) (Net)
	TEnumAsByte<EBabaYagaA01AnimState>                 r_eA01AnimState;                                          // 0x2615(0x0001) (Net)
	TEnumAsByte<ETG_EQUIP_POINT>                       r_eA02StoredPotionEQPPoint;                               // 0x2616(0x0001) (Net)
	unsigned char                                      UnknownData00[0x1];                                       // 0x2617(0x0001) MISSED OFFSET
	class ATgPawn_BabaYaga_Hut*                        r_Hut;                                                    // 0x2618(0x0008) (Net)
	struct FBabaYagaA01FxTrigger                       r_fxtSecondaryShotDelay;                                  // 0x2620(0x0014) (Net)
	int                                                m_nSecondaryShotDelayFxId;                                // 0x2634(0x0004) (Const)
	TArray<struct FName>                               m_nmA02DisplayGroupIngredients;                           // 0x2638(0x0010) (Const, NeedCtorLink)
	TArray<int>                                        m_nA02IngredientTotals;                                   // 0x2648(0x0010) (Const, NeedCtorLink)
	struct FName                                       m_nmA02PotionDisplayGroupName;                            // 0x2658(0x0008) (Const)
	struct FName                                       m_nmA02PotionBoneName;                                    // 0x2660(0x0008) (Const)
	struct FName                                       m_nmA02IngredientParameterName;                           // 0x2668(0x0008) (Const)
	struct FName                                       m_nmA02LiquidParameterName;                               // 0x2670(0x0008) (Const)
	int                                                m_nA02PotionMeshAssemblyId;                               // 0x2678(0x0004) (Const)
	struct FName                                       m_nmA02FireSocketName;                                    // 0x267C(0x0008) (Const)
	int                                                r_nA02CurrentIngredients[0x3];                            // 0x2684(0x0004) (Net)
	int                                                r_eA02PotionIdsVisualTracker[0x3];                        // 0x2690(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    c_smcA02PotionComponent;                                  // 0x269C(0x0008) (ExportObject, Component, EditInline)
	TArray<class ATgSkeletalMeshActorSpawnable_BabaYagaPotion*> m_actorPotionMeshes;                                      // 0x26A4(0x0010) (NeedCtorLink)
	float                                              m_fA02MajorityThreshold;                                  // 0x26B4(0x0004) (Const)
	class UTgDeviceForm_BabaYaga_A03*                  c_formCachedA03;                                          // 0x26B8(0x0008) (Const)
	TArray<class UTgAnimNodeBlentList_IntroLoopOutro*> m_A04BlentListNodes;                                      // 0x26C0(0x0010) (NeedCtorLink)
	struct FName                                       m_nmA04FireSocketName;                                    // 0x26D0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BabaYaga");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void AddSelfToViewerList();
	bool CanBeBaseForPawn(class APawn* aPawn);
	void EndViewTarget(class APlayerController* PC);
	struct FVector GetA04ProjectileStartTraceLocation();
	void PlayA04Outro();
	void PlayA04Intro();
	void HandleA04Anims();
	void SetA04InHutState(bool bInHut);
	void UnequipA04SubDevice();
	void STATIC_EquipA04SubDevice();
	bool IsA04Active();
	void SetA03InMortarState(bool bInMortar);
	void STATIC_HandleA03MortarVisuals();
	void UpdateA02StoredPotionEQPPoint(TEnumAsByte<ETG_EQUIP_POINT> eEqpPoint);
	struct FVector GetA02ProjectileStartTraceLocation();
	int STATIC_FindA02MeshIndexByPotionId(int nPotionId);
	void ActivateA02NewPotionMesh(int nPotionId, int nIngredients, class ATgSkeletalMeshActorSpawnable_BabaYagaPotion** actorPotionMesh);
	void STATIC_HandleA02ConsumedPotionVisuals(int nPotionId);
	void STATIC_HandleA02StoredPotionVisuals(int nPotionId);
	void STATIC_HandleA02EquippedPotionVisuals(int nPotionId);
	void STATIC_HandleA02PotionVisuals();
	void STATIC_SetA02PotionConsumed(int nPotionId);
	void STATIC_SetA02PotionStored(int nPotionId);
	void STATIC_SetA02PotionEquipped(int nPotionId);
	void UnpackageA02IngredientData(int nPackageValue, int* nIngredients);
	void STATIC_PackageA02IngredientData(int nIngredients, int* nPackageValue);
	TEnumAsByte<EBabaYagaA02IngredientMajority> STATIC_GetA02IngredientMajority(int nIngredients);
	void STATIC_CustomizeA02PotionVisuals(class UTgSkeletalMeshComponent* meshPotion, int nIngredients);
	void STATIC_SetA02Ingredients(int nCountA, int nCountB, int nCountC);
	void UnequipA02Potion();
	void STATIC_EquipA02Potion(int nIngredients);
	void UnequipA02SubDevice();
	void STATIC_EquipA02SubDevice();
	TEnumAsByte<ETG_EQUIP_POINT> STATIC_GetA02PotionStoredSlot();
	void STATIC_GetA02EquippedPotionIngredients(int* nCountA, int* nCountB, int* nCountC);
	bool STATIC_HasA02PotionEquipped();
	void SetA01AnimState(TEnumAsByte<EBabaYagaA01AnimState> eNewState);
	void STATIC_PlaySecondaryShotDelayFx(int nCustomFilter, struct FVector* vSpawnLoc);
	void STATIC_InitSpawnedPet(class ATgPawn* Pet);
	struct FVector STATIC_GetPassivePetSpawnOffset(class ATgPawn* pSpawnedPet);
	void STATIC_SwapDeviceEquipPoints(int nEqpSlot1, int nEqpSlot2);
	void STATIC_OnDeviceFormStopFire(int nEquipSlot);
	void STATIC_OnDeviceFormHit(int nEquipSlot, class ATgPawn* TargetPawn);
	void STATIC_OnDeviceFormFire(int nEquipSlot);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_ClearMultiMeshAnimNodeReferences();
	void STATIC_CacheMultiMeshAnimNodeReferences(class UTgSkeletalMeshComponent* smcomp);
	void STATIC_DeviceFormChanged(bool bForceReload);
	void UnequipTargeter(TEnumAsByte<EBabaYagaTargeterDevice> eSourceTargeter);
	void STATIC_HandleEquippedTargeterChange();
	void STATIC_SetEquippedTargeter(TEnumAsByte<EBabaYagaTargeterDevice> eNewTargeter);
	void SetTargetingDevice(class ATgDevice* Dev);
	void STATIC_PawnOnDamaged(struct FOnDamagedParams* Params);
	void DeviceOnStartBuildup(class ATgDevice* Dev);
	bool STATIC_GetPassiveString(struct FString* sResult);
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_PawnOnSpecialReset();
	void STATIC_PostPawnSetupServer();
	void UpdateClientDevices(bool bForce);
	void Destroyed();
};


// Class TgGame.TgPawn_BabaYaga_Hut
// 0x004C (0x24DC - 0x2490)
class ATgPawn_BabaYaga_Hut : public ATgPawn_Familiar_LongTerm
{
public:
	class ATgDevice_BabaYagaHut_A04_Reposition*        m_deviceA04Reposition;                                    // 0x2490(0x0008)
	class ATgDevice_BabaYagaHut_PSV*                   m_devicePsv;                                              // 0x2498(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x24A0(0x0004) (Const)
	unsigned long                                      r_bA04WillReturnToPrevLoc : 1;                            // 0x24A0(0x0004) (Net)
	unsigned long                                      r_bA04ActivePosOverride : 1;                              // 0x24A0(0x0004) (Net)
	unsigned long                                      m_bJumpingUp : 1;                                         // 0x24A0(0x0004)
	TArray<TEnumAsByte<ETG_EQUIP_POINT>>               m_eEQPForSetup;                                           // 0x24A4(0x0010) (Const, NeedCtorLink)
	int                                                m_nTrackedPostureID;                                      // 0x24B4(0x0004)
	TEnumAsByte<EBabaYagaHutState>                     r_eHutState;                                              // 0x24B8(0x0001) (Net)
	TEnumAsByte<EBabaYagaHutA04FireType>               r_eA04FireType;                                           // 0x24B9(0x0001) (Const, Net)
	unsigned char                                      UnknownData00[0x2];                                       // 0x24BA(0x0002) MISSED OFFSET
	float                                              r_fHutEnergy;                                             // 0x24BC(0x0004) (Net)
	struct FVector                                     m_vPreviousLocation;                                      // 0x24C0(0x000C)
	struct FName                                       m_nmA04InterruptAnimName;                                 // 0x24CC(0x0008) (Const)
	struct FName                                       m_nmA04FiringAnimName;                                    // 0x24D4(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_BabaYaga_Hut");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	bool STATIC_TakeDamageSpecial(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void TakeDamage(int Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void HandleStateChange();
	void UpdatePetPhase(TEnumAsByte<EPetPhase> NewPhase, const struct FName& SourceName);
	bool Teleport(const struct FVector& vDest, const struct FRotator& rDest, bool bPlayFx, int TeleportEnterState, int TeleportExitState, bool bMaintainControllerPitch);
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	void STATIC_SetProperty(int nPropIndex, float fNewValue);
	bool IsNonCombat();
	void STATIC_PostPawnSetupServer();
	void UpdateClientDevices(bool bForce);
	void SetA04WillReturnToPrevLocation(bool bActive);
	void SetA04PositionOverrideActive(bool bActive);
	void UpdateA04FireType(unsigned char nFireCount);
	void ModifyEnergy(float fEnergyMod);
	void STATIC_OverrideA04Position();
};


// Class TgGame.TgProj_BabaYaga_VisualLob
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_BabaYaga_VisualLob : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BabaYaga_VisualLob");
		return ptr;
	}

};


// Class TgGame.TgProj_BabaYaga_A02
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_BabaYaga_A02 : public ATgProj_BabaYaga_VisualLob
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BabaYaga_A02");
		return ptr;
	}

};


// Class TgGame.TgProj_BabaYaga_A01
// 0x0044 (0x03F0 - 0x03AC)
class ATgProj_BabaYaga_A01 : public ATgProj_SimulatedPassThrough
{
public:
	class ATgDevice_BabaYaga_A01*                      m_devBabaYagaA01;                                         // 0x03AC(0x0008) (Const)
	unsigned long                                      m_bRefire : 1;                                            // 0x03B4(0x0004)
	unsigned long                                      m_bCirRotatesClockwise : 1;                               // 0x03B4(0x0004) (Const)
	unsigned long                                      c_bCanSpawnClientEffects : 1;                             // 0x03B4(0x0004) (Const)
	unsigned long                                      s_bHasDelayedSecondarySpawn : 1;                          // 0x03B4(0x0004) (Const)
	unsigned long                                      m_bIsOnCirReturnArc : 1;                                  // 0x03B4(0x0004)
	TEnumAsByte<EBabaYagaProjStatusType>               m_eStatusType;                                            // 0x03B8(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x03B9(0x0003) MISSED OFFSET
	int                                                m_nFxDeployableId[0x3];                                   // 0x03BC(0x0004) (Const)
	float                                              m_fCirStartTime;                                          // 0x03C8(0x0004) (Const)
	float                                              m_fCirDuration;                                           // 0x03CC(0x0004) (Const)
	float                                              m_fCirRadius;                                             // 0x03D0(0x0004) (Const)
	struct FVector                                     m_vCirCenterLoc;                                          // 0x03D4(0x000C) (Const)
	struct FVector                                     m_vCirStartingAngle;                                      // 0x03E0(0x000C) (Const)
	float                                              m_fOvalRadius;                                            // 0x03EC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BabaYaga_A01");
		return ptr;
	}


	void STATIC_RefreshPreviousHitTargetList();
	void ShutDown();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_SpawnSecondaryShot();
	void GoToShapeState(TEnumAsByte<EBabaYagaProjShape> eProjShape);
	int GetFxDeployableId();
	void STATIC_ClientUpdateSecondaryShotRange();
	void STATIC_SetStatusType(TEnumAsByte<EBabaYagaProjStatusType> eStatusType);
	void STATIC_InitializeSecondaryShot();
	void STATIC_CompleteInitialization();
	bool ShouldDelayCompleteInitialization();
	TEnumAsByte<EBabaYagaProjShape> GetProjShape();
	float GetTrailEnd();
	float GetTrailProgress(const struct FVector& vLocOverride);
};


// Class TgGame.TgSkeletalMeshActorSpawnable_BabaYagaPotion
// 0x007C (0x0398 - 0x031C)
class ATgSkeletalMeshActorSpawnable_BabaYagaPotion : public ATgSkeletalMeshActorSpawnable
{
public:
	TEnumAsByte<EBabaYagaA02VisualState>               m_eCurrentVisualState;                                    // 0x031C(0x0001) (Const)
	TEnumAsByte<EBabaYagaPotionAnimState>              m_eCurrentAnimState;                                      // 0x031D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x031E(0x0002) MISSED OFFSET
	struct FName                                       m_nmStateNames[0x5];                                      // 0x0320(0x0008) (Const)
	struct FName                                       m_nmFunctionHandleStateTimerEnd;                          // 0x0348(0x0008) (Const)
	float                                              m_fStateTimes[0x5];                                       // 0x0350(0x0004) (Const)
	class UTgSkeletalMeshComponent*                    m_smcPotionMeshComponent;                                 // 0x0364(0x0008) (Const, ExportObject, Component, EditInline)
	int                                                m_nMeshId;                                                // 0x036C(0x0004) (Const)
	int                                                m_nIngredients[0x3];                                      // 0x0370(0x0004) (Const)
	int                                                m_nPotionId;                                              // 0x037C(0x0004) (Const)
	int                                                m_nPotionMeshAssemblyId;                                  // 0x0380(0x0004) (Const)
	struct FName                                       m_nmFadeParameter;                                        // 0x0384(0x0008) (Const)
	float                                              m_fFadeTime;                                              // 0x038C(0x0004) (Const)
	float                                              m_fCurrentFadeTime;                                       // 0x0390(0x0004)
	unsigned long                                      m_bShouldApplyFade : 1;                                   // 0x0394(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable_BabaYagaPotion");
		return ptr;
	}


	void STATIC_HandleStateTimerEnd();
	float STATIC_GetStateTime();
	void TickFade(float fDeltaSeconds);
	void STATIC_EnterStoredVisualState();
	void STATIC_EnterEquippedVisualState();
	void STATIC_CleanUpMeshActor(bool bForceHidden);
	void STATIC_GenerateMesh(class ATgPawn_BabaYaga* pawnBabaOwner);
	void STATIC_SetPotionData(int nPotionId, int nIngredients);
	void STATIC_CustomInitialize(class ATgPawn_BabaYaga* pawnBabaOwner, int nPotionId, int nIngredients);
};


// Class TgGame.TgAchievement_Depthzy_ShatteredMind
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_Depthzy_ShatteredMind : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Depthzy_ShatteredMind");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Depthzy_WhispersOfTheOldGods
// 0x0000 (0x00A4 - 0x00A4)
class UTgAchievement_Depthzy_WhispersOfTheOldGods : public UTgAchievement_DeviceXHitsWithEffect_UniqueGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Depthzy_WhispersOfTheOldGods");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Depthzy
// 0x0068 (0x0110 - 0x00A8)
class UTgCameraModule_Depthzy : public UTgCameraModule_ThirdPerson
{
public:
	struct FDepthzyCameraSetup                         m_cameraSettings[0x2];                                    // 0x00A8(0x002C) (Const)
	TEnumAsByte<EDepthzyMeshSwapStance>                m_eCurrentSettingsState;                                  // 0x0100(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0101(0x0003) MISSED OFFSET
	struct FVector                                     m_vAbsoluteOffsetCurrent;                                 // 0x0104(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Depthzy");
		return ptr;
	}


	void ResetCamera();
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void STATIC_RestoreRelativeZoom(float fPrevZoomFactor, float fPrevZoomMax, float fPrevZoomMin);
	void UpdateZoomSettings();
	void UpdateCurrentSettings(TEnumAsByte<EDepthzyMeshSwapStance> eSettingsState);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgDamageType_DepthzyIState
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_DepthzyIState : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_DepthzyIState");
		return ptr;
	}

};


// Class TgGame.TgDeploy_Depthzy_A02
// 0x00A0 (0x0498 - 0x03F8)
class ATgDeploy_Depthzy_A02 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	class ATgPawn_Depthzy*                             m_depthzy;                                                // 0x03F8(0x0008) (Const)
	class ATgDevice_Depthzy_A02*                       m_devA02;                                                 // 0x0400(0x0008) (Const)
	struct FName                                       m_nmFinishGrowth;                                         // 0x0408(0x0008) (Const)
	struct FName                                       m_nmGrowthComplete;                                       // 0x0410(0x0008) (Const)
	struct FName                                       m_nmPulseFireDisplayGroup;                                // 0x0418(0x0008) (Const)
	TArray<struct FName>                               m_nmPulseImpactDisplayGroupChain;                         // 0x0420(0x0010) (Const, NeedCtorLink)
	float                                              r_fMaxRadius;                                             // 0x0430(0x0004) (Const, Net)
	float                                              r_fMinRadius;                                             // 0x0434(0x0004) (Const, Net)
	float                                              r_fFinalRadiusScale;                                      // 0x0438(0x0004) (Const, Net)
	float                                              r_fPersistTime;                                           // 0x043C(0x0004) (Const, Net)
	float                                              m_fCurrentRadius;                                         // 0x0440(0x0004)
	int                                                s_nMaxPulseCount;                                         // 0x0444(0x0004) (Const, Config)
	float                                              s_fPulsePreCommitTime;                                    // 0x0448(0x0004) (Const, Config)
	TArray<int>                                        m_nPulseSituationalTypeChain;                             // 0x044C(0x0010) (Const, NeedCtorLink)
	float                                              r_fPulseTime;                                             // 0x045C(0x0004) (Const, Net)
	int                                                m_nPulseIndex;                                            // 0x0460(0x0004)
	float                                              s_fLifespanAfterChanneling;                               // 0x0464(0x0004) (Const, Config)
	float                                              s_fMaxChannelDist;                                        // 0x0468(0x0004) (Const, Config)
	float                                              m_fMaxChannelDistSq;                                      // 0x046C(0x0004) (Const)
	TArray<class ATgPawn*>                             s_pawnWaitingToApplyList;                                 // 0x0470(0x0010) (NeedCtorLink)
	float                                              s_fTimeTillOutro;                                         // 0x0480(0x0004) (Const, Config)
	int                                                r_nMaxPulseCount;                                         // 0x0484(0x0004) (Const, Net)
	float                                              r_fPulsePreCommitTime;                                    // 0x0488(0x0004) (Const, Net)
	float                                              r_fLifespanAfterChanneling;                               // 0x048C(0x0004) (Const, Net)
	float                                              r_fMaxChannelDist;                                        // 0x0490(0x0004) (Const, Net)
	float                                              r_fTimeTillOutro;                                         // 0x0494(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Depthzy_A02");
		return ptr;
	}


	void STATIC_StartLifespanTimer();
	void STATIC_CheckMaxChannelDistReached();
	void STATIC_FirePulseWarningFx();
	void STATIC_CommitToPulse();
	void DestroyIt(bool bSkipFx);
	void Cleanup();
	void STATIC_SwapToOutroFx();
	void STATIC_FireAmmunitionDeployable();
	void STATIC_FirePulseImpactFx(int nPulseIndex);
	void STATIC_FirePulse();
	bool IsTargetAffectedByPulseCC(class ATgPawn* PawnTarget);
	void HandleUnTouch(class AActor* Other);
	void STATIC_HandleWaitingToApplyList();
	void ApplyTouchHitSpecial(class AActor* Other, const struct FImpactInfo& Impact);
	void Tick(float DeltaTime);
	void STATIC_DeployComplete();
	void StartDeploy();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_FinishGrowth();
	float STATIC_GetRadiusScale();
	void UpdateComponentsScale();
};


// Class TgGame.TgDeploy_Depthzy_A03
// 0x0010 (0x0408 - 0x03F8)
class ATgDeploy_Depthzy_A03 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	class ATgPawn_Depthzy*                             m_depthzy;                                                // 0x0400(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Depthzy_A03");
		return ptr;
	}


	void TimeDeviceFiring();
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDeploy_Depthzy_B02
// 0x0014 (0x04AC - 0x0498)
class ATgDeploy_Depthzy_B02 : public ATgDeploy_ExplodingCylinder
{
public:
	struct FName                                       m_nmHandSocketName;                                       // 0x0498(0x0008) (Const)
	int                                                m_nHandProjFiremodeId;                                    // 0x04A0(0x0004) (Const)
	class ATgPawn_Depthzy*                             m_depthzy;                                                // 0x04A4(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Depthzy_B02");
		return ptr;
	}


	void STATIC_SpawnClientHandProjectile();
};


// Class TgGame.TgDepthzy_IStateMeshProcessor
// 0x002C (0x008C - 0x0060)
class UTgDepthzy_IStateMeshProcessor : public UObject
{
public:
	struct FPointer                                    VfTable_ITgPawnSingletonProcessor;                        // 0x0060(0x0008) (Const, Native, NoExport)
	TArray<struct FDepthzyIStateAssetMap>              c_assetMaps;                                              // 0x0068(0x0010) (NeedCtorLink)
	TArray<class ATgPawn_Depthzy*>                     c_candidates;                                             // 0x0078(0x0010) (NeedCtorLink)
	unsigned long                                      c_bIsFinal : 1;                                           // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDepthzy_IStateMeshProcessor");
		return ptr;
	}


	class UTgMeshPool_Depthzy_IState* STATIC_GetMeshPool(class ATgPawn_Depthzy* Depthzy);
	class UTgMapTracker_Depthzy_IState* STATIC_GetMapTracker(class ATgPawn_Depthzy* Depthzy);
	int STATIC_GetVisualsIndexFor(class ATgPawn_Depthzy* Depthzy);
	void UnregisterPawn(class ATgPawn* PawnRep);
	bool STATIC_HasFinalizedRepresentation();
	void STATIC_FinalizeRepresentation();
	void STATIC_RegisterPawn(class ATgPawn* PawnRep);
	bool STATIC_RepresentsPawn(class ATgPawn* PawnRep);
};


// Class TgGame.TgDevice_Depthzy_A04_Sub
// 0x0028 (0x054C - 0x0524)
class ATgDevice_Depthzy_A04_Sub : public ATgDevice_Aura
{
public:
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x0524(0x0008) (Net)
	TArray<struct FDepthzyA04AuraTormentTargetTimer>   m_TormentTargetTimers;                                    // 0x052C(0x0010) (NeedCtorLink)
	float                                              s_fTormentTriggerTime;                                    // 0x053C(0x0004) (Const, Config)
	float                                              s_fFacingTowardDepthzyModifier;                           // 0x0540(0x0004) (Const, Config)
	float                                              r_fTormentTriggerTime;                                    // 0x0544(0x0004) (Const, Net)
	float                                              r_fFacingTowardDepthzyModifier;                           // 0x0548(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_A04_Sub");
		return ptr;
	}


	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_RemoveUniqueTormentTargetTimer(class ATgPawn* PawnTarget);
	void AddUniqueTormentTargetTimer(class ATgPawn* PawnTarget);
};


// Class TgGame.TgDevice_Depthzy_Psv
// 0x0010 (0x0534 - 0x0524)
class ATgDevice_Depthzy_Psv : public ATgDevice_PassiveAura
{
public:
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x0524(0x0008) (Net)
	int                                                m_nTormentSituationalType;                                // 0x052C(0x0004) (Const)
	int                                                m_nInsanitySituationalType;                               // 0x0530(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_Psv");
		return ptr;
	}


	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
	void UpdateHitAuraApplication(class AActor* Other, bool bInsanityApplied);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ConsumeInsanityState(class ATgPawn* PawnTarget);
	void ApplyInsanityState(class ATgPawn* PawnTarget);
	void ApplyTormentStack(class ATgPawn* PawnTarget, int nNumStacks);
};


// Class TgGame.TgDevice_Depthzy_Auto
// 0x0008 (0x0540 - 0x0538)
class ATgDevice_Depthzy_Auto : public ATgDevice_ChainedMelee
{
public:
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x0538(0x0008) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_Auto");
		return ptr;
	}


	bool CanDeviceStartFiringNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDebugRelevant, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_Depthzy_A03
// 0x0048 (0x0584 - 0x053C)
class ATgDevice_Depthzy_A03 : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgDeviceSurrogateInterface;                      // 0x053C(0x0008) (Const, Native, NoExport)
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x0544(0x0008) (Net)
	class ATgDevice_Depthzy_A03_Sub*                   m_devSub;                                                 // 0x054C(0x0008)
	unsigned long                                      m_bRightClickCanceled : 1;                                // 0x0554(0x0004)
	unsigned long                                      c_bUseServerAim : 1;                                      // 0x0554(0x0004)
	float                                              m_fChargeStartTime;                                       // 0x0558(0x0004)
	float                                              s_fDepSpreadDistance;                                     // 0x055C(0x0004) (Const, Config)
	float                                              s_fKnockbackDist;                                         // 0x0560(0x0004) (Const, Config)
	float                                              s_fKnockbackSpeed;                                        // 0x0564(0x0004) (Const, Config)
	float                                              s_fPreChargeDelay;                                        // 0x0568(0x0004) (Const, Config)
	float                                              s_fCanCancelDelay;                                        // 0x056C(0x0004) (Const, Config)
	float                                              r_fDepSpreadDistance;                                     // 0x0570(0x0004) (Const, Net)
	float                                              r_fKnockbackDist;                                         // 0x0574(0x0004) (Const, Net)
	float                                              r_fKnockbackSpeed;                                        // 0x0578(0x0004) (Const, Net)
	float                                              r_fPreChargeDelay;                                        // 0x057C(0x0004) (Const, Net)
	float                                              r_fCanCancelDelay;                                        // 0x0580(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_A03");
		return ptr;
	}


	void STATIC_ClientSetChargeAim(const struct FRotator& rChargeAim);
	void STATIC_SetLockInstigatorRotation(bool bLockRotation);
	void InterruptWithoutNotifyingClient();
	void STATIC_HandleInterrupt();
	void STATIC_ClientInterrupt();
	void InterruptFiring();
	bool CanBeCanceledByRightMouse();
	bool CanBeCanceled();
	bool STATIC_GetOrientationVectors(struct FVector* vForward, struct FVector* vRight);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	bool STATIC_CanPerformKnockback(class AActor* Other);
	void STATIC_FirePreChargeDelay();
	class UTgDeviceFire* STATIC_GetCurrentFire();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool IsLockedDown();
	bool STATIC_ShouldUpdateTimer();
	unsigned char STATIC_IncrementFiringInstance();
	bool STATIC_HasBeenTrained();
	int STATIC_GetAllocatedDevicePoints(bool bForceBasePoints);
	int STATIC_GetTotalDevicePoints();
	bool IsDeviceCoolingDown();
	bool STATIC_ShouldUseSurrogateDevice();
	class ATgDevice* STATIC_GetSurrogateDevice();
	struct FAimData STATIC_CacheAim();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_CustomUpdateTargetingModeLocation();
	void STATIC_PerformKnockback(struct FImpactInfo* Impact);
};


// Class TgGame.TgDevice_Depthzy_B02
// 0x0008 (0x0504 - 0x04FC)
class ATgDevice_Depthzy_B02 : public ATgDevice_Deployable
{
public:
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x04FC(0x0008) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_B02");
		return ptr;
	}


	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	int STATIC_GetTotalDevicePoints();
};


// Class TgGame.TgDevice_Depthzy_A01
// 0x0044 (0x0534 - 0x04F0)
class ATgDevice_Depthzy_A01 : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgDeviceSurrogateInterface;                      // 0x04F0(0x0008) (Const, Native, NoExport)
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x04F8(0x0008) (Const, Net)
	float                                              m_fBaseDamageReductionDebuff;                             // 0x0500(0x0004) (Const)
	float                                              r_fAdditionalDamageReductionDebuff;                       // 0x0504(0x0004) (Net)
	float                                              s_fMaxAdditionalDamageReductionDebuff;                    // 0x0508(0x0004) (Const, Config)
	float                                              s_fAdditionalDamageReductionDebuffStep;                   // 0x050C(0x0004) (Const, Config)
	float                                              s_fA04DamageReductionModifier;                            // 0x0510(0x0004) (Const, Config)
	float                                              s_fConePullbackDistance;                                  // 0x0514(0x0004) (Const, Config)
	float                                              r_fMaxAdditionalDamageReductionDebuff;                    // 0x0518(0x0004) (Const, Net)
	float                                              r_fAdditionalDamageReductionDebuffStep;                   // 0x051C(0x0004) (Const, Net)
	float                                              r_fA04DamageReductionModifier;                            // 0x0520(0x0004) (Const, Net)
	float                                              r_fConePullbackDistance;                                  // 0x0524(0x0004) (Const, Net)
	int                                                m_nManagedDebuffSituationalType;                          // 0x0528(0x0004) (Const)
	class UTgDeviceFire*                               s_firemodeUltCached;                                      // 0x052C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_A01");
		return ptr;
	}


	void STATIC_RemoveManagedDebuff(class AActor* Target);
	void ApplyManagedDebuff(class AActor* Target);
	void STATIC_IncreaseAdditionalDamageReductionDebuff(int nCount);
	void DeliverQueuedPendingHits();
	class UTgDeviceFire* STATIC_GetCurrentFire();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool IsLockedDown();
	bool STATIC_ShouldUpdateTimer();
	unsigned char STATIC_IncrementFiringInstance();
	bool STATIC_HasBeenTrained();
	int STATIC_GetAllocatedDevicePoints(bool bForceBasePoints);
	int STATIC_GetTotalDevicePoints();
	bool IsDeviceCoolingDown();
	bool STATIC_ShouldUseSurrogateDevice();
	class ATgDevice* STATIC_GetSurrogateDevice();
	float STATIC_GetDamageReductionDebuff();
	float STATIC_GetConePullbackDistance();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void STATIC_CacheConfigValues();
};


// Class TgGame.TgDevice_Depthzy_A03_Sub
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Depthzy_A03_Sub : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_A03_Sub");
		return ptr;
	}

};


// Class TgGame.TgDevice_Depthzy_B01
// 0x005C (0x054C - 0x04F0)
class ATgDevice_Depthzy_B01 : public ATgDevice
{
public:
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x04F0(0x0008) (Net)
	class UTgDeviceForm_Depthzy_B01*                   c_formB01;                                                // 0x04F8(0x0008)
	TArray<struct FMultiHitInfo>                       s_multiHitTargets;                                        // 0x0500(0x0010) (NeedCtorLink)
	int                                                m_nTargetPruneThreshold;                                  // 0x0510(0x0004) (Const)
	float                                              s_fLateralOffset;                                         // 0x0514(0x0004) (Const, Config)
	float                                              s_fRotationAngle;                                         // 0x0518(0x0004) (Const, Config)
	float                                              s_fCenterForwardOffset;                                   // 0x051C(0x0004) (Const, Config)
	float                                              s_fLeftForwardOffset;                                     // 0x0520(0x0004) (Const, Config)
	float                                              s_fRightForwardOffset;                                    // 0x0524(0x0004) (Const, Config)
	float                                              s_fLeftRange;                                             // 0x0528(0x0004) (Const, Config)
	float                                              s_fRightRange;                                            // 0x052C(0x0004) (Const, Config)
	float                                              r_fLateralOffset;                                         // 0x0530(0x0004) (Const, Net)
	float                                              r_fRotationAngle;                                         // 0x0534(0x0004) (Const, Net)
	float                                              r_fCenterForwardOffset;                                   // 0x0538(0x0004) (Const, Net)
	float                                              r_fLeftForwardOffset;                                     // 0x053C(0x0004) (Const, Net)
	float                                              r_fRightForwardOffset;                                    // 0x0540(0x0004) (Const, Net)
	float                                              r_fLeftRange;                                             // 0x0544(0x0004) (Const, Net)
	float                                              r_fRightRange;                                            // 0x0548(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_B01");
		return ptr;
	}


	struct FVector STATIC_GetRotatedVector(float fRotationAngle, struct FVector* vInVector);
	void STATIC_GetRightAim(struct FAimData* Aim);
	void STATIC_GetLeftAim(struct FAimData* Aim);
	void STATIC_GetCenterAim(struct FAimData* Aim);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void STATIC_PruneProjHitTargets(int nFiringInstanceThreshold);
	bool STATIC_HasPreviouslyHitProjTarget(class AActor* ATarget, int nFiringInstance);
	void AddUniqueProjHitTarget(class AActor* ATarget, int nFiringInstance);
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	int STATIC_GetTotalDevicePoints();
	void TickTargetingMode(float DeltaSeconds);
};


// Class TgGame.TgDevice_Depthzy_B03
// 0x002C (0x051C - 0x04F0)
class ATgDevice_Depthzy_B03 : public ATgDevice
{
public:
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x04F0(0x0008) (Net)
	float                                              s_fHealthThreshold;                                       // 0x04F8(0x0004) (Const, Config)
	float                                              s_fMaxHealthSacrificePct;                                 // 0x04FC(0x0004) (Const, Config)
	float                                              s_fRemainingHealthSacrificePct;                           // 0x0500(0x0004) (Const, Config)
	float                                              r_fHealthThreshold;                                       // 0x0504(0x0004) (Const, Net)
	float                                              r_fMaxHealthSacrificePct;                                 // 0x0508(0x0004) (Const, Net)
	float                                              r_fRemainingHealthSacrificePct;                           // 0x050C(0x0004) (Const, Net)
	int                                                m_nGreaterEffectSituationalType;                          // 0x0510(0x0004) (Const)
	int                                                m_nLesserEffectSituationalType;                           // 0x0514(0x0004) (Const)
	unsigned long                                      m_bUseGreaterEffect : 1;                                  // 0x0518(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_B03");
		return ptr;
	}


	void DeviceConsumePowerPool(unsigned char FireModeNum);
	void DeliverQueuedPendingHits();
	bool IsTargetingModeReady(TEnumAsByte<EDeviceFailType>* failType);
	int STATIC_GetTotalDevicePoints();
};


// Class TgGame.TgDevice_Depthzy_A02
// 0x0024 (0x0518 - 0x04F4)
class ATgDevice_Depthzy_A02 : public ATgDevice_Toggle
{
public:
	struct FPointer                                    VfTable_ITgDeviceSurrogateInterface;                      // 0x04F4(0x0008) (Const, Native, NoExport)
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x04FC(0x0008) (Net)
	float                                              m_fMaxRadius;                                             // 0x0504(0x0004) (Const)
	float                                              m_fMinRadius;                                             // 0x0508(0x0004) (Const)
	float                                              m_fPersistTime;                                           // 0x050C(0x0004) (Const)
	float                                              m_fPulseTime;                                             // 0x0510(0x0004) (Const)
	unsigned long                                      m_bRightClickCanceled : 1;                                // 0x0514(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_A02");
		return ptr;
	}


	bool CanBeCanceled();
	void InterruptWithoutNotifyingClient();
	void STATIC_HandleInterrupt();
	void STATIC_ClientInterrupt();
	void InterruptFiring();
	bool ShouldInterruptInhand();
	bool CanBeCanceledByRightMouse();
	void STATIC_DeployableMaxChannelDistReached();
	class UTgDeviceFire* STATIC_GetCurrentFire();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool IsLockedDown();
	bool STATIC_ShouldUpdateTimer();
	unsigned char STATIC_IncrementFiringInstance();
	bool STATIC_HasBeenTrained();
	int STATIC_GetAllocatedDevicePoints(bool bForceBasePoints);
	int STATIC_GetTotalDevicePoints();
	bool IsDeviceCoolingDown();
	bool STATIC_ShouldUseSurrogateDevice();
	class ATgDevice* STATIC_GetSurrogateDevice();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
};


// Class TgGame.TgDevice_Depthzy_A04
// 0x0020 (0x0514 - 0x04F4)
class ATgDevice_Depthzy_A04 : public ATgDevice_Toggle
{
public:
	class ATgPawn_Depthzy*                             r_depthzy;                                                // 0x04F4(0x0008) (Net)
	TArray<class ATgDevice*>                           m_deviceDependents;                                       // 0x04FC(0x0010) (NeedCtorLink)
	unsigned long                                      m_bWaitingToEndFiring : 1;                                // 0x050C(0x0004)
	int                                                m_nTimeoutSituationalType;                                // 0x0510(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Depthzy_A04");
		return ptr;
	}


	bool CanBeCanceled();
	bool CanBeCanceledByRightMouse();
	void STATIC_RemoveTimeoutIcon();
	void ApplyTimeoutIcon();
	void EndFiring();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	bool STATIC_CanBeSilenced();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	void ApplyInitialAoe();
};


// Class TgGame.TgDeviceFire_Depthzy_B03
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Depthzy_B03 : public UTgDeviceFire_Deploy
{
public:
	float                                              m_fMaxDamageFalloff;                                      // 0x01C0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Depthzy_B03");
		return ptr;
	}


	void AddEffectiveRangeReduction(class AActor* DamageInstigator, const struct FVector& originLocation, bool bUseRadius, struct FImpactInfo* Impact);
};


// Class TgGame.TgDeviceForm_Depthzy_A03
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Depthzy_A03 : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Depthzy_A03");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Depthzy_B01
// 0x0000 (0x0258 - 0x0258)
class UTgDeviceForm_Depthzy_B01 : public UTgDeviceForm_MultiTargeters
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Depthzy_B01");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Depthzy_Base
// 0x0008 (0x0118 - 0x0110)
class UTgEffectForm_Depthzy_Base : public UTgEffectForm
{
public:
	class ATgPawn_Depthzy*                             m_depthzyInstigator;                                      // 0x0110(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Depthzy_Base");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Depthzy_A04
// 0x0018 (0x0130 - 0x0118)
class UTgEffectForm_Depthzy_A04 : public UTgEffectForm_Depthzy_Base
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0118(0x0008) (Const, Native, NoExport)
	float                                              m_fMeshScaleMax;                                          // 0x0120(0x0004) (Const)
	float                                              m_fMeshScaleIntroDuration;                                // 0x0124(0x0004) (Const)
	float                                              m_fStartTime;                                             // 0x0128(0x0004) (Const)
	float                                              m_fMeshScaleCurrent;                                      // 0x012C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Depthzy_A04");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Depthzy_IState
// 0x00A0 (0x01B8 - 0x0118)
class UTgEffectForm_Depthzy_IState : public UTgEffectForm_Depthzy_Base
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0118(0x0008) (Const, Native, NoExport)
	TArray<class ATgSkeletalMeshActorSpawnable_DepthzyIStateMesh*> m_meshes;                                                 // 0x0120(0x0010) (NeedCtorLink)
	class UTgMapTracker_Depthzy_IState*                m_mapTrackerIState;                                       // 0x0130(0x0008) (Const)
	class UTgMeshPool_Depthzy_IState*                  m_meshPoolIState;                                         // 0x0138(0x0008) (Const)
	struct FLinearValueRange                           m_lvrEyeZOffset;                                          // 0x0140(0x0008) (Const)
	struct FLinearValueRange                           m_lvrEyeScale;                                            // 0x0148(0x0008) (Const)
	struct FLinearValueRange                           m_lvrPlayAreaTentacleZOffset;                             // 0x0150(0x0008) (Const)
	struct FLinearValueRange                           m_lvrPlayAreaTentaclePitch;                               // 0x0158(0x0008) (Const)
	struct FLinearValueRange                           m_lvrWallTentaclePitch;                                   // 0x0160(0x0008) (Const)
	float                                              m_fOpacityTransitionTime;                                 // 0x0168(0x0004) (Const)
	float                                              m_fGroundZ;                                               // 0x016C(0x0004) (Const)
	float                                              m_fVisionRange;                                           // 0x0170(0x0004) (Const)
	float                                              m_fVisionRangeSq;                                         // 0x0174(0x0004) (Const)
	float                                              m_fMaxDuration;                                           // 0x0178(0x0004) (Const)
	float                                              m_fActiveTimeRemaining;                                   // 0x017C(0x0004)
	unsigned long                                      m_bActive : 1;                                            // 0x0180(0x0004)
	int                                                c_nLoopingSoundFxId;                                      // 0x0184(0x0004) (Const)
	int                                                c_nRandomSoundsFxId;                                      // 0x0188(0x0004) (Const)
	struct FLinearValueRange                           m_lvrRandomSoundRadius;                                   // 0x018C(0x0008) (Const)
	struct FLinearValueRange                           m_lvrRandomSoundAngle;                                    // 0x0194(0x0008) (Const)
	struct FLinearValueRange                           m_lvrRandomSoundTime;                                     // 0x019C(0x0008) (Const)
	float                                              m_fRandomSoundCooldown;                                   // 0x01A4(0x0004) (Const)
	class UTgSpecialFx*                                c_fxRandomSounds;                                         // 0x01A8(0x0008)
	struct FName                                       c_nmPlayRandomSoundFx;                                    // 0x01B0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Depthzy_IState");
		return ptr;
	}


	void STATIC_PlayRandomSoundFx();
	void STATIC_HideEffectForm();
	void STATIC_RefreshEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
};


// Class TgGame.TgEffectForm_Depthzy_SBreak
// 0x001D (0x0135 - 0x0118)
class UTgEffectForm_Depthzy_SBreak : public UTgEffectForm_Depthzy_Base
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0118(0x0008) (Const, Native, NoExport)
	struct FName                                       m_nmSanityBreak;                                          // 0x0120(0x0008) (Const)
	float                                              m_fRampTime;                                              // 0x0128(0x0004) (Const)
	float                                              m_fRampStep;                                              // 0x012C(0x0004) (Const)
	float                                              m_fSanityBreakStrength;                                   // 0x0130(0x0004)
	TEnumAsByte<ESBreakMicState>                       c_eMicState;                                              // 0x0134(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Depthzy_SBreak");
		return ptr;
	}


	void STATIC_RemoveSanityBreakMic();
	void ApplySanityBreakMic();
};


// Class TgGame.TgEffectForm_Depthzy_TStacks
// 0x002E (0x0140 - 0x0112)
class UTgEffectForm_Depthzy_TStacks : public UTgEffectForm_Stacks
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x0112(0x0002) MISSED OFFSET
	TArray<struct FFx_PSC>                             c_pscStackList;                                           // 0x0114(0x0010) (Component, NeedCtorLink)
	TArray<struct FFx_Sound>                           c_soundStackList;                                         // 0x0124(0x0010) (Component, NeedCtorLink)
	class UTgSpecialFx*                                c_fxStack;                                                // 0x0134(0x0008)
	int                                                c_nPersistentFxId;                                        // 0x013C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Depthzy_TStacks");
		return ptr;
	}


	void STATIC_SetCurrentStacks(unsigned char nStacks);
};


// Class TgGame.TgInventoryObject_Listen_Depthzy_TStacks
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Depthzy_TStacks : public UTgInventoryObject_Listen
{
public:
	class ATgPawn_Depthzy*                             s_depthzy;                                                // 0x00D0(0x0008) (Const)
	class ATgDevice_Depthzy_Psv*                       s_devPsv;                                                 // 0x00D8(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Depthzy_TStacks");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Depthzy_A01
// 0x0004 (0x00E4 - 0x00E0)
class UTgInventoryObject_Listen_Depthzy_A01 : public UTgInventoryObject_Listen_Depthzy_TStacks
{
public:
	int                                                m_nFearSituationalType;                                   // 0x00E0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Depthzy_A01");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Depthzy_A03_Sub
// 0x0000 (0x00E0 - 0x00E0)
class UTgInventoryObject_Listen_Depthzy_A03_Sub : public UTgInventoryObject_Listen_Depthzy_TStacks
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Depthzy_A03_Sub");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Depthzy_Auto
// 0x0000 (0x00E0 - 0x00E0)
class UTgInventoryObject_Listen_Depthzy_Auto : public UTgInventoryObject_Listen_Depthzy_TStacks
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Depthzy_Auto");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Effect_Depthzy_A01
// 0x0014 (0x00F8 - 0x00E4)
class UTgInventoryObject_Listen_Effect_Depthzy_A01 : public UTgInventoryObject_Listen_Effect
{
public:
	class ATgPawn_Depthzy*                             s_depthzy;                                                // 0x00E4(0x0008) (Const)
	class ATgDevice_Depthzy_A01*                       s_devA01;                                                 // 0x00EC(0x0008) (Const)
	float                                              s_fReducedDamageVsDepthzyPct;                             // 0x00F4(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_Depthzy_A01");
		return ptr;
	}


	void STATIC_OnAppliedAsListener();
};


// Class TgGame.TgInventoryObject_Listen_Effect_Depthzy_Psv
// 0x0018 (0x00FC - 0x00E4)
class UTgInventoryObject_Listen_Effect_Depthzy_Psv : public UTgInventoryObject_Listen_Effect
{
public:
	class ATgDevice_Depthzy_Psv*                       s_devPsv;                                                 // 0x00E4(0x0008)
	class ATgCollisionProxy*                           s_collisionAura;                                          // 0x00EC(0x0008) (Const)
	class AActor*                                      s_aTarget;                                                // 0x00F4(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_Depthzy_Psv");
		return ptr;
	}


	void STATIC_OnRemovedAsListener();
	void STATIC_OnAppliedAsListener();
};


// Class TgGame.TgMapTracker_Depthzy_IState
// 0x4E74 (0x4ED4 - 0x0060)
class UTgMapTracker_Depthzy_IState : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	class ATgPawn_Depthzy*                             m_depthzy;                                                // 0x0068(0x0008) (Const)
	float                                              m_fPlacementRadius;                                       // 0x0070(0x0004) (Const)
	float                                              m_fWallCheckRadius;                                       // 0x0074(0x0004) (Const)
	float                                              m_fSeparationRadius;                                      // 0x0078(0x0004) (Const)
	int                                                m_nRepeatCount;                                           // 0x007C(0x0004) (Const)
	int                                                m_nStartingPolygonNum;                                    // 0x0080(0x0004) (Const)
	int                                                m_nSkippedIndexCount;                                     // 0x0084(0x0004) (Const)
	struct FVector2D                                   m_fMapLocations[0x7D0];                                   // 0x0088(0x0008) (Const, Native)
	unsigned char                                      m_byCompressedMapYaws[0x7D0];                             // 0x3F08(0x0001) (Const, Native)
	unsigned char                                      m_byCompressedMapRolls[0x7D0];                            // 0x46D8(0x0001) (Const, Native)
	struct FBitArray_Mirror                            m_byMapFlags;                                             // 0x4EA8(0x0020) (Const, Native)
	int                                                m_nMaxRadialIdx;                                          // 0x4EC8(0x0004)
	int                                                m_nCurrentInitializationIdx;                              // 0x4ECC(0x0004)
	unsigned long                                      m_bInitializationComplete : 1;                            // 0x4ED0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMapTracker_Depthzy_IState");
		return ptr;
	}


	void STATIC_Initialize(class ATgPawn_Depthzy* depthzyInstigator);
};


// Class TgGame.TgMeshPool_Depthzy_IState
// 0x0000 (0x0094 - 0x0094)
class UTgMeshPool_Depthzy_IState : public UTgMeshPool
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMeshPool_Depthzy_IState");
		return ptr;
	}

};


// Class TgGame.TgPawn_Depthzy
// 0x0124 (0x2708 - 0x25E4)
class ATgPawn_Depthzy : public ATgPawn_MeshSwapper
{
public:
	class ATgDevice_Depthzy_Auto*                      m_devAuto;                                                // 0x25E4(0x0008)
	class ATgDevice_Depthzy_Psv*                       m_devPsv;                                                 // 0x25EC(0x0008)
	class ATgDevice_Depthzy_A01*                       m_devA01;                                                 // 0x25F4(0x0008)
	class ATgDevice_Depthzy_A02*                       m_devA02;                                                 // 0x25FC(0x0008)
	class ATgDevice_Depthzy_A03*                       m_devA03;                                                 // 0x2604(0x0008)
	class ATgDevice_Depthzy_A03_Sub*                   m_devA03Sub;                                              // 0x260C(0x0008)
	class ATgDevice_Depthzy_A04*                       m_devA04;                                                 // 0x2614(0x0008)
	class ATgDevice_Depthzy_A04_Sub*                   m_devA04Sub;                                              // 0x261C(0x0008)
	class ATgDevice_Depthzy_B01*                       m_devB01;                                                 // 0x2624(0x0008)
	class ATgDevice_Depthzy_B02*                       m_devB02;                                                 // 0x262C(0x0008)
	class ATgDevice_Depthzy_B03*                       m_devB03;                                                 // 0x2634(0x0008)
	unsigned long                                      m_bDevicesPrecached : 1;                                  // 0x263C(0x0004) (Const)
	unsigned long                                      r_bA02Channeling : 1;                                     // 0x263C(0x0004) (Net)
	unsigned long                                      r_bA02Interrupted : 1;                                    // 0x263C(0x0004) (Net)
	unsigned long                                      r_bA03Charging : 1;                                       // 0x263C(0x0004) (Net)
	unsigned long                                      r_bA03Interrupted : 1;                                    // 0x263C(0x0004) (Net)
	unsigned long                                      r_bA04StimActive : 1;                                     // 0x263C(0x0004) (Net)
	float                                              s_fFacingTowardAngle;                                     // 0x2640(0x0004) (Const, Config)
	float                                              s_fBaseHudHeight;                                         // 0x2644(0x0004) (Const, Config)
	float                                              r_fFacingTowardAngle;                                     // 0x2648(0x0004) (Const, Net)
	float                                              r_fBaseHudHeight;                                         // 0x264C(0x0004) (Const, Net)
	float                                              s_fOsirisA04HeightOffset[0x2];                            // 0x2650(0x0004) (Const, Config)
	float                                              r_fOsirisA04HeightOffset[0x2];                            // 0x2658(0x0004) (Const, Net)
	int                                                r_nPsvAuraStacks;                                         // 0x2660(0x0004) (Net)
	class UTgDepthzy_IStateMeshProcessor*              c_meshProcessor;                                          // 0x2664(0x0008)
	float                                              s_fA02IntroDuration;                                      // 0x266C(0x0004) (Const, Config)
	float                                              s_fA02OutroDuration;                                      // 0x2670(0x0004) (Const, Config)
	float                                              r_fA02IntroDuration;                                      // 0x2674(0x0004) (Const, Net)
	float                                              r_fA02OutroDuration;                                      // 0x2678(0x0004) (Const, Net)
	struct FName                                       m_nmFireA02AmmunitionFx;                                  // 0x267C(0x0008) (Const)
	struct FName                                       m_nmA02PulseFireDisplayGroup;                             // 0x2684(0x0008) (Const)
	float                                              s_fA03IntroDuration;                                      // 0x268C(0x0004) (Const, Config)
	float                                              s_fA03OutroDuration;                                      // 0x2690(0x0004) (Const, Config)
	float                                              r_fA03IntroDuration;                                      // 0x2694(0x0004) (Const, Net)
	float                                              r_fA03OutroDuration;                                      // 0x2698(0x0004) (Const, Net)
	float                                              s_fA04StimIntroTime;                                      // 0x269C(0x0004) (Const, Config)
	float                                              s_fA04StimOutroTime;                                      // 0x26A0(0x0004) (Const, Config)
	float                                              s_fA04StimSwapInTime;                                     // 0x26A4(0x0004) (Const, Config)
	float                                              s_fA04MinPitchLimit;                                      // 0x26A8(0x0004) (Const, Config)
	float                                              s_fA04MaxPitchLimit;                                      // 0x26AC(0x0004) (Const, Config)
	float                                              s_fA04MaxRestrictedPitchLimit;                            // 0x26B0(0x0004) (Const, Config)
	float                                              s_fA04HudHeight;                                          // 0x26B4(0x0004) (Const, Config)
	float                                              s_fA04OwningClientHudHeight;                              // 0x26B8(0x0004) (Const, Config)
	float                                              s_fA04WaistFxOffset;                                      // 0x26BC(0x0004) (Const, Config)
	float                                              r_fA04StimIntroTime;                                      // 0x26C0(0x0004) (Const, Net)
	float                                              r_fA04StimOutroTime;                                      // 0x26C4(0x0004) (Const, Net)
	float                                              r_fA04StimSwapInTime;                                     // 0x26C8(0x0004) (Const, Net)
	float                                              r_fA04MinPitchLimit;                                      // 0x26CC(0x0004) (Const, Net)
	float                                              r_fA04MaxPitchLimit;                                      // 0x26D0(0x0004) (Const, Net)
	float                                              r_fA04MaxRestrictedPitchLimit;                            // 0x26D4(0x0004) (Const, Net)
	float                                              r_fA04HudHeight;                                          // 0x26D8(0x0004) (Const, Net)
	float                                              r_fA04OwningClientHudHeight;                              // 0x26DC(0x0004) (Const, Net)
	float                                              r_fA04WaistFxOffset;                                      // 0x26E0(0x0004) (Const, Net)
	int                                                m_nA04OutroSituationalType;                               // 0x26E4(0x0004) (Const)
	class UTgDeviceFire*                               s_firemodeA04Cached;                                      // 0x26E8(0x0008)
	TArray<struct FCachedParticleSystem>               c_cachedParticleSystemWaistOffsets;                       // 0x26F0(0x0010) (Component, NeedCtorLink)
	class USkelControlBase*                            c_skelControllerRootScale;                                // 0x2700(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Depthzy");
		return ptr;
	}


	void TurnOnDeadCamera();
	void TurnOnDepthzyDeadCamera();
	void STATIC_EndOutro();
	void STATIC_EndIntro();
	void STATIC_FireA02PulseWarningFx();
	bool DeviceOverrideLockedDown(class ATgDevice* Dev);
	void STATIC_CleanupA04OutroState();
	void STATIC_CleanupA04State();
	void STATIC_OnA04AuraUnTouch(class AActor* Other);
	void STATIC_OnA04AuraTouch(class AActor* Other);
	void UnforceClientUnrestrictedCameraPitch();
	void STATIC_ForceClientUnrestrictedCameraPitch();
	void UpdateExternalCameraOverrides(TEnumAsByte<EDepthzyMeshSwapStance> eCameraState);
	void TurnOffLargeCamera();
	void TurnOnLargeCamera();
	void ActivateA04IntroBurstFx();
	void DeactivateSkydomeFx();
	void ActivateSkydomeFx();
	void STATIC_ResetTargetingDevice();
	void STATIC_ClearTargetingDevice();
	void STATIC_HaltFiringDevices();
	void STATIC_SwapActiveIcon(TEnumAsByte<ETG_EQUIP_POINT> eqp, class ATgDevice* devActive, class ATgDevice* devInactive);
	void STATIC_DisableStimIcons();
	void STATIC_EnableStimIcons();
	void STATIC_SwapToLargeMesh();
	void STATIC_SwapToBaseMesh();
	void Transform();
	void STATIC_RemoveA04Stim(bool bInterrupted);
	void ApplyA04Stim();
	void STATIC_EndA03Charging(bool bInterrupted);
	void BeginA03Charging();
	void STATIC_EndA02Channeling(bool bInterrupted);
	void BeginA02Channeling();
	void UpdatePsvStacks();
	bool STATIC_HandleA03RightMouseCancel();
	bool STATIC_HandleA02RightMouseCancel();
	void STATIC_ServerOnRightMousePressed();
	void STATIC_OnRightMousePressed();
	void STATIC_EndDeviceFiring(class ATgDevice* Dev);
	void BecomeViewTarget(class APlayerController* PC);
	class UTgCameraModule_Depthzy* STATIC_GetDepthzyCamera();
	void TurnOnDepthzyCamera(bool bResetCamera);
	void STATIC_DebugFireDevice(int eEqPoint);
	void STATIC_PlayDying(class UClass* dmgType, const struct FVector& HitLoc);
	void STATIC_OnRespawn();
	void STATIC_OnPreRespawn();
	void TgPawnControllerSet();
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_RepairWaistFx();
	void STATIC_OffsetWaistFx();
	float STATIC_GetSoulRipHeightOffset();
	class UTgSkeletalMeshComponent* STATIC_GetSoulRipMesh();
	bool ApplyMicOverride(int nMatIndex, class UMeshComponent* meshExtra, int nStackIndexOverride, bool bForceApply);
	void STATIC_OnMeshSwapped();
	bool AreAnyOtherOffhandsLockingFiring(class ATgDevice* CurrentDevice);
	bool IsUlting();
	bool IsDeviceBType(class ATgDevice* Dev);
	bool IsAnyBDeviceFiring();
	bool IsTargetFacingDepthzy(class ATgPawn* PawnTarget);
	bool IsTargetInsane(class ATgPawn* PawnTarget);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	void STATIC_DeviceFormChanged(bool bForceReload);
	void DeviceOnStopFire(class ATgDevice* Dev, bool WasInterrupted);
	class UClass* STATIC_CreatePawnSpecificProcessor();
	bool UsesSinglePawnProcessor();
	void STATIC_ClientInitializeIStateResources();
	void STATIC_SetupParentOwnership(class ATgDevice* Parent, class ATgDevice* sub, bool bUsesParentFiringInstance);
	void UpdateClientDevices(bool bForce);
	void STATIC_CacheConfigValues();
};


// Class TgGame.TgProj_Depthzy_B01
// 0x0008 (0x03B4 - 0x03AC)
class ATgProj_Depthzy_B01 : public ATgProj_SimulatedPassThrough
{
public:
	class ATgDevice_Depthzy_B01*                       m_devB01;                                                 // 0x03AC(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Depthzy_B01");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_Depthzy_A03
// 0x0008 (0x03B4 - 0x03AC)
class ATgProj_Depthzy_A03 : public ATgProj_Simulated_RollingLineAttack
{
public:
	unsigned long                                      c_bHasInitializedCustomFilters : 1;                       // 0x03AC(0x0004)
	int                                                m_nCustomFilterOverride;                                  // 0x03B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Depthzy_A03");
		return ptr;
	}


	void STATIC_CompleteInitialization();
	void STATIC_SetCustomFilterOverride(int nCustomFilter);
};


// Class TgGame.TgSkeletalMeshActorSpawnable_DepthzyIStateMesh
// 0x0021 (0x033D - 0x031C)
class ATgSkeletalMeshActorSpawnable_DepthzyIStateMesh : public ATgSkeletalMeshActorSpawnable
{
public:
	int                                                m_nTentacleMeshIds[0x4];                                  // 0x031C(0x0004) (Const)
	class UTgSkeletalMeshComponent*                    m_meshComponent;                                          // 0x032C(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fOpacity;                                               // 0x0334(0x0004)
	int                                                m_nMapTrackerIndex;                                       // 0x0338(0x0004)
	TEnumAsByte<EDepthzyIStateMeshType>                m_eMeshType;                                              // 0x033C(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable_DepthzyIStateMesh");
		return ptr;
	}


	void STATIC_DestroyMesh();
	void STATIC_CreateMesh(class ATgPawn* PawnTarget, class ATgPawn* pawnInstigator, TEnumAsByte<EDepthzyIStateMeshType> EMeshType);
};


// Class TgGame.TgAchievement_Tsukuyomi_FullMoon
// 0x000C (0x0090 - 0x0084)
class UTgAchievement_Tsukuyomi_FullMoon : public UTgAchievement
{
public:
	int                                                m_nDashHitCount;                                          // 0x0084(0x0004)
	int                                                m_nDashHitNeeded;                                         // 0x0088(0x0004) (Const)
	int                                                m_nDeviceId;                                              // 0x008C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Tsukuyomi_FullMoon");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Tsukuyomi_WatchYourStep
// 0x0004 (0x0088 - 0x0084)
class UTgAchievement_Tsukuyomi_WatchYourStep : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                              // 0x0084(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Tsukuyomi_WatchYourStep");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Tsukuyomi_A03
// 0x0034 (0x042C - 0x03F8)
class ATgDeployable_Tsukuyomi_A03 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	class ATgPawn_Tsukuyomi*                           r_tsukuyomi;                                              // 0x0400(0x0008) (Const, Net)
	TArray<struct FMoveDamageInfo>                     m_trackers;                                               // 0x0408(0x0010) (NeedCtorLink)
	struct FVector                                     r_vFilterLocation;                                        // 0x0418(0x000C) (Const, Net)
	float                                              s_fDamageDistance;                                        // 0x0424(0x0004) (Const, Config)
	float                                              r_fDamageDistance;                                        // 0x0428(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Tsukuyomi_A03");
		return ptr;
	}


	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void STATIC_HandlePawnUnTouch(class ATgPawn* untouchedPawn);
	void STATIC_HandlePawnTouch(class ATgPawn* TouchedPawn, bool bSkipFilterCheck);
	void UpdateTrackerList();
	void STATIC_GetFilterList(TArray<class ATgPawn*>* filterPawnList);
};


// Class TgGame.TgDevice_Tsukuyomi_Inhand
// 0x0004 (0x053C - 0x0538)
class ATgDevice_Tsukuyomi_Inhand : public ATgDevice_ChainedMelee
{
public:
	int                                                m_nSecondaryDeviceType;                                   // 0x0538(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tsukuyomi_Inhand");
		return ptr;
	}


	void STATIC_FireAmmunition();
	int STATIC_GetMoonlightFireMode(int nMode);
	int CalculateNextMode(int CurrentMode);
	int GetBaseMode();
	int STATIC_GetCurrentDeviceType();
};


// Class TgGame.TgDevice_Tsukuyomi_A01
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_Tsukuyomi_A01 : public ATgDevice
{
public:
	class ATgPawn_Tsukuyomi*                           r_tsukuyomi;                                              // 0x04F0(0x0008) (Net)
	int                                                m_nReturnProjectileId;                                    // 0x04F8(0x0004) (Const)
	float                                              s_fCooldownReductionPct;                                  // 0x04FC(0x0004) (Const, Config)
	float                                              r_fCooldownReductionPct;                                  // 0x0500(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tsukuyomi_A01");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void NativeFireAmmunition();
	void STATIC_FireRecallingShuriken(class ATgPawn* PawnTarget);
	void TriggerCooldownReduction();
};


// Class TgGame.TgDevice_Tsukuyomi_A02
// 0x001C (0x050C - 0x04F0)
class ATgDevice_Tsukuyomi_A02 : public ATgDevice
{
public:
	class ATgPawn_Tsukuyomi*                           r_tsukuyomi;                                              // 0x04F0(0x0008) (Net)
	int                                                s_nMaxAttacks;                                            // 0x04F8(0x0004) (Const, Config)
	int                                                r_nMaxAttacks;                                            // 0x04FC(0x0004) (Const, Net)
	class ATgDevice*                                   m_devSub;                                                 // 0x0500(0x0008)
	int                                                m_nAttacksFired;                                          // 0x0508(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tsukuyomi_A02");
		return ptr;
	}


	void STATIC_FireAmmunition();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_NativeIsFiring();
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	class UTgDeviceFire* STATIC_GetCurrentFire();
};


// Class TgGame.TgDevice_Tsukuyomi_A03
// 0x0018 (0x0508 - 0x04F0)
class ATgDevice_Tsukuyomi_A03 : public ATgDevice
{
public:
	class ATgPawn_Tsukuyomi*                           r_tsukuyomi;                                              // 0x04F0(0x0008) (Net)
	float                                              s_fFilterOffset;                                          // 0x04F8(0x0004) (Const, Config)
	float                                              s_fFilterRadius;                                          // 0x04FC(0x0004) (Const, Config)
	float                                              r_fFilterOffset;                                          // 0x0500(0x0004) (Const, Net)
	float                                              r_fFilterRadius;                                          // 0x0504(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tsukuyomi_A03");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void STATIC_GetCachedAim(struct FAimData* Aim);
	void NativeFireAmmunition();
	void STATIC_GetFilterList(TArray<struct FImpactInfo>* filterImpactList);
};


// Class TgGame.TgDevice_Tsukuyomi_A04
// 0x0024 (0x0514 - 0x04F0)
class ATgDevice_Tsukuyomi_A04 : public ATgDevice
{
public:
	class ATgPawn_Tsukuyomi*                           r_tsukuyomi;                                              // 0x04F0(0x0008) (Net)
	class ATgDevice_Tsukuyomi_A04_Sub*                 m_deviceSub;                                              // 0x04F8(0x0008)
	int                                                m_nAttacksFired;                                          // 0x0500(0x0004)
	float                                              s_fRefireRate;                                            // 0x0504(0x0004) (Const, Config)
	float                                              s_nMaxAmmoCount;                                          // 0x0508(0x0004) (Const, Config)
	float                                              r_fRefireRate;                                            // 0x050C(0x0004) (Const, Net)
	float                                              r_nMaxAmmoCount;                                          // 0x0510(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tsukuyomi_A04");
		return ptr;
	}


	bool CanBeCanceled();
	void STATIC_FireAmmunition();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_NativeIsFiring();
	void STATIC_SetFireMode(int nFireModeNum, bool ForceSet);
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_HasEnoughPowerPool(unsigned char FireModeNum);
	void FireSubDevice();
};


// Class TgGame.TgDevice_Tsukuyomi_A04_Sub
// 0x004C (0x053C - 0x04F0)
class ATgDevice_Tsukuyomi_A04_Sub : public ATgDevice
{
public:
	TArray<class ATgPawn*>                             s_pawnTargetGods;                                         // 0x04F0(0x0010) (NeedCtorLink)
	TArray<int>                                        m_nInvalidTargetCategories;                               // 0x0500(0x0010) (NeedCtorLink)
	class ATgPawn_Tsukuyomi*                           r_tsukuyomi;                                              // 0x0510(0x0008) (Net)
	float                                              s_fMinTargetCountTweenTime;                               // 0x0518(0x0004) (Const, Config)
	float                                              s_fMaxTargetCountTweenTime;                               // 0x051C(0x0004) (Const, Config)
	float                                              s_fEndFireLoopDelay;                                      // 0x0520(0x0004) (Const, Config)
	float                                              r_fMinTargetCountTweenTime;                               // 0x0524(0x0004) (Const, Net)
	float                                              r_fMaxTargetCountTweenTime;                               // 0x0528(0x0004) (Const, Net)
	float                                              r_fEndFireLoopDelay;                                      // 0x052C(0x0004) (Const, Net)
	float                                              m_fTweenTime;                                             // 0x0530(0x0004)
	int                                                m_nMaxTargets;                                            // 0x0534(0x0004)
	unsigned long                                      r_bHasValidTweenTargets : 1;                              // 0x0538(0x0004) (Net)
	unsigned long                                      s_bHasHitCurrentTweenTarget : 1;                          // 0x0538(0x0004)
	unsigned long                                      s_bCurrentTargetValid : 1;                                // 0x0538(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tsukuyomi_A04_Sub");
		return ptr;
	}


	void STATIC_DelayedEndFireLoop();
	bool StartFire();
	void STATIC_CustomFire();
	void UseDevice();
	float STATIC_GetFiringPostHitDelay(int nMode);
	float STATIC_GetFiringPreHitDelay(int nMode);
	void STATIC_CalcTweenTime();
	void STATIC_ConsumeTweenTarget();
	void STATIC_FireTweenHit();
	bool ValidateCurrentTarget();
	bool IsTouchingTweenTarget();
	void STATIC_FireTargetTween();
};


// Class TgGame.TgDeviceFire_Tsukuyomi_A02
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Tsukuyomi_A02 : public UTgDeviceFire
{
public:
	class ATgDevice_Tsukuyomi_A02*                     m_a02;                                                    // 0x01C0(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Tsukuyomi_A02");
		return ptr;
	}


	float GetConeAttackAngleOffset();
};


// Class TgGame.TgDeviceFire_Tsukuyomi_Inhand
// 0x001C (0x01DC - 0x01C0)
class UTgDeviceFire_Tsukuyomi_Inhand : public UTgDeviceFire
{
public:
	class ATgPawn_Tsukuyomi*                           m_tsukuyomi;                                              // 0x01C0(0x0008) (Const)
	int                                                m_nPsvBuffSituationalType;                                // 0x01C8(0x0004) (Const)
	int                                                m_nPsvMoonlightSituationalType;                           // 0x01CC(0x0004) (Const)
	int                                                m_nPsvBuffCategoryCode;                                   // 0x01D0(0x0004) (Const)
	int                                                m_nPsvMoonlightCategoryCode;                              // 0x01D4(0x0004) (Const)
	int                                                m_nLastPsvBonusFiringInstance;                            // 0x01D8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Tsukuyomi_Inhand");
		return ptr;
	}


	bool STATIC_HasPsvMoonlight();
	void STATIC_RemoveMoonlight();
	void ApplyMoonlight();
};


// Class TgGame.TgDeviceFire_Tsukuyomi_Inhand_A
// 0x0000 (0x01DC - 0x01DC)
class UTgDeviceFire_Tsukuyomi_Inhand_A : public UTgDeviceFire_Tsukuyomi_Inhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Tsukuyomi_Inhand_A");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcConeFire(class AActor* DamageInstigator, const struct FAimData& Aim, bool bUseRange, bool bPredicting, TArray<struct FImpactInfo>* ImpactList);
	bool IsMeleeAttack();
};


// Class TgGame.TgDeviceFire_Tsukuyomi_Inhand_B
// 0x0000 (0x01DC - 0x01DC)
class UTgDeviceFire_Tsukuyomi_Inhand_B : public UTgDeviceFire_Tsukuyomi_Inhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Tsukuyomi_Inhand_B");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Tsukuyomi_Inhand
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Tsukuyomi_Inhand : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Tsukuyomi_Inhand");
		return ptr;
	}


	bool UsesTargetingMode();
	void STATIC_SetFireMode(int nMode);
};


// Class TgGame.TgEffectForm_Tsukuyomi_A01
// 0x000C (0x011C - 0x0110)
class UTgEffectForm_Tsukuyomi_A01 : public UTgEffectForm
{
public:
	class UMeshComponent*                              m_meshAttached;                                           // 0x0110(0x0008) (ExportObject, Component, EditInline)
	int                                                m_nMeshId;                                                // 0x0118(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Tsukuyomi_A01");
		return ptr;
	}


	void STATIC_DetachMeshes();
	void AttachMeshes(class AActor* pOwner);
	void AdjustHidden();
	void Detach();
	void STATIC_Reattach();
	void Attach(class AActor* pOwner);
	void STATIC_HideEffectForm();
	void STATIC_ShowEffectForm(bool bLocal);
	void STATIC_RecalculateFx();
};


// Class TgGame.TgInventoryObject_Listen_Effect_Tsukuyomi_A01
// 0x0020 (0x0104 - 0x00E4)
class UTgInventoryObject_Listen_Effect_Tsukuyomi_A01 : public UTgInventoryObject_Listen_Effect
{
public:
	float                                              s_fTriggerShurikenRecallDist;                             // 0x00E4(0x0004) (Const, Config)
	float                                              s_fTriggerShurikenRecallDistSq;                           // 0x00E8(0x0004) (Const)
	class ATgDevice_Tsukuyomi_A01*                     s_devA01;                                                 // 0x00EC(0x0008)
	class ATgPawn_Tsukuyomi*                           s_tsukuyomi;                                              // 0x00F4(0x0008)
	class ATgPawn*                                     s_pawnTarget;                                             // 0x00FC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_Tsukuyomi_A01");
		return ptr;
	}


	void STATIC_OnAppliedAsListener();
};


// Class TgGame.TgInventoryObject_Listen_Tsukuyomi_A04_Sub
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Tsukuyomi_A04_Sub : public UTgInventoryObject_Listen
{
public:
	class ATgPawn_Tsukuyomi*                           s_tsukuyomi;                                              // 0x00D0(0x0008)
	class ATgDevice_Tsukuyomi_A04_Sub*                 s_deviceSub;                                              // 0x00D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Tsukuyomi_A04_Sub");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Tsukuyomi_Inhand
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Tsukuyomi_Inhand : public UTgInventoryObject_Listen
{
public:
	float                                              s_fCleaveDamageReduction;                                 // 0x00D0(0x0004) (Const, Config)
	int                                                s_nHitFiringInstance;                                     // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Tsukuyomi_Inhand");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Tsukuyomi_Psv
// 0x0010 (0x00E0 - 0x00D0)
class UTgInventoryObject_Listen_Tsukuyomi_Psv : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_Tsukuyomi_Inhand*                  m_devInhand;                                              // 0x00D0(0x0008)
	class ATgDevice_Tsukuyomi_A04*                     m_devA04;                                                 // 0x00D8(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Tsukuyomi_Psv");
		return ptr;
	}

};


// Class TgGame.TgMeshPool_Tsukuyomi
// 0x0000 (0x0094 - 0x0094)
class UTgMeshPool_Tsukuyomi : public UTgMeshPool
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMeshPool_Tsukuyomi");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tsukuyomi
// 0x0099 (0x2651 - 0x25B8)
class ATgPawn_Tsukuyomi : public ATgPawn_Character
{
public:
	class ATgDevice_Tsukuyomi_Inhand*                  m_devInhand;                                              // 0x25B8(0x0008)
	class ATgDevice*                                   m_devPsv;                                                 // 0x25C0(0x0008)
	class ATgDevice_Tsukuyomi_A01*                     m_devA01;                                                 // 0x25C8(0x0008)
	class ATgDevice_Tsukuyomi_A02*                     m_devA02;                                                 // 0x25D0(0x0008)
	class ATgDevice*                                   m_devA02Sub;                                              // 0x25D8(0x0008)
	class ATgDevice_Tsukuyomi_A03*                     m_devA03;                                                 // 0x25E0(0x0008)
	class ATgDevice_Tsukuyomi_A04*                     m_devA04;                                                 // 0x25E8(0x0008)
	class ATgDevice_Tsukuyomi_A04_Sub*                 m_devA04Sub;                                              // 0x25F0(0x0008)
	unsigned long                                      m_bDevicesCached : 1;                                     // 0x25F8(0x0004) (Const)
	unsigned long                                      r_bShingetsuBuffActive : 1;                               // 0x25F8(0x0004) (Net)
	unsigned long                                      r_bMangetsuBuffActive : 1;                                // 0x25F8(0x0004) (Net)
	unsigned long                                      r_bDarkMoonlightActive : 1;                               // 0x25F8(0x0004) (Net)
	unsigned long                                      r_bWhiteMoonlightActive : 1;                              // 0x25F8(0x0004) (Net)
	unsigned long                                      c_bDarkMoonlightActive : 1;                               // 0x25F8(0x0004)
	unsigned long                                      c_bWhiteMoonlightActive : 1;                              // 0x25F8(0x0004)
	unsigned long                                      r_bUltimatePostureActive : 1;                             // 0x25F8(0x0004) (Net)
	class UTgEffectTransitions*                        c_effectTransitions;                                      // 0x25FC(0x0008)
	class UTgDeviceForm_Tsukuyomi_Inhand*              c_deviceFormInhand;                                       // 0x2604(0x0008)
	int                                                m_nDarkMoonlightFireMode;                                 // 0x260C(0x0004) (Const)
	int                                                m_nWhiteMoonlightFireMode;                                // 0x2610(0x0004) (Const)
	float                                              s_fTweenTargetOvershootScalar;                            // 0x2614(0x0004) (Const, Config)
	float                                              r_fTweenTargetOvershootScalar;                            // 0x2618(0x0004) (Const, Net)
	class UTgMeshPool_Tsukuyomi*                       c_meshPool;                                               // 0x261C(0x0008)
	class AActor*                                      r_cloneActivationTarget;                                  // 0x2624(0x0008) (Net)
	struct FVector                                     m_vPrevTweenDirection;                                    // 0x262C(0x000C)
	int                                                m_nNumClones;                                             // 0x2638(0x0004) (Const)
	float                                              s_fCloneSpawnTime;                                        // 0x263C(0x0004) (Const, Config)
	float                                              s_fClonePersistTime;                                      // 0x2640(0x0004) (Const, Config)
	float                                              r_fCloneSpawnTime;                                        // 0x2644(0x0004) (Const, Net)
	float                                              r_fClonePersistTime;                                      // 0x2648(0x0004) (Const, Net)
	int                                                c_nUltimatePostureId;                                     // 0x264C(0x0004)
	TEnumAsByte<ETG_POSTURE>                           c_eUltimatePosture;                                       // 0x2650(0x0001) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tsukuyomi");
		return ptr;
	}


	void STATIC_EndUltPosture();
	void BeginUltPosture();
	struct FVector GetPhysTweenTargetLocation();
	void STATIC_EndTween(TEnumAsByte<ETweenState> endingTweenState, bool bInterrupted);
	void BeginTween(TEnumAsByte<ETweenState> newTweenState);
	void ActivateUltClone();
	bool IsInClassSpecificChannel();
	void STATIC_OnDeviceFormStartFire(int nEquipSlot, float FireDuration, int nFireMode);
	bool PostPawnSetup();
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_ProcessA04PhysTweening(float fMaxAccel, float fMaxSpeed, struct FVector* vTargetLocation);
	bool STATIC_DeviceOnCanDeviceFireNow(class ATgDevice* Dev, unsigned char FireModeNum, bool bDeviceFailLog, struct FAimData* Aim);
	struct FVector STATIC_CalcTsukuyomiUltTweenTargetLoc();
	void STATIC_InitializeMeshPool();
	bool STATIC_GetPassiveInt2(int* nResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool STATIC_GetPassiveFloat1(float* fResult);
	bool STATIC_GetPassiveBool(int* bResult);
	void UpdateInhandDeviceForm();
	void UpdateMangetsuBuffMaterials();
	void UpdateShingetsuBuffMaterials();
	bool STATIC_ShouldAllowOffhandFireLock();
	void STATIC_PawnOnDied(class AController* pKilller);
	void STATIC_CacheConfigValues();
	void STATIC_InitializeEffectTransitions();
	void UpdateClientDevices(bool bForce);
};


// Class TgGame.TgProj_Tsukuyomi_A01
// 0x0008 (0x03B4 - 0x03AC)
class ATgProj_Tsukuyomi_A01 : public ATgProj_SimulatedPassThroughUntilGod_CollidesWorld
{
public:
	class ATgPawn_Tsukuyomi*                           s_tsukuyomi;                                              // 0x03AC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Tsukuyomi_A01");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshActorSpawnable_TsukuyomiClone
// 0x0020 (0x033C - 0x031C)
class ATgSkeletalMeshActorSpawnable_TsukuyomiClone : public ATgSkeletalMeshActorSpawnable
{
public:
	int                                                c_nMeshId;                                                // 0x031C(0x0004) (Const)
	class UTgMeshPool_Tsukuyomi*                       c_meshPool;                                               // 0x0320(0x0008)
	class UTgSkeletalMeshComponent*                    c_CloneMesh;                                              // 0x0328(0x0008) (ExportObject, Component, EditInline)
	class UTgAnimNodeSlot*                             c_FullBodyAnimNode;                                       // 0x0330(0x0008)
	unsigned long                                      c_bActive : 1;                                            // 0x0338(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable_TsukuyomiClone");
		return ptr;
	}


	void STATIC_Deactivate();
	void Activate(const struct FVector& vSpawnLoc, const struct FRotator& rSpawnRotation, float fActiveTime);
	void STATIC_CreateCloneMesh(class ATgPawn* PawnOwner, class UTgMeshPool_Tsukuyomi* MeshPool);
};


// Class TgGame.TgAchievement_Danzaburou_FortuitousInvestment
// 0x0008 (0x008C - 0x0084)
class UTgAchievement_Danzaburou_FortuitousInvestment : public UTgAchievement
{
public:
	class ATgDevice_Danzaburou_PSV*                    m_devPsv;                                                 // 0x0084(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Danzaburou_FortuitousInvestment");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Danzaburou_TheBestSakeMerchant
// 0x001C (0x00A0 - 0x0084)
class UTgAchievement_Danzaburou_TheBestSakeMerchant : public UTgAchievement
{
public:
	class ATgPawn_Danzaburou*                          m_Owner;                                                  // 0x0084(0x0008) (Const)
	int                                                m_nTauntRequirement;                                      // 0x008C(0x0004) (Const)
	TArray<class AActor*>                              m_actorTaunted;                                           // 0x0090(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Danzaburou_TheBestSakeMerchant");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeSequence_Danzaburou_A01_Deploy
// 0x0014 (0x01C8 - 0x01B4)
class UTgAnimNodeSequence_Danzaburou_A01_Deploy : public UTgAnimNodeSequence
{
public:
	class UTgGameplayCurves*                           m_gameplayCurveStoppingMotion;                            // 0x01B4(0x0008) (Edit)
	unsigned long                                      m_bUseStopTimePercent : 1;                                // 0x01BC(0x0004) (Edit, Const)
	unsigned long                                      m_bIsInRollingStop : 1;                                   // 0x01BC(0x0004)
	float                                              m_fTimeToStop;                                            // 0x01C0(0x0004) (Const)
	float                                              m_fStoppingTimeElapsed;                                   // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequence_Danzaburou_A01_Deploy");
		return ptr;
	}


	void AdjustPlayRateForStop(float fDeltaTime);
	void STATIC_StartRollingStop(float fTimeToStop);
};


// Class TgGame.TgDeployable_Danzaburou_A01
// 0x00A0 (0x0498 - 0x03F8)
class ATgDeployable_Danzaburou_A01 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	class ATgPawn_Danzaburou*                          m_danzaburou;                                             // 0x0400(0x0008)
	class UTgSkeletalMeshComponent*                    c_meshDeploy;                                             // 0x0408(0x0008) (ExportObject, Component, EditInline)
	class ATgCollisionProxy*                           m_proxyCollisionActor;                                    // 0x0410(0x0008)
	float                                              s_fDistanceSpeedLossTriggers;                             // 0x0418(0x0004) (Const, Config)
	float                                              s_fSpeedLossPerFt;                                        // 0x041C(0x0004) (Const, Config)
	float                                              s_fMinSpeed;                                              // 0x0420(0x0004) (Const, Config)
	unsigned long                                      s_bEnableRicochet : 1;                                    // 0x0424(0x0004) (Const, Config)
	unsigned long                                      s_bFixedWorldCollisionSize : 1;                           // 0x0424(0x0004) (Const, Config)
	unsigned long                                      r_bEnableRicochet : 1;                                    // 0x0424(0x0004) (Const, Net)
	unsigned long                                      r_bFixedWorldCollisionSize : 1;                           // 0x0424(0x0004) (Const, Net)
	unsigned long                                      r_bMarkedForExplosion : 1;                                // 0x0424(0x0004) (Net)
	unsigned long                                      r_bPlayExplosionFx : 1;                                   // 0x0424(0x0004) (Net)
	float                                              r_fDistanceSpeedLossTriggers;                             // 0x0428(0x0004) (Const, Net)
	float                                              r_fSpeedLossPerFt;                                        // 0x042C(0x0004) (Const, Net)
	float                                              r_fMinSpeed;                                              // 0x0430(0x0004) (Const, Net)
	float                                              r_fRange;                                                 // 0x0434(0x0004) (Const, Net)
	float                                              r_fSpeed;                                                 // 0x0438(0x0004) (Const, Net)
	float                                              r_fCollisionStartingRadius;                               // 0x043C(0x0004) (Const, Net)
	float                                              r_fCollisionEndingRadius;                                 // 0x0440(0x0004) (Const, Net)
	float                                              r_fMaxCollisionSizeIncrease;                              // 0x0444(0x0004) (Const, Net)
	float                                              r_fWorldCollisionPercent;                                 // 0x0448(0x0004) (Const, Net)
	int                                                r_nMaxRicochets;                                          // 0x044C(0x0004) (Const, Net)
	struct FVector                                     r_vSeekLocation;                                          // 0x0450(0x000C) (Net)
	struct FVector                                     m_vPrevLocation;                                          // 0x045C(0x000C)
	float                                              m_fDistanceTraveled;                                      // 0x0468(0x0004)
	int                                                m_nNumRicochets;                                          // 0x046C(0x0004)
	float                                              s_fExplodeTime;                                           // 0x0470(0x0004) (Const, Config)
	float                                              r_fExplodeTime;                                           // 0x0474(0x0004) (Const, Net)
	float                                              r_fMaxExplosionRadius;                                    // 0x0478(0x0004) (Const, Net)
	float                                              r_fMinExplosionRadius;                                    // 0x047C(0x0004) (Const, Net)
	class UTgSpecialFx*                                c_fxAoeIndicator;                                         // 0x0480(0x0008) (Const)
	float                                              s_fPickupOffset;                                          // 0x0488(0x0004) (Const, Config)
	int                                                s_nMaxPickups;                                            // 0x048C(0x0004) (Const, Config)
	float                                              r_fPickupOffset;                                          // 0x0490(0x0004) (Const, Net)
	int                                                r_nMaxPickups;                                            // 0x0494(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Danzaburou_A01");
		return ptr;
	}


	void Cleanup();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void SpawningDeviceToggledOff();
	void HandleTouch(class AActor* Other);
	void ActorUnTouch(class AActor* Other);
	void ActorTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_FirePickupProjectile(class UTgDeviceFire* FireMode, struct FVector* vTargetLoc);
	int STATIC_GetNumPickups();
	bool STATIC_FindValidPickupLoc(struct FVector* vInitialEndLoc, struct FVector* vOffsetDirection, struct FVector* vValidDeployLoc);
	void STATIC_SpawnPickups();
	void STATIC_SwapToBombVisuals();
	void STATIC_PlayExplosionFx();
	void TriggerExplosion();
	void STATIC_StartExplosionTimer();
	float STATIC_GetExplosionRadius();
	void TriggerRicochet(const struct FVector& vHitNormal);
	void UpdateDeployableScale();
	float STATIC_GetPercentDistanceTraveled();
	struct FVector STATIC_GetWorldCollisionSize();
	struct FVector STATIC_GetCurrentSize();
	float STATIC_GetCurrentSpeed();
	bool WasActorHitByCollision(class AActor* actorHit);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDeployable_Danzaburou_A01_V2
// 0x009C (0x0494 - 0x03F8)
class ATgDeployable_Danzaburou_A01_V2 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	class ATgPawn_Danzaburou*                          m_danzaburou;                                             // 0x0400(0x0008)
	class UTgSkeletalMeshComponent*                    c_meshDeploy;                                             // 0x0408(0x0008) (ExportObject, Component, EditInline)
	class ATgCollisionProxy*                           m_proxyCollisionActor;                                    // 0x0410(0x0008)
	float                                              s_fDistanceSpeedLossTriggers;                             // 0x0418(0x0004) (Const, Config)
	float                                              s_fSpeedLossPerFt;                                        // 0x041C(0x0004) (Const, Config)
	float                                              s_fMinSpeed;                                              // 0x0420(0x0004) (Const, Config)
	unsigned long                                      s_bEnableRicochet : 1;                                    // 0x0424(0x0004) (Const, Config)
	unsigned long                                      r_bEnableRicochet : 1;                                    // 0x0424(0x0004) (Const, Net)
	unsigned long                                      r_bMarkedForExplosion : 1;                                // 0x0424(0x0004) (Net)
	unsigned long                                      r_bPlayExplosionFx : 1;                                   // 0x0424(0x0004) (Net)
	float                                              r_fDistanceSpeedLossTriggers;                             // 0x0428(0x0004) (Const, Net)
	float                                              r_fSpeedLossPerFt;                                        // 0x042C(0x0004) (Const, Net)
	float                                              r_fMinSpeed;                                              // 0x0430(0x0004) (Const, Net)
	float                                              r_fRange;                                                 // 0x0434(0x0004) (Const, Net)
	float                                              r_fSpeed;                                                 // 0x0438(0x0004) (Const, Net)
	float                                              r_fCollisionRadius;                                       // 0x043C(0x0004) (Const, Net)
	float                                              r_fWorldCollisionPercent;                                 // 0x0440(0x0004) (Const, Net)
	int                                                r_nMaxRicochets;                                          // 0x0444(0x0004) (Const, Net)
	struct FVector                                     r_vSeekLocation;                                          // 0x0448(0x000C) (Net)
	struct FVector                                     m_vPrevLocation;                                          // 0x0454(0x000C)
	float                                              m_fDistanceTraveled;                                      // 0x0460(0x0004)
	int                                                m_nNumRicochets;                                          // 0x0464(0x0004)
	class UTgAnimNodeSequence_Danzaburou_A01_Deploy*   c_animNodeRolling;                                        // 0x0468(0x0008)
	float                                              s_fExplodeTime;                                           // 0x0470(0x0004) (Const, Config)
	float                                              r_fExplodeTime;                                           // 0x0474(0x0004) (Const, Net)
	float                                              r_fExplosionRadius;                                       // 0x0478(0x0004) (Const, Net)
	class UTgSpecialFx*                                c_fxAoeIndicator;                                         // 0x047C(0x0008) (Const)
	float                                              s_fPickupOffset;                                          // 0x0484(0x0004) (Const, Config)
	int                                                s_nMaxPickups;                                            // 0x0488(0x0004) (Const, Config)
	float                                              r_fPickupOffset;                                          // 0x048C(0x0004) (Const, Net)
	int                                                r_nMaxPickups;                                            // 0x0490(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Danzaburou_A01_V2");
		return ptr;
	}


	void Cleanup();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void HandleTouch(class AActor* Other);
	void ActorUnTouch(class AActor* Other);
	void ActorTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_FirePickupProjectile(class UTgDeviceFire* FireMode, struct FVector* vTargetLoc);
	int STATIC_GetNumPickups();
	bool STATIC_FindValidPickupLoc(struct FVector* vInitialEndLoc, struct FVector* vOffsetDirection, struct FVector* vValidDeployLoc);
	void STATIC_SpawnPickups();
	void STATIC_SwapToBombVisuals();
	void STATIC_PlayExplosionFx();
	void TriggerExplosion();
	void STATIC_StartExplosionTimer();
	float STATIC_GetExplosionRadius();
	void TriggerRicochet(const struct FVector& vHitNormal);
	float STATIC_GetPercentDistanceTraveled();
	struct FVector STATIC_GetWorldCollisionSize();
	float STATIC_GetCurrentSpeed();
	bool WasActorHitByCollision(class AActor* actorHit);
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDeployable_Danzaburou_A03
// 0x005C (0x0454 - 0x03F8)
class ATgDeployable_Danzaburou_A03 : public ATgDeploy_EffectVolume_WithCollision
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	class ATgPawn_Danzaburou*                          m_danzaburou;                                             // 0x0400(0x0008)
	float                                              s_fCollisionHeight;                                       // 0x0408(0x0004) (Const, Config)
	float                                              r_fCollisionHeight;                                       // 0x040C(0x0004) (Const, Net)
	unsigned long                                      r_bExploded : 1;                                          // 0x0410(0x0004) (Net)
	unsigned long                                      m_bPreventExplosion : 1;                                  // 0x0410(0x0004)
	unsigned long                                      s_bCanBreakIllusion : 1;                                  // 0x0410(0x0004)
	unsigned long                                      m_bHasDeactivatedDanzaDecoySwap : 1;                      // 0x0410(0x0004)
	unsigned long                                      c_bHasDeactivatedDecoyWhileAliveFx : 1;                   // 0x0410(0x0004)
	int                                                s_nNumDecoys;                                             // 0x0414(0x0004) (Const, Config)
	float                                              s_fDecoySpawnAngleOffset;                                 // 0x0418(0x0004) (Const, Config)
	float                                              s_fDecoyPersistTime;                                      // 0x041C(0x0004) (Const, Config)
	float                                              s_fMinDecoySpeed;                                         // 0x0420(0x0004) (Const, Config)
	float                                              s_fTimeTillIllusionCanBreak;                              // 0x0424(0x0004) (Const, Config)
	int                                                r_nNumDecoys;                                             // 0x0428(0x0004) (Const, Net)
	float                                              r_fDecoySpawnAngleOffset;                                 // 0x042C(0x0004) (Const, Net)
	float                                              r_fDecoyPersistTime;                                      // 0x0430(0x0004) (Const, Net)
	float                                              r_fMinDecoySpeed;                                         // 0x0434(0x0004) (Const, Net)
	float                                              r_fTimeTillIllusionCanBreak;                              // 0x0438(0x0004) (Const, Net)
	TArray<class ATgSkeletalMeshActorSpawnable_DanzaburouDecoy*> c_decoys;                                                 // 0x043C(0x0010) (NeedCtorLink)
	float                                              r_fCurrentAoeSize;                                        // 0x044C(0x0004) (Const, Net)
	float                                              r_fOriginalFxRadiusSize;                                  // 0x0450(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Danzaburou_A03");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
	void HandleUnTouch(class AActor* Other);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_DeployableDestroyed();
	float STATIC_GetFxScaling();
	void STATIC_PlayExplosionFx();
	void TriggerExplosion();
	bool IsDanzaburouFiringAttacks();
	bool STATIC_CanTriggerExplosion();
	void AllowIllusionBreak();
	void BreakIllusion();
	bool STATIC_CanBreakIllusion();
	void STATIC_DeployDecoys();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDeployable_Danzaburou_A01_Pickup
// 0x0014 (0x040C - 0x03F8)
class ATgDeployable_Danzaburou_A01_Pickup : public ATgDeploy_EffectVolume
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03F8(0x0008) (Const, Native, NoExport)
	int                                                m_nDanzaProjectileId;                                     // 0x0400(0x0004) (Const)
	class ATgPawn_Danzaburou*                          m_danzaburou;                                             // 0x0404(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Danzaburou_A01_Pickup");
		return ptr;
	}


	void HandleTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_FireProjectile();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
};


// Class TgGame.TgDeployable_Danzaburou_A04
// 0x0000 (0x0434 - 0x0434)
class ATgDeployable_Danzaburou_A04 : public ATgDeployable_Statue
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Danzaburou_A04");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Danzaburou_A02
// 0x0048 (0x041C - 0x03D4)
class ATgDeployable_Danzaburou_A02 : public ATgDeployable
{
public:
	struct FPointer                                    VfTable_ITgDeployable_CustomRanksInterface;               // 0x03D4(0x0008) (Const, Native, NoExport)
	struct FPointer                                    VfTable_ITgTauntSettingsInterface;                        // 0x03DC(0x0008) (Const, Native, NoExport)
	class ATgPawn_Danzaburou*                          m_danzaburou;                                             // 0x03E4(0x0008)
	int                                                m_nDamageOverride;                                        // 0x03EC(0x0004) (Const)
	float                                              r_fPersistPulseTime;                                      // 0x03F0(0x0004) (Const, Net)
	float                                              s_fMinTauntRadius;                                        // 0x03F4(0x0004) (Const, Config)
	int                                                s_nPulseStacksNeededToTaunt;                              // 0x03F8(0x0004) (Const, Config)
	float                                              r_fMinTauntRadius;                                        // 0x03FC(0x0004) (Const, Net)
	int                                                r_nPulseStacksNeededToTaunt;                              // 0x0400(0x0004) (Const, Net)
	TArray<class AActor*>                              s_actorsTaunted;                                          // 0x0404(0x0010) (NeedCtorLink)
	float                                              s_fCollisionRadius;                                       // 0x0414(0x0004) (Const, Config)
	float                                              r_fCollisionRadius;                                       // 0x0418(0x0004) (Const, Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Danzaburou_A02");
		return ptr;
	}


	void TakeDamage(int Damage, class AController* EventInstigator, const struct FVector& HitLocation, const struct FVector& Momentum, class UClass* DamageType, const struct FTraceHitInfo& HitInfo, class AActor* DamageCauser);
	void STATIC_InstantFireDeployable();
	void TimeDeviceFiring();
	void STATIC_DeployableDestroyed();
	bool IsInvisibleToSpecialAI(class AActor* TestActor);
	bool STATIC_IsInvisible(class AActor* TestActor);
	float STATIC_GetMinTauntRadius();
	bool IsCustomDeviceFireOwner();
	class UTgDeviceFire* STATIC_GetCustomDeviceFire();
	void ApplyHitPulse();
};


// Class TgGame.TgDevice_Danzaburou_A04_Charge
// 0x0014 (0x0550 - 0x053C)
class ATgDevice_Danzaburou_A04_Charge : public ATgDevice_Charge
{
public:
	float                                              s_fChargeTurnRate;                                        // 0x053C(0x0004) (Const, Config)
	float                                              r_fChargeTurnRate;                                        // 0x0540(0x0004) (Const, Net)
	class ATgPawn_Danzaburou*                          r_danzaburou;                                             // 0x0544(0x0008) (Net)
	int                                                m_nChargeIcon;                                            // 0x054C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Danzaburou_A04_Charge");
		return ptr;
	}


	void STATIC_ClientStoppingOnHit();
	void STATIC_OnChargeEnd();
	void STATIC_OnChargeStart();
	float GetChargeSpeed();
	bool CanBeInterrupted();
	void STATIC_EnforcePostFire();
	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
	void STATIC_FireAoeExplosion();
};


// Class TgGame.TgDevice_Danzaburou_A04
// 0x0028 (0x0518 - 0x04F0)
class ATgDevice_Danzaburou_A04 : public ATgDevice
{
public:
	class ATgPawn_Danzaburou*                          r_danzaburou;                                             // 0x04F0(0x0008) (Net)
	TEnumAsByte<EDanzaburouA04FireType>                r_eSelectedFireType;                                      // 0x04F8(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F9(0x0003) MISSED OFFSET
	class AActor*                                      m_cachedHomingTarget;                                     // 0x04FC(0x0008)
	float                                              s_fFireTypeLockoutTime;                                   // 0x0504(0x0004) (Const, Config)
	float                                              r_fFireTypeLockoutTime;                                   // 0x0508(0x0004) (Const, Net)
	unsigned long                                      r_bFireChargeDevice : 1;                                  // 0x050C(0x0004) (Net)
	unsigned long                                      m_bLockoutFireTypeToggle : 1;                             // 0x050C(0x0004)
	class ATgDevice_Danzaburou_A04_Charge*             m_devCharge;                                              // 0x0510(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Danzaburou_A04");
		return ptr;
	}


	void STATIC_EndFireTypeToggleLockOut();
	void STATIC_ServerDoToggledAction();
	bool STATIC_CanFireWhileTargetingWhenOffhandPressed();
	void STATIC_FireAmmunition();
	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_RemoveCCImmunity();
	void ApplyCCImmunity();
	class AActor* STATIC_FindClosestHomingTarget();
	class AActor* STATIC_FindHomingTarget();
	void STATIC_FireChargeDevice();
	bool STATIC_ShouldLockFiring(class ATgDevice* Current);
	bool STATIC_NativeIsFiring();
	void STATIC_SetA04IconStatus(bool bChargeIcon);
};


// Class TgGame.TgDevice_Danzaburou_PSV
// 0x0044 (0x0534 - 0x04F0)
class ATgDevice_Danzaburou_PSV : public ATgDevice
{
public:
	unsigned char                                      r_bPouchCompleted[0x4];                                   // 0x04F0(0x0001) (Net)
	TEnumAsByte<EDanzaburouMoneyPouchType>             r_eCurrentPouch;                                          // 0x04F4(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x04F5(0x0003) MISSED OFFSET
	int                                                r_nCurrentGoldPocketed;                                   // 0x04F8(0x0004) (Net)
	float                                              s_fGoldStealPercent;                                      // 0x04FC(0x0004) (Const, Config)
	int                                                s_nPouchGoldThreshold[0x4];                               // 0x0500(0x0004) (Const, Config)
	float                                              r_fGoldStealPercent;                                      // 0x0510(0x0004) (Const, Net)
	int                                                r_nPouchGoldThreshold[0x4];                               // 0x0514(0x0004) (Const, Net)
	int                                                m_nPouchHitSituationalType[0x4];                          // 0x0524(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Danzaburou_PSV");
		return ptr;
	}

};


// Class TgGame.TgDevice_Danzaburou_A01_V2
// 0x0040 (0x053C - 0x04FC)
class ATgDevice_Danzaburou_A01_V2 : public ATgDevice_Deployable
{
public:
	TArray<class ATgDeployable*>                       s_deployablesActive;                                      // 0x04FC(0x0010) (NeedCtorLink)
	float                                              s_fCollisionRadius;                                       // 0x050C(0x0004) (Const, Config)
	float                                              s_fWorldCollisionPercent;                                 // 0x0510(0x0004) (Const, Config)
	float                                              r_fCollisionRadius;                                       // 0x0514(0x0004) (Const, Net)
	float                                              r_fWorldCollisionPercent;                                 // 0x0518(0x0004) (Const, Net)
	float                                              s_fDeployableAimAngleOffset;                              // 0x051C(0x0004) (Const, Config)
	float                                              r_fDeployableAimAngleOffset;                              // 0x0520(0x0004) (Const, Net)
	int                                                s_nMaxRicochets;                                          // 0x0524(0x0004) (Const, Config)
	int                                                r_nMaxRicochets;                                          // 0x0528(0x0004) (Const, Net)
	TArray<struct FRicochetTargetingInfoV2>            c_ricochetTargetingInfos;                                 // 0x052C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Danzaburou_A01_V2");
		return ptr;
	}


	void OnDeployableDestroyed(class ATgDeployable* deployable);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	struct FVector STATIC_CalcRicochetDirection(const struct FVector& vIncomingDirection, const struct FVector& vHitNormal);
	struct FVector STATIC_FindTargetingSectionEndTrace(const struct FVector& vStartTrace, const struct FVector& vEndTrace, const struct FVector& vCollisionExtent, class ATgPawn* pawnInstigator, bool bIsRicochetSection, struct FImpactInfo* impactWorld);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDevice_Danzaburou_A02
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Danzaburou_A02 : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Danzaburou_A02");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Danzaburou_A01
// 0x0030 (0x0544 - 0x0514)
class ATgDevice_Danzaburou_A01 : public ATgDevice_TogglableDeployable
{
public:
	float                                              s_fCollisionStartingRadius;                               // 0x0514(0x0004) (Const, Config)
	float                                              s_fCollisionEndingRadius;                                 // 0x0518(0x0004) (Const, Config)
	float                                              s_fWorldCollisionPercent;                                 // 0x051C(0x0004) (Const, Config)
	float                                              r_fCollisionStartingRadius;                               // 0x0520(0x0004) (Const, Net)
	float                                              r_fCollisionEndingRadius;                                 // 0x0524(0x0004) (Const, Net)
	float                                              r_fWorldCollisionPercent;                                 // 0x0528(0x0004) (Const, Net)
	int                                                s_nMaxRicochets;                                          // 0x052C(0x0004) (Const, Config)
	int                                                r_nMaxRicochets;                                          // 0x0530(0x0004) (Const, Net)
	TArray<struct FRicochetTargetingInfo>              c_ricochetTargetingInfos;                                 // 0x0534(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Danzaburou_A01");
		return ptr;
	}


	void STATIC_ClientSetState(TEnumAsByte<ETogglableDeployableState> NewState);
	struct FVector STATIC_CalcRicochetDirection(const struct FVector& vIncomingDirection, const struct FVector& vHitNormal);
	void STATIC_GetTargetingAim(struct FAimData* Aim);
};


// Class TgGame.TgDeviceFire_Danzaburou_A04_Charge
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Danzaburou_A04_Charge : public UTgDeviceFire
{
public:
	class UTgDeviceFire*                               m_firemodeA04;                                            // 0x01C0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Danzaburou_A04_Charge");
		return ptr;
	}


	void ApplyHitSpecial(class AActor* Target, const struct FImpactInfo& Impact, int nHitSpecialSituationalType, int StackCount);
	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Danzaburou_A01
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Danzaburou_A01 : public UTgDeviceFire_MultiDeploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Danzaburou_A01");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	class ATgDeployable* STATIC_SpawnDeployable(int nDeployIndex);
};


// Class TgGame.TgDeviceForm_Danzaburou_A01_V2
// 0x0020 (0x0258 - 0x0238)
class UTgDeviceForm_Danzaburou_A01_V2 : public UTgDeviceForm
{
public:
	TArray<class UTgSpecialFx*>                        c_fxRicochetTargeters;                                    // 0x0238(0x0010) (NeedCtorLink)
	class ATgDevice_Danzaburou_A01_V2*                 c_devA01V2;                                               // 0x0248(0x0008)
	float                                              c_fMaxRange;                                              // 0x0250(0x0004) (Const)
	int                                                c_nMaxTargeters;                                          // 0x0254(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Danzaburou_A01_V2");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
	void UpdateTargetingModeLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation, float DistanceScale);
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void UpdateRicochetTargeter(class UTgSpecialFx* fxTargeter, struct FRicochetTargetingInfoV2* ricochetInfo);
	void STATIC_InitializeTargetingModeFX();
	class UTgSpecialFx* STATIC_CreateTargeterFX(int nFxId);
};


// Class TgGame.TgDeviceForm_Danzaburou_A03
// 0x0008 (0x0240 - 0x0238)
class UTgDeviceForm_Danzaburou_A03 : public UTgDeviceForm
{
public:
	class ATgPawn_Danzaburou*                          c_danzaburou;                                             // 0x0238(0x0008) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Danzaburou_A03");
		return ptr;
	}


	void EnterTargetingMode();
	void UpdateTargeterScale();
};


// Class TgGame.TgDeviceForm_Danzaburou_A04
// 0x0020 (0x026C - 0x024C)
class UTgDeviceForm_Danzaburou_A04 : public UTgDeviceForm_TargetIndicator
{
public:
	class ATgDevice_Danzaburou_A04*                    c_devA04;                                                 // 0x024C(0x0008)
	int                                                c_nAOETargeterFxId;                                       // 0x0254(0x0004) (Const)
	class UTgSpecialFx*                                c_fxAOETargeter;                                          // 0x0258(0x0008)
	int                                                c_nChargeTargeterFxId;                                    // 0x0260(0x0004) (Const)
	class UTgSpecialFx*                                c_fxChargeTargeter;                                       // 0x0264(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Danzaburou_A04");
		return ptr;
	}


	void ExitTargetingMode();
	void UpdateTargetingModeStatus(TEnumAsByte<ETargetingModeStatus> Status, struct FAimData* Aim);
	void STATIC_InitializeTargetingModeFX();
	class UTgSpecialFx* STATIC_CreateTargeterFX(int nFxId);
};


// Class TgGame.TgEffect_Danzaburou_A02
// 0x0000 (0x009C - 0x009C)
class UTgEffect_Danzaburou_A02 : public UTgEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffect_Danzaburou_A02");
		return ptr;
	}


	class AActor* STATIC_GetTauntTarget();
};


// Class TgGame.TgEffectForm_Danzaburou_A02_Stack
// 0x001A (0x012C - 0x0112)
class UTgEffectForm_Danzaburou_A02_Stack : public UTgEffectForm_Stacks
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x0112(0x0002) MISSED OFFSET
	TArray<struct FFx_Sound>                           c_soundStackList;                                         // 0x0114(0x0010) (Component, NeedCtorLink)
	class UTgSpecialFx*                                c_fxStack;                                                // 0x0124(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Danzaburou_A02_Stack");
		return ptr;
	}


	void STATIC_SetCurrentStacks(unsigned char nStacks);
};


// Class TgGame.TgInventoryObject_Listen_Danzaburou_A01_V2
// 0x0020 (0x00F0 - 0x00D0)
class UTgInventoryObject_Listen_Danzaburou_A01_V2 : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_Danzaburou_A01_V2*                 s_a01V2;                                                  // 0x00D0(0x0008)
	float                                              s_fMuliHitDamagePercent;                                  // 0x00D8(0x0004) (Const, Config)
	TArray<struct FDanzaburouA01HitTrackerInfo>        s_trackingInfoList;                                       // 0x00DC(0x0010) (NeedCtorLink)
	unsigned long                                      s_bCurrentHitIsBombHit : 1;                               // 0x00EC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Danzaburou_A01_V2");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Danzaburou_A03
// 0x0008 (0x00D8 - 0x00D0)
class UTgInventoryObject_Listen_Danzaburou_A03 : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_Deployable*                        s_devA03;                                                 // 0x00D0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Danzaburou_A03");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Danzaburou_PSV
// 0x0014 (0x00E4 - 0x00D0)
class UTgInventoryObject_Listen_Danzaburou_PSV : public UTgInventoryObject_Listen
{
public:
	class ATgDevice_Danzaburou_PSV*                    s_devPsv;                                                 // 0x00D0(0x0008)
	class ATgPawn_Danzaburou*                          s_danzaburou;                                             // 0x00D8(0x0008)
	unsigned long                                      s_bEnableSpooling : 1;                                    // 0x00E0(0x0004) (Const, Config)
	unsigned long                                      s_bIsOpeningPouch : 1;                                    // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Danzaburou_PSV");
		return ptr;
	}


	bool AttemptPouchComplete(TEnumAsByte<EDanzaburouMoneyPouchType> eDanzaburouPouch);
};


// Class TgGame.TgInventoryObject_Listen_Effect_Danzaburou_A02
// 0x0018 (0x00FC - 0x00E4)
class UTgInventoryObject_Listen_Effect_Danzaburou_A02 : public UTgInventoryObject_Listen_Effect
{
public:
	class ATgEffectManager*                            s_effectManagerTarget;                                    // 0x00E4(0x0008)
	float                                              s_fDamageThresholdPercent;                                // 0x00EC(0x0004) (Const, Config)
	float                                              s_fDamageThresholdAmount;                                 // 0x00F0(0x0004) (Const)
	float                                              s_fDamageTaken;                                           // 0x00F4(0x0004)
	unsigned long                                      s_bIsTauntActive : 1;                                     // 0x00F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Effect_Danzaburou_A02");
		return ptr;
	}

};


// Class TgGame.TgPawn_Danzaburou
// 0x00E4 (0x269C - 0x25B8)
class ATgPawn_Danzaburou : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_devInhand;                                              // 0x25B8(0x0008)
	class ATgDevice_Danzaburou_PSV*                    m_devPsv;                                                 // 0x25C0(0x0008)
	class ATgDevice_Danzaburou_A01_V2*                 m_devA01;                                                 // 0x25C8(0x0008)
	class ATgDevice*                                   m_devA01Sub;                                              // 0x25D0(0x0008)
	class ATgDevice_Danzaburou_A02*                    m_devA02;                                                 // 0x25D8(0x0008)
	class ATgDevice*                                   m_devA02Sub;                                              // 0x25E0(0x0008)
	class ATgDevice_Deployable*                        m_devA03;                                                 // 0x25E8(0x0008)
	class ATgDevice_Danzaburou_A04*                    m_devA04;                                                 // 0x25F0(0x0008)
	class ATgDevice_Danzaburou_A04_Charge*             m_devA04Sub;                                              // 0x25F8(0x0008)
	unsigned long                                      m_bDevicesCached : 1;                                     // 0x2600(0x0004) (Const)
	unsigned long                                      r_bIsDecoy : 1;                                           // 0x2600(0x0004) (Net)
	unsigned long                                      r_bSpawnStatue : 1;                                       // 0x2600(0x0004) (Net)
	unsigned long                                      r_bIsMissile : 1;                                         // 0x2600(0x0004) (Net)
	unsigned long                                      r_bA04PlayChargeExplosionFx : 1;                          // 0x2600(0x0004) (Net)
	unsigned long                                      r_bIsInCameraLock : 1;                                    // 0x2600(0x0004) (Net)
	class UTgSkeletalMeshComponent*                    m_meshDanzaburou;                                         // 0x2604(0x0008) (ExportObject, Component, EditInline)
	float                                              s_fInhandCombatStanceTimeout;                             // 0x260C(0x0004) (Const, Config)
	float                                              r_fInhandCombatStanceTimeout;                             // 0x2610(0x0004) (Const, Net)
	float                                              s_fA02ProjAirTime;                                        // 0x2614(0x0004) (Const, Config)
	float                                              s_fA02ProjGravityMultiplier;                              // 0x2618(0x0004) (Const, Config)
	float                                              r_fA02ProjAirTime;                                        // 0x261C(0x0004) (Const, Net)
	float                                              r_fA02ProjGravityMultiplier;                              // 0x2620(0x0004) (Const, Net)
	class ATgDeployable_Danzaburou_A03*                r_deployableA03;                                          // 0x2624(0x0008) (Net)
	struct FName                                       m_nmDecoyFxGroup;                                         // 0x262C(0x0008) (Const)
	struct FName                                       m_nmDecoyOutroFxGroup;                                    // 0x2634(0x0008) (Const)
	float                                              s_fStatuePersistTime;                                     // 0x263C(0x0004) (Const, Config)
	float                                              r_fStatuePersistTime;                                     // 0x2640(0x0004) (Const, Net)
	int                                                m_nStatueDeployableId;                                    // 0x2644(0x0004) (Const)
	float                                              s_fA04ProjInitialHorizontalTurnStrength;                  // 0x2648(0x0004) (Const, Config)
	float                                              r_fA04ProjInitialHorizontalTurnStrength;                  // 0x264C(0x0004) (Const, Net)
	float                                              s_fA04ProjMaxHorizontalTurnStrength;                      // 0x2650(0x0004) (Const, Config)
	float                                              r_fA04ProjMaxHorizontalTurnStrength;                      // 0x2654(0x0004) (Const, Net)
	float                                              s_fA04ProjTimeTillTurnStrengthRampUpStarts;               // 0x2658(0x0004) (Const, Config)
	float                                              r_fA04ProjTimeTillTurnStrengthRampUpStarts;               // 0x265C(0x0004) (Const, Net)
	float                                              s_fA04WorldCollisionPercent;                              // 0x2660(0x0004) (Const, Config)
	float                                              r_fA04WorldCollisionPercent;                              // 0x2664(0x0004) (Const, Net)
	float                                              s_fA04ProjRampUpDuration;                                 // 0x2668(0x0004) (Const, Config)
	float                                              r_fA04ProjRampUpDuration;                                 // 0x266C(0x0004) (Const, Net, Config)
	float                                              r_fDanzaburouBaseCollisionRadius;                         // 0x2670(0x0004) (Const, Net)
	float                                              r_fDanzaburouBaseCollisionHeight;                         // 0x2674(0x0004) (Const, Net)
	float                                              r_fDanzaburouBaseCollisionTranslationZ;                   // 0x2678(0x0004) (Const, Net)
	int                                                m_nChargeProjectileMeshId;                                // 0x267C(0x0004) (Const)
	class UTgSkeletalMeshComponent*                    c_projMesh;                                               // 0x2680(0x0008) (ExportObject, Component, EditInline)
	float                                              s_fRestrictedCameraRotationThreshold;                     // 0x2688(0x0004) (Const, Config)
	float                                              r_fRestrictedCameraRotationThreshold;                     // 0x268C(0x0004) (Const, Net)
	struct FRotator                                    m_rCameraOrigin;                                          // 0x2690(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Danzaburou");
		return ptr;
	}


	void FaceRotation(const struct FRotator& NewRotation, float DeltaTime);
	bool PostPawnSetup();
	float STATIC_GetChargeTurnRate();
	void BumpLevel(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Bump(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitNormal);
	void PawnOnOffhandSlotPressed(TEnumAsByte<ETG_EQUIP_POINT> eqpSlot);
	void ReplicatedEvent(const struct FName& VarName);
	void TransmitTiDiClient();
	void STATIC_EnforceCameraLock(struct FRotator* rCameraLockRotation);
	void ToggleCameraLock(bool bEnable);
	void STATIC_PlayA04ChargeExplosionFx();
	void STATIC_SpawnStatue();
	float STATIC_GetGravityZ();
	void UpdateDanzaburouCollisionSize(bool bChargeStart);
	struct FVector STATIC_CalcWorldCollisionSize();
	void STATIC_ClientSwapToHomingMissile();
	void STATIC_ServerSwapToHomingMissile(bool bSwapToMissile);
	void STATIC_SwapToHomingMissile(bool bSwapToMissile);
	void STATIC_CreateHomingProjectileMesh();
	void STATIC_ClientDecoySwap();
	void STATIC_ServerDecoySwap(bool bSwapToDecoy);
	void STATIC_DecoySwap(bool bSwapToDecoy);
	void STATIC_OnLevelUp(int nLevel);
	void STATIC_ServerUpdateHiddenStatus();
	bool STATIC_ShouldUseFadeOverlay();
	bool STATIC_GetPassiveAuxMax(float* fResult);
	bool STATIC_GetPassiveAux(float* fResult);
	bool STATIC_GetPassiveBool(int* bResult);
	bool STATIC_GetPassiveInt1(int* nResult);
	bool ApplyPawnSetup();
	void STATIC_CacheConfigValues();
	void UpdateClientDevices(bool bForce);
};


// Class TgGame.TgProj_Danzaburou_A02
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Danzaburou_A02 : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Danzaburou_A02");
		return ptr;
	}


	void STATIC_CompleteInitialization();
};


// Class TgGame.TgProj_Danzaburou_A04
// 0x0034 (0x0414 - 0x03E0)
class ATgProj_Danzaburou_A04 : public ATgProj_SimulatedSeekingPassThrough
{
public:
	class ATgPawn_Danzaburou*                          m_danzaburou;                                             // 0x03E0(0x0008)
	float                                              m_fInitialTurnStrength;                                   // 0x03E8(0x0004) (Const)
	float                                              m_fMaxTurnStrength;                                       // 0x03EC(0x0004) (Const)
	float                                              m_fTimeTillTurnStrengthRampUpStarts;                      // 0x03F0(0x0004) (Const)
	float                                              m_fRampUpDuration;                                        // 0x03F4(0x0004) (Const)
	float                                              m_fRampUpCurrentTime;                                     // 0x03F8(0x0004)
	unsigned long                                      m_bRampUpTurnStrength : 1;                                // 0x03FC(0x0004)
	float                                              m_fWorldCollisionPercent;                                 // 0x0400(0x0004) (Const)
	class ATgCollisionProxy*                           m_proxyWorldCollision;                                    // 0x0404(0x0008)
	class AActor*                                      s_actorExplosionInstigator;                               // 0x040C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Danzaburou_A04");
		return ptr;
	}


	void ShutDown();
	void UpdateSeekingDirection(float fDeltaTime);
	void Tick(float fDeltaTime);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void ProjectileShutdownExplode();
	void STATIC_FireAoe(const struct FVector& HitLocation);
	bool UseAOE();
	struct FVector STATIC_CalcWorldCollisionSize();
	void STATIC_ChangeTurnStrength(float fDeltaTime);
	void BeginRampUpTurnStrength();
	void STATIC_InitializeCollisionProxies();
	void STATIC_CompleteInitialization();
};


// Class TgGame.TgSkeletalMeshActorSpawnable_DanzaburouDecoy
// 0x0024 (0x0340 - 0x031C)
class ATgSkeletalMeshActorSpawnable_DanzaburouDecoy : public ATgSkeletalMeshActorSpawnable
{
public:
	struct FPointer                                    VfTable_ITgTiDiInterfaceLite;                             // 0x031C(0x0008) (Const, Native, NoExport)
	int                                                m_nMeshId;                                                // 0x0324(0x0004) (Const)
	float                                              m_fMinDecoySpeed;                                         // 0x0328(0x0004) (Const)
	class ATgPawn_Danzaburou*                          m_danzaburouOwner;                                        // 0x032C(0x0008)
	class UTgSkeletalMeshComponent*                    c_meshDecoy;                                              // 0x0334(0x0008) (ExportObject, Component, EditInline)
	float                                              m_fInitialYawRotationFromDanza;                           // 0x033C(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActorSpawnable_DanzaburouDecoy");
		return ptr;
	}


	void ApplyTiDi(float fTotalTiDi);
	struct FVector STATIC_CalcVelocity();
	void STATIC_InitializeDecoy(class ATgPawn_Danzaburou* Danzaburou, float fMinDecoySpeed, float fIntialYawRotationFromDanza);
	void STATIC_CreateMesh();
};


// Class TgGame.TgSkinAssemblyConfig
// 0x0010 (0x0070 - 0x0060)
class UTgSkinAssemblyConfig : public UObject
{
public:
	TArray<struct FBotAssemblyPackages>                m_BotAssemblies;                                          // 0x0060(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkinAssemblyConfig");
		return ptr;
	}


	void AddSkinRefs(int nBotId, int nSkinId, TArray<struct FString> PackageRefs, int nFlag);
};


// Class TgGame.TgAchievement_AbilityMultiHit_SingleDevice
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_AbilityMultiHit_SingleDevice : public UTgAchievement_AbilityMultiHit
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_AbilityMultiHit_SingleDevice");
		return ptr;
	}

};


// Class TgGame.TgAchievement_Freeze
// 0x0000 (0x00A8 - 0x00A8)
class UTgAchievement_Freeze : public UTgAchievement_OnEffectApplied
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_Freeze");
		return ptr;
	}

};


// Class TgGame.TgAchievement_GuanYu_Charge
// 0x0000 (0x00B0 - 0x00B0)
class UTgAchievement_GuanYu_Charge : public UTgAchievement_AbilityMultiHit_SingleDeviceSingleEffect
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAchievement_GuanYu_Charge");
		return ptr;
	}

};


// Class TgGame.TgDevice_Nemesis_Num4
// 0x0008 (0x04FC - 0x04F4)
class ATgDevice_Nemesis_Num4 : public ATgDevice_GroundTarget_LockOn
{
public:
	float                                              m_fPhysicalProtectionToAdd;                               // 0x04F4(0x0004)
	float                                              m_fMagicalProtectionToAdd;                                // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nemesis_Num4");
		return ptr;
	}


	bool CanBeCanceled();
	bool CanBeInterrupted();
};


// Class TgGame.TgAIBehavior_Action_FireKismet
// 0x000C (0x00A0 - 0x0094)
class UTgAIBehavior_Action_FireKismet : public UTgAIBehaviorAction
{
public:
	unsigned long                                      s_bPassTarget : 1;                                        // 0x0094(0x0004) (Edit)
	int                                                s_nGeneralInt;                                            // 0x0098(0x0004) (Edit)
	float                                              s_fGeneralFloat;                                          // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehavior_Action_FireKismet");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_AssignLane
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_AssignLane : public UTgAIBehaviorAction
{
public:
	int                                                LaneIndex;                                                // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_AssignLane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_CancelFiring
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_CancelFiring : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_CancelFiring");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearLaneMoveTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearLaneMoveTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearLaneMoveTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearLastAttacker
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearLastAttacker : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearLookAtTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearLookAtTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearLookAtTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearNavigationQueue
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearNavigationQueue : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearNavigationQueue");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearRallyPoint
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearRallyPoint : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_ClearSpreadLocation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_ClearSpreadLocation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_ClearSpreadLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveBase
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorAction_MoveBase : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSubtractPawnRadius : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bSubtractTargetPawnRadius : 1;                            // 0x0094(0x0004) (Edit)
	unsigned long                                      bLookAtTarget : 1;                                        // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveLOS : 1;                                         // 0x0094(0x0004) (Edit)
	float                                              MoveTolerance;                                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveBase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToTarget : public UTgAIBehaviorAction_MoveBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowCombatTarget
// 0x0001 (0x009D - 0x009C)
class UTgAIBehaviorAction_FollowCombatTarget : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowLane
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_FollowLane : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bUseReverseDirection : 1;                                 // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowLane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowLoop
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_FollowLoop : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowLoop");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_FollowPatrol
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_FollowPatrol : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_FollowPatrol");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Juke
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Juke : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Juke");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Jump
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Jump : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Jump");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Leash
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Leash : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Leash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_LookAtSpawnRotation
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_LookAtSpawnRotation : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_LookAtSpawnRotation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLaneTarget
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_MoveToLaneTarget : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLaneTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToLaneVolume
// 0x0004 (0x00A0 - 0x009C)
class UTgAIBehaviorAction_MoveToLaneVolume : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToLaneVolume");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetTaskforce
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_SetTaskforce : public USequenceAction
{
public:
	int                                                TaskForceNumber;                                          // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetTaskforce");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ToggleImmuneGodMode
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ToggleImmuneGodMode : public USeqAct_ToggleGodMode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ToggleImmuneGodMode");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToNearestJungleBuff
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveToNearestJungleBuff : public UTgAIBehaviorAction_MoveToTarget
{
public:
	TEnumAsByte<EJungleTargetType>                     CampType;                                                 // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToNearestJungleBuff");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_MoveToRallyPoint
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_MoveToRallyPoint : public UTgAIBehaviorAction_MoveToTarget
{
public:
	float                                              fMaximumDistanceToRallyPoint;                             // 0x009C(0x0004) (Edit)
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x00A0(0x0004) (Edit)
	unsigned long                                      bMustBeSameTaskforce : 1;                                 // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_MoveToRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PauseAI
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PauseAI : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PauseAI");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTeamIndex
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetTeamIndex : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTeamIndex");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetTaskForceNumber
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetTaskForceNumber : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetTaskForceNumber");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_KillBots
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_KillBots : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_KillBots");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_Killpawns
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_Killpawns : public UTgSeqAct_KillBots
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_Killpawns");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DoDamageToPawn
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_DoDamageToPawn : public USequenceAction
{
public:
	unsigned long                                      IsPercentDamage : 1;                                      // 0x0108(0x0004) (Edit)
	unsigned long                                      DoNotKill : 1;                                            // 0x0108(0x0004) (Edit)
	int                                                Damage;                                                   // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DoDamageToPawn");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_DespawnBots
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_DespawnBots : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_DespawnBots");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ResetCooldown
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_ResetCooldown : public USequenceAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       m_eEquipPoint;                                            // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ResetCooldown");
		return ptr;
	}

};


// Class TgGame.TgAnimBlendByFireMode
// 0x0000 (0x0168 - 0x0168)
class UTgAnimBlendByFireMode : public UTgAnimNodeBlendList
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimBlendByFireMode");
		return ptr;
	}


	void STATIC_SelectFireMode(int FireMode);
};


// Class TgGame.TgSeqAct_JoinTeam
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_JoinTeam : public USequenceAction
{
public:
	class AActor*                                      TeamLeader;                                               // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_JoinTeam");
		return ptr;
	}

};


// Class TgGame.TgControlModule
// 0x000C (0x006C - 0x0060)
class UTgControlModule : public UObject
{
public:
	class ATgPlayerController*                         Controller;                                               // 0x0060(0x0008)
	unsigned long                                      m_bIsActive : 1;                                          // 0x0068(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule");
		return ptr;
	}


	bool STATIC_InterceptRawKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> Event, float AmountDepressed);
	bool STATIC_InterceptFlashInput(const struct FName& ButtonName, TEnumAsByte<EInputEvent> Event);
	void AdjustAimingView(struct FVector* ViewLocation, struct FRotator* ViewRotation);
	void STATIC_OnRightMouseReleased();
	void STATIC_OnRightMousePressed();
	void UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void OnSettingsChanged(class UTgClientSettings* Settings);
	void OnBecomeInActive(class UTgControlModule* NewModule);
	void OnBecomeActive(class UTgControlModule* OldModule);
	void Init();
};


// Class TgGame.TgControlModule_ThirdPerson
// 0x0068 (0x00D4 - 0x006C)
class UTgControlModule_ThirdPerson : public UTgControlModule
{
public:
	int                                                CameraYawOffset;                                          // 0x006C(0x0004)
	float                                              fRotInterpSpeed;                                          // 0x0070(0x0004)
	struct FVector2D                                   vIntoxicatedRotError;                                     // 0x0074(0x0008)
	float                                              fAimPitch;                                                // 0x007C(0x0004)
	struct FInterpCurveFloat                           PitchCurve;                                               // 0x0080(0x0014) (NeedCtorLink)
	struct FInterpCurveFloat                           PitchCurveDown;                                           // 0x0094(0x0014) (NeedCtorLink)
	struct FInterpCurveFloat                           AimCurve;                                                 // 0x00A8(0x0014) (NeedCtorLink)
	struct FInterpCurveFloat                           AimCurveDown;                                             // 0x00BC(0x0014) (NeedCtorLink)
	unsigned long                                      bForceUnrestrictedPitch : 1;                              // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_ThirdPerson");
		return ptr;
	}


	void AdjustAimingView(struct FVector* ViewLocation, struct FRotator* ViewRotation);
	bool IsAimingDown();
	bool IsFixedPitchMode();
	bool IsYawLocked();
	bool IsCameraOnlyLocked();
	bool IsCameraLocked();
	bool IsInputLocked();
	void UpdateAimPitch();
	void UpdateRotation(float DeltaTime);
	float STATIC_EvalUnrestrictedPitch(float InLookup);
	struct FVector STATIC_CalcNewAccel();
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void OnBecomeActive(class UTgControlModule* OldModule);
	void UpdatePitchCurve();
	void OnSettingsChanged(class UTgClientSettings* Settings);
	void Init();
};


// Class TgGame.TgControlModule_StunTaunted
// 0x000C (0x00E0 - 0x00D4)
class UTgControlModule_StunTaunted : public UTgControlModule_ThirdPerson
{
public:
	float                                              m_fInitialYaw;                                            // 0x00D4(0x0004)
	float                                              m_fInterpTime;                                            // 0x00D8(0x0004) (Const)
	float                                              m_fRemainingInterpTime;                                   // 0x00DC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_StunTaunted");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	struct FVector STATIC_CalcNewAccel();
	void OnBecomeInActive(class UTgControlModule* NewModule);
	void OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgControlModule_Dead
// 0x0000 (0x006C - 0x006C)
class UTgControlModule_Dead : public UTgControlModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Dead");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	void OnBecomeActive(class UTgControlModule* OldModule);
	bool STATIC_InterceptRawKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> Event, float AmountDepressed);
};


// Class TgGame.TgDeploy_HitOnLanded
// 0x0014 (0x040C - 0x03F8)
class ATgDeploy_HitOnLanded : public ATgDeploy_EffectVolume
{
public:
	unsigned long                                      m_bShouldFireAmmo : 1;                                    // 0x03F8(0x0004)
	TArray<class AActor*>                              s_LandedList;                                             // 0x03FC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_HitOnLanded");
		return ptr;
	}


	void STATIC_FireAmmunitionDeployable();
	void STATIC_OnActorLanded(class AActor* Other);
};


// Class TgGame.TgCarriedFlag
// 0x004C (0x02AC - 0x0260)
class ATgCarriedFlag : public AActor
{
public:
	int                                                r_nDefenderTaskForce;                                     // 0x0260(0x0004) (Net, Transient)
	class ATgCTFFlagBase*                              s_FlagBase;                                               // 0x0264(0x0008) (Transient)
	unsigned long                                      r_bIsHome : 1;                                            // 0x026C(0x0004) (Net, Transient)
	class ATgPawn_Character*                           m_Holder;                                                 // 0x0270(0x0008) (Transient)
	class ATgRepInfo_Player*                           r_HolderPRI;                                              // 0x0278(0x0008) (Net, Transient)
	class ATgPawn_Character*                           m_OldHolder;                                              // 0x0280(0x0008) (Transient)
	class AController*                                 m_FirstTouch;                                             // 0x0288(0x0008)
	TArray<class AController*>                         m_Assists;                                                // 0x0290(0x0010) (NeedCtorLink)
	float                                              m_fMaxDropTime;                                           // 0x02A0(0x0004)
	float                                              m_fDefaultRadius;                                         // 0x02A4(0x0004) (Transient)
	float                                              m_fDefaultHeight;                                         // 0x02A8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCarriedFlag");
		return ptr;
	}


	void STATIC_CheckPain();
	void STATIC_ClearOldHolder();
	void STATIC_Drop(class AController* Killer, bool bNoThrow);
	void STATIC_CheckFit();
	void AutoSendHome();
	void STATIC_Score();
	void STATIC_SendHome();
	void STATIC_ClearHolder();
	void STATIC_SetHolder(class AController* C);
	bool ValidHolder(class AActor* Other);
	void CheckTouching();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
};


// Class TgGame.TgCameraModule_FallOutOfWorld
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_FallOutOfWorld : public UTgCameraModule_Free
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_FallOutOfWorld");
		return ptr;
	}


	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgSeqAct_Stasis
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_Stasis : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_Stasis");
		return ptr;
	}

};


// Class TgGame.TgBasicSilhouetteComponent
// 0x0000 (0x0294 - 0x0294)
class UTgBasicSilhouetteComponent : public UTgSilhouetteComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBasicSilhouetteComponent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PlayEmote
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_PlayEmote : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EEmote>                                EmoteToPlay;                                              // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PlayEmote");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PurchaseItems
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PurchaseItems : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PurchaseItems");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_PurchaseSkills
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_PurchaseSkills : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_PurchaseSkills");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Regen
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_Regen : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Regen");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToOwner
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_RunToOwner : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToOwner");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToOwner_FanOut
// 0x000C (0x00A8 - 0x009C)
class UTgAIBehaviorAction_RunToOwner_FanOut : public UTgAIBehaviorAction_RunToOwner
{
public:
	TEnumAsByte<EPetPosition>                          m_eFanOutType;                                            // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	float                                              m_fDistanceAwayFromOwner;                                 // 0x00A0(0x0004) (Edit)
	unsigned long                                      m_bFollowerPositionUsesVelocity : 1;                      // 0x00A4(0x0004) (Edit)
	unsigned long                                      m_bEnableNGMLogic : 1;                                    // 0x00A4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToOwner_FanOut");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToSpawn
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_RunToSpawn : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToSpawn");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_RunToSpreadLocation
// 0x0000 (0x009C - 0x009C)
class UTgAIBehaviorAction_RunToSpreadLocation : public UTgAIBehaviorAction_MoveToTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_RunToSpreadLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectCombatTargetsTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectCombatTargetsTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bGodsOnly : 1;                                            // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectCombatTargetsTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget
// 0x0018 (0x00AC - 0x0094)
class UTgAIBehaviorAction_SelectLaneCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeWeakest : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bSelectRandom : 1;                                        // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveLineOfSight : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveDamagedGod : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustNotBeImmune : 1;                                     // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeSafeToTarget : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeInForwardCone : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeFurthest : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bCheckSpecialAIConditions : 1;                            // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     IgnoreTargetType;                                         // 0x0099(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x009A(0x0002) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)
	int                                                ExcludeEffectCategoryId;                                  // 0x00A0(0x0004) (Edit)
	float                                              DistanceThreshold;                                        // 0x00A4(0x0004) (Edit)
	float                                              ForwardConeAngle;                                         // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_Jungle
// 0x0005 (0x0099 - 0x0094)
class UTgAIBehaviorAction_SelectLaneCombatTarget_Jungle : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeWeakest : 1;                                       // 0x0094(0x0004) (Edit)
	TEnumAsByte<EJungleTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_Jungle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker
// 0x0005 (0x0099 - 0x0094)
class UTgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSkipPawnNotify : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bCheckSpecialAIConditions : 1;                            // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     IgnoreTargetType;                                         // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBePhoenix : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeSameLane : 1;                                      // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Jungle
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget_Jungle : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EJungleTargetType>                     TargetType;                                               // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Jungle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Minotaur
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget_Minotaur : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Minotaur");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_NearestJungle
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTarget_NearestJungle : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EJungleTargetType>                     TargetType;                                               // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_NearestJungle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSkipPawnNotify : 1;                                      // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectLeashCombatTarget
// 0x0010 (0x00A4 - 0x0094)
class UTgAIBehaviorAction_SelectLeashCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeWeakest : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveLineOfSight : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustHaveDamagedGod : 1;                                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustNotBeImmune : 1;                                     // 0x0094(0x0004) (Edit)
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bCheckSpecialAIConditions : 1;                            // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     IgnoreTargetType;                                         // 0x0099(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x009A(0x0002) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)
	int                                                ExcludeEffectCategoryId;                                  // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectLeashCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectOwnerAsTarget
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SelectOwnerAsTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bGodsOnly : 1;                                            // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectOwnerAsTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectSpecialCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectSpecialCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectSpecialCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectSquadCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SelectSquadCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectSquadCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SelectThreatCombatTarget
// 0x0010 (0x00A4 - 0x0094)
class UTgAIBehaviorAction_SelectThreatCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeHighestThreat : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeInLeash : 1;                                       // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeInSightRadius : 1;                                 // 0x0094(0x0004) (Edit)
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;                  // 0x0094(0x0004) (Edit)
	unsigned long                                      bMustBeHittable : 1;                                      // 0x0094(0x0004) (Edit)
	unsigned long                                      bCheckSpecialAIConditions : 1;                            // 0x0094(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     IgnoreTargetType;                                         // 0x0099(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x009A(0x0002) MISSED OFFSET
	int                                                EffectCategoryId;                                         // 0x009C(0x0004) (Edit)
	int                                                ExcludeEffectCategoryId;                                  // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SelectThreatCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SetOwnerGroundSpeedPercent
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorAction_SetOwnerGroundSpeedPercent : public UTgAIBehaviorAction
{
public:
	float                                              m_fNewPercent;                                            // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SetOwnerGroundSpeedPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SetPetPhase
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_SetPetPhase : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EPetPhase>                             NewPhaseName;                                             // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SetPetPhase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_Strafe
// 0x0008 (0x00A4 - 0x009C)
class UTgAIBehaviorAction_Strafe : public UTgAIBehaviorAction_MoveToTarget
{
public:
	float                                              StrafeUpdateTime;                                         // 0x009C(0x0004) (Edit)
	float                                              DistanceMultiplier;                                       // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_Strafe");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_SuggestSquadCombatTarget
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorAction_SuggestSquadCombatTarget : public UTgAIBehaviorAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_SuggestSquadCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseActive
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_UseActive : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EActiveType>                           ActiveType;                                               // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseActive");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseConsumable
// 0x0001 (0x0095 - 0x0094)
class UTgAIBehaviorAction_UseConsumable : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<EConsumableType>                       ConsumableType;                                           // 0x0094(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseConsumable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorAction_UseDevice
// 0x0002 (0x0096 - 0x0094)
class UTgAIBehaviorAction_UseDevice : public UTgAIBehaviorAction
{
public:
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceToUse;                                              // 0x0094(0x0001) (Edit)
	TEnumAsByte<EUseDeviceAimType>                     aimType;                                                  // 0x0095(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorAction_UseDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SequenceAND
// 0x0000 (0x00BC - 0x00BC)
class UTgAIBehaviorComposite_SequenceAND : public UTgAIBehaviorComposite_Sequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SequenceAND");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorComposite_SequenceOR
// 0x0000 (0x00BC - 0x00BC)
class UTgAIBehaviorComposite_SequenceOR : public UTgAIBehaviorComposite_Sequence
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorComposite_SequenceOR");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CanPurchaseItems
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CanPurchaseItems : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CanPurchaseItems");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CanPurchaseSkills
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CanPurchaseSkills : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CanPurchaseSkills");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDamageable
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDamageable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDamageable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDamageableByDevice
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDamageableByDevice : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDamageableByDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDamagedFriendlyGod
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDamagedFriendlyGod : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDamagedFriendlyGod");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetDropped
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetDropped : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetDropped");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CombatTargetHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetIsInMinotaurRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CombatTargetIsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetIsInMinotaurRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetIsInTowerRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CombatTargetIsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetIsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CombatTargetPhysicsState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_CombatTargetPhysicsState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPhysics>                              PhysicsState;                                             // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CombatTargetPhysicsState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_CurrentLevel
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_CurrentLevel : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                LevelThreshold;                                           // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_CurrentLevel");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DeviceIsFiring
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_DeviceIsFiring : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DeviceIsFiring");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DeviceReadyToUse
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_DeviceReadyToUse : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DeviceReadyToUse");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DifficultyLevel
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_DifficultyLevel : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EBotDifficultyLevel>                   Difficulty;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DifficultyLevel");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromCombatTarget
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DistanceFromCombatTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromLaneTarget
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DistanceFromLaneTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromLaneTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromNearestGod
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_DistanceFromNearestGod : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     GodType;                                                  // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromNearestGod");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromNearestJungleBuff
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_DistanceFromNearestJungleBuff : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EJungleTargetType>                     CampType;                                                 // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromNearestJungleBuff");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromNearestJungleCamp
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_DistanceFromNearestJungleCamp : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bCheckCampLiving : 1;                                     // 0x0098(0x0004) (Edit)
	TEnumAsByte<EJungleTargetType>                     CampType;                                                 // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromNearestJungleCamp");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromOwner
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DistanceFromOwner : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromOwner");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_DistanceFromSpawn
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_DistanceFromSpawn : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              DistanceThreshold;                                        // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_DistanceFromSpawn");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_Energy
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_Energy : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              Energy;                                                   // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_Energy");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_GameType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_GameType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_GAME_TYPE>                         GameType;                                                 // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_GameType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasActive
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_HasActive : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EActiveType>                           ActiveType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasActive");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasCombatTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasCombatTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasConsumable
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_HasConsumable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EConsumableType>                       ConsumableType;                                           // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasConsumable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasIncomingDamage
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasIncomingDamage : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasIncomingDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasLaneTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasLaneTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasLaneTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasMoveTarget
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasMoveTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasMoveTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HasSpreadLocation
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_HasSpreadLocation : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HasSpreadLocation");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_HealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_HealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_HealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsActiveReady
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsActiveReady : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EActiveType>                           ActiveType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsActiveReady");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAtRallyPoint
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAtRallyPoint : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAtRallyPoint");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsAtSpawn
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsAtSpawn : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsAtSpawn");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetHittable
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetHittable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bCheckSpecialAIConditions : 1;                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetHittable");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetHostile
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetHostile : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetHostile");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInFountain
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetInFountain : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetInFountain");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInLeash
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetInLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetInLeash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInSightRadius
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetInSightRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetInSightRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetLastAttacker
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetLastAttacker : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetLastAttacker");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetOfType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetOfType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetStealthed
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetStealthed : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bTreatUnhittableTargetsAsStealthed : 1;                   // 0x0098(0x0004) (Edit)
	unsigned long                                      bCheckSpecialAIConditions : 1;                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetStealthed");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetTargetingFriend
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetTargetingFriend : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetTargetingFriend");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsCombatTargetVisible
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsCombatTargetVisible : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bTreatUnhittableTargetsAsNotVisible : 1;                  // 0x0098(0x0004) (Edit)
	unsigned long                                      bCheckSpecialAIConditions : 1;                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsCombatTargetVisible");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsDeviceAimInTowerRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_IsDeviceAimInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsDeviceAimInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsFactoryAggro
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsFactoryAggro : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsFactoryAggro");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInHostileAbility
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsInHostileAbility : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInHostileAbility");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInJungle
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsInJungle : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInJungle");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInMinotaurRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInMinotaurRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsInTowerRadius
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLastAttackerOfType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsLastAttackerOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLastAttackerOfType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsLookingAtCombatTarget
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_IsLookingAtCombatTarget : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              VisibilityAngle;                                          // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsLookingAtCombatTarget");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsNonCombat
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsNonCombat : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsNonCombat");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsOutsideLeash
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsOutsideLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsOutsideLeash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsOwnerInLineOfSight
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsOwnerInLineOfSight : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsOwnerInLineOfSight");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsRoleType
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsRoleType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ERoleType>                             RoleType;                                                 // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsRoleType");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsSafeToRecall
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsSafeToRecall : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsSafeToRecall");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsTargetTypeInLeash
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsTargetTypeInLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsTargetTypeInLeash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsTooFarFromLane
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_IsTooFarFromLane : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsTooFarFromLane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsWithinCombatDistance
// 0x0008 (0x009D - 0x0095)
class UTgAIBehaviorCondition_IsWithinCombatDistance : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bSubtractTargetPawnRadius : 1;                            // 0x0098(0x0004) (Edit)
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsWithinCombatDistance");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsWithinDistance
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_IsWithinDistance : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bIsXYOnly : 1;                                            // 0x0098(0x0004) (Edit)
	float                                              DistanceCheck;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsWithinDistance");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_IsWithinDistanceOfOwner
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_IsWithinDistanceOfOwner : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bIsXYOnly : 1;                                            // 0x0098(0x0004) (Edit)
	float                                              DistanceCheck;                                            // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_IsWithinDistanceOfOwner");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_ManaPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_ManaPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              ManaPct;                                                  // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_ManaPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_MinotaurHealthPercent
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_MinotaurHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	float                                              HealthPct;                                                // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_MinotaurHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyGodCount
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_NearbyGodCount : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x009C(0x0004) (Edit)
	int                                                DistanceThreshold;                                        // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyGodCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyGodDelta
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NearbyGodDelta : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                GodThreshold;                                             // 0x0098(0x0004) (Edit)
	int                                                DistanceThreshold;                                        // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyGodDelta");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyMinionCount
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_NearbyMinionCount : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	int                                                MinionThreshold;                                          // 0x009C(0x0004) (Edit)
	int                                                DistanceThreshold;                                        // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyMinionCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyMinionDelta
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NearbyMinionDelta : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                MinionThreshold;                                          // 0x0098(0x0004) (Edit)
	int                                                DistanceThreshold;                                        // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyMinionDelta");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyTargetCount
// 0x0017 (0x00AC - 0x0095)
class UTgAIBehaviorCondition_NearbyTargetCount : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     eTargetType;                                              // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x009C(0x0004) (Edit)
	int                                                TargetThreshold;                                          // 0x00A0(0x0004) (Edit)
	int                                                DistanceThreshold;                                        // 0x00A4(0x0004) (Edit)
	float                                              HealthThreshold;                                          // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyTargetCount");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearbyTargetDelta
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_NearbyTargetDelta : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     eTargetType;                                              // 0x0098(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	int                                                TargetThreshold;                                          // 0x009C(0x0004) (Edit)
	int                                                DistanceThreshold;                                        // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearbyTargetDelta");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearestGodHealthPercent
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_NearestGodHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     GodType;                                                  // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearestGodHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearestPawnInMinotaurRadius
// 0x0008 (0x009D - 0x0095)
class UTgAIBehaviorCondition_NearestPawnInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	unsigned long                                      bMinotaurMustBeEnemy : 1;                                 // 0x0098(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     GodType;                                                  // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearestPawnInMinotaurRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearestPawnInTowerRadius
// 0x0008 (0x009D - 0x0095)
class UTgAIBehaviorCondition_NearestPawnInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	unsigned long                                      bTowerMustBeEnemy : 1;                                    // 0x0098(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     GodType;                                                  // 0x009C(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearestPawnInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearestTargetHealthPercent
// 0x000F (0x00A4 - 0x0095)
class UTgAIBehaviorCondition_NearestTargetHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x009C(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x00A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearestTargetHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NearestTowerHealthPercent
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NearestTowerHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMustBeEnemy : 1;                                         // 0x0098(0x0004) (Edit)
	float                                              HealthPct;                                                // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NearestTowerHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsInMinotaurRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumGodsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bGodsMustBeEnemy : 1;                                     // 0x0098(0x0004) (Edit)
	unsigned long                                      bMinotaurMustBeEnemy : 1;                                 // 0x0098(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsInMinotaurRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumGodsInTowerRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumGodsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bGodsMustBeEnemy : 1;                                     // 0x0098(0x0004) (Edit)
	unsigned long                                      bTowerMustBeEnemy : 1;                                    // 0x0098(0x0004) (Edit)
	int                                                GodThreshold;                                             // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumGodsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumMinionsInMinotaurRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumMinionsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMinionsMustBeEnemy : 1;                                  // 0x0098(0x0004) (Edit)
	unsigned long                                      bMinotaurMustBeEnemy : 1;                                 // 0x0098(0x0004) (Edit)
	int                                                MinionThreshold;                                          // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumMinionsInMinotaurRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_NumMinionsInTowerRadius
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_NumMinionsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	unsigned long                                      bMinionsMustBeEnemy : 1;                                  // 0x0098(0x0004) (Edit)
	unsigned long                                      bTowerMustBeEnemy : 1;                                    // 0x0098(0x0004) (Edit)
	int                                                MinionThreshold;                                          // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_NumMinionsInTowerRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_OwnerHealthPercent
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_OwnerHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              HealthPct;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_OwnerHealthPercent");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_OwnerIsVisibleToAI
// 0x0003 (0x0098 - 0x0095)
class UTgAIBehaviorCondition_OwnerIsVisibleToAI : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_OwnerIsVisibleToAI");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_OwnerPawnState
// 0x0003 (0x00A0 - 0x009D)
class UTgAIBehaviorCondition_OwnerPawnState : public UTgAIBehaviorCondition_PawnState
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_OwnerPawnState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_PetPhase
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_PetPhase : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPetPhase>                             Phase;                                                    // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_PetPhase");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_PhysicsState
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_PhysicsState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EPhysics>                              PhysicsState;                                             // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_PhysicsState");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_ReturnAlways
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_ReturnAlways : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<EBehaviorStatus>                       AlwaysReturn;                                             // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_ReturnAlways");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TargetsDamageableByDevice
// 0x000B (0x00A0 - 0x0095)
class UTgAIBehaviorCondition_TargetsDamageableByDevice : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ETG_EQUIP_POINT>                       DeviceSlot;                                               // 0x0098(0x0001) (Edit)
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0099(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x2];                                       // 0x009A(0x0002) MISSED OFFSET
	int                                                TargetCount;                                              // 0x009C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TargetsDamageableByDevice");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_Taskforce
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_Taskforce : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	int                                                TaskForce;                                                // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_Taskforce");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_Timer
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_Timer : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimerLength;                                              // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_Timer");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_TimeSinceLastTookDamage
// 0x0007 (0x009C - 0x0095)
class UTgAIBehaviorCondition_TimeSinceLastTookDamage : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	float                                              TimeThreshold;                                            // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_TimeSinceLastTookDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_WhatIsCombatTargetTargeting
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_WhatIsCombatTargetTargeting : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_WhatIsCombatTargetTargeting");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorCondition_WhatIsLastAttackerTargeting
// 0x0004 (0x0099 - 0x0095)
class UTgAIBehaviorCondition_WhatIsLastAttackerTargeting : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	TEnumAsByte<ECombatTargetType>                     TargetType;                                               // 0x0098(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorCondition_WhatIsLastAttackerTargeting");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Devices
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Devices : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Devices");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Gods
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Gods : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Gods");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_IncomingDamage
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_IncomingDamage : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_IncomingDamage");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_InHostileAbility
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_InHostileAbility : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_InHostileAbility");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_JungleCamps
// 0x0008 (0x009C - 0x0094)
class UTgAIBehaviorSensor_JungleCamps : public UTgAIBehaviorSensor
{
public:
	unsigned long                                      bOmniscient : 1;                                          // 0x0094(0x0004) (Edit)
	float                                              fCacheUpdateTimer;                                        // 0x0098(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_JungleCamps");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Lane
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Lane : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Lane");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Leash
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Leash : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Leash");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_PurchaseSkills
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_PurchaseSkills : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_PurchaseSkills");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_RallyPoints
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_RallyPoints : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_RallyPoints");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_SafeToRecall
// 0x0004 (0x0098 - 0x0094)
class UTgAIBehaviorSensor_SafeToRecall : public UTgAIBehaviorSensor
{
public:
	float                                              SafeRecallDist;                                           // 0x0094(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_SafeToRecall");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_SightRadius
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_SightRadius : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_SightRadius");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_Towers
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_Towers : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_Towers");
		return ptr;
	}

};


// Class TgGame.TgAIBehaviorSensor_TowersOnlyAvoidance
// 0x0000 (0x0094 - 0x0094)
class UTgAIBehaviorSensor_TowersOnlyAvoidance : public UTgAIBehaviorSensor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIBehaviorSensor_TowersOnlyAvoidance");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver_Pet
// 0x0000 (0x00A0 - 0x00A0)
class UTgAILocalPositionSolver_Pet : public UTgAILocalPositionSolver
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver_Pet");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver_PVEMinion
// 0x0000 (0x00A0 - 0x00A0)
class UTgAILocalPositionSolver_PVEMinion : public UTgAILocalPositionSolver_Pet
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver_PVEMinion");
		return ptr;
	}

};


// Class TgGame.TgAILocalPositionSolver_God
// 0x0000 (0x00A0 - 0x00A0)
class UTgAILocalPositionSolver_God : public UTgAILocalPositionSolver
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAILocalPositionSolver_God");
		return ptr;
	}

};


// Class TgGame.TgAIScout
// 0x0000 (0x061C - 0x061C)
class ATgAIScout : public AScout
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAIScout");
		return ptr;
	}

};


// Class TgGame.TgSkeletalMeshActor_Posture
// 0x0014 (0x02DC - 0x02C8)
class ATgSkeletalMeshActor_Posture : public ASkeletalMeshActor
{
public:
	TEnumAsByte<ETG_POSTURE>                           r_CurrentPosture;                                         // 0x02C8(0x0001) (Edit, Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C9(0x0003) MISSED OFFSET
	TArray<class UTgAnimBlendByPosture*>               m_PostureBlendNodes;                                      // 0x02CC(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_Posture");
		return ptr;
	}


	void STATIC_OnSetSkelPosture(class UTgSeqAct_SetSkelPosture* Action);
	void STATIC_InitPostureNodes();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void STATIC_SetActivePosture(TEnumAsByte<ETG_POSTURE> Posture);
	void ReplicatedEvent(const struct FName& VarName);
	void PostBeginPlay();
};


// Class TgGame.TgControlModule_Racer
// 0x0004 (0x00D8 - 0x00D4)
class UTgControlModule_Racer : public UTgControlModule_ThirdPerson
{
public:
	unsigned long                                      m_DebugAutoDrive : 1;                                     // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Racer");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	bool IsInputLocked();
	struct FVector STATIC_CalcNewAccel();
};


// Class TgGame.TgCameraModule_Racer
// 0x0010 (0x00B8 - 0x00A8)
class UTgCameraModule_Racer : public UTgCameraModule_ThirdPerson
{
public:
	unsigned long                                      m_ForceFreeCam : 1;                                       // 0x00A8(0x0004)
	float                                              m_LastRotation;                                           // 0x00AC(0x0004)
	float                                              m_PostWallBumpFaceRate;                                   // 0x00B0(0x0004)
	float                                              m_FOV;                                                    // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Racer");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamLocationOffset(const struct FRotator& PawnRot, class AActor* ViewTarget);
};


// Class TgGame.TgAnimMetaData_SkelControlKeyFrame
// 0x0000 (0x00A8 - 0x00A8)
class UTgAnimMetaData_SkelControlKeyFrame : public UTgAnimMetaData_SkelControl_BoneScale_KeyFrame
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimMetaData_SkelControlKeyFrame");
		return ptr;
	}

};


// Class TgGame.TgDevice_DaJi_Paolao_Dismount
// 0x0000 (0x0508 - 0x0508)
class ATgDevice_DaJi_Paolao_Dismount : public ATgDevice_AnvilSlamBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_Paolao_Dismount");
		return ptr;
	}


	void STATIC_ClientInterrupt();
	void InterruptFiring();
};


// Class TgGame.TgAnimNodeBlendList_JingWei_Dev4
// 0x0003 (0x016C - 0x0169)
class UTgAnimNodeBlendList_JingWei_Dev4 : public UTgAnimNodeBlendList_Staging_Multi
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0169(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendList_JingWei_Dev4");
		return ptr;
	}

};


// Class TgGame.TgAnimNodeBlendNPC
// 0x003C (0x01A4 - 0x0168)
class UTgAnimNodeBlendNPC : public UTgAnimNodeBlendList
{
public:
	float                                              m_NoCustomerPresentBlendInTime;                           // 0x0168(0x0004) (Edit)
	float                                              m_CustomerPresentBlendInTime;                             // 0x016C(0x0004) (Edit)
	float                                              m_GreetingBlendInTime;                                    // 0x0170(0x0004) (Edit)
	float                                              m_NoSaleBlendInTime;                                      // 0x0174(0x0004) (Edit)
	float                                              m_CallOutBlendInTime;                                     // 0x0178(0x0004) (Edit)
	float                                              m_SaleBlendInTime;                                        // 0x017C(0x0004) (Edit)
	float                                              m_TransCustomerPresentToNotPresentBlendInTime;            // 0x0180(0x0004) (Edit)
	TArray<struct FName>                               m_UninterruptibleAnims;                                   // 0x0184(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ENPCAnimationStates>                   m_QueuedChild;                                            // 0x0194(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0195(0x0003) MISSED OFFSET
	float                                              m_QueuedBlendTime;                                        // 0x0198(0x0004)
	struct FName                                       m_CurrentAnimPlaying;                                     // 0x019C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeBlendNPC");
		return ptr;
	}


	void STATIC_OnChildAnimEnd(const struct FAnimationEndInformation& Information);
	void STATIC_PlaySaleAnimation();
	void STATIC_PlayNoSaleAnimation();
	void STATIC_PlayCallOutAnimation();
	void STATIC_PlayCustomerPresentAnimation();
	void STATIC_PlayGreetingAnimation();
	void STATIC_PlayNoCustomerPresentAnimation();
	void STATIC_QueueActiveChild(TEnumAsByte<ENPCAnimationStates> QueuedChild, float BlendTime);
	bool IsAnUninterruptableAnim(const struct FName& AnimName);
};


// Class TgGame.TgAnimNodeSequenceByBoneRotation
// 0x001C (0x01C8 - 0x01AC)
class UTgAnimNodeSequenceByBoneRotation : public UAnimNodeSequence
{
public:
	struct FName                                       BoneName;                                                 // 0x01AC(0x0008) (Edit)
	TEnumAsByte<EAxis>                                 BoneAxis;                                                 // 0x01B4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01B5(0x0003) MISSED OFFSET
	TArray<struct FAnimByRotation>                     AnimList;                                                 // 0x01B8(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgAnimNodeSequenceByBoneRotation");
		return ptr;
	}


	void OnBecomeRelevant();
};


// Class TgGame.TgBasicSilhouetteComponent_ZMask
// 0x0000 (0x0294 - 0x0294)
class UTgBasicSilhouetteComponent_ZMask : public UTgBasicSilhouetteComponent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBasicSilhouetteComponent_ZMask");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_SpectatorFreeCam
// 0x001C (0x00B8 - 0x009C)
class UTgCameraModule_SpectatorFreeCam : public UTgCameraModule_Spectator
{
public:
	float                                              CurrentZoom;                                              // 0x009C(0x0004) (Transient)
	float                                              CurrentZoomAmount;                                        // 0x00A0(0x0004)
	struct FVector                                     CurrentSpringLocation;                                    // 0x00A4(0x000C)
	float                                              ZoomIncrement;                                            // 0x00B0(0x0004) (Edit, Config)
	float                                              SpringAmount;                                             // 0x00B4(0x0004) (Edit, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorFreeCam");
		return ptr;
	}


	void UpdateZoom(float DeltaTime, class ATgSpectatorController* Spectator);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void STATIC_ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void STATIC_GetNextTarget();
};


// Class TgGame.TgControlModule_Spectator
// 0x0010 (0x007C - 0x006C)
class UTgControlModule_Spectator : public UTgControlModule
{
public:
	float                                              RotationLimit;                                            // 0x006C(0x0004) (Edit, Config)
	float                                              SpectatorStallZ;                                          // 0x0070(0x0004) (Edit, Const, Config)
	float                                              SpectatorMinStallZ;                                       // 0x0074(0x0004) (Edit, Const, Config)
	unsigned long                                      bIgnoreCameraHeightRestriction : 1;                       // 0x0078(0x0004) (Edit, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Spectator");
		return ptr;
	}


	void STATIC_OnLeftMousePressed();
	bool STATIC_InterceptFlashInput(const struct FName& ButtonName, TEnumAsByte<EInputEvent> Event);
	void STATIC_GetActorListAtCursor(TArray<class AActor*>* ActorList);
	class APawn* STATIC_GetPawnAtCursor();
	void UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
};


// Class TgGame.TgControlModule_SpectatorFreeCam
// 0x002C (0x00A8 - 0x007C)
class UTgControlModule_SpectatorFreeCam : public UTgControlModule_Spectator
{
public:
	float                                              m_RotationVelPitch;                                       // 0x007C(0x0004)
	float                                              m_RotationVelYaw;                                         // 0x0080(0x0004)
	float                                              m_RotationAccelPitch;                                     // 0x0084(0x0004)
	float                                              m_RotationAccelYaw;                                       // 0x0088(0x0004)
	float                                              m_RotationAccelWeightPitch;                               // 0x008C(0x0004) (Edit, Config)
	float                                              m_RotationAccelWeightYaw;                                 // 0x0090(0x0004) (Edit, Config)
	float                                              m_RotationDecelWeightPitch;                               // 0x0094(0x0004) (Edit, Config)
	float                                              m_RotationDecelWeightYaw;                                 // 0x0098(0x0004) (Edit, Config)
	float                                              m_LastFrameX;                                             // 0x009C(0x0004)
	float                                              m_LastFrameY;                                             // 0x00A0(0x0004)
	unsigned long                                      m_bUseRigidMovement : 1;                                  // 0x00A4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_SpectatorFreeCam");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	void STATIC_GetNextTarget();
	class APawn* STATIC_GetNearestPawn();
};


// Class TgGame.TgSeqAct_ModifyFactorySpawn
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_ModifyFactorySpawn : public USequenceAction
{
public:
	int                                                ItemId;                                                   // 0x0108(0x0004) (Edit)
	int                                                NumStacks;                                                // 0x010C(0x0004) (Edit)
	float                                              Duration;                                                 // 0x0110(0x0004) (Edit)
	unsigned long                                      UsesTimerIndicator : 1;                                   // 0x0114(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ModifyFactorySpawn");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetBot
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_GetBot : public USequenceAction
{
public:
	int                                                m_nBotNumber;                                             // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetBot");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_Factory_FireGiantGC2015a
// 0x000C (0x02E4 - 0x02D8)
class ATgRepInfo_Factory_FireGiantGC2015a : public ATgRepInfo_Factory
{
public:
	TEnumAsByte<EFireGiantChestState>                  r_eChestState;                                            // 0x02D8(0x0001) (Net)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02D9(0x0003) MISSED OFFSET
	float                                              c_ChestOpeningOffset;                                     // 0x02DC(0x0004)
	unsigned long                                      c_bChestTriggered : 1;                                    // 0x02E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Factory_FireGiantGC2015a");
		return ptr;
	}


	void UpdateChestFromPawn(float ChestStartOffset);
	void UpdateChestState(TEnumAsByte<EFireGiantChestState> NewChestState);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgBotFactory_FireGiant_GC2015a
// 0x0011 (0x043D - 0x042C)
class ATgBotFactory_FireGiant_GC2015a : public ATgBotFactory_Leashed
{
public:
	TArray<class ATgSkeletalMeshActor_FireGiantIntro_GC2015a*> ChestActors;                                              // 0x042C(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<EFireGiantChestState>                  ChestState;                                               // 0x043C(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgBotFactory_FireGiant_GC2015a");
		return ptr;
	}


	void UpdateChestFromPawn(float fCurrentTimeOffset);
	void UpdateChestFromRepInfo(TEnumAsByte<EFireGiantChestState> NewState);
};


// Class TgGame.TgRepInfo_Factory_Configurable
// 0x0004 (0x02DC - 0x02D8)
class ATgRepInfo_Factory_Configurable : public ATgRepInfo_Factory
{
public:
	int                                                r_nConfiguration;                                         // 0x02D8(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Factory_Configurable");
		return ptr;
	}


	void UpdateFactoryConfiguration();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgSeqAct_GetPEPInfo
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetPEPInfo : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetPEPInfo");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_Factory_Configurable_PEP
// 0x0008 (0x02E4 - 0x02DC)
class ATgRepInfo_Factory_Configurable_PEP : public ATgRepInfo_Factory_Configurable
{
public:
	class ATgRepInfo_Game_PEP*                         m_GRIPEP;                                                 // 0x02DC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_Factory_Configurable_PEP");
		return ptr;
	}


	void UpdateInWorldIndicators();
};


// Class TgGame.TgCameraModule_ApolloChariot
// 0x0000 (0x00A8 - 0x00A8)
class UTgCameraModule_ApolloChariot : public UTgCameraModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_ApolloChariot");
		return ptr;
	}


	void STATIC_ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_AthenaUlt
// 0x0010 (0x00B8 - 0x00A8)
class UTgCameraModule_AthenaUlt : public UTgCameraModule_ThirdPerson
{
public:
	unsigned long                                      m_bGrabCurrentFOV : 1;                                    // 0x00A8(0x0004)
	float                                              m_fInterpSpeed;                                           // 0x00AC(0x0004)
	float                                              m_fAimFOVInterp;                                          // 0x00B0(0x0004)
	float                                              m_fAimFOV;                                                // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_AthenaUlt");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_Attached
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Attached : public UTgCameraModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Attached");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FRotator STATIC_GetAttachRotation(class APawn* ViewTarget);
	struct FVector STATIC_GetAttachLocation(class APawn* ViewTarget);
};


// Class TgGame.TgCameraModule_ThirdPerson_Offset
// 0x0000 (0x00A8 - 0x00A8)
class UTgCameraModule_ThirdPerson_Offset : public UTgCameraModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_ThirdPerson_Offset");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_BabaYagaA04
// 0x000C (0x00B4 - 0x00A8)
class UTgCameraModule_BabaYagaA04 : public UTgCameraModule_ThirdPerson_Offset
{
public:
	float                                              m_fOffsetX;                                               // 0x00A8(0x0004)
	float                                              m_fOffsetY;                                               // 0x00AC(0x0004)
	float                                              m_fOffsetZ;                                               // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_BabaYagaA04");
		return ptr;
	}


	struct FVector STATIC_GetCamLocationOffset(const struct FRotator& PawnRot, class AActor* ViewTarget);
};


// Class TgGame.TgCameraModule_CamazotzUltimate
// 0x0008 (0x00B0 - 0x00A8)
class UTgCameraModule_CamazotzUltimate : public UTgCameraModule_ThirdPerson
{
public:
	float                                              fStoredZoomFactor;                                        // 0x00A8(0x0004)
	float                                              fStoredZoomFactorInterp;                                  // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_CamazotzUltimate");
		return ptr;
	}


	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_Cinematic
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Cinematic : public UTgCameraModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Cinematic");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Dead
// 0x0004 (0x0080 - 0x007C)
class UTgCameraModule_Dead : public UTgCameraModule_Free
{
public:
	float                                              c_fCurrentZoom;                                           // 0x007C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Dead");
		return ptr;
	}


	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_Depthzy_Dead
// 0x0021 (0x00A1 - 0x0080)
class UTgCameraModule_Depthzy_Dead : public UTgCameraModule_Dead
{
public:
	struct FDepthzyDeadCameraSetup                     m_cameraSettings[0x2];                                    // 0x0080(0x0010) (Const)
	TEnumAsByte<EDepthzyMeshSwapStance>                m_eCurrentSettingsState;                                  // 0x00A0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Depthzy_Dead");
		return ptr;
	}


	struct FVector STATIC_GetCamLocationOffset(class APawn* P);
	void STATIC_ProcessInput(class UPlayerInput* PlayerInput, float DeltaTime);
};


// Class TgGame.TgCameraModule_Hachiman_Ult_MountedArchery
// 0x0000 (0x00A8 - 0x00A8)
class UTgCameraModule_Hachiman_Ult_MountedArchery : public UTgCameraModule_ThirdPerson_Offset
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Hachiman_Ult_MountedArchery");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_JingWeiUltimate
// 0x001C (0x00C4 - 0x00A8)
class UTgCameraModule_JingWeiUltimate : public UTgCameraModule_ThirdPerson
{
public:
	struct FVector                                     m_CamLocation;                                            // 0x00A8(0x000C)
	struct FVector                                     m_FollowVelocity;                                         // 0x00B4(0x000C)
	float                                              m_PawnVelocityModifier;                                   // 0x00C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_JingWeiUltimate");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamAttachPoint(class AActor* ViewTarget);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	struct FVector STATIC_GetDefaultCamAttachPoint(class AActor* ActorTarget);
};


// Class TgGame.TgCameraModule_LockToPawnRotation
// 0x0000 (0x00A8 - 0x00A8)
class UTgCameraModule_LockToPawnRotation : public UTgCameraModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_LockToPawnRotation");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_LockToPlane
// 0x0018 (0x00C0 - 0x00A8)
class UTgCameraModule_LockToPlane : public UTgCameraModule_ThirdPerson
{
public:
	struct FVector                                     m_PlaneNormal;                                            // 0x00A8(0x000C)
	struct FVector                                     m_PointOnPlane;                                           // 0x00B4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_LockToPlane");
		return ptr;
	}


	struct FVector STATIC_GetCamAttachPoint(class AActor* ViewTarget);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_Minotaur
// 0x0000 (0x0068 - 0x0068)
class UTgCameraModule_Minotaur : public UTgCameraModule_Attached
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Minotaur");
		return ptr;
	}


	struct FRotator STATIC_FindGoodActorRotation(class ATgPawn* P);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgCameraModule_Neith_WorldWeaver
// 0x0010 (0x00B8 - 0x00A8)
class UTgCameraModule_Neith_WorldWeaver : public UTgCameraModule_ThirdPerson
{
public:
	unsigned long                                      m_bGrabCurrentFOV : 1;                                    // 0x00A8(0x0004)
	float                                              m_fInterpSpeed;                                           // 0x00AC(0x0004)
	float                                              m_fAimFOVInterp;                                          // 0x00B0(0x0004)
	float                                              m_fAimFOV;                                                // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Neith_WorldWeaver");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_NuWaUltimate
// 0x0000 (0x00A8 - 0x00A8)
class UTgCameraModule_NuWaUltimate : public UTgCameraModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_NuWaUltimate");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_PlayerOverview
// 0x0000 (0x00A8 - 0x00A8)
class UTgCameraModule_PlayerOverview : public UTgCameraModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_PlayerOverview");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_Ram_Ult_AstralArrow
// 0x0008 (0x00B0 - 0x00A8)
class UTgCameraModule_Ram_Ult_AstralArrow : public UTgCameraModule_ThirdPerson
{
public:
	float                                              fStoredZoomFactor;                                        // 0x00A8(0x0004)
	float                                              fStoredZoomFactorInterp;                                  // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Ram_Ult_AstralArrow");
		return ptr;
	}


	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_SpectatorLockedView
// 0x001C (0x00B8 - 0x009C)
class UTgCameraModule_SpectatorLockedView : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                        // 0x009C(0x000C) (Edit)
	unsigned long                                      bAutoRotate : 1;                                          // 0x00A8(0x0004) (Edit)
	float                                              FOV;                                                      // 0x00AC(0x0004)
	float                                              ZoomIncrement;                                            // 0x00B0(0x0004)
	int                                                CurrentWorldViewTargetIndex;                              // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorLockedView");
		return ptr;
	}


	void STATIC_RotateView();
	void ZoomOut();
	void ZoomIn();
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	void BlendCameraToLocation(const struct FVector& NewLocation, float BlendTime, bool bUseFocalPoint);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgControlModule_SpectatorLockedView
// 0x0008 (0x0084 - 0x007C)
class UTgControlModule_SpectatorLockedView : public UTgControlModule_Spectator
{
public:
	float                                              DirectorModeSpectatorStallZ;                              // 0x007C(0x0004) (Const, Config)
	float                                              DirectorModeSpectatorMinStallZ;                           // 0x0080(0x0004) (Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_SpectatorLockedView");
		return ptr;
	}


	void STATIC_PlayerMove(float DeltaTime);
	float STATIC_GetMinStallZ();
	float STATIC_GetMaxStallZ();
};


// Class TgGame.TgControlModule_SpectatorOverview
// 0x000C (0x0088 - 0x007C)
class UTgControlModule_SpectatorOverview : public UTgControlModule_Spectator
{
public:
	float                                              DirectorModeSpectatorStallZ;                              // 0x007C(0x0004) (Edit, Const, Config)
	float                                              DirectorModeSpectatorMinStallZ;                           // 0x0080(0x0004) (Edit, Const, Config)
	unsigned long                                      bIgnoreCapture : 1;                                       // 0x0084(0x0004) (Edit)
	unsigned long                                      bCaptureOnInactive : 1;                                   // 0x0084(0x0004) (Edit)
	unsigned long                                      m_bActiveInExpertMode : 1;                                // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_SpectatorOverview");
		return ptr;
	}


	void STATIC_OnRightMouseReleased();
	void STATIC_OnRightMousePressed();
	void STATIC_OnLeftMousePressed();
	void UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	float STATIC_GetMinStallZ();
	float STATIC_GetMaxStallZ();
	void OnBecomeInActive(class UTgControlModule* NewModule);
	void OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgCameraModule_SpectatorOverview_Console
// 0x0000 (0x0150 - 0x0150)
class UTgCameraModule_SpectatorOverview_Console : public UTgCameraModule_SpectatorOverview
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_SpectatorOverview_Console");
		return ptr;
	}

};


// Class TgGame.TgCameraModule_ThirdPersonVariableHeight
// 0x0004 (0x00AC - 0x00A8)
class UTgCameraModule_ThirdPersonVariableHeight : public UTgCameraModule_ThirdPerson
{
public:
	float                                              ZOffset;                                                  // 0x00A8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_ThirdPersonVariableHeight");
		return ptr;
	}


	void ZoomOut();
	void ZoomIn();
	struct FVector STATIC_GetCamLocationOffset(const struct FRotator& PawnRot, class AActor* ViewTarget);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
};


// Class TgGame.TgCameraModule_Test
// 0x000C (0x00B8 - 0x00AC)
class UTgCameraModule_Test : public UTgCameraModule_ThirdPersonVariableHeight
{
public:
	struct FRotator                                    FixedRotation;                                            // 0x00AC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Test");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamLocationOffset(const struct FRotator& PawnRot, class AActor* ViewTarget);
};


// Class TgGame.TgCameraModule_Thor_HammerJump
// 0x0000 (0x00A8 - 0x00A8)
class UTgCameraModule_Thor_HammerJump : public UTgCameraModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_Thor_HammerJump");
		return ptr;
	}


	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
	struct FVector STATIC_GetCamAttachPoint(class AActor* ViewTarget);
};


// Class TgGame.TgCameraModule_TopDown
// 0x000C (0x00A8 - 0x009C)
class UTgCameraModule_TopDown : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                        // 0x009C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCameraModule_TopDown");
		return ptr;
	}


	void BlendToTarget(float BlendTime);
	void OnBecomeInActive(class UTgCameraModule* NewCamera);
	void OnBecomeActive(class UTgCameraModule* OldCamera);
	void UpdateCamera(class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT);
};


// Class TgGame.TgControlModule_TopDown
// 0x0004 (0x0080 - 0x007C)
class UTgControlModule_TopDown : public UTgControlModule_Spectator
{
public:
	float                                              DefaultStartHeight;                                       // 0x007C(0x0004) (Const, Config)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_TopDown");
		return ptr;
	}


	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgSeqEvent_ControlPointOwnershipChange
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_ControlPointOwnershipChange : public USequenceEvent
{
public:
	int                                                PointIndex;                                               // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ControlPointOwnershipChange");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ControlPointOwnershipChange_Server
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_ControlPointOwnershipChange_Server : public USequenceEvent
{
public:
	int                                                PointIndex;                                               // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ControlPointOwnershipChange_Server");
		return ptr;
	}

};


// Class TgGame.TgCTFFlagBase
// 0x0014 (0x0274 - 0x0260)
class ATgCTFFlagBase : public AActor
{
public:
	int                                                m_nDefenderTaskForce;                                     // 0x0260(0x0004) (Edit, Const)
	class ATgCarriedFlag*                              m_SpawnedFlag;                                            // 0x0264(0x0008) (Transient)
	class ATgGame_CTF*                                 m_CTFGame;                                                // 0x026C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCTFFlagBase");
		return ptr;
	}


	void STATIC_DestroyFlag();
	void STATIC_SpawnFlag();
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void CheckTouching();
	void PostBeginPlay();
};


// Class TgGame.TgControlModule_Test
// 0x0000 (0x00D4 - 0x00D4)
class UTgControlModule_Test : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Test");
		return ptr;
	}


	void AdjustAimingView(struct FVector* ViewLocation, struct FRotator* ViewRotation);
	void UpdateRotation(float DeltaTime);
	struct FVector STATIC_CalcNewAccel();
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
	void OnBecomeInActive(class UTgControlModule* NewModule);
	void OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgControlModule_BaseEngine
// 0x0000 (0x006C - 0x006C)
class UTgControlModule_BaseEngine : public UTgControlModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_BaseEngine");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_ApolloChariot
// 0x0010 (0x00E4 - 0x00D4)
class UTgControlModule_ApolloChariot : public UTgControlModule_ThirdPerson
{
public:
	float                                              m_fPawnTurnMultipler;                                     // 0x00D4(0x0004)
	struct FRotator                                    m_BodyRotation;                                           // 0x00D8(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_ApolloChariot");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	struct FVector STATIC_CalcNewAccel();
};


// Class TgGame.TgControlModule_NeZha_Ultimate
// 0x0000 (0x00D4 - 0x00D4)
class UTgControlModule_NeZha_Ultimate : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_NeZha_Ultimate");
		return ptr;
	}


	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_Awilix_Reposition
// 0x0000 (0x00D4 - 0x00D4)
class UTgControlModule_Awilix_Reposition : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Awilix_Reposition");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
};


// Class TgGame.TgSeqAct_RestartPlayers
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_RestartPlayers : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_RestartPlayers");
		return ptr;
	}

};


// Class TgGame.TgControlModule_Panicked
// 0x0014 (0x00E8 - 0x00D4)
class UTgControlModule_Panicked : public UTgControlModule_ThirdPerson
{
public:
	float                                              c_fLastSwitchTime;                                        // 0x00D4(0x0004)
	float                                              c_fNextSwitchTime;                                        // 0x00D8(0x0004)
	struct FVector                                     c_vCurrentDirection;                                      // 0x00DC(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Panicked");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	void STATIC_ChangeDirections();
	struct FVector STATIC_CalcNewAccel();
	void OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgControlModule_Stunned
// 0x0000 (0x00D4 - 0x00D4)
class UTgControlModule_Stunned : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Stunned");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	struct FVector STATIC_CalcNewAccel();
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
};


// Class TgGame.TgControlModule_StunDisoriented
// 0x0010 (0x00E4 - 0x00D4)
class UTgControlModule_StunDisoriented : public UTgControlModule_Stunned
{
public:
	int                                                m_nInitialYaw;                                            // 0x00D4(0x0004)
	int                                                m_nTargetYaw;                                             // 0x00D8(0x0004)
	float                                              m_fInterpTime;                                            // 0x00DC(0x0004) (Const)
	float                                              m_fRemainingInterpTime;                                   // 0x00E0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_StunDisoriented");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	void OnBecomeActive(class UTgControlModule* OldModule);
};


// Class TgGame.TgSeqAct_TgCameraShake
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TgCameraShake : public USequenceAction
{
public:
	class UTgCameraShake*                              m_CameraShake;                                            // 0x0108(0x0008) (Edit)
	class AActor*                                      m_LocationActor;                                          // 0x0110(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TgCameraShake");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_LogTutorialAction
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_LogTutorialAction : public USequenceAction
{
public:
	int                                                PlayerAction;                                             // 0x0108(0x0004) (Edit)
	int                                                EventData;                                                // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LogTutorialAction");
		return ptr;
	}

};


// Class TgGame.TgTutorialAnnouncer
// 0x0020 (0x0080 - 0x0060)
class UTgTutorialAnnouncer : public UObject
{
public:
	TArray<class USoundCue*>                           QueuedSounds;                                             // 0x0060(0x0010) (Transient, NeedCtorLink)
	class UAudioComponent*                             CurrentSoundAC;                                           // 0x0070(0x0008) (ExportObject, Transient, Component, EditInline)
	class ATgPlayerController*                         OwnerPC;                                                  // 0x0078(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTutorialAnnouncer");
		return ptr;
	}


	void STATIC_StopAnnouncement(bool bFlushOthers);
	void STATIC_PlayAnnouncement(class USoundCue* CueToPlay, bool bPlayImmediately, bool bFlushOthers);
	void AudioFinishedPlaying(class UAudioComponent* AC);
	void Destroyed();
	void Init();
};


// Class TgGame.TgSeqEvent_CrowdEvent
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_CrowdEvent : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_CrowdEvent");
		return ptr;
	}

};


// Class TgGame.TgControlModule_PlayerOverview
// 0x0000 (0x00D4 - 0x00D4)
class UTgControlModule_PlayerOverview : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_PlayerOverview");
		return ptr;
	}


	bool IsFixedPitchMode();
	void UpdatePitchCurve();
};


// Class TgGame.TgSavedMove
// 0x0028 (0x0140 - 0x0118)
class UTgSavedMove : public USavedMove
{
public:
	unsigned char                                      m_nChargeNumber;                                          // 0x0118(0x0001)
	unsigned char                                      m_eChargeState;                                           // 0x0119(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x011A(0x0002) MISSED OFFSET
	int                                                m_nChargeInitialYaw;                                      // 0x011C(0x0004)
	struct FVector                                     m_vChargeInitialLocation;                                 // 0x0120(0x000C)
	float                                              m_fChargeSpeed;                                           // 0x012C(0x0004)
	float                                              m_fChargeRange;                                           // 0x0130(0x0004)
	unsigned long                                      m_bChargeIgnoreHumanoidBlocking : 1;                      // 0x0134(0x0004)
	unsigned long                                      m_bWantsCharge : 1;                                       // 0x0134(0x0004)
	unsigned long                                      m_bSavedWantsCharge : 1;                                  // 0x0134(0x0004)
	class ATgPawn*                                     m_ChargeTarget;                                           // 0x0138(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSavedMove");
		return ptr;
	}


	TEnumAsByte<EDoubleClickDir> STATIC_SetFlags(unsigned char Flags, class APlayerController* PC);
	unsigned char CompressedFlags();
	void STATIC_ResetMoveFor(class APawn* P);
	void STATIC_PrepMoveFor(class APawn* P);
	bool CanCombineWith(class USavedMove* NewMove, class APawn* inPawn, float MaxDelta);
	void STATIC_SetMoveFor(class APlayerController* P, float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> InDoubleClick);
	bool STATIC_IsImportantMove(const struct FVector& CompareAccel);
	void STATIC_PostUpdate(class APlayerController* P);
	void Clear();
};


// Class TgGame.TgOnlineGameSettings
// 0x0000 (0x0144 - 0x0144)
class UTgOnlineGameSettings : public UOnlineGameSettings
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgOnlineGameSettings");
		return ptr;
	}

};


// Class TgGame.TgProj_AhMuzenCab_Num2
// 0x001C (0x03B4 - 0x0398)
class ATgProj_AhMuzenCab_Num2 : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x0398(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x039C(0x0010) (NeedCtorLink)
	class ATgAhMuzenCabSwarmInstance*                  m_Strain;                                                 // 0x03AC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AhMuzenCab_Num2");
		return ptr;
	}


	void ShutDown();
	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgControlModule_ChironChargeAim
// 0x0010 (0x00E4 - 0x00D4)
class UTgControlModule_ChironChargeAim : public UTgControlModule_ThirdPerson
{
public:
	float                                              m_fPawnTurnMultipler;                                     // 0x00D4(0x0004)
	struct FRotator                                    c_DesiredPawnRotation;                                    // 0x00D8(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_ChironChargeAim");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	struct FVector STATIC_CalcNewAccel();
};


// Class TgGame.TgControlModule_Dummy
// 0x0000 (0x006C - 0x006C)
class UTgControlModule_Dummy : public UTgControlModule
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Dummy");
		return ptr;
	}

};


// Class TgGame.TgControlModule_Free
// 0x0004 (0x0070 - 0x006C)
class UTgControlModule_Free : public UTgControlModule
{
public:
	int                                                CameraYawOffset;                                          // 0x006C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Free");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	void STATIC_PlayerMove(float DeltaTime);
	void STATIC_ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	struct FRotator GetBaseAimRotation(class AWeapon* W, bool bIgnoreAutoLock);
};


// Class TgGame.TgControlModule_HachimanChargeSpeedInput
// 0x0010 (0x00F4 - 0x00E4)
class UTgControlModule_HachimanChargeSpeedInput : public UTgControlModule_ChironChargeAim
{
public:
	int                                                m_nYawLock;                                               // 0x00E4(0x0004)
	int                                                m_nPitchLock;                                             // 0x00E8(0x0004)
	int                                                m_nPitchCenter;                                           // 0x00EC(0x0004)
	int                                                m_nCameraLimit;                                           // 0x00F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_HachimanChargeSpeedInput");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
	bool IsFixedPitchMode();
	struct FVector STATIC_CalcNewAccel();
};


// Class TgGame.TgControlModule_Khepri_CrawlBack
// 0x0000 (0x00D4 - 0x00D4)
class UTgControlModule_Khepri_CrawlBack : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Khepri_CrawlBack");
		return ptr;
	}


	struct FVector STATIC_CalcNewAccel();
};


// Class TgGame.TgControlModule_Persephone_A03
// 0x000C (0x00E0 - 0x00D4)
class UTgControlModule_Persephone_A03 : public UTgControlModule_ThirdPerson
{
public:
	struct FRotator                                    m_rForwardDirection;                                      // 0x00D4(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Persephone_A03");
		return ptr;
	}


	void UpdateRotation(float DeltaTime);
};


// Class TgGame.TgControlModule_Persephone_Dead
// 0x0008 (0x0074 - 0x006C)
class UTgControlModule_Persephone_Dead : public UTgControlModule_Dead
{
public:
	class ATgPawn_Persephone*                          m_persephone;                                             // 0x006C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_Persephone_Dead");
		return ptr;
	}


	bool STATIC_InterceptRawKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> Event, float AmountDepressed);
	void Init();
};


// Class TgGame.TgControlModule_RatatoskrUltimate
// 0x0000 (0x00D4 - 0x00D4)
class UTgControlModule_RatatoskrUltimate : public UTgControlModule_ThirdPerson
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgControlModule_RatatoskrUltimate");
		return ptr;
	}


	struct FVector STATIC_CalcNewAccel();
};


// Class TgGame.TgCTFVolume
// 0x0004 (0x02F8 - 0x02F4)
class ATgCTFVolume : public APhysicsVolume
{
public:
	int                                                m_nDefenderTeamIndex;                                     // 0x02F4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgCTFVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	int STATIC_SortByTimestamp(class ATgPawn* A, class ATgPawn* B);
	bool IsValidToucher(class ATgPawn_Character* TgP);
	void TimerPop(class AVolumeTimer* T);
};


// Class TgGame.TgDamageType_AnubisDeathGaze
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_AnubisDeathGaze : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_AnubisDeathGaze");
		return ptr;
	}

};


// Class TgGame.TgDamageType_AnubisT5_HighImpulse
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_AnubisT5_HighImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_AnubisT5_HighImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_AnubisT5_MidImpulse
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_AnubisT5_MidImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_AnubisT5_MidImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_Frozen
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_Frozen : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_Frozen");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralAfflicted
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_GeneralAfflicted : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralAfflicted");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralCharred
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_GeneralCharred : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralCharred");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralConcussion
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_GeneralConcussion : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralConcussion");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralElectric
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_GeneralElectric : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralElectric");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralFlattened
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_GeneralFlattened : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralFlattened");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralImpulseOut
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_GeneralImpulseOut : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralImpulseOut");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralMidImpulse
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_GeneralMidImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralMidImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_GeneralOnFire
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_GeneralOnFire : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_GeneralOnFire");
		return ptr;
	}

};


// Class TgGame.TgDamageType_HerculesExcavate
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_HerculesExcavate : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_HerculesExcavate");
		return ptr;
	}

};


// Class TgGame.TgDamageType_Medusa_Dev2
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_Medusa_Dev2 : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_Medusa_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDamageType_MegaKill
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_MegaKill : public UTgDamageType_GeneralConcussion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_MegaKill");
		return ptr;
	}

};


// Class TgGame.TgDamageType_MeleeBasicAttack
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_MeleeBasicAttack : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_MeleeBasicAttack");
		return ptr;
	}

};


// Class TgGame.TgDamageType_MeleeBasicAttackImpulse
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_MeleeBasicAttackImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_MeleeBasicAttackImpulse");
		return ptr;
	}


	float STATIC_GetRagdollImpulseMultiplier(class AActor* DamageInstigator);
};


// Class TgGame.TgDamageType_RaCelestialBeam
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_RaCelestialBeam : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_RaCelestialBeam");
		return ptr;
	}

};


// Class TgGame.TgDamageType_RangedBasicAttack
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_RangedBasicAttack : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_RangedBasicAttack");
		return ptr;
	}

};


// Class TgGame.TgDamageType_RangedBasicAttackImpulse
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_RangedBasicAttackImpulse : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_RangedBasicAttackImpulse");
		return ptr;
	}

};


// Class TgGame.TgDamageType_SobekTailWhip
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_SobekTailWhip : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_SobekTailWhip");
		return ptr;
	}

};


// Class TgGame.TgDamageType_SoulRip
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_SoulRip : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_SoulRip");
		return ptr;
	}

};


// Class TgGame.TgDamageType_Terra_MegaPunch
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_Terra_MegaPunch : public UTgDamageType_GeneralConcussion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_Terra_MegaPunch");
		return ptr;
	}

};


// Class TgGame.TgDamageType_ThanatosExecute
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_ThanatosExecute : public UTgDamageType_GeneralConcussion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_ThanatosExecute");
		return ptr;
	}

};


// Class TgGame.TgDamageType_ThanatosExecuteMinion
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_ThanatosExecuteMinion : public UTgDamageType_ThanatosExecute
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_ThanatosExecuteMinion");
		return ptr;
	}

};


// Class TgGame.TgDamageType_ThorAnvilOfDawn
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_ThorAnvilOfDawn : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_ThorAnvilOfDawn");
		return ptr;
	}

};


// Class TgGame.TgDamageType_VulcanBackfire
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_VulcanBackfire : public UTgDamageType
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_VulcanBackfire");
		return ptr;
	}

};


// Class TgGame.TgDamageType_VulcanSauce
// 0x0000 (0x0104 - 0x0104)
class UTgDamageType_VulcanSauce : public UTgDamageType_GeneralConcussion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDamageType_VulcanSauce");
		return ptr;
	}

};


// Class TgGame.TgDebugCameraController
// 0x0000 (0x07A4 - 0x07A4)
class ATgDebugCameraController : public ADebugCameraController
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDebugCameraController");
		return ptr;
	}


	void DisableDebugCamera();
	void Camera(const struct FName& NewMode);
};


// Class TgGame.TgDebugCameraInput
// 0x0000 (0x02D4 - 0x02D4)
class UTgDebugCameraInput : public UDebugCameraInput
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDebugCameraInput");
		return ptr;
	}

};


// Class TgGame.TgDefensePoint
// 0x0024 (0x0380 - 0x035C)
class ATgDefensePoint : public ATgNavigationPoint
{
public:
	class AController*                                 CurrentUser;                                              // 0x035C(0x0008)
	class ATgDefensePoint*                             NextDefensePoint;                                         // 0x0364(0x0008)
	unsigned long                                      bFirstScript : 1;                                         // 0x036C(0x0004)
	unsigned long                                      bSniping : 1;                                             // 0x036C(0x0004) (Edit)
	unsigned long                                      bDontChangePosition : 1;                                  // 0x036C(0x0004) (Edit)
	unsigned long                                      bAvoid : 1;                                               // 0x036C(0x0004)
	unsigned long                                      bDisabled : 1;                                            // 0x036C(0x0004)
	unsigned long                                      bNotInVehicle : 1;                                        // 0x036C(0x0004) (Edit)
	unsigned char                                      Priority;                                                 // 0x0370(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0371(0x0003) MISSED OFFSET
	class UClass*                                      WeaponPreference;                                         // 0x0374(0x0008) (Edit)
	float                                              NumChecked;                                               // 0x037C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDefensePoint");
		return ptr;
	}


	class AActor* STATIC_GetMoveTarget();
	bool STATIC_HigherPriorityThan(class ATgDefensePoint* S, class ATgAIController* B);
	void PreBeginPlay();
	void STATIC_FreePoint();
	void Reset();
};


// Class TgGame.TgSpectatorTempCam
// 0x0004 (0x0404 - 0x0400)
class ATgSpectatorTempCam : public ADynamicCameraActor
{
public:
	unsigned long                                      bIsViewTarget : 1;                                        // 0x0400(0x0004)
	unsigned long                                      bIsBookmark : 1;                                          // 0x0400(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSpectatorTempCam");
		return ptr;
	}


	void STATIC_DestroyIfNeeded();
	void STATIC_SetIsBookmark(bool bBookmark);
	void EndViewTarget(class APlayerController* PC);
	void BecomeViewTarget(class APlayerController* PC);
};


// Class TgGame.TgDeploy_AimForward
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeploy_AimForward : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_AimForward");
		return ptr;
	}


	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
};


// Class TgGame.TgDeploy_Bellona_VeniVidiVici
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeploy_Bellona_VeniVidiVici : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Bellona_VeniVidiVici");
		return ptr;
	}

};


// Class TgGame.TgDeploy_CH06_TurtleSpin
// 0x0018 (0x03EC - 0x03D4)
class ATgDeploy_CH06_TurtleSpin : public ATgDeployable
{
public:
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03D4(0x0010) (NeedCtorLink)
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03E4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_CH06_TurtleSpin");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeploy_Chronos_SlowTime
// 0x0008 (0x03DC - 0x03D4)
class ATgDeploy_Chronos_SlowTime : public ATgDeployable
{
public:
	class ATgTimeDilationVolume*                       m_TimeVolume;                                             // 0x03D4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Chronos_SlowTime");
		return ptr;
	}


	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
};


// Class TgGame.TgTimeDilationVolume
// 0x0028 (0x031C - 0x02F4)
class ATgTimeDilationVolume : public APhysicsVolume
{
public:
	float                                              m_fTimeMultiplier;                                        // 0x02F4(0x0004)
	unsigned long                                      m_bAffectInstigator : 1;                                  // 0x02F8(0x0004)
	TArray<class AActor*>                              m_AffectedActors;                                         // 0x02FC(0x0010) (NeedCtorLink)
	TArray<class APawn*>                               m_AffectedPawns;                                          // 0x030C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgTimeDilationVolume");
		return ptr;
	}


	void Destroyed();
	void PawnLeavingVolume(class APawn* Other);
	void PawnEnteredVolume(class APawn* Other);
	void ActorLeavingVolume(class AActor* Other);
	void ActorEnteredVolume(class AActor* Other);
	void PostBeginPlay();
};


// Class TgGame.TgDeploy_Geb_Ultimate
// 0x0000 (0x040C - 0x040C)
class ATgDeploy_Geb_Ultimate : public ATgDeploy_HitOnLanded
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Geb_Ultimate");
		return ptr;
	}


	void STATIC_FireAmmunitionDeployable();
	void STATIC_OnActorLanded(class AActor* Other);
	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeploy_Racer_Pulse
// 0x003C (0x0410 - 0x03D4)
class ATgDeploy_Racer_Pulse : public ATgDeployable
{
public:
	TArray<class AActor*>                              m_HitActors;                                              // 0x03D4(0x0010) (NeedCtorLink)
	TArray<float>                                      m_fHitTimes;                                              // 0x03E4(0x0010) (NeedCtorLink)
	float                                              m_fMinHitTime;                                            // 0x03F4(0x0004) (Const)
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                         // 0x03F8(0x0008)
	float                                              r_fRadiusScale;                                           // 0x0400(0x0004) (Net)
	int                                                m_nGrowthCycle;                                           // 0x0404(0x0004)
	int                                                m_nMaxCycles;                                             // 0x0408(0x0004) (Const)
	float                                              m_nTimeInCycle;                                           // 0x040C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Racer_Pulse");
		return ptr;
	}


	void STATIC_ScaleCollisionProxy();
	void STATIC_SpawnCollisionProxy();
	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void STATIC_ClearAllTouched();
	void STATIC_OnProxyUnTouch(class AActor* Other);
	void STATIC_OnProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ScaleAbilityFX();
	void Tick(float DeltaSeconds);
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgDeploy_Ravana_PranaOnslaught
// 0x0000 (0x0498 - 0x0498)
class ATgDeploy_Ravana_PranaOnslaught : public ATgDeploy_ExplodingCylinder
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_Ravana_PranaOnslaught");
		return ptr;
	}

};


// Class TgGame.TgDeploy_S5_Buff
// 0x0000 (0x03F0 - 0x03F0)
class ATgDeploy_S5_Buff : public ATgDeployable_Buff_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_S5_Buff");
		return ptr;
	}

};


// Class TgGame.TgDeploy_SunWukong_MastersWill
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeploy_SunWukong_MastersWill : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeploy_SunWukong_MastersWill");
		return ptr;
	}


	class AProjectile* STATIC_SpawnReturnProjectile();
	void Cleanup();
};


// Class TgGame.TgDeployable_Agni_FlameWave
// 0x0000 (0x047C - 0x047C)
class ATgDeployable_Agni_FlameWave : public ATgDeploy_MovingEffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Agni_FlameWave");
		return ptr;
	}

};


// Class TgGame.TgRepInfo_AhMuzenCab_Stinger
// 0x0000 (0x03F8 - 0x03F8)
class ATgRepInfo_AhMuzenCab_Stinger : public ATgRepInfo_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_AhMuzenCab_Stinger");
		return ptr;
	}

};


// Class TgGame.TgDeployable_AhPuch_EmptyTheCrypts
// 0x0034 (0x0408 - 0x03D4)
class ATgDeployable_AhPuch_EmptyTheCrypts : public ATgDeployable
{
public:
	float                                              m_fFiringTimer;                                           // 0x03D4(0x0004)
	int                                                m_nNumberOfCreepLanes;                                    // 0x03D8(0x0004)
	int                                                m_nCreepsBeforeLaneRepeat;                                // 0x03DC(0x0004)
	int                                                m_nCurrentLane;                                           // 0x03E0(0x0004)
	float                                              m_fMinCreepRefire;                                        // 0x03E4(0x0004)
	float                                              m_fMaxCreepRefire;                                        // 0x03E8(0x0004)
	struct FVector                                     m_vAdditionalSpawnOffset;                                 // 0x03EC(0x000C)
	TArray<int>                                        m_LaneHistory;                                            // 0x03F8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_AhPuch_EmptyTheCrypts");
		return ptr;
	}


	void TimeDeviceFiring();
	struct FVector STATIC_GetPhysicalFireAimDirection(const struct FVector& fireLoc, const struct FVector& TargetLocation);
	struct FVector STATIC_GetPhysicalFireStartLoc();
	struct FVector STATIC_GetLaneCenter(int nLane, float fLaneWidth, const struct FVector& Left);
	void STATIC_FireAmmunitionDeployable();
	void AddToLaneHistory(int nLane);
	int STATIC_ChooseNextLane();
	void StartFire();
	void StartDeploy();
};


// Class TgGame.TgDeployable_AoKuang_WildStorm
// 0x0000 (0x0498 - 0x0498)
class ATgDeployable_AoKuang_WildStorm : public ATgDeploy_ExplodingCylinder
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_AoKuang_WildStorm");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Artio_Dev1
// 0x0000 (0x0498 - 0x0498)
class ATgDeployable_Artio_Dev1 : public ATgDeploy_ExplodingCylinder
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Artio_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Athena_ShieldWall
// 0x0008 (0x03DC - 0x03D4)
class ATgDeployable_Athena_ShieldWall : public ATgDeployable
{
public:
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                                       // 0x03D4(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Athena_ShieldWall");
		return ptr;
	}


	void PlayFireFx();
};


// Class TgGame.TgDeployable_Buff_MonsterStacking
// 0x0000 (0x03F0 - 0x03F0)
class ATgDeployable_Buff_MonsterStacking : public ATgDeployable_Buff_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Buff_MonsterStacking");
		return ptr;
	}


	void ApplyBuff(class AActor* Other);
};


// Class TgGame.TgDeployable_Chaac_Num1Axe
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_Chaac_Num1Axe : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Chaac_Num1Axe");
		return ptr;
	}


	void DestroyIt(bool bSkipFx);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_Chaac_Num3Rain
// 0x0018 (0x03EC - 0x03D4)
class ATgDeployable_Chaac_Num3Rain : public ATgDeployable
{
public:
	class ATgCollisionProxy*                           s_CollisionProxy;                                         // 0x03D4(0x0008)
	TArray<class AActor*>                              s_AppliedList;                                            // 0x03DC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Chaac_Num3Rain");
		return ptr;
	}


	void Cleanup();
	void Destroyed();
	void DestroyIt(bool bSkipFx);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_Cupid_SpeedPad
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_Cupid_SpeedPad : public ATgDeployable_PulseEffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Cupid_SpeedPad");
		return ptr;
	}

};


// Class TgGame.TgDeployable_God94_Dev1
// 0x0000 (0x0498 - 0x0498)
class ATgDeployable_God94_Dev1 : public ATgDeploy_ExplodingCylinder
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_God94_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Janus_Transitions
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeployable_Janus_Transitions : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Janus_Transitions");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Janus_Ultimate
// 0x0000 (0x04AC - 0x04AC)
class ATgDeployable_Janus_Ultimate : public ATgDeploy_AutoPortal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Janus_Ultimate");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Kukulkan_Tempest
// 0x0010 (0x03E4 - 0x03D4)
class ATgDeployable_Kukulkan_Tempest : public ATgDeployable_PulseEffectVolume
{
public:
	TArray<class AActor*>                              m_HitActors;                                              // 0x03D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Kukulkan_Tempest");
		return ptr;
	}


	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	bool STATIC_ShouldHit(class AActor* Other);
};


// Class TgGame.TgDeployable_Mercury_Num4AOE
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_Mercury_Num4AOE : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Mercury_Num4AOE");
		return ptr;
	}

};


// Class TgGame.TgDeployable_NuWa_Fog
// 0x0010 (0x03E4 - 0x03D4)
class ATgDeployable_NuWa_Fog : public ATgDeployable
{
public:
	TArray<class AActor*>                              m_AlreadyHitOnce;                                         // 0x03D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_NuWa_Fog");
		return ptr;
	}


	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable_NuWa_Meteor
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_NuWa_Meteor : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_NuWa_Meteor");
		return ptr;
	}


	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void StartFire();
};


// Class TgGame.TgDeployable_Ram_Circle
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeployable_Ram_Circle : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ram_Circle");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Ratatoskr_ExplosiveAcorn
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_Ratatoskr_ExplosiveAcorn : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ratatoskr_ExplosiveAcorn");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcDeviceFire(const struct FVector& StartTrace, const struct FVector& EndTrace, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDeployable_Ratatoskr_Tree
// 0x0010 (0x03E4 - 0x03D4)
class ATgDeployable_Ratatoskr_Tree : public ATgDeployable
{
public:
	float                                              m_fOpacity;                                               // 0x03D4(0x0004)
	struct FName                                       m_OpacityParamName;                                       // 0x03D8(0x0008)
	float                                              m_fOpacityFadeOutTime;                                    // 0x03E0(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ratatoskr_Tree");
		return ptr;
	}


	void Tick(float DeltaSeconds);
};


// Class TgGame.TgDeployable_Scylla_Number2
// 0x0000 (0x03F8 - 0x03F8)
class ATgDeployable_Scylla_Number2 : public ATgDeploy_EffectVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Scylla_Number2");
		return ptr;
	}


	void DestroyIt(bool bSkipIt);
	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployable_ScyllaWardNoLOS
// 0x0000 (0x0420 - 0x0420)
class ATgDeployable_ScyllaWardNoLOS : public ATgDeployable_ScyllaWard
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_ScyllaWardNoLOS");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Skadi_Ice
// 0x0008 (0x0404 - 0x03FC)
class ATgDeployable_Skadi_Ice : public ATgDeploy_Scaling_EffectVolume
{
public:
	int                                                m_NormalBuffSituationalType;                              // 0x03FC(0x0004)
	int                                                m_LingeringBuffSituationalType;                           // 0x0400(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Skadi_Ice");
		return ptr;
	}


	void Cleanup();
	void HandleUnTouch(class AActor* Other);
	void HandleTouch(class AActor* Other);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDevice_Susano_Dev4
// 0x0000 (0x0514 - 0x0514)
class ATgDevice_Susano_Dev4 : public ATgDevice_TogglableDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Susano_Dev4");
		return ptr;
	}


	void STATIC_OnTravelStarted(class ATgDeployable* deployable);
};


// Class TgGame.TgDeployable_Thanatos_DeathGrip
// 0x0000 (0x03D4 - 0x03D4)
class ATgDeployable_Thanatos_DeathGrip : public ATgDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Thanatos_DeathGrip");
		return ptr;
	}


	void STATIC_FireAmmunitionDeployable();
};


// Class TgGame.TgDeployable_VisionShardWard
// 0x0000 (0x0410 - 0x0410)
class ATgDeployable_VisionShardWard : public ATgDeployable_Ward
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_VisionShardWard");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Vulcan_ProximityMine
// 0x0000 (0x0434 - 0x0434)
class ATgDeployable_Vulcan_ProximityMine : public ATgDeployable_TriggerableWard
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Vulcan_ProximityMine");
		return ptr;
	}


	void SpawningDeviceToggledOff();
	void DestroyIt(bool bSkipIt);
};


// Class TgGame.TgDeployable_Ward_NotStatTracked
// 0x0000 (0x0410 - 0x0410)
class ATgDeployable_Ward_NotStatTracked : public ATgDeployable_Ward
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Ward_NotStatTracked");
		return ptr;
	}

};


// Class TgGame.TgDeployable_WardSentryNoLOS
// 0x0000 (0x0410 - 0x0410)
class ATgDeployable_WardSentryNoLOS : public ATgDeployable_WardSentry
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_WardSentryNoLOS");
		return ptr;
	}

};


// Class TgGame.TgDeployable_Zeus_Shield
// 0x0024 (0x03F8 - 0x03D4)
class ATgDeployable_Zeus_Shield : public ATgDeployable
{
public:
	TArray<int>                                        m_HitProjectiles;                                         // 0x03D4(0x0010) (NeedCtorLink)
	int                                                r_nExplodeTicker;                                         // 0x03E4(0x0004) (Net)
	TArray<int>                                        s_nChainInstances;                                        // 0x03E8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_Zeus_Shield");
		return ptr;
	}


	void STATIC_HitByChainLightning(class ATgDevice* ChainDev);
	void STATIC_HitByProjectile(class ATgProj_Simulated* Proj);
	void ApplyHit(TArray<struct FImpactInfo>* ImpactList);
	void DestroyIt(bool bSkipFx);
	void STATIC_SpawnReturnProjectile();
	void InitReplicationInfo();
	void STATIC_PlaySpecialExplodeFx();
	void STATIC_FlashSpecialExplodeFx();
	void STATIC_InstantFireDeployable();
	void ReplicatedEvent(const struct FName& VarName);
};


// Class TgGame.TgRepInfo_ZeusShield
// 0x0000 (0x03F8 - 0x03F8)
class ATgRepInfo_ZeusShield : public ATgRepInfo_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgRepInfo_ZeusShield");
		return ptr;
	}

};


// Class TgGame.TgDeployable_ZeusV2_LightningStorm
// 0x0004 (0x03D8 - 0x03D4)
class ATgDeployable_ZeusV2_LightningStorm : public ATgDeployable
{
public:
	unsigned long                                      m_bFirstHit : 1;                                          // 0x03D4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_ZeusV2_LightningStorm");
		return ptr;
	}


	void STATIC_FireAmmunitionDeployable();
};


// Class TgGame.TgDeployable_ZhongKui_Exorcism
// 0x0000 (0x047C - 0x047C)
class ATgDeployable_ZhongKui_Exorcism : public ATgDeployable_ChangE_Sweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_ZhongKui_Exorcism");
		return ptr;
	}


	void TurnCollisionOff();
	void TurnCollisionOn();
};


// Class TgGame.TgDeployable_ZhongKui_ExorcismSplit
// 0x0000 (0x047C - 0x047C)
class ATgDeployable_ZhongKui_ExorcismSplit : public ATgDeployable_ChangE_Sweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployable_ZhongKui_ExorcismSplit");
		return ptr;
	}


	void STATIC_DeployComplete();
};


// Class TgGame.TgDeployableFactory_TimedRepeat
// 0x0008 (0x02D0 - 0x02C8)
class ATgDeployableFactory_TimedRepeat : public ATgDeployableFactory
{
public:
	unsigned long                                      s_bRefire : 1;                                            // 0x02C8(0x0004) (Edit)
	float                                              s_fRefireTime;                                            // 0x02CC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeployableFactory_TimedRepeat");
		return ptr;
	}


	void STATIC_SpawnTimerExpired();
	void PostBeginPlay();
};


// Class TgGame.TgDevice_AoKuang_BasicAttack
// 0x0004 (0x053C - 0x0538)
class ATgDevice_AoKuang_BasicAttack : public ATgDevice_ChainedMelee
{
public:
	unsigned long                                      m_bFromSheath : 1;                                        // 0x0538(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AoKuang_BasicAttack");
		return ptr;
	}


	void DeliverQueuedPendingHits();
};


// Class TgGame.TgProj_AoKuang_DragonCall
// 0x0004 (0x039C - 0x0398)
class ATgProj_AoKuang_DragonCall : public ATgProj_Simulated
{
public:
	int                                                m_nNumDragonsAbsorbed;                                    // 0x0398(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AoKuang_DragonCall");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgDevice_AoKuang_UltimateStaging
// 0x0004 (0x052C - 0x0528)
class ATgDevice_AoKuang_UltimateStaging : public ATgDevice_ThorAnvilStaging
{
public:
	int                                                s_nCooldownMode;                                          // 0x0528(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AoKuang_UltimateStaging");
		return ptr;
	}


	void STATIC_ClientStartSecondStage();
	bool STATIC_StartSecondStage(int nCooldownMode);
};


// Class TgGame.TgDevice_AoKuang_WildStorm
// 0x0004 (0x0500 - 0x04FC)
class ATgDevice_AoKuang_WildStorm : public ATgDevice_Deployable_ConeShaped
{
public:
	unsigned long                                      c_bUsingEnergy : 1;                                       // 0x04FC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AoKuang_WildStorm");
		return ptr;
	}


	void DeviceConsumePowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_Aphrodite_ManaToHealth
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Aphrodite_ManaToHealth : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Aphrodite_ManaToHealth");
		return ptr;
	}


	void STATIC_CustomFire();
};


// Class TgGame.TgDevice_ApolloInHand
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_ApolloInHand : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ApolloInHand");
		return ptr;
	}


	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_Arachne_CreepyCrawly
// 0x0000 (0x0528 - 0x0528)
class ATgDevice_Arachne_CreepyCrawly : public ATgDevice_Staging
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Arachne_CreepyCrawly");
		return ptr;
	}


	bool STATIC_FireEndStageDevice();
	void OnStageShooterStopFire(bool bInterrupted);
	void OnStageShooterStartBuildup(bool bShouldInterrupt);
};


// Class TgGame.TgDevice_Ares_Tether
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Ares_Tether : public ATgDevice
{
public:
	TArray<struct FImpactInfo>                         ImpactsOnFireStart;                                       // 0x04F0(0x0010) (Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ares_Tether");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDevice_Argus_Inhand
// 0x0004 (0x053C - 0x0538)
class ATgDevice_Argus_Inhand : public ATgDevice_ChainedMelee
{
public:
	unsigned long                                      s_bDidHit : 1;                                            // 0x0538(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Argus_Inhand");
		return ptr;
	}


	void STATIC_GoToNextChainAttack(int nMode);
	void DeliverQueuedPendingHits();
};


// Class TgGame.TgDevice_Artemis_Inhand
// 0x000C (0x04FC - 0x04F0)
class ATgDevice_Artemis_Inhand : public ATgDevice_Range
{
public:
	class ATgPawn_Artemis*                             m_Artemis;                                                // 0x04F0(0x0008)
	int                                                m_ProjOverrideId;                                         // 0x04F8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Artemis_Inhand");
		return ptr;
	}


	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
};


// Class TgGame.TgDevice_Artio_Charge
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Artio_Charge : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Artio_Charge");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Artio_LifeTap
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Artio_LifeTap : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Artio_LifeTap");
		return ptr;
	}


	bool CanBeInterrupted();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Athena_DefenderOfOlympus
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Athena_DefenderOfOlympus : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Athena_DefenderOfOlympus");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	bool ShouldInterruptInhand();
};


// Class TgGame.TgDevice_Athena_DefenderOfOlympusShooter
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Athena_DefenderOfOlympusShooter : public ATgDevice_LockOnShooter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Athena_DefenderOfOlympusShooter");
		return ptr;
	}


	void InterruptFiring();
};


// Class TgGame.TgDevice_Athena_LeapingLungeSub
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Athena_LeapingLungeSub : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Athena_LeapingLungeSub");
		return ptr;
	}


	bool CanBeCanceled();
	void InterruptFiring();
};


// Class TgGame.TgDevice_AthenaInHand
// 0x0000 (0x0538 - 0x0538)
class ATgDevice_AthenaInHand : public ATgDevice_ChainedMelee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_AthenaInHand");
		return ptr;
	}

};


// Class TgGame.TgDevice_Awilix_KittenCannon
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Awilix_KittenCannon : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Awilix_KittenCannon");
		return ptr;
	}

};


// Class TgGame.TgDevice_Awilix_MountLeap
// 0x0001 (0x04F1 - 0x04F0)
class ATgDevice_Awilix_MountLeap : public ATgDevice
{
public:
	TEnumAsByte<ETweenState>                           m_LeapTweenState;                                         // 0x04F0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Awilix_MountLeap");
		return ptr;
	}


	void InterruptFiring();
	bool CanJumpWhileFiring();
	bool ShouldTriggerCastReactionItems();
	bool ApplyGlobalOffhandCooldown();
	bool ShouldInterruptInhand();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Bacchus_BellyFlop
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Bacchus_BellyFlop : public ATgDevice_TweenBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bacchus_BellyFlop");
		return ptr;
	}

};


// Class TgGame.TgDevice_BaronSamedi_Psv
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_BaronSamedi_Psv : public ATgDevice_SpecialItem
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_BaronSamedi_Psv");
		return ptr;
	}

};


// Class TgGame.TgDevice_Bellona_Scourge
// 0x0001 (0x04F1 - 0x04F0)
class ATgDevice_Bellona_Scourge : public ATgDevice
{
public:
	TEnumAsByte<EBellonaWeaponSet>                     m_eSwitchToSet;                                           // 0x04F0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Bellona_Scourge");
		return ptr;
	}


	void InterruptFiring();
};


// Class TgGame.TgDeviceForm_Bellona_SpinToStrike
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Bellona_SpinToStrike : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Bellona_SpinToStrike");
		return ptr;
	}

};


// Class TgGame.TgDevice_Cabrakan_Dev1
// 0x0020 (0x055C - 0x053C)
class ATgDevice_Cabrakan_Dev1 : public ATgDevice_Charge
{
public:
	struct FVector                                     m_fStartLocation;                                         // 0x053C(0x000C)
	unsigned char                                      m_bHitBlocker;                                            // 0x0548(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0549(0x0003) MISSED OFFSET
	TArray<struct FChargeHitInfo>                      m_HitInfos;                                               // 0x054C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cabrakan_Dev1");
		return ptr;
	}


	bool StartFire();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Cabrakan_Dev4_Ult
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Cabrakan_Dev4_Ult : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cabrakan_Dev4_Ult");
		return ptr;
	}

};


// Class TgGame.TgDevice_Cabrakan_ShadowZone
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_Cabrakan_ShadowZone : public ATgDevice_PassiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Cabrakan_ShadowZone");
		return ptr;
	}

};


// Class TgGame.TgDevice_Camazotz_ToothAndNail
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Camazotz_ToothAndNail : public ATgDevice_TweenBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Camazotz_ToothAndNail");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Xbalanque_PoisonDarts
// 0x0020 (0x051C - 0x04FC)
class ATgDevice_Xbalanque_PoisonDarts : public ATgDevice_HitPulse
{
public:
	TArray<struct ATgDevice_Xbalanque_PoisonDarts_FFanInformation> s_FanInfos;                                               // 0x04FC(0x0010) (NeedCtorLink)
	TArray<class ATgProjectile*>                       s_ActiveProjectiles;                                      // 0x050C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Xbalanque_PoisonDarts");
		return ptr;
	}


	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool ShouldCooldownAfterFire();
	void STATIC_OnProjectileShutdown(class ATgProjectile* Proj);
	class AProjectile* STATIC_ProjectileFire(int nProjectileIndex);
	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	float GetPersistPulseHitTime(int nMode);
	bool STATIC_ShouldApplyHit(class ATgProjectile* Proj, class AActor* HitActor, int* nHitCount);
};


// Class TgGame.TgDevice_CH05_ArcherPulse
// 0x0000 (0x051C - 0x051C)
class ATgDevice_CH05_ArcherPulse : public ATgDevice_Xbalanque_PoisonDarts
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_ArcherPulse");
		return ptr;
	}


	bool STATIC_HasSpecificOffset();
};


// Class TgGame.TgDevice_CH05_RemoveEffect
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_CH05_RemoveEffect : public ATgDevice_PassiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH05_RemoveEffect");
		return ptr;
	}


	void ApplyHitAura(class AActor* Other);
};


// Class TgGame.TgDevice_CH06_Lobber_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_CH06_Lobber_Dev1 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CH06_Lobber_Dev1");
		return ptr;
	}


	bool STATIC_HasSpecificOffset();
};


// Class TgGame.TgProj_Chiron_Passive
// 0x0004 (0x03D0 - 0x03CC)
class ATgProj_Chiron_Passive : public ATgProj_SimulatedSeeking
{
public:
	int                                                m_nChironLevel;                                           // 0x03CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Chiron_Passive");
		return ptr;
	}


	bool UseAOE();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void UpdateSeekingDirection(float fDeltaTime);
};


// Class TgGame.TgDevice_Chronos_StopTime
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Chronos_StopTime : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Chronos_StopTime");
		return ptr;
	}

};


// Class TgGame.TgDevice_CuChulainnInhand
// 0x0000 (0x0538 - 0x0538)
class ATgDevice_CuChulainnInhand : public ATgDevice_ChainedMelee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CuChulainnInhand");
		return ptr;
	}

};


// Class TgGame.TgDevice_CustomOffset
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_CustomOffset : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_CustomOffset");
		return ptr;
	}


	struct FVector STATIC_GetSpecificOffset();
	bool STATIC_HasSpecificOffset();
};


// Class TgGame.TgDevice_DaJi_PaolaoTargetter_PVE
// 0x0000 (0x0504 - 0x0504)
class ATgDevice_DaJi_PaolaoTargetter_PVE : public ATgDevice_DaJi_PaolaoTargetter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_PaolaoTargetter_PVE");
		return ptr;
	}

};


// Class TgGame.TgDevice_DaJi_SlashAndDash
// 0x0000 (0x053C - 0x053C)
class ATgDevice_DaJi_SlashAndDash : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_DaJi_SlashAndDash");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDevice_ErlangShen_Pin
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_ErlangShen_Pin : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ErlangShen_Pin");
		return ptr;
	}


	int STATIC_GetAnimMode(float fAimDist);
	void STATIC_HandleDeviceFormStartFire(int nDeviceModeNum, float fRefireTime, struct FAimData* Aim);
};


// Class TgGame.TgDevice_Fenrir_DoubleTargetLeap
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Fenrir_DoubleTargetLeap : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fenrir_DoubleTargetLeap");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Fenrir_DoubleLeap
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Fenrir_DoubleLeap : public UTgDeviceFire
{
public:
	float                                              m_fCooldownTimeModifier;                                  // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Fenrir_DoubleLeap");
		return ptr;
	}


	float GetCooldownTime();
	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void STATIC_SetCooldownModifier(float NewValue);
};


// Class TgGame.TgDevice_Fenrir_Ragnarok
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Fenrir_Ragnarok : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Fenrir_Ragnarok");
		return ptr;
	}


	void InterruptFiring();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Freya_CloakOfFeathers
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Freya_CloakOfFeathers : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Freya_CloakOfFeathers");
		return ptr;
	}


	void STATIC_ClientInterrupt();
	void InterruptFiring();
	bool STATIC_CloakTakedown();
};


// Class TgGame.TgDevice_Freya_ValkyrieShooter
// 0x0002 (0x04F8 - 0x04F6)
class ATgDevice_Freya_ValkyrieShooter : public ATgDevice_TimerFromParent
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x04F6(0x0002) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Freya_ValkyrieShooter");
		return ptr;
	}

};


// Class TgGame.TgDevice_G86_Dev3
// 0x0000 (0x053C - 0x053C)
class ATgDevice_G86_Dev3 : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G86_Dev3");
		return ptr;
	}


	bool CanBeCanceled();
};


// Class TgGame.TgDevice_G86_Inhand
// 0x0014 (0x054C - 0x0538)
class ATgDevice_G86_Inhand : public ATgDevice_ChainedMelee
{
public:
	int                                                m_NormalProjId;                                           // 0x0538(0x0004)
	int                                                m_WinterProjId;                                           // 0x053C(0x0004)
	int                                                m_SpringProjId;                                           // 0x0540(0x0004)
	int                                                m_SummerProjId;                                           // 0x0544(0x0004)
	int                                                m_FallProjId;                                             // 0x0548(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G86_Inhand");
		return ptr;
	}


	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
};


// Class TgGame.TgDevice_G86_Passive
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_G86_Passive : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_G86_Passive");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
};


// Class TgGame.TgDevice_Geb_Boulder
// 0x0010 (0x054C - 0x053C)
class ATgDevice_Geb_Boulder : public ATgDevice_Charge
{
public:
	float                                              m_fStartChargeTimeStamp;                                  // 0x053C(0x0004)
	float                                              m_fStartFireGroundSpeed;                                  // 0x0540(0x0004)
	class UTgEffectGroup*                              s_CCImmunity;                                             // 0x0544(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Geb_Boulder");
		return ptr;
	}


	void InstantFire();
	float STATIC_CalcFinalSpeed();
	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_RemoveCCImmunity();
	void ApplyDamageReduction(struct FImpactInfo* Impact);
	bool STATIC_ShouldApplyHitSpecialOnTouch(class AActor* Target);
	float STATIC_GetAccelTime();
	void TransformBack();
	void TransformTo();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Geb_Boulder_PVERounds
// 0x0000 (0x054C - 0x054C)
class ATgDevice_Geb_Boulder_PVERounds : public ATgDevice_Geb_Boulder
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Geb_Boulder_PVERounds");
		return ptr;
	}

};


// Class TgGame.TgDevice_Geb_Shield
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Geb_Shield : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Geb_Shield");
		return ptr;
	}

};


// Class TgGame.TgDevice_GlobalFire
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_GlobalFire : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GlobalFire");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
	void STATIC_CollectImpactsForTaskForce(class UTgDeviceFire* FireMode, class ATgRepInfo_TaskForce* Team, TArray<struct FImpactInfo>* ImpactList);
	class ATgRepInfo_TaskForce* STATIC_GetInstigatorTeam();
};


// Class TgGame.TgDevice_GuanYuV2UltDismount
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_GuanYuV2UltDismount : public ATgDevice_Melee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GuanYuV2UltDismount");
		return ptr;
	}


	bool ApplyGlobalOffhandCooldown();
};


// Class TgGame.TgDevice_GuanYuV2UltShooter
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_GuanYuV2UltShooter : public ATgDevice_Melee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_GuanYuV2UltShooter");
		return ptr;
	}


	bool ApplyGlobalOffhandCooldown();
};


// Class TgGame.TgDevice_Hachiman_InHand
// 0x0000 (0x054C - 0x054C)
class ATgDevice_Hachiman_InHand : public ATgDevice_ActiveMode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hachiman_InHand");
		return ptr;
	}

};


// Class TgGame.TgDevice_HandOfGods
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_HandOfGods : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HandOfGods");
		return ptr;
	}


	void StartCooldown(int nMode, float fCooldownTimeOverride);
};


// Class TgGame.TgDevice_Hercules_BatterUp
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Hercules_BatterUp : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Hercules_BatterUp");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_HouYi_DiveBomb
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_HouYi_DiveBomb : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HouYi_DiveBomb");
		return ptr;
	}

};


// Class TgGame.TgDevice_HouYi_DivebombStaging
// 0x0000 (0x0528 - 0x0528)
class ATgDevice_HouYi_DivebombStaging : public ATgDevice_Staging
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HouYi_DivebombStaging");
		return ptr;
	}


	bool STATIC_FireEndStageDevice();
	void STATIC_ClientInterrupt();
	bool CanBeInterrupted();
};


// Class TgGame.TgDevice_HouYi_GoldenCrow
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_HouYi_GoldenCrow : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_HouYi_GoldenCrow");
		return ptr;
	}


	bool UsesTrackingTarget();
};


// Class TgGame.TgDevice_Isis_DeathWard
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Isis_DeathWard : public ATgDevice_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Isis_DeathWard");
		return ptr;
	}

};


// Class TgGame.TgDevice_Izanami_Dev2
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Izanami_Dev2 : public ATgDevice_Range
{
public:
	unsigned long                                      m_bHasMasStacks : 1;                                      // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Izanami_Dev2");
		return ptr;
	}


	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
};


// Class TgGame.TgDevice_Janus_A01
// 0x0000 (0x0598 - 0x0598)
class ATgDevice_Janus_A01 : public ATgDevice_AutoPortal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Janus_A01");
		return ptr;
	}

};


// Class TgGame.TgDevice_Jumong_FanOfArrows
// 0x0024 (0x0514 - 0x04F0)
class ATgDevice_Jumong_FanOfArrows : public ATgDevice
{
public:
	int                                                s_CurrentFanId;                                           // 0x04F0(0x0004)
	TArray<struct ATgDevice_Jumong_FanOfArrows_FFanInformation> s_FanInfos;                                               // 0x04F4(0x0010) (NeedCtorLink)
	TArray<class ATgProj_Jumong_FanArrow*>             s_SpawnedProjectiles;                                     // 0x0504(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Jumong_FanOfArrows");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void STATIC_OnProjectileDestroyed(class ATgProj_Jumong_FanArrow* SpawnedProjectile);
	void STATIC_FireAmmunition();
};


// Class TgGame.TgProj_Jumong_FanArrow
// 0x0004 (0x039C - 0x0398)
class ATgProj_Jumong_FanArrow : public ATgProj_Simulated
{
public:
	int                                                s_FanId;                                                  // 0x0398(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Jumong_FanArrow");
		return ptr;
	}


	void Destroyed();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgDevice_Kali_Destruction
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Kali_Destruction : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kali_Destruction");
		return ptr;
	}


	void STATIC_RecoverHealth();
};


// Class TgGame.TgDevice_Kali_NimbleStrike
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Kali_NimbleStrike : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kali_NimbleStrike");
		return ptr;
	}

};


// Class TgGame.TgDevice_Knight_Dev2B_Sub
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Knight_Dev2B_Sub : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Knight_Dev2B_Sub");
		return ptr;
	}


	bool StartFire();
	bool UsesControllerRotation();
};


// Class TgGame.TgDevice_Kumbhakarna_Num2Sub
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Kumbhakarna_Num2Sub : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kumbhakarna_Num2Sub");
		return ptr;
	}


	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
};


// Class TgGame.TgDevice_Kumbhakarna_Num4
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Kumbhakarna_Num4 : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Kumbhakarna_Num4");
		return ptr;
	}


	void STATIC_ClientForcePostFire();
	bool STATIC_ShouldStopOnThisHit(class AActor* Other);
};


// Class TgGame.TgDevice_LeadersCowl
// 0x0014 (0x0538 - 0x0524)
class ATgDevice_LeadersCowl : public ATgDevice_PassiveAura
{
public:
	int                                                m_nStacksToAdd;                                           // 0x0524(0x0004)
	TArray<class AActor*>                              s_AppliedAllyList;                                        // 0x0528(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_LeadersCowl");
		return ptr;
	}


	void UpdateStacksOnAllies();
	void AuraRemoved(class AActor* Other);
	void AuraApplied(class AActor* Other);
};


// Class TgGame.TgDevice_Manticore_A01
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Manticore_A01 : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Manticore_A01");
		return ptr;
	}

};


// Class TgGame.TgDevice_Medusa_Dev3
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Medusa_Dev3 : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Medusa_Dev3");
		return ptr;
	}

};


// Class TgGame.TgDevice_Mercury_Num1
// 0x0014 (0x0504 - 0x04F0)
class ATgDevice_Mercury_Num1 : public ATgDevice
{
public:
	TArray<struct FImpactInfo>                         m_QueuedHits;                                             // 0x04F0(0x0010) (Component, NeedCtorLink)
	float                                              m_fHitInterval;                                           // 0x0500(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mercury_Num1");
		return ptr;
	}


	bool CanBeInterrupted();
	void ApplyNextHit();
	void DeliverQueuedPendingHits();
};


// Class TgGame.TgDevice_Mercury_Num4
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Mercury_Num4 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Mercury_Num4");
		return ptr;
	}


	bool ShouldTriggerCastReactionItems();
	bool ShouldInterruptInhand();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	bool ShouldCooldownAfterFire();
};


// Class TgGame.TgDeviceForm_Mulan_A01
// 0x0000 (0x0250 - 0x0250)
class UTgDeviceForm_Mulan_A01 : public UTgDeviceForm_Mulan_EvolutionForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Mulan_A01");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Mulan_A02
// 0x0000 (0x0250 - 0x0250)
class UTgDeviceForm_Mulan_A02 : public UTgDeviceForm_Mulan_EvolutionForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Mulan_A02");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Mulan_B04
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Mulan_B04 : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Mulan_B04");
		return ptr;
	}

};


// Class TgGame.TgDevice_Neith_ThreadOfLife
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Neith_ThreadOfLife : public ATgDevice
{
public:
	TArray<class AActor*>                              s_ActorHitList;                                           // 0x04F0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Neith_ThreadOfLife");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_Neith_WorldWeaverStance
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Neith_WorldWeaverStance : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Neith_WorldWeaverStance");
		return ptr;
	}


	void InterruptFiring();
	bool ShouldTriggerCastReactionItems();
	void STATIC_ForceDeviceConsumePowerPool(unsigned char FireModeNum);
	void DeviceConsumePowerPool(unsigned char FireModeNum);
};


// Class TgGame.TgDevice_Nemesis_Num2
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Nemesis_Num2 : public ATgDevice_HitPulse
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nemesis_Num2");
		return ptr;
	}


	void GetAdjustedAim(int nShotIndex, struct FAimData* Aim);
	void InstantFire();
	bool CanBeInterrupted();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_NeZha_WindFireWheels
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_NeZha_WindFireWheels : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NeZha_WindFireWheels");
		return ptr;
	}


	void STATIC_ClientOnPossibleDryFire();
	void InterruptFiring();
};


// Class TgGame.TgDevice_NoFire
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_NoFire : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NoFire");
		return ptr;
	}


	bool StartFire();
	bool Use();
};


// Class TgGame.TgDevice_NoItemProc
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_NoItemProc : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NoItemProc");
		return ptr;
	}

};


// Class TgGame.TgDevice_Nox_Dev4
// 0x0000 (0x04F4 - 0x04F4)
class ATgDevice_Nox_Dev4 : public ATgDevice_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Nox_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDevice_NuWa_ClaySoldierCharge
// 0x0000 (0x053C - 0x053C)
class ATgDevice_NuWa_ClaySoldierCharge : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_NuWa_ClaySoldierCharge");
		return ptr;
	}


	bool IsSpecialChargeTarget(class AActor* Other);
};


// Class TgGame.TgDevice_OniHunterGarb_S5
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_OniHunterGarb_S5 : public ATgDevice_Aura_PawnsInProximity
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_OniHunterGarb_S5");
		return ptr;
	}

};


// Class TgGame.TgDevice_PassiveAura_OnOtherEnemyDied
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_PassiveAura_OnOtherEnemyDied : public ATgDevice_PassiveAura
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_PassiveAura_OnOtherEnemyDied");
		return ptr;
	}


	void STATIC_HandleTrackedTargetDied(class ATgPawn* PawnTarget);
	void ProxyUnTouch(class AActor* Other);
};


// Class TgGame.TgDevice_Poseidon_Deployable
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Poseidon_Deployable : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Poseidon_Deployable");
		return ptr;
	}


	void OnDeployableSpawned(class ATgDeployable* deployable);
};


// Class TgGame.TgDevice_Poseidon_Kraken
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Poseidon_Kraken : public ATgDevice_Poseidon_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Poseidon_Kraken");
		return ptr;
	}

};


// Class TgGame.TgDevice_ProcOnNearbyDeath_FriendlyMinions
// 0x0003 (0x0540 - 0x053D)
class ATgDevice_ProcOnNearbyDeath_FriendlyMinions : public ATgDevice_ProcOnNearbyDeath
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x053D(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ProcOnNearbyDeath_FriendlyMinions");
		return ptr;
	}

};


// Class TgGame.TgDevice_Racer_Detonate
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Racer_Detonate : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Racer_Detonate");
		return ptr;
	}


	void STATIC_CalculateTargetingEarly();
	void InstantFire();
};


// Class TgGame.TgDevice_Racer_HandBrake
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Racer_HandBrake : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Racer_HandBrake");
		return ptr;
	}


	bool ApplyGlobalOffhandCooldown();
};


// Class TgGame.TgDevice_Ram_Basic
// 0x0000 (0x054C - 0x054C)
class ATgDevice_Ram_Basic : public ATgDevice_ActiveMode
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ram_Basic");
		return ptr;
	}


	class AProjectile* STATIC_ProjectileFire(int ProjectileIndex);
	void InterruptFiring();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Ratatoskr_AcornPurchase
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Ratatoskr_AcornPurchase : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ratatoskr_AcornPurchase");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void STATIC_ClientForceStartFire();
	bool StartFire();
	bool ShouldCancelStealth();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgDevice_Ravana_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Ravana_Dev1 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ravana_Dev1");
		return ptr;
	}


	bool ShouldInterruptInhand();
};


// Class TgGame.TgDevice_Ravana_Dev2
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Ravana_Dev2 : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Ravana_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDevice_Rogue_Adv_Dev1
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Rogue_Adv_Dev1 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Rogue_Adv_Dev1");
		return ptr;
	}


	bool CanBeCanceled();
	bool CanBeInterrupted();
};


// Class TgGame.TgDevice_ScaleProjectileByHits
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_ScaleProjectileByHits : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_ScaleProjectileByHits");
		return ptr;
	}


	void STATIC_CustomProjectileInit(class AProjectile* Proj, int ProjIndex, const struct FAimData& BaseAim);
};


// Class TgGame.TgDevice_Scylla_Num2
// 0x0000 (0x0514 - 0x0514)
class ATgDevice_Scylla_Num2 : public ATgDevice_TogglableDeployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Scylla_Num2");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Scylla_Num3
// 0x0004 (0x023C - 0x0238)
class UTgDeviceForm_Scylla_Num3 : public UTgDeviceForm
{
public:
	unsigned long                                      m_bInSuppressionMode : 1;                                 // 0x0238(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Scylla_Num3");
		return ptr;
	}


	void StopFire(int nFireModeNum);
	void StartFire(int nFireMode, float fRefireTime, class AActor* Target);
	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
	void BeginDeviceSuppression();
};


// Class TgGame.TgDevice_Serqet_Backflip
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Serqet_Backflip : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Serqet_Backflip");
		return ptr;
	}


	bool CanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, bool bSkipStunCheck, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgProj_Serqet_CobrasKiss
// 0x0004 (0x039C - 0x0398)
class ATgProj_Serqet_CobrasKiss : public ATgProj_Simulated
{
public:
	int                                                s_nIndex;                                                 // 0x0398(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Serqet_CobrasKiss");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgDevice_Serqet_PassiveLeap
// 0x0001 (0x04F1 - 0x04F0)
class ATgDevice_Serqet_PassiveLeap : public ATgDevice
{
public:
	TEnumAsByte<ETweenState>                           m_LeapTweenState;                                         // 0x04F0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Serqet_PassiveLeap");
		return ptr;
	}


	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	bool ApplyGlobalOffhandCooldown();
	bool ShouldInterruptInhand();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Sobek_TailWhip
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Sobek_TailWhip : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sobek_TailWhip");
		return ptr;
	}


	bool CanBeInterrupted();
};


// Class TgGame.TgDevice_Sol_SolarFlair
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Sol_SolarFlair : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sol_SolarFlair");
		return ptr;
	}


	struct FImpactInfo STATIC_CalcWeaponFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgDevice_SoulEater_Evolving
// 0x0000 (0x0528 - 0x0528)
class ATgDevice_SoulEater_Evolving : public ATgDevice_AchieveOnNearbyDeath
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SoulEater_Evolving");
		return ptr;
	}


	int STATIC_GetStacksFor(class ATgPawn* Other);
};


// Class TgGame.TgDevice_SunWukong_SomersaultSlam
// 0x0000 (0x0508 - 0x0508)
class ATgDevice_SunWukong_SomersaultSlam : public ATgDevice_AnvilSlamBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SunWukong_SomersaultSlam");
		return ptr;
	}


	void STATIC_FireAmmunition();
};


// Class TgGame.TgDevice_SunWukong_Transform_OxOnly
// 0x0000 (0x0554 - 0x0554)
class ATgDevice_SunWukong_Transform_OxOnly : public ATgDevice_SunWukong_Transform
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SunWukong_Transform_OxOnly");
		return ptr;
	}

};


// Class TgGame.TgDevice_SunWukong_Transform_TigerOnly
// 0x0000 (0x0554 - 0x0554)
class ATgDevice_SunWukong_Transform_TigerOnly : public ATgDevice_SunWukong_Transform
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SunWukong_Transform_TigerOnly");
		return ptr;
	}

};


// Class TgGame.TgDevice_SunWukong_TransformEagle
// 0x0000 (0x0554 - 0x0554)
class ATgDevice_SunWukong_TransformEagle : public ATgDevice_SunWukong_Transform
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SunWukong_TransformEagle");
		return ptr;
	}

};


// Class TgGame.TgDevice_SunWukong_TransformTiger
// 0x0004 (0x0558 - 0x0554)
class ATgDevice_SunWukong_TransformTiger : public ATgDevice_SunWukong_Transform
{
public:
	unsigned long                                      m_bTriggerPounce : 1;                                     // 0x0554(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_SunWukong_TransformTiger");
		return ptr;
	}


	void STATIC_ClientTriggerPounce();
	void TriggerPounce();
	void InterruptFiring();
	void TransformBack();
};


// Class TgGame.TgDevice_Sylvanus_Deploy
// 0x0000 (0x04FC - 0x04FC)
class ATgDevice_Sylvanus_Deploy : public ATgDevice_Deployable
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sylvanus_Deploy");
		return ptr;
	}

};


// Class TgGame.TgDevice_Sylvanus_Ground
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Sylvanus_Ground : public ATgDevice_Range
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Sylvanus_Ground");
		return ptr;
	}

};


// Class TgGame.TgDevice_Terra_BasicAttack
// 0x0000 (0x0538 - 0x0538)
class ATgDevice_Terra_BasicAttack : public ATgDevice_ChainedMelee
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Terra_BasicAttack");
		return ptr;
	}

};


// Class TgGame.TgDevice_Thanatos_ScentOfDeath
// 0x0014 (0x0538 - 0x0524)
class ATgDevice_Thanatos_ScentOfDeath : public ATgDevice_Aura
{
public:
	int                                                m_nMaxBuffStacks;                                         // 0x0524(0x0004)
	TArray<class AActor*>                              m_PotentialTargets;                                       // 0x0528(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thanatos_ScentOfDeath");
		return ptr;
	}


	void STATIC_DeviceShutDown(bool bDeactiveMode, bool bResetCooldowns);
	void STATIC_FireAmmunition();
	void Tick(float DeltaTime);
	void RemoveFromAllHitAura();
	bool STATIC_RemoveHitAura(class AActor* Other, bool bRemoveFromList);
	void ApplyHitAura(class AActor* Other);
	bool IsAuraActive();
	bool CanBeCanceled();
};


// Class TgGame.TgDevice_Thoth_Assault
// 0x0000 (0x0528 - 0x0528)
class ATgDevice_Thoth_Assault : public ATgDevice_Staging
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thoth_Assault");
		return ptr;
	}


	bool ShouldCooldownAfterFire();
	void InterruptFiring();
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
	TEnumAsByte<EDevOnTriggerType> TriggerCastReactionItemsOn();
	bool ShouldTriggerCastReactionItems();
	bool STATIC_ShouldConsumePowerPoolAfterFire();
	bool STATIC_ShouldConsumePowerPoolOnStartFire();
	void OnStageShooterFire();
	bool CanBeCanceled();
	bool CanJumpWhileFiring();
};


// Class TgGame.TgDevice_Thoth_Assault_Shooter
// 0x0010 (0x0500 - 0x04F0)
class ATgDevice_Thoth_Assault_Shooter : public ATgDevice_Thoth_RangeExtension
{
public:
	int                                                m_ProjectileIdsPerPage[0x4];                              // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Thoth_Assault_Shooter");
		return ptr;
	}


	int STATIC_GetProjectileIDOverride(int ProjectileIndex);
	bool CustomCanDeviceFireNow(unsigned char FireModeNum, const struct FAimData& Aim, bool bDeviceFailLog, TEnumAsByte<EDeviceFailType>* failType);
};


// Class TgGame.TgProj_Tsukuyomi_A04
// 0x0008 (0x03B4 - 0x03AC)
class ATgProj_Tsukuyomi_A04 : public ATgProj_SimulatedPassThrough
{
public:
	int                                                m_nMaxHits;                                               // 0x03AC(0x0004) (Const)
	int                                                m_nCurrentHits;                                           // 0x03B0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Tsukuyomi_A04");
		return ptr;
	}


	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgDevice_Tyr_AggressiveStance2
// 0x0000 (0x04F0 - 0x04F0)
class ATgDevice_Tyr_AggressiveStance2 : public ATgDevice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Tyr_AggressiveStance2");
		return ptr;
	}

};


// Class TgGame.TgDevice_VoidBuff
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_VoidBuff : public ATgDevice_PassiveAura_EffectListener
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_VoidBuff");
		return ptr;
	}


	void AuraRemoved(class AActor* Other);
	void AuraApplied(class AActor* Other);
	void STATIC_RefreshFireModeEffects(class AActor* Other);
	void ProxyUnTouch(class AActor* Other);
	void ProxyTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_Vulcan_ForgeCannon
// 0x0000 (0x053C - 0x053C)
class ATgDevice_Vulcan_ForgeCannon : public ATgDevice_Charge
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Vulcan_ForgeCannon");
		return ptr;
	}


	float GetChargeRange();
};


// Class TgGame.TgDevice_Wizard_A04_Select
// 0x0000 (0x0524 - 0x0524)
class ATgDevice_Wizard_A04_Select : public ATgDevice_Wizard_A04
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Wizard_A04_Select");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_XingTian_AxeSweepShieldBash
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_XingTian_AxeSweepShieldBash : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_XingTian_AxeSweepShieldBash");
		return ptr;
	}

};


// Class TgGame.TgDevice_XingTian_AxeSweepShieldBashV2
// 0x0002 (0x04F4 - 0x04F2)
class ATgDevice_XingTian_AxeSweepShieldBashV2 : public ATgDevice_XingTian_AxeSweepShieldBash
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x04F2(0x0002) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_XingTian_AxeSweepShieldBashV2");
		return ptr;
	}

};


// Class TgGame.TgProj_XingTian_Battlecry
// 0x0004 (0x03B0 - 0x03AC)
class ATgProj_XingTian_Battlecry : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      bCachedEnragedOnFire : 1;                                 // 0x03AC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_XingTian_Battlecry");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgDevice_Zeus_Coffin
// 0x0004 (0x04F4 - 0x04F0)
class ATgDevice_Zeus_Coffin : public ATgDevice
{
public:
	unsigned long                                      m_bCollisionOff : 1;                                      // 0x04F0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Zeus_Coffin");
		return ptr;
	}


	void STATIC_FireAmmunition();
	void TurnOnInstigatorCollision();
	void TurnOffInstigatorCollision();
};


// Class TgGame.TgDevice_Zeus_FlashOfLightning
// 0x0000 (0x04F8 - 0x04F8)
class ATgDevice_Zeus_FlashOfLightning : public ATgDevice_TweenBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDevice_Zeus_FlashOfLightning");
		return ptr;
	}

};


// Class TgGame.TgProj_ZhongKui_RecallDemons
// 0x002C (0x03F8 - 0x03CC)
class ATgProj_ZhongKui_RecallDemons : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bIsCharged : 1;                                         // 0x03CC(0x0004)
	unsigned long                                      m_bExplodeFlashed : 1;                                    // 0x03CC(0x0004)
	float                                              m_fExplosionDelay;                                        // 0x03D0(0x0004)
	class AActor*                                      m_ExplodeTarget;                                          // 0x03D4(0x0008)
	struct FVector                                     m_vExplodeHitLocation;                                    // 0x03DC(0x000C)
	struct FVector                                     m_vExplodeHitNormal;                                      // 0x03E8(0x000C)
	float                                              m_fInitialLifeSpan;                                       // 0x03F4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ZhongKui_RecallDemons");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_ExplodeOnTargetTimer();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostProjectileInitialize();
};


// Class TgGame.TgDeviceFire_AhPuch_Dev1
// 0x0003 (0x01C4 - 0x01C1)
class UTgDeviceFire_AhPuch_Dev1 : public UTgDeviceFire_TwoPhase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x01C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AhPuch_Dev1");
		return ptr;
	}


	float GetPostHitDelay();
	float GetPreHitDelay();
	float GetBuildupTime();
	float GetRefireTime();
};


// Class TgGame.TgDeviceFire_AhPuch_EmptyTheCrypts
// 0x0003 (0x01C4 - 0x01C1)
class UTgDeviceFire_AhPuch_EmptyTheCrypts : public UTgDeviceFire_TwoPhase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x01C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AhPuch_EmptyTheCrypts");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_AoKuang_DragonCall
// 0x0003 (0x01C4 - 0x01C1)
class UTgDeviceFire_AoKuang_DragonCall : public UTgDeviceFire_TwoPhase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x01C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AoKuang_DragonCall");
		return ptr;
	}


	class UTgEffectGroup* STATIC_GetNewEffectGroupForAbsorbDragons(class UTgEffectGroup* Original, struct FImpactInfo* Impact);
	void STATIC_SubmitHitEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact, int nType);
};


// Class TgGame.TgDeviceFire_AoKuang_UltimateJumpDown
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_AoKuang_UltimateJumpDown : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AoKuang_UltimateJumpDown");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_AoKuang_WildStorm
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_AoKuang_WildStorm : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_AoKuang_WildStorm");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
};


// Class TgGame.TgDeviceFire_Ares_Tether
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Ares_Tether : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ares_Tether");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Artio_StanceChange
// 0x0001 (0x01C1 - 0x01C0)
class UTgDeviceFire_Artio_StanceChange : public UTgDeviceFire
{
public:
	TEnumAsByte<EArtioStances>                         m_eStartStance;                                           // 0x01C0(0x0001)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Artio_StanceChange");
		return ptr;
	}


	float GetPostHitDelay();
	float GetPreHitDelay();
};


// Class TgGame.TgDeviceFire_Athena_ShieldWall
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Athena_ShieldWall : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Athena_ShieldWall");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Bastet_A02
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Bastet_A02 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Bastet_A02");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Bastet_UsePassive
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Bastet_UsePassive : public UTgDeviceFire
{
public:
	unsigned long                                      m_bApplyExtraDamage : 1;                                  // 0x01C0(0x0004)
	float                                              m_fDefaultExtraDamageAmount;                              // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Bastet_UsePassive");
		return ptr;
	}


	void STATIC_SubmitHitEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact, int nType);
	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_BastetPounce
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_BastetPounce : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_BastetPounce");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Bellona_VeniVidiVici
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Bellona_VeniVidiVici : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Bellona_VeniVidiVici");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceFire_Camazotz_SiphonPower
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_Camazotz_SiphonPower : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Camazotz_SiphonPower");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Chaac_Num2
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Chaac_Num2 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Chaac_Num2");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
};


// Class TgGame.TgDeviceFire_Chiron_ChargeLong
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Chiron_ChargeLong : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Chiron_ChargeLong");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Equip_Unhittable
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Equip_Unhittable : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Equip_Unhittable");
		return ptr;
	}


	void ApplyEquipEffects();
};


// Class TgGame.TgDeviceFire_Fafnir_Dev2
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_Fafnir_Dev2 : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Fafnir_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Fenrir_Howl
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Fenrir_Howl : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Fenrir_Howl");
		return ptr;
	}


	void STATIC_SubmitHitEffects(class AActor* DamageInstigator, const struct FImpactInfo& Impact, int nType);
};


// Class TgGame.TgDeviceFire_QinsSais
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_QinsSais : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_QinsSais");
		return ptr;
	}


	class ATgPawn* STATIC_GetRelevantPawn(const struct FImpactInfo& Impact);
	float STATIC_GetSpecialPropertyValue(class ATgPawn* RelevantPawn);
	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_HeartseekerS6
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_HeartseekerS6 : public UTgDeviceFire_QinsSais
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HeartseekerS6");
		return ptr;
	}


	class ATgPawn* STATIC_GetRelevantPawn(const struct FImpactInfo& Impact);
	float STATIC_GetSpecialPropertyValue(class ATgPawn* RelevantPawn);
};


// Class TgGame.TgDeviceFire_Hel_Decay
// 0x0014 (0x01D4 - 0x01C0)
class UTgDeviceFire_Hel_Decay : public UTgDeviceFire
{
public:
	TArray<class AActor*>                              s_LastHitList;                                            // 0x01C0(0x0010) (NeedCtorLink)
	int                                                s_LastFiringInstance;                                     // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hel_Decay");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Hera_Dev1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Hera_Dev1 : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hera_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Hercules_Batterup
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_Hercules_Batterup : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Hercules_Batterup");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_HitOncePerTarget
// 0x0014 (0x01D4 - 0x01C0)
class UTgDeviceFire_HitOncePerTarget : public UTgDeviceFire
{
public:
	TArray<class AActor*>                              s_LastHitList;                                            // 0x01C0(0x0010) (NeedCtorLink)
	int                                                s_LastFiringInstance;                                     // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HitOncePerTarget");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_HouYi_Dev1_Shooter
// 0x0000 (0x01D4 - 0x01D4)
class UTgDeviceFire_HouYi_Dev1_Shooter : public UTgDeviceFire_Spline
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_HouYi_Dev1_Shooter");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Izanami_Inhand
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Izanami_Inhand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Izanami_Inhand");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_JingWei_Dev2
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_JingWei_Dev2 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_JingWei_Dev2");
		return ptr;
	}


	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceFire_Neith_WorldWeaver
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_Neith_WorldWeaver : public UTgDeviceFire
{
public:
	class ATgPawn_Neith*                               m_OwningNeith;                                            // 0x01C0(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Neith_WorldWeaver");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	void AdjustStun(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Nemesis_Num4
// 0x0000 (0x01C4 - 0x01C4)
class UTgDeviceFire_Nemesis_Num4 : public UTgDeviceFire_GroundTarget_LockOn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Nemesis_Num4");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_Nemesis_Num4SelfHitSub
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Nemesis_Num4SelfHitSub : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Nemesis_Num4SelfHitSub");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_Nemesis_Passive
// 0x0004 (0x01C4 - 0x01C0)
class UTgDeviceFire_Nemesis_Passive : public UTgDeviceFire
{
public:
	float                                              m_fPhysicalPowerToAdd;                                    // 0x01C0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Nemesis_Passive");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_NeZha_Passive
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_NeZha_Passive : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NeZha_Passive");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_NoSuccessfulHitOnStructures
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_NoSuccessfulHitOnStructures : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_NoSuccessfulHitOnStructures");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
};


// Class TgGame.TgDeviceFire_OniFuryBuff
// 0x0003 (0x01C4 - 0x01C1)
class UTgDeviceFire_OniFuryBuff : public UTgDeviceFire_LayeredBuffEffects
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x01C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_OniFuryBuff");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Osiris_5
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Osiris_5 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Osiris_5");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Osiris_MummyWrap
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Osiris_MummyWrap : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Osiris_MummyWrap");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Racer_HitByPlace
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Racer_HitByPlace : public UTgDeviceFire_Racer_TargetAhead
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Racer_HitByPlace");
		return ptr;
	}


	void ApplyPlaceBasedEffects(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Racer_SpeedPad
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Racer_SpeedPad : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Racer_SpeedPad");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Raijin_Dev1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Raijin_Dev1 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Raijin_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Ram_AstralQuiver2
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Ram_AstralQuiver2 : public UTgDeviceFire_Deploy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ram_AstralQuiver2");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Ratatoskr_Dart
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Ratatoskr_Dart : public UTgDeviceFire_Ratatoskr_Base
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ratatoskr_Dart");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
	bool AllowAcornBasedHits(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Ratatoskr_FlurryV2
// 0x0014 (0x01D4 - 0x01C0)
class UTgDeviceFire_Ratatoskr_FlurryV2 : public UTgDeviceFire
{
public:
	TArray<struct FAcornThrowHitData>                  m_HitData;                                                // 0x01C0(0x0010) (NeedCtorLink)
	int                                                m_currentFiringInstance;                                  // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ratatoskr_FlurryV2");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
};


// Class TgGame.TgDeviceFire_Ratatoskr_FlurryV3
// 0x0000 (0x01D4 - 0x01D4)
class UTgDeviceFire_Ratatoskr_FlurryV3 : public UTgDeviceFire_Ratatoskr_FlurryV2
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ratatoskr_FlurryV3");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
};


// Class TgGame.TgDeviceFire_Ratatoskr_TailSpin
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Ratatoskr_TailSpin : public UTgDeviceFire_Ratatoskr_Base
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ratatoskr_TailSpin");
		return ptr;
	}


	bool AllowAcornBasedHits(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Ratatoskr_UltimateShooter
// 0x0003 (0x01C4 - 0x01C1)
class UTgDeviceFire_Ratatoskr_UltimateShooter : public UTgDeviceFire_TwoPhase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x01C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ratatoskr_UltimateShooter");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_Ravana_Dev4
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Ravana_Dev4 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Ravana_Dev4");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceFire_RotationAsImpact
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_RotationAsImpact : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_RotationAsImpact");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_ScaryPotion
// 0x0008 (0x01C8 - 0x01C0)
class UTgDeviceFire_ScaryPotion : public UTgDeviceFire
{
public:
	float                                              m_fMinEffectGroupLifeTime;                                // 0x01C0(0x0004)
	float                                              m_fMaxEffectGroupLifeTime;                                // 0x01C4(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ScaryPotion");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_Scylla_Num1
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Scylla_Num1 : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Scylla_Num1");
		return ptr;
	}


	bool ApplyHit(const struct FImpactInfo& Impact, class AActor* DamageInstigator);
};


// Class TgGame.TgDeviceFire_Serqet_InHand
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Serqet_InHand : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Serqet_InHand");
		return ptr;
	}


	bool IsTargetPoisoned(class AActor* Target);
	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceFire_ShieldStacker
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_ShieldStacker : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_ShieldStacker");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_Sol_SolarFlair
// 0x0000 (0x01D4 - 0x01D4)
class UTgDeviceFire_Sol_SolarFlair : public UTgDeviceFire_Spline
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Sol_SolarFlair");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
	void STATIC_GetHitType(const struct FImpactInfo& Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType);
};


// Class TgGame.TgDeviceFire_SoulMates
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_SoulMates : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SoulMates");
		return ptr;
	}


	void STATIC_HandleSuccessfulHit(class AActor* DamageInstigator, class APawn* OwnerInstigator, const struct FImpactInfo& Impact, int nHitType, int nSituationalType);
};


// Class TgGame.TgDeviceFire_SunWukong_Passive
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_SunWukong_Passive : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_SunWukong_Passive");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_XingTian_HeroicLeap
// 0x0003 (0x01C4 - 0x01C1)
class UTgDeviceFire_XingTian_HeroicLeap : public UTgDeviceFire_TwoPhase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x01C1(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_XingTian_HeroicLeap");
		return ptr;
	}

};


// Class TgGame.TgDeviceFire_XingTian_UltSweep
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_XingTian_UltSweep : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_XingTian_UltSweep");
		return ptr;
	}


	void SubmitEffect(const struct FImpactInfo& Impact, class UTgEffectGroup* EffectGroup, bool bRemove, int StackCount);
};


// Class TgGame.TgDeviceFire_Zeus_Coffin
// 0x0000 (0x01C0 - 0x01C0)
class UTgDeviceFire_Zeus_Coffin : public UTgDeviceFire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceFire_Zeus_Coffin");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_AhMuzenCab_Hive
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_AhMuzenCab_Hive : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AhMuzenCab_Hive");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
};


// Class TgGame.TgDeviceForm_AhMuzenCab_Honey
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_AhMuzenCab_Honey : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AhMuzenCab_Honey");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
};


// Class TgGame.TgDeviceForm_AhPuch_EmptyTheCrypts
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_AhPuch_EmptyTheCrypts : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AhPuch_EmptyTheCrypts");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_AoKuang_DragonCall
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_AoKuang_DragonCall : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_AoKuang_DragonCall");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Apep_AcidSpray
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Apep_AcidSpray : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Apep_AcidSpray");
		return ptr;
	}


	void ExitTargetingMode();
	void EnterTargetingMode();
};


// Class TgGame.TgDeviceForm_Aphrodite_Kiss
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Aphrodite_Kiss : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Aphrodite_Kiss");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Arachne_WebShooter
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Arachne_WebShooter : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Arachne_WebShooter");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Bastet_A01
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_Bastet_A01 : public UTgDeviceForm_Bastet_EnhancedOffhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Bastet_A01");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Bastet_A02
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_Bastet_A02 : public UTgDeviceForm_Bastet_EnhancedOffhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Bastet_A02");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Bastet_A03
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_Bastet_A03 : public UTgDeviceForm_Bastet_EnhancedOffhand
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Bastet_A03");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Bastet_Declaw
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Bastet_Declaw : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Bastet_Declaw");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Bellona_ShieldBash
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Bellona_ShieldBash : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Bellona_ShieldBash");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Cerberus_Dev4
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Cerberus_Dev4 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Cerberus_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_CH05_Flamethrower
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_CH05_Flamethrower : public UTgDeviceForm_RadialSweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CH05_Flamethrower");
		return ptr;
	}


	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceForm_ChangE_CrescentMoonDance
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_ChangE_CrescentMoonDance : public UTgDeviceForm_RadialSweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_ChangE_CrescentMoonDance");
		return ptr;
	}


	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceForm_Change_Moonflower
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Change_Moonflower : public UTgDeviceForm_RadialSweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Change_Moonflower");
		return ptr;
	}


	void RadialSweep(int nYaw, float fDuration);
	void StopFire(int nFireModeNum);
};


// Class TgGame.TgDeviceForm_Chiron_Charge
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_Chiron_Charge : public UTgDeviceForm_SunWukong_Transform
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Chiron_Charge");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_CTF_FlagMelee
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_CTF_FlagMelee : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_CTF_FlagMelee");
		return ptr;
	}


	void StartFire(int nFireMode, float fRefireTime, class AActor* Target);
};


// Class TgGame.TgDeviceForm_DaJi_SpiritLink
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_DaJi_SpiritLink : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_DaJi_SpiritLink");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Discordia_ChaosBlast
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Discordia_ChaosBlast : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Discordia_ChaosBlast");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Discordia_GoldenAppleOfDiscord
// 0x0000 (0x029C - 0x029C)
class UTgDeviceForm_Discordia_GoldenAppleOfDiscord : public UTgDeviceForm_SplineTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Discordia_GoldenAppleOfDiscord");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Fafnir_Dev2
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Fafnir_Dev2 : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Fafnir_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Fafnir_Dev3
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Fafnir_Dev3 : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Fafnir_Dev3");
		return ptr;
	}


	void BuildUp(int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime);
};


// Class TgGame.TgDeviceForm_Fenrir_Brutalize
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Fenrir_Brutalize : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Fenrir_Brutalize");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_G86_Dev1
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_G86_Dev1 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_G86_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Geb_StoneShield
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Geb_StoneShield : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Geb_StoneShield");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Hachiman_Dev2
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Hachiman_Dev2 : public UTgDeviceForm_RadialSweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hachiman_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Hel_Dev1
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Hel_Dev1 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hel_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Hera_Dev4_AltTargeting
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Hera_Dev4_AltTargeting : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Hera_Dev4_AltTargeting");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Horus_Dev3
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Horus_Dev3 : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Horus_Dev3");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_HouYi_Dev1_Shooter
// 0x0000 (0x029C - 0x029C)
class UTgDeviceForm_HouYi_Dev1_Shooter : public UTgDeviceForm_SplineTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HouYi_Dev1_Shooter");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_HouYi_GoldenCrow
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_HouYi_GoldenCrow : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_HouYi_GoldenCrow");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Janus_DeathGate
// 0x0000 (0x029C - 0x029C)
class UTgDeviceForm_Janus_DeathGate : public UTgDeviceForm_SplineTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Janus_DeathGate");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_JingWei_Dev4
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_JingWei_Dev4 : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_JingWei_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Khepri_Dev4
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Khepri_Dev4 : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Khepri_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Kukulkan_Dev1
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Kukulkan_Dev1 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Kukulkan_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Kuzenbo_NeNeKappa
// 0x0000 (0x029C - 0x029C)
class UTgDeviceForm_Kuzenbo_NeNeKappa : public UTgDeviceForm_SplineTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Kuzenbo_NeNeKappa");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_LineConePrefire
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_LineConePrefire : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_LineConePrefire");
		return ptr;
	}


	void NotifyTargetingModeStatusChange();
};


// Class TgGame.TgDeviceForm_Loki_Assassinate
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Loki_Assassinate : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Loki_Assassinate");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Medusa_Offhand2
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Medusa_Offhand2 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Medusa_Offhand2");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Neith_Unravel
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceForm_Neith_Unravel : public UTgDeviceForm_Neith_SpiritArrow
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Neith_Unravel");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Nemesis_Ult
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Nemesis_Ult : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Nemesis_Ult");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Nox_Dev4
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Nox_Dev4 : public UTgDeviceForm_LineConePrefire
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Nox_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_NuWa_ShiningMetal
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceForm_NuWa_ShiningMetal : public UTgDeviceForm_Neith_SpiritArrow
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_NuWa_ShiningMetal");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Persephone_A01
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Persephone_A01 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Persephone_A01");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_PreFire
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_PreFire : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_PreFire");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Raijin_Dev1
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Raijin_Dev1 : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Raijin_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Ratatoskr_UltimateShooter
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Ratatoskr_UltimateShooter : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Ratatoskr_UltimateShooter");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Ravana_Dev4
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Ravana_Dev4 : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Ravana_Dev4");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Scylla_Dev1
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Scylla_Dev1 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Scylla_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Scylla_Monster
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_Scylla_Monster : public UTgDeviceForm_MultipleTargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Scylla_Monster");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Set_A01
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Set_A01 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Set_A01");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Skadi_Dev1
// 0x0000 (0x0268 - 0x0268)
class UTgDeviceForm_Skadi_Dev1 : public UTgDeviceForm_Neith_SpiritArrow
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Skadi_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Skadi_Dev2
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Skadi_Dev2 : public UTgDeviceForm_TargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Skadi_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Sol_Dev2
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Sol_Dev2 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Sol_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Sol_SolarFlair
// 0x0000 (0x029C - 0x029C)
class UTgDeviceForm_Sol_SolarFlair : public UTgDeviceForm_SplineTarget
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Sol_SolarFlair");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Susano_Dev2
// 0x0000 (0x024C - 0x024C)
class UTgDeviceForm_Susano_Dev2 : public UTgDeviceForm_Nemesis_Num2
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Susano_Dev2");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Susano_Dev2_Part3
// 0x0000 (0x0238 - 0x0238)
class UTgDeviceForm_Susano_Dev2_Part3 : public UTgDeviceForm
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Susano_Dev2_Part3");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Thor_AnvilOfDawn
// 0x0000 (0x023C - 0x023C)
class UTgDeviceForm_Thor_AnvilOfDawn : public UTgDeviceForm_Arcing
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Thor_AnvilOfDawn");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Thoth_Assault
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Thoth_Assault : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Thoth_Assault");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Thoth_Dev1
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Thoth_Dev1 : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Thoth_Dev1");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Thoth_Dev2_Shooter
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_Thoth_Dev2_Shooter : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Thoth_Dev2_Shooter");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_UllrDev3
// 0x0000 (0x0254 - 0x0254)
class UTgDeviceForm_UllrDev3 : public UTgDeviceForm_MultipleTargetIndicator
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_UllrDev3");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_Wizard_C01
// 0x0000 (0x0244 - 0x0244)
class UTgDeviceForm_Wizard_C01 : public UTgDeviceForm_LineCone
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_Wizard_C01");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_XingTian_SkyCuttingAxe
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_XingTian_SkyCuttingAxe : public UTgDeviceForm_TwoPhase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_XingTian_SkyCuttingAxe");
		return ptr;
	}

};


// Class TgGame.TgDeviceForm_XingTian_UltSweep
// 0x0000 (0x0248 - 0x0248)
class UTgDeviceForm_XingTian_UltSweep : public UTgDeviceForm_RadialSweep
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceForm_XingTian_UltSweep");
		return ptr;
	}

};


// Class TgGame.TgDeviceVolumeInfo
// 0x0008 (0x0268 - 0x0260)
class ATgDeviceVolumeInfo : public AInfo
{
public:
	class ATgDeviceVolume*                             V;                                                        // 0x0260(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolumeInfo");
		return ptr;
	}


	void Timer();
	void PostBeginPlay();
};


// Class TgGame.TgDeviceVolume_Moveable
// 0x0018 (0x0320 - 0x0308)
class ATgDeviceVolume_Moveable : public ATgDeviceVolume
{
public:
	unsigned long                                      m_bHitOncePerToggle : 1;                                  // 0x0308(0x0004) (Edit)
	float                                              m_fRehitAfter;                                            // 0x030C(0x0004) (Edit)
	TArray<struct FDVMHitTimeStamp>                    s_PrevHits;                                               // 0x0310(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume_Moveable");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void CausePainTo(class AActor* Other);
	bool STATIC_CanCausePainTo(class AActor* Other);
	void STATIC_OnToggle(class USeqAct_Toggle* inAction);
};


// Class TgGame.TgDeviceVolume_Untouch
// 0x0004 (0x030C - 0x0308)
class ATgDeviceVolume_Untouch : public ATgDeviceVolume
{
public:
	unsigned long                                      m_bRemoveOld : 1;                                         // 0x0308(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgDeviceVolume_Untouch");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void TimerPop(class ATgDeviceVolumeInfo* T);
	void PostBeginPlay();
};


// Class TgGame.TgEffectDamage_ReapplyInterval
// 0x0000 (0x00B8 - 0x00B8)
class UTgEffectDamage_ReapplyInterval : public UTgEffectDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectDamage_ReapplyInterval");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Arachne_LoveFangs
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_Arachne_LoveFangs : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Arachne_LoveFangs");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_BaronSamedi_Skull
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_BaronSamedi_Skull : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_BaronSamedi_Skull");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_BaronSamedi_Snake
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_BaronSamedi_Snake : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_BaronSamedi_Snake");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_ErlangShen_NineTurnsBlessing
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_ErlangShen_NineTurnsBlessing : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_ErlangShen_NineTurnsBlessing");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_HelSkin_A01_Light
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_HelSkin_A01_Light : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_HelSkin_A01_Light");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_HouYi_Mark
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_HouYi_Mark : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_HouYi_Mark");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Nox_ShieldBreak
// 0x0000 (0x011C - 0x011C)
class UTgEffectForm_Nox_ShieldBreak : public UTgEffectForm_BulwarkOfHope
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Nox_ShieldBreak");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_NuWa_Meteor
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_NuWa_Meteor : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_NuWa_Meteor");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Odin_RavenShout
// 0x0000 (0x011C - 0x011C)
class UTgEffectForm_Odin_RavenShout : public UTgEffectForm_BulwarkOfHope
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Odin_RavenShout");
		return ptr;
	}

};


// Class TgGame.TgEffectForm_Sylvanus_Hand
// 0x0000 (0x0120 - 0x0120)
class UTgEffectForm_Sylvanus_Hand : public UTgEffectForm_WithMeshes
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectForm_Sylvanus_Hand");
		return ptr;
	}

};


// Class TgGame.TgEffectHeal_True
// 0x0000 (0x00A8 - 0x00A8)
class UTgEffectHeal_True : public UTgEffectHeal
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEffectHeal_True");
		return ptr;
	}

};


// Class TgGame.TgElevatingVolume
// 0x0000 (0x02F4 - 0x02F4)
class ATgElevatingVolume : public APhysicsVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgElevatingVolume");
		return ptr;
	}

};


// Class TgGame.TgEmitterCrashlanding
// 0x0024 (0x0298 - 0x0274)
class ATgEmitterCrashlanding : public ATgEmitterSpawnable
{
public:
	class UStaticMeshComponent*                        m_PrimaryMesh;                                            // 0x0274(0x0008) (ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        m_SecondaryMesh;                                          // 0x027C(0x0008) (ExportObject, Component, EditInline)
	float                                              ParticleDurationAfterImpact;                              // 0x0284(0x0004)
	class ULensFlareComponent*                         m_LensFlare;                                              // 0x0288(0x0008) (ExportObject, Component, EditInline)
	class UAudioComponent*                             m_AudioComponent;                                         // 0x0290(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmitterCrashlanding");
		return ptr;
	}


	void STATIC_PostImpactComplete();
	void STATIC_OnImpact();
	void STATIC_SetAudio(class USoundCue* SoundCueToSet);
	void STATIC_SetSecondaryMesh(class UStaticMesh* StaticMeshToSet);
	void STATIC_SetPrimaryMesh(class UStaticMesh* StaticMeshToSet);
};


// Class TgGame.TgEmoteConfigResource_VXGMusic
// 0x0000 (0x0080 - 0x0080)
class UTgEmoteConfigResource_VXGMusic : public UTgEmoteConfigResource_VXGLooping
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmoteConfigResource_VXGMusic");
		return ptr;
	}

};


// Class TgGame.TgEmoteConfigResource_VXGSuppressed20
// 0x0000 (0x0080 - 0x0080)
class UTgEmoteConfigResource_VXGSuppressed20 : public UTgEmoteConfigResource
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgEmoteConfigResource_VXGSuppressed20");
		return ptr;
	}

};


// Class TgGame.TgFadingEnvironmentInterface
// 0x0000 (0x0060 - 0x0060)
class UTgFadingEnvironmentInterface : public UInterface
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgFadingEnvironmentInterface");
		return ptr;
	}


	void STATIC_SetFading(bool bShouldBeFaded, bool bImmediate);
};


// Class TgGame.TgSeqEvent_Training_QuestComplete
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_Training_QuestComplete : public USequenceEvent
{
public:
	int                                                m_nEventId;                                               // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_Training_QuestComplete");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Clash_Training
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Clash_Training : public ATgGame_Battle_Clash_Practice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Clash_Training");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_ClashV2_Training
// 0x0000 (0x07F0 - 0x07F0)
class ATgGame_Battle_ClashV2_Training : public ATgGame_Battle_ClashV2_Practice
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_ClashV2_Training");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Conquest_Casual_1_10_9
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Conquest_Casual_1_10_9 : public ATgGame_Battle_Conquest
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Casual_1_10_9");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Conquest_Casual_3_6_7
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Conquest_Casual_3_6_7 : public ATgGame_Battle_Conquest
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Casual_3_6_7");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Conquest_Casual_5_0_7
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Conquest_Casual_5_0_7 : public ATgGame_Battle_Conquest
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Conquest_Casual_5_0_7");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Joust_Casual_3_10_9
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Joust_Casual_3_10_9 : public ATgGame_Battle_Joust
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Joust_Casual_3_10_9");
		return ptr;
	}

};


// Class TgGame.TgGame_Battle_Joust_Casual_5_0_7
// 0x0000 (0x07E0 - 0x07E0)
class ATgGame_Battle_Joust_Casual_5_0_7 : public ATgGame_Battle_Joust
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgGame_Battle_Joust_Casual_5_0_7");
		return ptr;
	}

};


// Class TgGame.TgIdol
// 0x001C (0x027C - 0x0260)
class ATgIdol : public AActor
{
public:
	int                                                r_nDefenderTaskForce;                                     // 0x0260(0x0004) (Net, Transient)
	class ATgPawn_Character*                           m_Holder;                                                 // 0x0264(0x0008) (Transient)
	class ATgRepInfo_Player*                           r_HolderPRI;                                              // 0x026C(0x0008) (Net, Transient)
	class ATgPawn_Character*                           m_OldHolder;                                              // 0x0274(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgIdol");
		return ptr;
	}

};


// Class TgGame.TgHoldSpot
// 0x0008 (0x0388 - 0x0380)
class ATgHoldSpot : public ATgDefensePoint
{
public:
	class AVehicle*                                    HoldVehicle;                                              // 0x0380(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgHoldSpot");
		return ptr;
	}


	void STATIC_FreePoint();
	class AActor* STATIC_GetMoveTarget();
};


// Class TgGame.TgInterpolatingCameraActor
// 0x001C (0x041C - 0x0400)
class ATgInterpolatingCameraActor : public ACameraActor
{
public:
	TArray<struct FInterpolatingCameraInfo>            m_CameraArray;                                            // 0x0400(0x0010) (Edit, NeedCtorLink)
	int                                                m_nCurrentCameraIndex;                                    // 0x0410(0x0004) (Edit)
	float                                              m_fCurrentInterpValue;                                    // 0x0414(0x0004)
	float                                              m_fTargetInterpValue;                                     // 0x0418(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInterpolatingCameraActor");
		return ptr;
	}


	void Tick(float DeltaTime);
	void STATIC_GetCameraView(float DeltaTime, bool bOnlyFOV, struct FTPOV* OutPOV);
	void GetActorEyesViewPoint(struct FVector* out_Location, struct FRotator* out_Rotation);
};


// Class TgGame.TgInventoryObject_Device_NotEquipped
// 0x0000 (0x00CC - 0x00CC)
class UTgInventoryObject_Device_NotEquipped : public UTgInventoryObject_Device
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Device_NotEquipped");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_EvolvedCharonsCoin
// 0x0000 (0x014C - 0x014C)
class UTgInventoryObject_Listen_EvolvedCharonsCoin : public UTgInventoryObject_Listen_KillStackRandom
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_EvolvedCharonsCoin");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Heartseeker
// 0x0000 (0x0134 - 0x0134)
class UTgInventoryObject_Listen_Heartseeker : public UTgInventoryObject_Listen_SoulStone_S3
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Heartseeker");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HydrasDemise
// 0x0000 (0x00EC - 0x00EC)
class UTgInventoryObject_Listen_HydrasDemise : public UTgInventoryObject_Listen_NextAuto_AdjustDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HydrasDemise");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_HydrasStar
// 0x0000 (0x00EC - 0x00EC)
class UTgInventoryObject_Listen_HydrasStar : public UTgInventoryObject_Listen_NextAuto_AdjustDamage
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_HydrasStar");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_OnHitBy_or_Hit_Once
// 0x0000 (0x00E4 - 0x00E4)
class UTgInventoryObject_Listen_OnHitBy_or_Hit_Once : public UTgInventoryObject_Listen_OnHit_or_HitBy
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_OnHitBy_or_Hit_Once");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_SerqetCatalystWithRemove
// 0x0000 (0x00FC - 0x00FC)
class UTgInventoryObject_Listen_SerqetCatalystWithRemove : public UTgInventoryObject_Listen_SerqetCatalyst
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_SerqetCatalystWithRemove");
		return ptr;
	}

};


// Class TgGame.TgInventoryObject_Listen_Thyrsus
// 0x0000 (0x00E0 - 0x00E0)
class UTgInventoryObject_Listen_Thyrsus : public UTgInventoryObject_Listen_OnEffectCategoryRemoved
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgInventoryObject_Listen_Thyrsus");
		return ptr;
	}

};


// Class TgGame.TgKismetTestActor
// 0x0040 (0x02F0 - 0x02B0)
class ATgKismetTestActor : public ADynamicSMActor
{
public:
	int                                                m_nTestCount;                                             // 0x02B0(0x0004) (Edit)
	int                                                r_nCurrentTest;                                           // 0x02B4(0x0004) (Edit, Net)
	int                                                r_nPassCount;                                             // 0x02B8(0x0004) (Net)
	int                                                r_nFailCount;                                             // 0x02BC(0x0004) (Net)
	TArray<class UTexture2D*>                          c_aTextures;                                              // 0x02C0(0x0010) (Edit, NeedCtorLink)
	class USoundCue*                                   c_PassSound;                                              // 0x02D0(0x0008) (Edit)
	class USoundCue*                                   c_FailSound;                                              // 0x02D8(0x0008) (Edit)
	TArray<class AInterpActor*>                        c_aResultActors;                                          // 0x02E0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgKismetTestActor");
		return ptr;
	}


	void ReplicatedEvent(const struct FName& VarName);
	void STATIC_StartTest(int Num);
	void STATIC_FailTest(int Num);
	void STATIC_PassTest(int Num);
	void PostBeginPlay();
	void STATIC_SetTestColor(int Num, const struct FLinearColor& Col);
	class APlayerController* STATIC_GetLocalPlayer();
	void STATIC_OnTestResult(class UTgSeqAct_TestResult* Action);
};


// Class TgGame.TgSeqAct_TestResult
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_TestResult : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TestResult");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_LobbyCameraSetActive
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_LobbyCameraSetActive : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_LobbyCameraSetActive");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_LobbyFocusChanged
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_LobbyFocusChanged : public USequenceAction
{
public:
	int                                                m_nFocusIndex;                                            // 0x0108(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LobbyFocusChanged");
		return ptr;
	}

};


// Class TgGame.TgMenuTransitionActor
// 0x0018 (0x0278 - 0x0260)
class ATgMenuTransitionActor : public AActor
{
public:
	class UParticleSystemComponent*                    m_IntroPSC;                                               // 0x0260(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    m_LoopPSC;                                                // 0x0268(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    m_OutroPSC;                                               // 0x0270(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgMenuTransitionActor");
		return ptr;
	}


	void STATIC_StopLoop();
	void STATIC_PlayLoop();
	void STATIC_PlayOutro();
	void STATIC_PlayIntro();
};


// Class TgGame.TgSeqAct_ParentAnimComponent
// 0x0004 (0x010C - 0x0108)
class UTgSeqAct_ParentAnimComponent : public USequenceAction
{
public:
	unsigned long                                      bDetach : 1;                                              // 0x0108(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ParentAnimComponent");
		return ptr;
	}

};


// Class TgGame.TgPawn_ArenaJuggernaut_RA2015a
// 0x0017 (0x25A4 - 0x258D)
class ATgPawn_ArenaJuggernaut_RA2015a : public ATgPawn_WiseCleric
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x258D(0x0003) MISSED OFFSET
	float                                              r_fDespawnHealthPercent;                                  // 0x2590(0x0004) (Net)
	TArray<struct FName>                               m_DespawnAnimNames;                                       // 0x2594(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_ArenaJuggernaut_RA2015a");
		return ptr;
	}


	struct FName GetDespawnAnimName();
	void Despawn();
};


// Class TgGame.TgSkeletalMeshActor_DestructibleTowerChunk
// 0x0008 (0x0324 - 0x031C)
class ATgSkeletalMeshActor_DestructibleTowerChunk : public ATgSkeletalMeshActorSpawnable
{
public:
	class UTgSkeletalMeshComponent*                    TgSkeletalMeshComp;                                       // 0x031C(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_DestructibleTowerChunk");
		return ptr;
	}


	bool PlayParticleEffect(class UAnimNotify_PlayParticleEffect* AnimNotifyData);
	void STATIC_PlayDestruction(int MeshId, class ATgPawn_Tower* OwningTower);
};


// Class TgGame.TgPawn_AsgardTower
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_AsgardTower : public ATgPawn_Tower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_AsgardTower");
		return ptr;
	}

};


// Class TgGame.TgPawn_Bakasura_Minion
// 0x0000 (0x2464 - 0x2464)
class ATgPawn_Bakasura_Minion : public ATgPawn_Familiar
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Bakasura_Minion");
		return ptr;
	}


	struct FName GetDeathAnimName();
};


// Class TgGame.TgPawn_CapturePointGuard
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_CapturePointGuard : public ATgPawn_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CapturePointGuard");
		return ptr;
	}


	bool STATIC_CanDespawn();
};


// Class TgGame.TgPawn_CH05_DraugrFinger
// 0x0000 (0x2574 - 0x2574)
class ATgPawn_CH05_DraugrFinger : public ATgPawn_EliteMOB_Adv
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH05_DraugrFinger");
		return ptr;
	}


	void STATIC_PossessedBy(class AController* C, bool bVehicleTransition);
};


// Class TgGame.TgPawn_CH06_Spawner
// 0x0000 (0x2574 - 0x2574)
class ATgPawn_CH06_Spawner : public ATgPawn_EliteMOB_CH06
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH06_Spawner");
		return ptr;
	}


	void KillAllOwnedPets();
};


// Class TgGame.TgPawn_CH07_Hydra
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_CH07_Hydra : public ATgPawn_Monster
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_CH07_Hydra");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ObjectiveEvent
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_ObjectiveEvent : public USequenceEvent
{
public:
	int                                                m_nTaskForce;                                             // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ObjectiveEvent");
		return ptr;
	}

};


// Class TgGame.TgPawn_Chaac_UltStorm
// 0x0000 (0x2464 - 0x2464)
class ATgPawn_Chaac_UltStorm : public ATgPawn_Familiar
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Chaac_UltStorm");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
};


// Class TgGame.TgPawn_DaJi_Skin9
// 0x0000 (0x26F0 - 0x26F0)
class ATgPawn_DaJi_Skin9 : public ATgPawn_DaJi
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_DaJi_Skin9");
		return ptr;
	}

};


// Class TgGame.TgPawn_DaJi_PVE
// 0x0000 (0x26F0 - 0x26F0)
class ATgPawn_DaJi_PVE : public ATgPawn_DaJi_Skin9
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_DaJi_PVE");
		return ptr;
	}

};


// Class TgGame.TgPawn_Discordia_Skin3
// 0x0000 (0x25FC - 0x25FC)
class ATgPawn_Discordia_Skin3 : public ATgPawn_Discordia
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Discordia_Skin3");
		return ptr;
	}

};


// Class TgGame.TgPawn_Egypt_Ba
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_Egypt_Ba : public ATgPawn_Fury
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Egypt_Ba");
		return ptr;
	}


	struct FName GetDeathAnimName();
};


// Class TgGame.TgPawn_Gryphon
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Gryphon : public ATgPawn_Tower_ArenaBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Gryphon");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TitanAggroState
// 0x0004 (0x012C - 0x0128)
class UTgSeqEvent_TitanAggroState : public USequenceEvent
{
public:
	unsigned long                                      m_bAggrod : 1;                                            // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TitanAggroState");
		return ptr;
	}

};


// Class TgGame.TgPawn_Guardian_PEP
// 0x0000 (0x25D4 - 0x25D4)
class ATgPawn_Guardian_PEP : public ATgPawn_Guardian
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Guardian_PEP");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
};


// Class TgGame.TgPawn_Guardian_Season5
// 0x0008 (0x25DC - 0x25D4)
class ATgPawn_Guardian_Season5 : public ATgPawn_Guardian
{
public:
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent2;                                    // 0x25D4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Guardian_Season5");
		return ptr;
	}


	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
};


// Class TgGame.TgPawn_HouYiSkin_PetA02
// 0x0000 (0x24F8 - 0x24F8)
class ATgPawn_HouYiSkin_PetA02 : public ATgPawn_HouYiSkin_BasePet
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_HouYiSkin_PetA02");
		return ptr;
	}

};


// Class TgGame.TgPawn_Isis_Skin6
// 0x0000 (0x25E4 - 0x25E4)
class ATgPawn_Isis_Skin6 : public ATgPawn_Isis
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Isis_Skin6");
		return ptr;
	}

};


// Class TgGame.TgPawn_JanusV2
// 0x0000 (0x25CC - 0x25CC)
class ATgPawn_JanusV2 : public ATgPawn_Janus
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_JanusV2");
		return ptr;
	}


	bool STATIC_DoesInstigatorAllowFloorPortalActorCollision();
};


// Class TgGame.TgPawn_JoustBoss_CJ2016a
// 0x0000 (0x2574 - 0x2574)
class ATgPawn_JoustBoss_CJ2016a : public ATgPawn_JoustBoss
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_JoustBoss_CJ2016a");
		return ptr;
	}

};


// Class TgGame.TgPawn_MiniBastet
// 0x0000 (0x2400 - 0x2400)
class ATgPawn_MiniBastet : public ATgPawn
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_MiniBastet");
		return ptr;
	}

};


// Class TgGame.TgPawn_Minion_RA2015a
// 0x0010 (0x259C - 0x258C)
class ATgPawn_Minion_RA2015a : public ATgPawn_Minion
{
public:
	TArray<struct FName>                               m_DespawnAnimNames;                                       // 0x258C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Minion_RA2015a");
		return ptr;
	}


	struct FName GetDespawnAnimName();
};


// Class TgGame.TgProj_NeZha_ArmillarySash
// 0x0000 (0x0398 - 0x0398)
class ATgProj_NeZha_ArmillarySash : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_NeZha_ArmillarySash");
		return ptr;
	}


	void ShutDown();
	void SpawnFlightEffects();
	void Tick(float DeltaSeconds);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_RangeReached();
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgPawn_Nox_Skin10
// 0x0000 (0x26AC - 0x26AC)
class ATgPawn_Nox_Skin10 : public ATgPawn_Nox
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Nox_Skin10");
		return ptr;
	}


	void UpdatePassiveFx(int NewPassiveCount);
};


// Class TgGame.TgPawn_Phoenix_ClashS5
// 0x0014 (0x249C - 0x2488)
class ATgPawn_Phoenix_ClashS5 : public ATgPawn_Phoenix_TowerPadOwner
{
public:
	struct FVector                                     m_vFireballSpawnOffset;                                   // 0x2488(0x000C)
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                                     // 0x2494(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Phoenix_ClashS5");
		return ptr;
	}


	struct FVector STATIC_GetFireLocationOffset(class ATgDevice* Dev);
	void STATIC_CleanUpDyingEffects();
	void STATIC_PlayDyingEffects();
};


// Class TgGame.TgPawn_Phoenix_GreekConquest
// 0x0000 (0x2488 - 0x2488)
class ATgPawn_Phoenix_GreekConquest : public ATgPawn_Phoenix_TowerPadOwner
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Phoenix_GreekConquest");
		return ptr;
	}

};


// Class TgGame.TgPawn_Phoenix_PVE_Tier2
// 0x0000 (0x2480 - 0x2480)
class ATgPawn_Phoenix_PVE_Tier2 : public ATgPawn_Phoenix_PVE
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Phoenix_PVE_Tier2");
		return ptr;
	}

};


// Class TgGame.TgPawn_Satyr_S8
// 0x0000 (0x2570 - 0x2570)
class ATgPawn_Satyr_S8 : public ATgPawn_Cyclops
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Satyr_S8");
		return ptr;
	}


	bool Died(class AController* Killer, class UClass* dmgType, const struct FVector& HitLocation);
};


// Class TgGame.TgPawn_Set_RotatedStorm
// 0x0000 (0x26D8 - 0x26D8)
class ATgPawn_Set_RotatedStorm : public ATgPawn_Set
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Set_RotatedStorm");
		return ptr;
	}

};


// Class TgGame.TgPawn_SunWukong_Skin9
// 0x0000 (0x2704 - 0x2704)
class ATgPawn_SunWukong_Skin9 : public ATgPawn_SunWukong_DarkLord
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_SunWukong_Skin9");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AddGoldToJungleShrine
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_AddGoldToJungleShrine : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AddGoldToJungleShrine");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_Arena
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_Arena : public ATgPawn_Tower_ArenaBase
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_Arena");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_Olympus
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_Olympus : public ATgPawn_Tower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_Olympus");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_AsgardLava
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_AsgardLava : public ATgPawn_Tower_Olympus
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_AsgardLava");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_AsgardNew
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_AsgardNew : public ATgPawn_Tower_Olympus
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_AsgardNew");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_EgyptClash
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_EgyptClash : public ATgPawn_Tower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_EgyptClash");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_Invader
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_Invader : public ATgPawn_Tower_Olympus
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_Invader");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_Joust
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_Joust : public ATgPawn_Tower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_Joust");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_Mayan
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_Mayan : public ATgPawn_Tower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_Mayan");
		return ptr;
	}


	void STATIC_OnSwapToDestroyedMesh();
};


// Class TgGame.TgPawn_Tower_MayanRed
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_MayanRed : public ATgPawn_Tower_Mayan
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_MayanRed");
		return ptr;
	}

};


// Class TgGame.TgPawn_Tower_OlympusV2
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_OlympusV2 : public ATgPawn_Tower_Olympus
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_OlympusV2");
		return ptr;
	}


	void PostDemoRewind();
};


// Class TgGame.TgPawn_Tower_RA2015a
// 0x0000 (0x24D4 - 0x24D4)
class ATgPawn_Tower_RA2015a : public ATgPawn_Tower
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_Tower_RA2015a");
		return ptr;
	}

};


// Class TgGame.TgPawn_WispyMinion
// 0x0000 (0x258C - 0x258C)
class ATgPawn_WispyMinion : public ATgPawn_Minion
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPawn_WispyMinion");
		return ptr;
	}

};


// Class TgGame.TgPhysAnimTestActor
// 0x00A8 (0x0308 - 0x0260)
class ATgPhysAnimTestActor : public AActor
{
public:
	TArray<struct FName>                               LowerBoneNames;                                           // 0x0260(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               LinearBoneSpringNames;                                    // 0x0270(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               AngularBoneSpringNames;                                   // 0x0280(0x0010) (Edit, NeedCtorLink)
	class USkeletalMeshComponent*                      SkeletalMeshComponent;                                    // 0x0290(0x0008) (Edit, ExportObject, Component, EditInline)
	TEnumAsByte<EPATAState>                            CurrentState;                                             // 0x0298(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0299(0x0003) MISSED OFFSET
	unsigned long                                      bBlendToGetUp : 1;                                        // 0x029C(0x0004)
	unsigned long                                      bBlendingBack : 1;                                        // 0x029C(0x0004)
	unsigned long                                      bRampingDownMotors : 1;                                   // 0x029C(0x0004)
	unsigned long                                      bNextPokeKnocksDown : 1;                                  // 0x029C(0x0004)
	float                                              GetUpBlendStartTime;                                      // 0x02A0(0x0004)
	float                                              GetUpBlendTime;                                           // 0x02A4(0x0004) (Edit)
	float                                              GetUpToIdleTime;                                          // 0x02A8(0x0004) (Edit)
	float                                              ActorOriginHeight;                                        // 0x02AC(0x0004) (Edit)
	float                                              PokePauseTime;                                            // 0x02B0(0x0004) (Edit)
	float                                              PokeBlendTime;                                            // 0x02B4(0x0004) (Edit)
	float                                              BlendBackStartTime;                                       // 0x02B8(0x0004)
	float                                              MotorDownStartTime;                                       // 0x02BC(0x0004)
	float                                              MotorDownTime;                                            // 0x02C0(0x0004) (Edit)
	float                                              MotorDownAnimTime;                                        // 0x02C4(0x0004) (Edit)
	float                                              BlendStaggerAnimTime;                                     // 0x02C8(0x0004) (Edit)
	float                                              StaggerSpeedAdj;                                          // 0x02CC(0x0004) (Edit)
	float                                              StaggerVel;                                               // 0x02D0(0x0004) (Edit)
	struct FVector                                     MoveDir;                                                  // 0x02D4(0x000C)
	float                                              AngularHipDriveScale;                                     // 0x02E0(0x0004) (Edit)
	float                                              StaggerMuscleScale;                                       // 0x02E4(0x0004) (Edit)
	class UAnimNodeBlend*                              blendNode;                                                // 0x02E8(0x0008)
	class UAnimNodeSequence*                           GetUpNode;                                                // 0x02F0(0x0008)
	class UAnimNodeSequence*                           RunNode;                                                  // 0x02F8(0x0008)
	class URB_BodyInstance*                            HipBody;                                                  // 0x0300(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPhysAnimTestActor");
		return ptr;
	}


	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void Tick(float DeltaSeconds);
	void STATIC_SetAllMotorsAngularDriveStrength(float InAngularSpringStrength, float InAngularDampingStrength, float InAngularForceLimitStrength, class USkeletalMeshComponent* SkelMeshComp);
	void STATIC_RecoverFromRagdoll();
	void STATIC_SetBoneSprings(bool bEnabled);
	bool IsAngularBoneSpringName(const struct FName& InName);
	bool IsLinearBoneSpringName(const struct FName& InName);
	void STATIC_SetLowerFixed();
	void STATIC_DetachAttachments();
	bool IsLowerBodyName(const struct FName& InName);
	void STATIC_SetBodiesFixed(bool InFixed);
	void STATIC_EnableMotors(bool InEnabled);
	void STATIC_SetPATAState(TEnumAsByte<EPATAState> NewState);
	void STATIC_EndGrab();
	bool STATIC_PreGrab();
	bool STATIC_PrePokeActor(const struct FVector& PokeDir);
	void BoneImpulse(const struct FVector& Impulse, const struct FName& BoneName);
	void PostBeginPlay();
};


// Class TgGame.TgPickupFactory_Item
// 0x001C (0x03D0 - 0x03B4)
class ATgPickupFactory_Item : public ATgPickupFactory
{
public:
	class USoundCue*                                   PickupSound;                                              // 0x03B4(0x0008)
	struct FString                                     PickupMessage;                                            // 0x03BC(0x0010) (Const, Localized, NeedCtorLink)
	float                                              RespawnTime;                                              // 0x03CC(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgPickupFactory_Item");
		return ptr;
	}


	float BotDesireability(class APawn* P);
	float STATIC_GetRespawnTime();
	void STATIC_SetRespawn();
	void STATIC_SpawnCopyFor(class APawn* Recipient);
	struct FString STATIC_GetLocalString(int Switch, class APlayerReplicationInfo* RelatedPRI_2, class APlayerReplicationInfo* RelatedPRI_3);
	void STATIC_InitializePickup();
};


// Class TgGame.TgProj_AhMuzenCab_BeeFlockAttack
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_AhMuzenCab_BeeFlockAttack : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AhMuzenCab_BeeFlockAttack");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_AhMuzenCab_Stinger
// 0x0014 (0x03AC - 0x0398)
class ATgProj_AhMuzenCab_Stinger : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x0398(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x039C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AhMuzenCab_Stinger");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_AhPuch_Dev3
// 0x0004 (0x03C8 - 0x03C4)
class ATgProj_AhPuch_Dev3 : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:
	unsigned long                                      m_bHitTarget : 1;                                         // 0x03C4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AhPuch_Dev3");
		return ptr;
	}


	void ShutDown();
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Anubis_Mummify
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Anubis_Mummify : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Anubis_Mummify");
		return ptr;
	}

};


// Class TgGame.TgProj_AoKuang_WildStorm
// 0x0000 (0x0398 - 0x0398)
class ATgProj_AoKuang_WildStorm : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_AoKuang_WildStorm");
		return ptr;
	}

};


// Class TgGame.TgProj_Apep_BasicAttack
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Apep_BasicAttack : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Apep_BasicAttack");
		return ptr;
	}


	void PostProjectileInitialize();
};


// Class TgGame.TgProj_Aphrodite_SoulMates
// 0x0004 (0x03D0 - 0x03CC)
class ATgProj_Aphrodite_SoulMates : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bExplodeOnBlocker : 1;                                  // 0x03CC(0x0004) (Const)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Aphrodite_SoulMates");
		return ptr;
	}


	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool IsValidTarget(class AActor* A);
};


// Class TgGame.TgProj_Ares_Shackle
// 0x0010 (0x03BC - 0x03AC)
class ATgProj_Ares_Shackle : public ATgProj_SimulatedPassThrough
{
public:
	class UTgStaticMeshComponent*                      c_ConnectedShackleMeshComponent;                          // 0x03AC(0x0008) (ExportObject, Component, EditInline)
	float                                              c_ShackleDestroyProgressPercentage;                       // 0x03B4(0x0004)
	unsigned long                                      c_ExplodedOnTarget : 1;                                   // 0x03B8(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ares_Shackle");
		return ptr;
	}


	void Destroyed();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaSeconds);
	void SpawnFlightEffects();
	void UpdateShackleChainComponent(float DeltaSeconds);
};


// Class TgGame.TgProj_Artio_Dev1
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Artio_Dev1 : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Artio_Dev1");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool UseAOE();
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Artio_Dev3
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Artio_Dev3 : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Artio_Dev3");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool UseAOE();
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Athena_ReachingStrike
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Athena_ReachingStrike : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Athena_ReachingStrike");
		return ptr;
	}

};


// Class TgGame.TgProj_BaronSamedi_Inhand
// 0x0000 (0x0398 - 0x0398)
class ATgProj_BaronSamedi_Inhand : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_BaronSamedi_Inhand");
		return ptr;
	}

};


// Class TgGame.TgProj_Cerberus_Dev1_Middle
// 0x0000 (0x03B0 - 0x03B0)
class ATgProj_Cerberus_Dev1_Middle : public ATgProj_Cerberus_Dev1
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Cerberus_Dev1_Middle");
		return ptr;
	}

};


// Class TgGame.TgProj_Cerberus_Dev1_Side
// 0x0000 (0x03B0 - 0x03B0)
class ATgProj_Cerberus_Dev1_Side : public ATgProj_Cerberus_Dev1
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Cerberus_Dev1_Side");
		return ptr;
	}

};


// Class TgGame.TgProj_Cerberus_Dev1_Snake
// 0x0000 (0x03B0 - 0x03B0)
class ATgProj_Cerberus_Dev1_Snake : public ATgProj_Cerberus_Dev1
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Cerberus_Dev1_Snake");
		return ptr;
	}

};


// Class TgGame.TgProj_CH06_Mage
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_CH06_Mage : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CH06_Mage");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_CH06_TrapperPull
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_CH06_TrapperPull : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CH06_TrapperPull");
		return ptr;
	}


	void ShutDown();
	void ClientExplode(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SpawnFlightEffects();
};


// Class TgGame.TgProj_Chaac_Num1Axe
// 0x0000 (0x03BC - 0x03BC)
class ATgProj_Chaac_Num1Axe : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Chaac_Num1Axe");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Chaac_Num4
// 0x0014 (0x03AC - 0x0398)
class ATgProj_Chaac_Num4 : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x0398(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x039C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Chaac_Num4");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Chiron_TrainingExercise
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Chiron_TrainingExercise : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Chiron_TrainingExercise");
		return ptr;
	}


	void SetGroundTarget(const struct FVector& GTLocation);
};


// Class TgGame.TgProj_CoinReturnStroke
// 0x0000 (0x03D0 - 0x03D0)
class ATgProj_CoinReturnStroke : public ATgProj_SimulatedReturnStroke
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_CoinReturnStroke");
		return ptr;
	}


	void UpdateSeekingDirection(float fDeltaTime);
};


// Class TgGame.TgProj_Danzaburou_A01_Pickup
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Danzaburou_A01_Pickup : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Danzaburou_A01_Pickup");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool UseAOE();
};


// Class TgGame.TgProj_Danzaburou_Inhand
// 0x0008 (0x03A0 - 0x0398)
class ATgProj_Danzaburou_Inhand : public ATgProj_Simulated
{
public:
	float                                              m_fVisibilityDistance;                                    // 0x0398(0x0004)
	unsigned long                                      m_bIsVisible : 1;                                         // 0x039C(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Danzaburou_Inhand");
		return ptr;
	}


	void Tick(float DeltaSeconds);
	void STATIC_SetVisibility(bool bIsVisible);
};


// Class TgGame.TgProj_ErlangShen_Pin
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_ErlangShen_Pin : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_ErlangShen_Pin");
		return ptr;
	}


	void STATIC_CalcAoeFire(const struct FAimData& Aim, TArray<struct FImpactInfo>* ImpactList);
};


// Class TgGame.TgProj_Fafnir_Dev1
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Fafnir_Dev1 : public ATgProj_SimulatedPassThroughUntilGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Fafnir_Dev1");
		return ptr;
	}


	void PostProjectileInitialize();
};


// Class TgGame.TgProj_Fafnir_Dev2
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Fafnir_Dev2 : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Fafnir_Dev2");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SetTarget(class AActor* TargetActor, const struct FVector& TargetLocation);
	bool UseAOE();
};


// Class TgGame.TgProj_G86_BasicAttackProj
// 0x0000 (0x0398 - 0x0398)
class ATgProj_G86_BasicAttackProj : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_G86_BasicAttackProj");
		return ptr;
	}


	void STATIC_HideProjectile();
	void STATIC_ShowProjectile();
	void STATIC_ShowSeasonEffects();
	void SpawnFlightEffects();
};


// Class TgGame.TgProj_God95_A02
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_God95_A02 : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_God95_A02");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool IsValidTarget(class AActor* A);
};


// Class TgGame.TgProj_God95_BasicAttack
// 0x0000 (0x0398 - 0x0398)
class ATgProj_God95_BasicAttack : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_God95_BasicAttack");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool IsValidTarget(class AActor* A);
};


// Class TgGame.TgProj_Grenade
// 0x0000 (0x0378 - 0x0378)
class ATgProj_Grenade : public ATgProj_Bounce
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Grenade");
		return ptr;
	}

};


// Class TgGame.TgProj_Hachiman_Inhand
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Hachiman_Inhand : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Hachiman_Inhand");
		return ptr;
	}

};


// Class TgGame.TgProj_Hachiman_Inhand_Stim
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Hachiman_Inhand_Stim : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Hachiman_Inhand_Stim");
		return ptr;
	}


	bool IsValidBlocker(class AActor* Other);
	void STATIC_PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Nox_Ult
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Nox_Ult : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Nox_Ult");
		return ptr;
	}


	bool UseAOE();
	void STATIC_RangeReached();
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool IsObjectivePawn(class AActor* Other);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Hel_Dev1
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Hel_Dev1 : public ATgProj_Nox_Ult
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Hel_Dev1");
		return ptr;
	}


	void STATIC_PlayFizzleFX(const struct FVector& HitLocation, const struct FVector& HitNormal, bool bIsExplosionFizzle);
	void STATIC_PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Hera_Dev1_Portal
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Hera_Dev1_Portal : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Hera_Dev1_Portal");
		return ptr;
	}

};


// Class TgGame.TgProj_Isis_SandTwister
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Isis_SandTwister : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Isis_SandTwister");
		return ptr;
	}

};


// Class TgGame.TgProj_Janus_DeathGate
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Janus_DeathGate : public ATgProj_SimulatedSinusoid
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Janus_DeathGate");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Janus_DeathGate_Middle
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Janus_DeathGate_Middle : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Janus_DeathGate_Middle");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Janus_DeathGate_Mirror
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Janus_DeathGate_Mirror : public ATgProj_Janus_DeathGate
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Janus_DeathGate_Mirror");
		return ptr;
	}

};


// Class TgGame.TgProj_Kali_Incense
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Kali_Incense : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Kali_Incense");
		return ptr;
	}

};


// Class TgGame.TgProj_Kumbhakarna_Num2Boulder
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Kumbhakarna_Num2Boulder : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Kumbhakarna_Num2Boulder");
		return ptr;
	}


	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Medusa_Dev1
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Medusa_Dev1 : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Medusa_Dev1");
		return ptr;
	}


	struct FVector GetSeekLocation();
};


// Class TgGame.TgProj_Mulan_C04
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Mulan_C04 : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Mulan_C04");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool UseAOE();
};


// Class TgGame.TgProj_Neith_BrokenWeaveUser
// 0x000C (0x03A4 - 0x0398)
class ATgProj_Neith_BrokenWeaveUser : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bDestroyWeaveOnHit : 1;                                 // 0x0398(0x0004)
	unsigned long                                      m_bSkipFxOnDestroyWeave : 1;                              // 0x0398(0x0004)
	class UTgDeviceFire_Neith_BrokenWeaveUser*         s_OwnerSpecialFireMode;                                   // 0x039C(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Neith_BrokenWeaveUser");
		return ptr;
	}


	void STATIC_HandleBrokenWeaveHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool IsValidTarget(class AActor* A);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Neith_SpiritArrow
// 0x0014 (0x03B8 - 0x03A4)
class ATgProj_Neith_SpiritArrow : public ATgProj_Neith_BrokenWeaveUser
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x03A4(0x0004)
	unsigned long                                      m_bExplodeOnBlocker : 1;                                  // 0x03A4(0x0004)
	unsigned long                                      m_bSkipFriendlies : 1;                                    // 0x03A4(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x03A8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Neith_SpiritArrow");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Neith_ThreadOfLife
// 0x0000 (0x03A4 - 0x03A4)
class ATgProj_Neith_ThreadOfLife : public ATgProj_Neith_BrokenWeaveUser
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Neith_ThreadOfLife");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Net
// 0x000C (0x0378 - 0x036C)
class ATgProj_Net : public ATgProjectile
{
public:
	struct FVector                                     c_Dir;                                                    // 0x036C(0x000C)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Net");
		return ptr;
	}


	void Init(const struct FVector& Direction);
};


// Class TgGame.TgProj_Nox_Dev1
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Nox_Dev1 : public ATgProj_SimulatedPassThroughUntilGod
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Nox_Dev1");
		return ptr;
	}


	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void STATIC_RangeReached();
};


// Class TgGame.TgProj_NuWa_ShiningMetal
// 0x0010 (0x03BC - 0x03AC)
class ATgProj_NuWa_ShiningMetal : public ATgProj_SimulatedPassThrough
{
public:
	TArray<class AActor*>                              m_ExemptList;                                             // 0x03AC(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_NuWa_ShiningMetal");
		return ptr;
	}


	bool STATIC_ExplodeMinion(class ATgPawn* Target, int HitItem);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool IsValidTarget(class AActor* A);
	bool IsFriendlyFamiliar(class AActor* Target);
};


// Class TgGame.TgProj_NuWa_ShiningMetal_PVE
// 0x0014 (0x03D0 - 0x03BC)
class ATgProj_NuWa_ShiningMetal_PVE : public ATgProj_NuWa_ShiningMetal
{
public:
	float                                              m_fHitLockoutPeriod;                                      // 0x03BC(0x0004) (Const)
	TArray<float>                                      m_fTargetLockoutPeriods;                                  // 0x03C0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_NuWa_ShiningMetal_PVE");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp);
	void Tick(float fDeltaTime);
};


// Class TgGame.TgProj_Odin_A04
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Odin_A04 : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Odin_A04");
		return ptr;
	}


	bool UseAOE();
};


// Class TgGame.TgProj_Persephone_BasicAttack
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Persephone_BasicAttack : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Persephone_BasicAttack");
		return ptr;
	}


	void STATIC_PulseAOEActivation();
	void ShutDown();
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	bool IsValidTarget(class AActor* A);
	struct FAimData STATIC_GetAOEAim(class AActor* Target);
};


// Class TgGame.TgProj_Racer_Hammerrang
// 0x0000 (0x03B8 - 0x03B8)
class ATgProj_Racer_Hammerrang : public ATgProj_SimulatedBoomerang
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Racer_Hammerrang");
		return ptr;
	}

};


// Class TgGame.TgProj_Ram_Quiver2
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Ram_Quiver2 : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ram_Quiver2");
		return ptr;
	}

};


// Class TgGame.TgProj_Ratatoskr_AcornThrowBlue
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Ratatoskr_AcornThrowBlue : public ATgProj_Ratatoskr_AcornThrow
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ratatoskr_AcornThrowBlue");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Ravana_Dev3
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Ravana_Dev3 : public ATgProj_SimulatedPassThroughUntilGod_CollidesWorld
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Ravana_Dev3");
		return ptr;
	}


	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Scylla_Num2
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Scylla_Num2 : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Scylla_Num2");
		return ptr;
	}


	void STATIC_HideProjectile();
	void UpdateVisualsOnSetGroundTarget();
};


// Class TgGame.TgProj_Skadi_Dev1
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_Skadi_Dev1 : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Skadi_Dev1");
		return ptr;
	}


	bool IsValidTarget(class AActor* A);
	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Sol_SolarFlair_Mirror
// 0x0000 (0x03E4 - 0x03E4)
class ATgProj_Sol_SolarFlair_Mirror : public ATgProj_Sol_SolarFlair
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Sol_SolarFlair_Mirror");
		return ptr;
	}

};


// Class TgGame.TgProj_Teleporter
// 0x0004 (0x037C - 0x0378)
class ATgProj_Teleporter : public ATgProj_FreeGrenade
{
public:
	unsigned long                                      m_bCollisionUpdated : 1;                                  // 0x0378(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Teleporter");
		return ptr;
	}


	void STATIC_TargetReached(const struct FVector& vLocation);
	void HitWall(const struct FVector& HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp);
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_GotoLocation(const struct FVector& Loc);
	void STATIC_CancelTeleporting();
	void STATIC_CheckInterruptTeleport();
	void STATIC_RangeReached();
	void Timer();
	void STATIC_SetMeshCollision();
	void PostBeginPlay();
};


// Class TgGame.TgProj_StraightTeleporter
// 0x0000 (0x037C - 0x037C)
class ATgProj_StraightTeleporter : public ATgProj_Teleporter
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_StraightTeleporter");
		return ptr;
	}

};


// Class TgGame.TgProj_SunWukong_MastersWillBack
// 0x0000 (0x03B4 - 0x03B4)
class ATgProj_SunWukong_MastersWillBack : public ATgProj_VamanaUmbrella
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SunWukong_MastersWillBack");
		return ptr;
	}

};


// Class TgGame.TgProj_SunWukong_MastersWillOut
// 0x0014 (0x03D4 - 0x03C0)
class ATgProj_SunWukong_MastersWillOut : public ATgProj_SimulatedGroundTarget_FixedVelocity_NoLob
{
public:
	unsigned long                                      m_bInitialHit : 1;                                        // 0x03C0(0x0004)
	unsigned long                                      m_bExplodeOnBlocker : 1;                                  // 0x03C0(0x0004)
	unsigned long                                      m_bSkipFriendlies : 1;                                    // 0x03C0(0x0004)
	TArray<class AActor*>                              m_PreviouslyHitTargets;                                   // 0x03C4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SunWukong_MastersWillOut");
		return ptr;
	}


	void STATIC_HitTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_SunWukong_SomersaultCloudReturn
// 0x0008 (0x03D4 - 0x03CC)
class ATgProj_SunWukong_SomersaultCloudReturn : public ATgProj_SimulatedSeeking
{
public:
	struct FName                                       m_TargetSocket;                                           // 0x03CC(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_SunWukong_SomersaultCloudReturn");
		return ptr;
	}


	struct FVector GetSeekLocation();
	struct FVector STATIC_GetDesiredHitLocation();
	bool STATIC_CheckProjectileRange(const struct FVector& vLocOverride);
	void STATIC_RangeReached();
	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Sylvanus_Dev1
// 0x0000 (0x03BC - 0x03BC)
class ATgProj_Sylvanus_Dev1 : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Sylvanus_Dev1");
		return ptr;
	}


	void STATIC_HideProjectile();
	void UpdateVisualsOnSetGroundTarget();
};


// Class TgGame.TgProj_Sylvanus_Dev2
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Sylvanus_Dev2 : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Sylvanus_Dev2");
		return ptr;
	}


	bool UseAOE();
	void UpdateSeekingDirection(float fDeltaTime);
};


// Class TgGame.TgProj_Sylvanus_Inhand
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Sylvanus_Inhand : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Sylvanus_Inhand");
		return ptr;
	}

};


// Class TgGame.TgProj_Tsukuyomi_A01_Return
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Tsukuyomi_A01_Return : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Tsukuyomi_A01_Return");
		return ptr;
	}


	void STATIC_ProcessTouch(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool STATIC_ShouldExplode(class AActor* Other, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgProj_Vulcan_Bomb
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Vulcan_Bomb : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Vulcan_Bomb");
		return ptr;
	}

};


// Class TgGame.TgProj_Vulcan_Tossed_Thumper
// 0x0000 (0x03C4 - 0x03C4)
class ATgProj_Vulcan_Tossed_Thumper : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Vulcan_Tossed_Thumper");
		return ptr;
	}

};


// Class TgGame.TgProj_Wizard_C01
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Wizard_C01 : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Wizard_C01");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	void STATIC_PlayFizzleFX(const struct FVector& HitLocation, const struct FVector& HitNormal, bool bIsExplosionFizzle);
	void STATIC_PlayHitTargetFX(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, bool bExploded);
	void STATIC_SpawnExplosionEffects(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ExplodeOnTarget(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool UseAOE();
};


// Class TgGame.TgProj_Xbalanque_PoisonDarts
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Xbalanque_PoisonDarts : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Xbalanque_PoisonDarts");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
};


// Class TgGame.TgProj_Xbalanque_Raining_Dart
// 0x0000 (0x03CC - 0x03CC)
class ATgProj_Xbalanque_Raining_Dart : public ATgProj_SimulatedSeeking
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Xbalanque_Raining_Dart");
		return ptr;
	}

};


// Class TgGame.TgProj_XingTian_ChestRoar
// 0x0000 (0x03AC - 0x03AC)
class ATgProj_XingTian_ChestRoar : public ATgProj_SimulatedPassThrough
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_XingTian_ChestRoar");
		return ptr;
	}

};


// Class TgGame.TgProj_Yemoja_A01
// 0x0030 (0x03F4 - 0x03C4)
class ATgProj_Yemoja_A01 : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:
	struct FAimData                                    m_SecondBounceAim;                                        // 0x03C4(0x0030)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Yemoja_A01");
		return ptr;
	}

};


// Class TgGame.TgProj_Zeus_BasicAttack
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Zeus_BasicAttack : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Zeus_BasicAttack");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool IsValidTarget(class AActor* A);
};


// Class TgGame.TgProj_Zeus_ChainLightning
// 0x0000 (0x0398 - 0x0398)
class ATgProj_Zeus_ChainLightning : public ATgProj_Simulated
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Zeus_ChainLightning");
		return ptr;
	}


	bool ApplyHit(class AActor* Target, const struct FVector& HitLocation, const struct FVector& HitNormal, int HitItem);
	bool IsValidTarget(class AActor* A);
};


// Class TgGame.TgProj_Zeus_Coffin
// 0x0000 (0x03C8 - 0x03C8)
class ATgProj_Zeus_Coffin : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime_NoLob
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProj_Zeus_Coffin");
		return ptr;
	}


	bool UseAOE();
};


// Class TgGame.TgProxyStaticMeshActor
// 0x0000 (0x0274 - 0x0274)
class ATgProxyStaticMeshActor : public AStaticMeshActor
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgProxyStaticMeshActor");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_ControlPointOwnershipPercent
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_ControlPointOwnershipPercent : public USequenceEvent
{
public:
	float                                              OwnershipPercent;                                         // 0x0128(0x0004) (Edit)
	int                                                PointIndex;                                               // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_ControlPointOwnershipPercent");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_BattleRoundState
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_BattleRoundState : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_BattleRoundState");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_TaskForceScoreUpdated
// 0x0008 (0x0130 - 0x0128)
class UTgSeqEvent_TaskForceScoreUpdated : public USequenceEvent
{
public:
	int                                                DefenderTaskForce;                                        // 0x0128(0x0004) (Edit)
	int                                                CurrentScore;                                             // 0x012C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_TaskForceScoreUpdated");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_ActivateGlobeCamera
// 0x0014 (0x011C - 0x0108)
class UTgSeqAct_ActivateGlobeCamera : public USequenceAction
{
public:
	int                                                m_nYawRotation;                                           // 0x0108(0x0004) (Edit)
	int                                                m_nPitchRotation;                                         // 0x010C(0x0004) (Edit)
	int                                                m_nTiledShotAmount;                                       // 0x0110(0x0004) (Edit)
	class ACameraActor*                                m_Camera;                                                 // 0x0114(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ActivateGlobeCamera");
		return ptr;
	}


	void Activated();
	class ATgPlayerController* STATIC_GetLocalPlayer();
};


// Class TgGame.TgSeqAct_AddAnimSets
// 0x0024 (0x012C - 0x0108)
class UTgSeqAct_AddAnimSets : public USequenceAction
{
public:
	TArray<class UAnimSet*>                            m_MaleAnimSets;                                           // 0x0108(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimSet*>                            m_FemaleAnimSets;                                         // 0x0118(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      m_bAppendToExisting : 1;                                  // 0x0128(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AddAnimSets");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIStartFireAt
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_AIStartFireAt : public USequenceAction
{
public:
	unsigned char                                      ForcedFireMode;                                           // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIStartFireAt");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_AIStopFire
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_AIStopFire : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_AIStopFire");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_GetCharClass
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_GetCharClass : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_GetCharClass");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_HackBot
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_HackBot : public USequenceAction
{
public:
	class AActor*                                      m_ControlPawn;                                            // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_HackBot");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_LaunchHomeInstance
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_LaunchHomeInstance : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_LaunchHomeInstance");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_MarkSpawnReturn
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_MarkSpawnReturn : public USequenceAction
{
public:
	class ATeleporter*                                 m_Teleporter;                                             // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_MarkSpawnReturn");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_PlayCameraAnim
// 0x0018 (0x0120 - 0x0108)
class UTgSeqAct_PlayCameraAnim : public USequenceAction
{
public:
	class UCameraAnim*                                 AnimToPlay;                                               // 0x0108(0x0008) (Edit)
	float                                              BlendInTime;                                              // 0x0110(0x0004) (Edit)
	float                                              BlendOutTime;                                             // 0x0114(0x0004) (Edit)
	float                                              Rate;                                                     // 0x0118(0x0004) (Edit)
	float                                              IntensityScale;                                           // 0x011C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_PlayCameraAnim");
		return ptr;
	}


	int GetObjClassVersion();
};


// Class TgGame.TgSeqAct_SetLobbyMeshSkin
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_SetLobbyMeshSkin : public USequenceAction
{
public:
	int                                                m_nMessageId;                                             // 0x0108(0x0004) (Edit)
	int                                                m_nSkinId;                                                // 0x010C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetLobbyMeshSkin");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SetSkelPosture
// 0x0001 (0x0109 - 0x0108)
class UTgSeqAct_SetSkelPosture : public USequenceAction
{
public:
	TEnumAsByte<ETG_POSTURE>                           m_Posture;                                                // 0x0108(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SetSkelPosture");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_SpawnProjectile
// 0x0008 (0x0110 - 0x0108)
class UTgSeqAct_SpawnProjectile : public USequenceAction
{
public:
	class UClass*                                      ProjectileClass;                                          // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_SpawnProjectile");
		return ptr;
	}


	void Activated();
};


// Class TgGame.TgSeqAct_ToggleSecondaryAnimLock
// 0x0000 (0x0108 - 0x0108)
class UTgSeqAct_ToggleSecondaryAnimLock : public USeqAct_Toggle
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_ToggleSecondaryAnimLock");
		return ptr;
	}

};


// Class TgGame.TgSeqAct_TriggerInterpActor
// 0x0010 (0x0118 - 0x0108)
class UTgSeqAct_TriggerInterpActor : public USequenceAction
{
public:
	struct FString                                     m_sStateName;                                             // 0x0108(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqAct_TriggerInterpActor");
		return ptr;
	}

};


// Class TgGame.TgSeqEvent_SiegePush
// 0x0000 (0x0128 - 0x0128)
class UTgSeqEvent_SiegePush : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSeqEvent_SiegePush");
		return ptr;
	}

};


// Class TgGame.TgSiegePushActor
// 0x0034 (0x0294 - 0x0260)
class ATgSiegePushActor : public AActor
{
public:
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                         // 0x0260(0x0008)
	float                                              m_fCollisionProxyRadius;                                  // 0x0268(0x0004) (Edit, Const)
	float                                              m_fCollisionProxyHeight;                                  // 0x026C(0x0004) (Edit, Const)
	class USkeletalMeshComponent*                      m_SkelMesh;                                               // 0x0270(0x0008) (Edit, ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        m_RadiusMesh;                                             // 0x0278(0x0008) (Edit, ExportObject, Component, EditInline)
	int                                                m_nTF1Count;                                              // 0x0280(0x0004) (Transient)
	int                                                m_nTF2Count;                                              // 0x0284(0x0004) (Transient)
	int                                                m_nDefenderTaskForce;                                     // 0x0288(0x0004) (Edit)
	TEnumAsByte<EPushState>                            m_CurrentPushState;                                       // 0x028C(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x028D(0x0003) MISSED OFFSET
	float                                              m_fPendingReverseTime;                                    // 0x0290(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSiegePushActor");
		return ptr;
	}


	void STATIC_SetCurrentPushState(TEnumAsByte<EPushState> NewPushState);
	void STATIC_SetReversePushState();
	void NearbyPawnsUpdated();
	void CollisionProxyOnUnTouch(class AActor* Other);
	void CollisionProxyOnTouch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
};


// Class TgGame.TgSkeletalMeshActor_KismetToggledAnimation
// 0x0008 (0x0314 - 0x030C)
class ATgSkeletalMeshActor_KismetToggledAnimation : public ATgSkeletalMeshActor
{
public:
	float                                              m_fToggleResetDelay;                                      // 0x030C(0x0004) (Edit)
	unsigned long                                      r_bAnimToggleEnabled : 1;                                 // 0x0310(0x0004) (Net)
	unsigned long                                      r_bSecondaryAnimLock : 1;                                 // 0x0310(0x0004) (Net)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_KismetToggledAnimation");
		return ptr;
	}


	void STATIC_OnToggleSecondaryAnimLock(class UTgSeqAct_ToggleSecondaryAnimLock* Action);
	void STATIC_OnToggle(class USeqAct_Toggle* Action);
	void STATIC_ResetAnimToggle();
};


// Class TgGame.TgSkeletalMeshActor_MercuryGhost
// 0x0008 (0x0324 - 0x031C)
class ATgSkeletalMeshActor_MercuryGhost : public ATgSkeletalMeshActorSpawnable
{
public:
	class UTgSkeletalMeshComponent*                    TgSkeletalMeshComp;                                       // 0x031C(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSkeletalMeshActor_MercuryGhost");
		return ptr;
	}


	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void Init();
};


// Class TgGame.TgSoundInsulationVolume
// 0x0000 (0x02EC - 0x02EC)
class ATgSoundInsulationVolume : public AReverbVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSoundInsulationVolume");
		return ptr;
	}

};


// Class TgGame.TgSplineActor_Adv_CartDefense
// 0x0004 (0x02D4 - 0x02D0)
class ATgSplineActor_Adv_CartDefense : public ATgSplineActor
{
public:
	unsigned long                                      m_bTowerPoint : 1;                                        // 0x02D0(0x0004) (Edit)
	unsigned long                                      m_bTowerExitPoint : 1;                                    // 0x02D0(0x0004) (Edit)
	unsigned long                                      m_bReached : 1;                                           // 0x02D0(0x0004)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgSplineActor_Adv_CartDefense");
		return ptr;
	}


	void OnSplineActorReached(class ATgPawn_SplineCart* Other);
};


// Class TgGame.TgVolumeInfo_VisRes
// 0x0008 (0x0268 - 0x0260)
class ATgVolumeInfo_VisRes : public AInfo
{
public:
	class ATgVisionRestrictionVolume*                  V;                                                        // 0x0260(0x0008)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolumeInfo_VisRes");
		return ptr;
	}


	void Timer();
	void PostBeginPlay();
};


// Class TgGame.TgVolume_InterruptTween
// 0x0008 (0x02A4 - 0x029C)
class ATgVolume_InterruptTween : public AVolume
{
public:
	unsigned long                                      bKeepMomentum : 1;                                        // 0x029C(0x0004) (Edit)
	float                                              fDampeningFactor;                                         // 0x02A0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolume_InterruptTween");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgVolume_KillZSim
// 0x0000 (0x029C - 0x029C)
class ATgVolume_KillZSim : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgVolume_KillZSim");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class TgGame.TgWaterVolume
// 0x0000 (0x0314 - 0x0314)
class ATgWaterVolume : public AWaterVolume
{
public:

	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass("Class TgGame.TgWaterVolume");
		return ptr;
	}

};


}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
